[
  {
    "function_name": "kvm_mmu_pre_destroy_vm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6408-6412",
    "snippet": "void kvm_mmu_pre_destroy_vm(struct kvm *kvm)\n{\n\tif (kvm->arch.nx_lpage_recovery_thread)\n\t\tkthread_stop(kvm->arch.nx_lpage_recovery_thread);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "kvm->arch.nx_lpage_recovery_thread"
          ],
          "line": 6411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_pre_destroy_vm(struct kvm *kvm)\n{\n\tif (kvm->arch.nx_lpage_recovery_thread)\n\t\tkthread_stop(kvm->arch.nx_lpage_recovery_thread);\n}"
  },
  {
    "function_name": "kvm_mmu_post_init_vm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6395-6406",
    "snippet": "int kvm_mmu_post_init_vm(struct kvm *kvm)\n{\n\tint err;\n\n\terr = kvm_vm_create_worker_thread(kvm, kvm_nx_lpage_recovery_worker, 0,\n\t\t\t\t\t  \"kvm-nx-lpage-recovery\",\n\t\t\t\t\t  &kvm->arch.nx_lpage_recovery_thread);\n\tif (!err)\n\t\tkthread_unpark(kvm->arch.nx_lpage_recovery_thread);\n\n\treturn err;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_unpark",
          "args": [
            "kvm->arch.nx_lpage_recovery_thread"
          ],
          "line": 6403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vm_create_worker_thread",
          "args": [
            "kvm",
            "kvm_nx_lpage_recovery_worker",
            "0",
            "\"kvm-nx-lpage-recovery\"",
            "&kvm->arch.nx_lpage_recovery_thread"
          ],
          "line": 6399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nint kvm_mmu_post_init_vm(struct kvm *kvm)\n{\n\tint err;\n\n\terr = kvm_vm_create_worker_thread(kvm, kvm_nx_lpage_recovery_worker, 0,\n\t\t\t\t\t  \"kvm-nx-lpage-recovery\",\n\t\t\t\t\t  &kvm->arch.nx_lpage_recovery_thread);\n\tif (!err)\n\t\tkthread_unpark(kvm->arch.nx_lpage_recovery_thread);\n\n\treturn err;\n}"
  },
  {
    "function_name": "kvm_nx_lpage_recovery_worker",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6370-6393",
    "snippet": "static int kvm_nx_lpage_recovery_worker(struct kvm *kvm, uintptr_t data)\n{\n\tu64 start_time;\n\tlong remaining_time;\n\n\twhile (true) {\n\t\tstart_time = get_jiffies_64();\n\t\tremaining_time = get_nx_lpage_recovery_timeout(start_time);\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!kthread_should_stop() && remaining_time > 0) {\n\t\t\tschedule_timeout(remaining_time);\n\t\t\tremaining_time = get_nx_lpage_recovery_timeout(start_time);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\n\t\tset_current_state(TASK_RUNNING);\n\n\t\tif (kthread_should_stop())\n\t\t\treturn 0;\n\n\t\tkvm_recover_nx_lpages(kvm);\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_recover_nx_lpages",
          "args": [
            "kvm"
          ],
          "line": 6391
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_recover_nx_lpages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "6326-6361",
          "snippet": "static void kvm_recover_nx_lpages(struct kvm *kvm)\n{\n\tint rcu_idx;\n\tstruct kvm_mmu_page *sp;\n\tunsigned int ratio;\n\tLIST_HEAD(invalid_list);\n\tulong to_zap;\n\n\trcu_idx = srcu_read_lock(&kvm->srcu);\n\tspin_lock(&kvm->mmu_lock);\n\n\tratio = READ_ONCE(nx_huge_pages_recovery_ratio);\n\tto_zap = ratio ? DIV_ROUND_UP(kvm->stat.nx_lpage_splits, ratio) : 0;\n\twhile (to_zap && !list_empty(&kvm->arch.lpage_disallowed_mmu_pages)) {\n\t\t/*\n\t\t * We use a separate list instead of just using active_mmu_pages\n\t\t * because the number of lpage_disallowed pages is expected to\n\t\t * be relatively small compared to the total.\n\t\t */\n\t\tsp = list_first_entry(&kvm->arch.lpage_disallowed_mmu_pages,\n\t\t\t\t      struct kvm_mmu_page,\n\t\t\t\t      lpage_disallowed_link);\n\t\tWARN_ON_ONCE(!sp->lpage_disallowed);\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, &invalid_list);\n\t\tWARN_ON_ONCE(sp->lpage_disallowed);\n\n\t\tif (!--to_zap || need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\t\tif (to_zap)\n\t\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n\tsrcu_read_unlock(&kvm->srcu, rcu_idx);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_recover_nx_lpages(struct kvm *kvm)\n{\n\tint rcu_idx;\n\tstruct kvm_mmu_page *sp;\n\tunsigned int ratio;\n\tLIST_HEAD(invalid_list);\n\tulong to_zap;\n\n\trcu_idx = srcu_read_lock(&kvm->srcu);\n\tspin_lock(&kvm->mmu_lock);\n\n\tratio = READ_ONCE(nx_huge_pages_recovery_ratio);\n\tto_zap = ratio ? DIV_ROUND_UP(kvm->stat.nx_lpage_splits, ratio) : 0;\n\twhile (to_zap && !list_empty(&kvm->arch.lpage_disallowed_mmu_pages)) {\n\t\t/*\n\t\t * We use a separate list instead of just using active_mmu_pages\n\t\t * because the number of lpage_disallowed pages is expected to\n\t\t * be relatively small compared to the total.\n\t\t */\n\t\tsp = list_first_entry(&kvm->arch.lpage_disallowed_mmu_pages,\n\t\t\t\t      struct kvm_mmu_page,\n\t\t\t\t      lpage_disallowed_link);\n\t\tWARN_ON_ONCE(!sp->lpage_disallowed);\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, &invalid_list);\n\t\tWARN_ON_ONCE(sp->lpage_disallowed);\n\n\t\tif (!--to_zap || need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\t\tif (to_zap)\n\t\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n\tsrcu_read_unlock(&kvm->srcu, rcu_idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 6388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 6386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 6383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nx_lpage_recovery_timeout",
          "args": [
            "start_time"
          ],
          "line": 6382
        },
        "resolved": true,
        "details": {
          "function_name": "get_nx_lpage_recovery_timeout",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "6363-6368",
          "snippet": "static long get_nx_lpage_recovery_timeout(u64 start_time)\n{\n\treturn READ_ONCE(nx_huge_pages) && READ_ONCE(nx_huge_pages_recovery_ratio)\n\t\t? start_time + 60 * HZ - get_jiffies_64()\n\t\t: MAX_SCHEDULE_TIMEOUT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic long get_nx_lpage_recovery_timeout(u64 start_time)\n{\n\treturn READ_ONCE(nx_huge_pages) && READ_ONCE(nx_huge_pages_recovery_ratio)\n\t\t? start_time + 60 * HZ - get_jiffies_64()\n\t\t: MAX_SCHEDULE_TIMEOUT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "remaining_time"
          ],
          "line": 6381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_should_stop",
          "args": [],
          "line": 6380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 6379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_jiffies_64",
          "args": [],
          "line": 6376
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_nx_lpage_recovery_worker(struct kvm *kvm, uintptr_t data)\n{\n\tu64 start_time;\n\tlong remaining_time;\n\n\twhile (true) {\n\t\tstart_time = get_jiffies_64();\n\t\tremaining_time = get_nx_lpage_recovery_timeout(start_time);\n\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\twhile (!kthread_should_stop() && remaining_time > 0) {\n\t\t\tschedule_timeout(remaining_time);\n\t\t\tremaining_time = get_nx_lpage_recovery_timeout(start_time);\n\t\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\t}\n\n\t\tset_current_state(TASK_RUNNING);\n\n\t\tif (kthread_should_stop())\n\t\t\treturn 0;\n\n\t\tkvm_recover_nx_lpages(kvm);\n\t}\n}"
  },
  {
    "function_name": "get_nx_lpage_recovery_timeout",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6363-6368",
    "snippet": "static long get_nx_lpage_recovery_timeout(u64 start_time)\n{\n\treturn READ_ONCE(nx_huge_pages) && READ_ONCE(nx_huge_pages_recovery_ratio)\n\t\t? start_time + 60 * HZ - get_jiffies_64()\n\t\t: MAX_SCHEDULE_TIMEOUT;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_jiffies_64",
          "args": [],
          "line": 6366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "nx_huge_pages_recovery_ratio"
          ],
          "line": 6365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "nx_huge_pages"
          ],
          "line": 6365
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic long get_nx_lpage_recovery_timeout(u64 start_time)\n{\n\treturn READ_ONCE(nx_huge_pages) && READ_ONCE(nx_huge_pages_recovery_ratio)\n\t\t? start_time + 60 * HZ - get_jiffies_64()\n\t\t: MAX_SCHEDULE_TIMEOUT;\n}"
  },
  {
    "function_name": "kvm_recover_nx_lpages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6326-6361",
    "snippet": "static void kvm_recover_nx_lpages(struct kvm *kvm)\n{\n\tint rcu_idx;\n\tstruct kvm_mmu_page *sp;\n\tunsigned int ratio;\n\tLIST_HEAD(invalid_list);\n\tulong to_zap;\n\n\trcu_idx = srcu_read_lock(&kvm->srcu);\n\tspin_lock(&kvm->mmu_lock);\n\n\tratio = READ_ONCE(nx_huge_pages_recovery_ratio);\n\tto_zap = ratio ? DIV_ROUND_UP(kvm->stat.nx_lpage_splits, ratio) : 0;\n\twhile (to_zap && !list_empty(&kvm->arch.lpage_disallowed_mmu_pages)) {\n\t\t/*\n\t\t * We use a separate list instead of just using active_mmu_pages\n\t\t * because the number of lpage_disallowed pages is expected to\n\t\t * be relatively small compared to the total.\n\t\t */\n\t\tsp = list_first_entry(&kvm->arch.lpage_disallowed_mmu_pages,\n\t\t\t\t      struct kvm_mmu_page,\n\t\t\t\t      lpage_disallowed_link);\n\t\tWARN_ON_ONCE(!sp->lpage_disallowed);\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, &invalid_list);\n\t\tWARN_ON_ONCE(sp->lpage_disallowed);\n\n\t\tif (!--to_zap || need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\t\tif (to_zap)\n\t\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n\tsrcu_read_unlock(&kvm->srcu, rcu_idx);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->srcu",
            "rcu_idx"
          ],
          "line": 6360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 6359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 6355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 6353
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2795-2818",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 6352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 6352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "sp->lpage_disallowed"
          ],
          "line": 6350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "&invalid_list"
          ],
          "line": 6349
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2786-2793",
          "snippet": "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!sp->lpage_disallowed"
          ],
          "line": 6348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&kvm->arch.lpage_disallowed_mmu_pages",
            "structkvm_mmu_page",
            "lpage_disallowed_link"
          ],
          "line": 6345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&kvm->arch.lpage_disallowed_mmu_pages"
          ],
          "line": 6339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DIV_ROUND_UP",
          "args": [
            "kvm->stat.nx_lpage_splits",
            "ratio"
          ],
          "line": 6338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "nx_huge_pages_recovery_ratio"
          ],
          "line": 6337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 6335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->srcu"
          ],
          "line": 6334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 6331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_recover_nx_lpages(struct kvm *kvm)\n{\n\tint rcu_idx;\n\tstruct kvm_mmu_page *sp;\n\tunsigned int ratio;\n\tLIST_HEAD(invalid_list);\n\tulong to_zap;\n\n\trcu_idx = srcu_read_lock(&kvm->srcu);\n\tspin_lock(&kvm->mmu_lock);\n\n\tratio = READ_ONCE(nx_huge_pages_recovery_ratio);\n\tto_zap = ratio ? DIV_ROUND_UP(kvm->stat.nx_lpage_splits, ratio) : 0;\n\twhile (to_zap && !list_empty(&kvm->arch.lpage_disallowed_mmu_pages)) {\n\t\t/*\n\t\t * We use a separate list instead of just using active_mmu_pages\n\t\t * because the number of lpage_disallowed pages is expected to\n\t\t * be relatively small compared to the total.\n\t\t */\n\t\tsp = list_first_entry(&kvm->arch.lpage_disallowed_mmu_pages,\n\t\t\t\t      struct kvm_mmu_page,\n\t\t\t\t      lpage_disallowed_link);\n\t\tWARN_ON_ONCE(!sp->lpage_disallowed);\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, &invalid_list);\n\t\tWARN_ON_ONCE(sp->lpage_disallowed);\n\n\t\tif (!--to_zap || need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\t\tif (to_zap)\n\t\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n\tsrcu_read_unlock(&kvm->srcu, rcu_idx);\n}"
  },
  {
    "function_name": "set_nx_huge_pages_recovery_ratio",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6301-6324",
    "snippet": "static int set_nx_huge_pages_recovery_ratio(const char *val, const struct kernel_param *kp)\n{\n\tunsigned int old_val;\n\tint err;\n\n\told_val = nx_huge_pages_recovery_ratio;\n\terr = param_set_uint(val, kp);\n\tif (err)\n\t\treturn err;\n\n\tif (READ_ONCE(nx_huge_pages) &&\n\t    !old_val && nx_huge_pages_recovery_ratio) {\n\t\tstruct kvm *kvm;\n\n\t\tmutex_lock(&kvm_lock);\n\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\t\twake_up_process(kvm->arch.nx_lpage_recovery_thread);\n\n\t\tmutex_unlock(&kvm_lock);\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int set_nx_huge_pages(const char *val, const struct kernel_param *kp);",
      "static int set_nx_huge_pages_recovery_ratio(const char *val, const struct kernel_param *kp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm_lock"
          ],
          "line": 6320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "kvm->arch.nx_lpage_recovery_thread"
          ],
          "line": 6318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kvm",
            "&vm_list",
            "vm_list"
          ],
          "line": 6317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm_lock"
          ],
          "line": 6315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "nx_huge_pages"
          ],
          "line": 6311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "param_set_uint",
          "args": [
            "val",
            "kp"
          ],
          "line": 6307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int set_nx_huge_pages(const char *val, const struct kernel_param *kp);\nstatic int set_nx_huge_pages_recovery_ratio(const char *val, const struct kernel_param *kp);\n\nstatic int set_nx_huge_pages_recovery_ratio(const char *val, const struct kernel_param *kp)\n{\n\tunsigned int old_val;\n\tint err;\n\n\told_val = nx_huge_pages_recovery_ratio;\n\terr = param_set_uint(val, kp);\n\tif (err)\n\t\treturn err;\n\n\tif (READ_ONCE(nx_huge_pages) &&\n\t    !old_val && nx_huge_pages_recovery_ratio) {\n\t\tstruct kvm *kvm;\n\n\t\tmutex_lock(&kvm_lock);\n\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list)\n\t\t\twake_up_process(kvm->arch.nx_lpage_recovery_thread);\n\n\t\tmutex_unlock(&kvm_lock);\n\t}\n\n\treturn err;\n}"
  },
  {
    "function_name": "kvm_mmu_module_exit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6293-6299",
    "snippet": "void kvm_mmu_module_exit(void)\n{\n\tmmu_destroy_caches();\n\tpercpu_counter_destroy(&kvm_total_used_mmu_pages);\n\tunregister_shrinker(&mmu_shrinker);\n\tmmu_audit_disable();\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_counter kvm_total_used_mmu_pages;",
      "static struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_audit_disable",
          "args": [],
          "line": 6298
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_audit_disable",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2323-2323",
          "snippet": "static void mmu_audit_disable(void) { }",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_audit_disable(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "unregister_shrinker",
          "args": [
            "&mmu_shrinker"
          ],
          "line": 6297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_destroy",
          "args": [
            "&kvm_total_used_mmu_pages"
          ],
          "line": 6296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_destroy_caches",
          "args": [],
          "line": 6295
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_destroy_caches",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "6134-6138",
          "snippet": "static void mmu_destroy_caches(void)\n{\n\tkmem_cache_destroy(pte_list_desc_cache);\n\tkmem_cache_destroy(mmu_page_header_cache);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void mmu_destroy_caches(void)\n{\n\tkmem_cache_destroy(pte_list_desc_cache);\n\tkmem_cache_destroy(mmu_page_header_cache);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct percpu_counter kvm_total_used_mmu_pages;\nstatic struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};\n\nvoid kvm_mmu_module_exit(void)\n{\n\tmmu_destroy_caches();\n\tpercpu_counter_destroy(&kvm_total_used_mmu_pages);\n\tunregister_shrinker(&mmu_shrinker);\n\tmmu_audit_disable();\n}"
  },
  {
    "function_name": "kvm_mmu_destroy",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6285-6291",
    "snippet": "void kvm_mmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tfree_mmu_pages(&vcpu->arch.root_mmu);\n\tfree_mmu_pages(&vcpu->arch.guest_mmu);\n\tmmu_free_memory_caches(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_free_memory_caches",
          "args": [
            "vcpu"
          ],
          "line": 6290
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_free_memory_caches",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1129-1136",
          "snippet": "static void mmu_free_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\tpte_list_desc_cache);\n\tmmu_free_memory_cache_page(&vcpu->arch.mmu_page_cache);\n\tmmu_free_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\tmmu_page_header_cache);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void mmu_free_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\tpte_list_desc_cache);\n\tmmu_free_memory_cache_page(&vcpu->arch.mmu_page_cache);\n\tmmu_free_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\tmmu_page_header_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_mmu_pages",
          "args": [
            "&vcpu->arch.guest_mmu"
          ],
          "line": 6289
        },
        "resolved": true,
        "details": {
          "function_name": "free_mmu_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5655-5659",
          "snippet": "static void free_mmu_pages(struct kvm_mmu *mmu)\n{\n\tfree_page((unsigned long)mmu->pae_root);\n\tfree_page((unsigned long)mmu->lm_root);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void free_mmu_pages(struct kvm_mmu *mmu)\n{\n\tfree_page((unsigned long)mmu->pae_root);\n\tfree_page((unsigned long)mmu->lm_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unload",
          "args": [
            "vcpu"
          ],
          "line": 6287
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unload",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5192-5198",
          "snippet": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.root_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.root_mmu.root_hpa));\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.guest_mmu.root_hpa));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.root_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.root_mmu.root_hpa));\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.guest_mmu.root_hpa));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_destroy(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tfree_mmu_pages(&vcpu->arch.root_mmu);\n\tfree_mmu_pages(&vcpu->arch.guest_mmu);\n\tmmu_free_memory_caches(vcpu);\n}"
  },
  {
    "function_name": "kvm_mmu_calculate_default_mmu_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6264-6283",
    "snippet": "unsigned long kvm_mmu_calculate_default_mmu_pages(struct kvm *kvm)\n{\n\tunsigned long nr_mmu_pages;\n\tunsigned long nr_pages = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\n\t\tkvm_for_each_memslot(memslot, slots)\n\t\t\tnr_pages += memslot->npages;\n\t}\n\n\tnr_mmu_pages = nr_pages * KVM_PERMILLE_MMU_PAGES / 1000;\n\tnr_mmu_pages = max(nr_mmu_pages, KVM_MIN_ALLOC_MMU_PAGES);\n\n\treturn nr_mmu_pages;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "max",
          "args": [
            "nr_mmu_pages",
            "KVM_MIN_ALLOC_MMU_PAGES"
          ],
          "line": 6280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_memslot",
          "args": [
            "memslot",
            "slots"
          ],
          "line": 6275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_memslots",
          "args": [
            "kvm",
            "i"
          ],
          "line": 6273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nunsigned long kvm_mmu_calculate_default_mmu_pages(struct kvm *kvm)\n{\n\tunsigned long nr_mmu_pages;\n\tunsigned long nr_pages = 0;\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\n\t\tkvm_for_each_memslot(memslot, slots)\n\t\t\tnr_pages += memslot->npages;\n\t}\n\n\tnr_mmu_pages = nr_pages * KVM_PERMILLE_MMU_PAGES / 1000;\n\tnr_mmu_pages = max(nr_mmu_pages, KVM_MIN_ALLOC_MMU_PAGES);\n\n\treturn nr_mmu_pages;\n}"
  },
  {
    "function_name": "kvm_mmu_module_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6214-6259",
    "snippet": "int kvm_mmu_module_init(void)\n{\n\tint ret = -ENOMEM;\n\n\tif (nx_huge_pages == -1)\n\t\t__set_nx_huge_pages(get_nx_auto_mode());\n\n\t/*\n\t * MMU roles use union aliasing which is, generally speaking, an\n\t * undefined behavior. However, we supposedly know how compilers behave\n\t * and the current status quo is unlikely to change. Guardians below are\n\t * supposed to let us know if the assumption becomes false.\n\t */\n\tBUILD_BUG_ON(sizeof(union kvm_mmu_page_role) != sizeof(u32));\n\tBUILD_BUG_ON(sizeof(union kvm_mmu_extended_role) != sizeof(u32));\n\tBUILD_BUG_ON(sizeof(union kvm_mmu_role) != sizeof(u64));\n\n\tkvm_mmu_reset_all_pte_masks();\n\n\tkvm_set_mmio_spte_mask();\n\n\tpte_list_desc_cache = kmem_cache_create(\"pte_list_desc\",\n\t\t\t\t\t    sizeof(struct pte_list_desc),\n\t\t\t\t\t    0, SLAB_ACCOUNT, NULL);\n\tif (!pte_list_desc_cache)\n\t\tgoto out;\n\n\tmmu_page_header_cache = kmem_cache_create(\"kvm_mmu_page_header\",\n\t\t\t\t\t\t  sizeof(struct kvm_mmu_page),\n\t\t\t\t\t\t  0, SLAB_ACCOUNT, NULL);\n\tif (!mmu_page_header_cache)\n\t\tgoto out;\n\n\tif (percpu_counter_init(&kvm_total_used_mmu_pages, 0, GFP_KERNEL))\n\t\tgoto out;\n\n\tret = register_shrinker(&mmu_shrinker);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tmmu_destroy_caches();\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pte_list_desc_cache;",
      "static struct kmem_cache *mmu_page_header_cache;",
      "static struct percpu_counter kvm_total_used_mmu_pages;",
      "static struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_destroy_caches",
          "args": [],
          "line": 6257
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_destroy_caches",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "6134-6138",
          "snippet": "static void mmu_destroy_caches(void)\n{\n\tkmem_cache_destroy(pte_list_desc_cache);\n\tkmem_cache_destroy(mmu_page_header_cache);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void mmu_destroy_caches(void)\n{\n\tkmem_cache_destroy(pte_list_desc_cache);\n\tkmem_cache_destroy(mmu_page_header_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_shrinker",
          "args": [
            "&mmu_shrinker"
          ],
          "line": 6250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "percpu_counter_init",
          "args": [
            "&kvm_total_used_mmu_pages",
            "0",
            "GFP_KERNEL"
          ],
          "line": 6247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"kvm_mmu_page_header\"",
            "sizeof(struct kvm_mmu_page)",
            "0",
            "SLAB_ACCOUNT",
            "NULL"
          ],
          "line": 6241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"pte_list_desc\"",
            "sizeof(struct pte_list_desc)",
            "0",
            "SLAB_ACCOUNT",
            "NULL"
          ],
          "line": 6235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_mmio_spte_mask",
          "args": [],
          "line": 6233
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_mmio_spte_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "6140-6166",
          "snippet": "static void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\n\t/*\n\t * Mask the uppermost physical address bit, which would be reserved as\n\t * long as the supported physical address width is less than 52.\n\t */\n\tmask = 1ull << 51;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (shadow_phys_bits == 52)\n\t\tmask &= ~1ull;\n\n\tkvm_mmu_set_mmio_spte_mask(mask, mask, ACC_WRITE_MASK | ACC_USER_MASK);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n\nstatic void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\n\t/*\n\t * Mask the uppermost physical address bit, which would be reserved as\n\t * long as the supported physical address width is less than 52.\n\t */\n\tmask = 1ull << 51;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (shadow_phys_bits == 52)\n\t\tmask &= ~1ull;\n\n\tkvm_mmu_set_mmio_spte_mask(mask, mask, ACC_WRITE_MASK | ACC_USER_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_reset_all_pte_masks",
          "args": [],
          "line": 6231
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_all_pte_masks",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "560-599",
          "snippet": "static void kvm_mmu_reset_all_pte_masks(void)\n{\n\tu8 low_phys_bits;\n\n\tshadow_user_mask = 0;\n\tshadow_accessed_mask = 0;\n\tshadow_dirty_mask = 0;\n\tshadow_nx_mask = 0;\n\tshadow_x_mask = 0;\n\tshadow_mmio_mask = 0;\n\tshadow_present_mask = 0;\n\tshadow_acc_track_mask = 0;\n\n\tshadow_phys_bits = kvm_get_shadow_phys_bits();\n\n\t/*\n\t * If the CPU has 46 or less physical address bits, then set an\n\t * appropriate mask to guard against L1TF attacks. Otherwise, it is\n\t * assumed that the CPU is not vulnerable to L1TF.\n\t *\n\t * Some Intel CPUs address the L1 cache using more PA bits than are\n\t * reported by CPUID. Use the PA width of the L1 cache when possible\n\t * to achieve more effective mitigation, e.g. if system RAM overlaps\n\t * the most significant bits of legal physical address space.\n\t */\n\tshadow_nonpresent_or_rsvd_mask = 0;\n\tlow_phys_bits = boot_cpu_data.x86_cache_bits;\n\tif (boot_cpu_data.x86_cache_bits <\n\t    52 - shadow_nonpresent_or_rsvd_mask_len) {\n\t\tshadow_nonpresent_or_rsvd_mask =\n\t\t\trsvd_bits(boot_cpu_data.x86_cache_bits -\n\t\t\t\t  shadow_nonpresent_or_rsvd_mask_len,\n\t\t\t\t  boot_cpu_data.x86_cache_bits - 1);\n\t\tlow_phys_bits -= shadow_nonpresent_or_rsvd_mask_len;\n\t} else\n\t\tWARN_ON_ONCE(boot_cpu_has_bug(X86_BUG_L1TF));\n\n\tshadow_nonpresent_or_rsvd_lower_gfn_mask =\n\t\tGENMASK_ULL(low_phys_bits - 1, PAGE_SHIFT);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u64 shadow_nonpresent_or_rsvd_mask_len = 5;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic const u64 shadow_nonpresent_or_rsvd_mask_len = 5;\n\nstatic void kvm_mmu_reset_all_pte_masks(void)\n{\n\tu8 low_phys_bits;\n\n\tshadow_user_mask = 0;\n\tshadow_accessed_mask = 0;\n\tshadow_dirty_mask = 0;\n\tshadow_nx_mask = 0;\n\tshadow_x_mask = 0;\n\tshadow_mmio_mask = 0;\n\tshadow_present_mask = 0;\n\tshadow_acc_track_mask = 0;\n\n\tshadow_phys_bits = kvm_get_shadow_phys_bits();\n\n\t/*\n\t * If the CPU has 46 or less physical address bits, then set an\n\t * appropriate mask to guard against L1TF attacks. Otherwise, it is\n\t * assumed that the CPU is not vulnerable to L1TF.\n\t *\n\t * Some Intel CPUs address the L1 cache using more PA bits than are\n\t * reported by CPUID. Use the PA width of the L1 cache when possible\n\t * to achieve more effective mitigation, e.g. if system RAM overlaps\n\t * the most significant bits of legal physical address space.\n\t */\n\tshadow_nonpresent_or_rsvd_mask = 0;\n\tlow_phys_bits = boot_cpu_data.x86_cache_bits;\n\tif (boot_cpu_data.x86_cache_bits <\n\t    52 - shadow_nonpresent_or_rsvd_mask_len) {\n\t\tshadow_nonpresent_or_rsvd_mask =\n\t\t\trsvd_bits(boot_cpu_data.x86_cache_bits -\n\t\t\t\t  shadow_nonpresent_or_rsvd_mask_len,\n\t\t\t\t  boot_cpu_data.x86_cache_bits - 1);\n\t\tlow_phys_bits -= shadow_nonpresent_or_rsvd_mask_len;\n\t} else\n\t\tWARN_ON_ONCE(boot_cpu_has_bug(X86_BUG_L1TF));\n\n\tshadow_nonpresent_or_rsvd_lower_gfn_mask =\n\t\tGENMASK_ULL(low_phys_bits - 1, PAGE_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(union kvm_mmu_role) != sizeof(u64)"
          ],
          "line": 6229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(union kvm_mmu_extended_role) != sizeof(u32)"
          ],
          "line": 6228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(union kvm_mmu_page_role) != sizeof(u32)"
          ],
          "line": 6227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_nx_huge_pages",
          "args": [
            "get_nx_auto_mode()"
          ],
          "line": 6219
        },
        "resolved": true,
        "details": {
          "function_name": "__set_nx_huge_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "6174-6177",
          "snippet": "static void __set_nx_huge_pages(bool val)\n{\n\tnx_huge_pages = itlb_multihit_kvm_mitigation = val;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool itlb_multihit_kvm_mitigation;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nextern bool itlb_multihit_kvm_mitigation;\n\nstatic void __set_nx_huge_pages(bool val)\n{\n\tnx_huge_pages = itlb_multihit_kvm_mitigation = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nx_auto_mode",
          "args": [],
          "line": 6219
        },
        "resolved": true,
        "details": {
          "function_name": "get_nx_auto_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "6168-6172",
          "snippet": "static bool get_nx_auto_mode(void)\n{\n\t/* Return true when CPU has the bug, and mitigations are ON */\n\treturn boot_cpu_has_bug(X86_BUG_ITLB_MULTIHIT) && !cpu_mitigations_off();\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool get_nx_auto_mode(void)\n{\n\t/* Return true when CPU has the bug, and mitigations are ON */\n\treturn boot_cpu_has_bug(X86_BUG_ITLB_MULTIHIT) && !cpu_mitigations_off();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic struct percpu_counter kvm_total_used_mmu_pages;\nstatic struct shrinker mmu_shrinker = {\n\t.count_objects = mmu_shrink_count,\n\t.scan_objects = mmu_shrink_scan,\n\t.seeks = DEFAULT_SEEKS * 10,\n};\n\nint kvm_mmu_module_init(void)\n{\n\tint ret = -ENOMEM;\n\n\tif (nx_huge_pages == -1)\n\t\t__set_nx_huge_pages(get_nx_auto_mode());\n\n\t/*\n\t * MMU roles use union aliasing which is, generally speaking, an\n\t * undefined behavior. However, we supposedly know how compilers behave\n\t * and the current status quo is unlikely to change. Guardians below are\n\t * supposed to let us know if the assumption becomes false.\n\t */\n\tBUILD_BUG_ON(sizeof(union kvm_mmu_page_role) != sizeof(u32));\n\tBUILD_BUG_ON(sizeof(union kvm_mmu_extended_role) != sizeof(u32));\n\tBUILD_BUG_ON(sizeof(union kvm_mmu_role) != sizeof(u64));\n\n\tkvm_mmu_reset_all_pte_masks();\n\n\tkvm_set_mmio_spte_mask();\n\n\tpte_list_desc_cache = kmem_cache_create(\"pte_list_desc\",\n\t\t\t\t\t    sizeof(struct pte_list_desc),\n\t\t\t\t\t    0, SLAB_ACCOUNT, NULL);\n\tif (!pte_list_desc_cache)\n\t\tgoto out;\n\n\tmmu_page_header_cache = kmem_cache_create(\"kvm_mmu_page_header\",\n\t\t\t\t\t\t  sizeof(struct kvm_mmu_page),\n\t\t\t\t\t\t  0, SLAB_ACCOUNT, NULL);\n\tif (!mmu_page_header_cache)\n\t\tgoto out;\n\n\tif (percpu_counter_init(&kvm_total_used_mmu_pages, 0, GFP_KERNEL))\n\t\tgoto out;\n\n\tret = register_shrinker(&mmu_shrinker);\n\tif (ret)\n\t\tgoto out;\n\n\treturn 0;\n\nout:\n\tmmu_destroy_caches();\n\treturn ret;\n}"
  },
  {
    "function_name": "set_nx_huge_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6179-6212",
    "snippet": "static int set_nx_huge_pages(const char *val, const struct kernel_param *kp)\n{\n\tbool old_val = nx_huge_pages;\n\tbool new_val;\n\n\t/* In \"auto\" mode deploy workaround only if CPU has the bug. */\n\tif (sysfs_streq(val, \"off\"))\n\t\tnew_val = 0;\n\telse if (sysfs_streq(val, \"force\"))\n\t\tnew_val = 1;\n\telse if (sysfs_streq(val, \"auto\"))\n\t\tnew_val = get_nx_auto_mode();\n\telse if (strtobool(val, &new_val) < 0)\n\t\treturn -EINVAL;\n\n\t__set_nx_huge_pages(new_val);\n\n\tif (new_val != old_val) {\n\t\tstruct kvm *kvm;\n\n\t\tmutex_lock(&kvm_lock);\n\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\tkvm_mmu_zap_all_fast(kvm);\n\t\t\tmutex_unlock(&kvm->slots_lock);\n\n\t\t\twake_up_process(kvm->arch.nx_lpage_recovery_thread);\n\t\t}\n\t\tmutex_unlock(&kvm_lock);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int set_nx_huge_pages(const char *val, const struct kernel_param *kp);",
      "static int set_nx_huge_pages_recovery_ratio(const char *val, const struct kernel_param *kp);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm_lock"
          ],
          "line": 6208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "kvm->arch.nx_lpage_recovery_thread"
          ],
          "line": 6206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 6204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_zap_all_fast",
          "args": [
            "kvm"
          ],
          "line": 6203
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_zap_all_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5786-5814",
          "snippet": "static void kvm_mmu_zap_all_fast(struct kvm *kvm)\n{\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_zap_all_fast(kvm);\n\n\t/*\n\t * Toggle mmu_valid_gen between '0' and '1'.  Because slots_lock is\n\t * held for the entire duration of zapping obsolete pages, it's\n\t * impossible for there to be multiple invalid generations associated\n\t * with *valid* shadow pages at any given time, i.e. there is exactly\n\t * one valid generation and (at most) one invalid generation.\n\t */\n\tkvm->arch.mmu_valid_gen = kvm->arch.mmu_valid_gen ? 0 : 1;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table and flush TLB.\n\t * Then all vcpus will switch to new shadow page table with the new\n\t * mmu_valid_gen.\n\t *\n\t * Note: we need to do this under the protection of mmu_lock,\n\t * otherwise, vcpu would purge shadow page but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_zap_all_fast(struct kvm *kvm)\n{\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_zap_all_fast(kvm);\n\n\t/*\n\t * Toggle mmu_valid_gen between '0' and '1'.  Because slots_lock is\n\t * held for the entire duration of zapping obsolete pages, it's\n\t * impossible for there to be multiple invalid generations associated\n\t * with *valid* shadow pages at any given time, i.e. there is exactly\n\t * one valid generation and (at most) one invalid generation.\n\t */\n\tkvm->arch.mmu_valid_gen = kvm->arch.mmu_valid_gen ? 0 : 1;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table and flush TLB.\n\t * Then all vcpus will switch to new shadow page table with the new\n\t * mmu_valid_gen.\n\t *\n\t * Note: we need to do this under the protection of mmu_lock,\n\t * otherwise, vcpu would purge shadow page but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 6202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kvm",
            "&vm_list",
            "vm_list"
          ],
          "line": 6201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm_lock"
          ],
          "line": 6199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_nx_huge_pages",
          "args": [
            "new_val"
          ],
          "line": 6194
        },
        "resolved": true,
        "details": {
          "function_name": "__set_nx_huge_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "6174-6177",
          "snippet": "static void __set_nx_huge_pages(bool val)\n{\n\tnx_huge_pages = itlb_multihit_kvm_mitigation = val;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool itlb_multihit_kvm_mitigation;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nextern bool itlb_multihit_kvm_mitigation;\n\nstatic void __set_nx_huge_pages(bool val)\n{\n\tnx_huge_pages = itlb_multihit_kvm_mitigation = val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtobool",
          "args": [
            "val",
            "&new_val"
          ],
          "line": 6191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_nx_auto_mode",
          "args": [],
          "line": 6190
        },
        "resolved": true,
        "details": {
          "function_name": "get_nx_auto_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "6168-6172",
          "snippet": "static bool get_nx_auto_mode(void)\n{\n\t/* Return true when CPU has the bug, and mitigations are ON */\n\treturn boot_cpu_has_bug(X86_BUG_ITLB_MULTIHIT) && !cpu_mitigations_off();\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool get_nx_auto_mode(void)\n{\n\t/* Return true when CPU has the bug, and mitigations are ON */\n\treturn boot_cpu_has_bug(X86_BUG_ITLB_MULTIHIT) && !cpu_mitigations_off();\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_streq",
          "args": [
            "val",
            "\"auto\""
          ],
          "line": 6189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_streq",
          "args": [
            "val",
            "\"force\""
          ],
          "line": 6187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_streq",
          "args": [
            "val",
            "\"off\""
          ],
          "line": 6185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int set_nx_huge_pages(const char *val, const struct kernel_param *kp);\nstatic int set_nx_huge_pages_recovery_ratio(const char *val, const struct kernel_param *kp);\n\nstatic int set_nx_huge_pages(const char *val, const struct kernel_param *kp)\n{\n\tbool old_val = nx_huge_pages;\n\tbool new_val;\n\n\t/* In \"auto\" mode deploy workaround only if CPU has the bug. */\n\tif (sysfs_streq(val, \"off\"))\n\t\tnew_val = 0;\n\telse if (sysfs_streq(val, \"force\"))\n\t\tnew_val = 1;\n\telse if (sysfs_streq(val, \"auto\"))\n\t\tnew_val = get_nx_auto_mode();\n\telse if (strtobool(val, &new_val) < 0)\n\t\treturn -EINVAL;\n\n\t__set_nx_huge_pages(new_val);\n\n\tif (new_val != old_val) {\n\t\tstruct kvm *kvm;\n\n\t\tmutex_lock(&kvm_lock);\n\n\t\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\t\tmutex_lock(&kvm->slots_lock);\n\t\t\tkvm_mmu_zap_all_fast(kvm);\n\t\t\tmutex_unlock(&kvm->slots_lock);\n\n\t\t\twake_up_process(kvm->arch.nx_lpage_recovery_thread);\n\t\t}\n\t\tmutex_unlock(&kvm_lock);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__set_nx_huge_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6174-6177",
    "snippet": "static void __set_nx_huge_pages(bool val)\n{\n\tnx_huge_pages = itlb_multihit_kvm_mitigation = val;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "extern bool itlb_multihit_kvm_mitigation;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nextern bool itlb_multihit_kvm_mitigation;\n\nstatic void __set_nx_huge_pages(bool val)\n{\n\tnx_huge_pages = itlb_multihit_kvm_mitigation = val;\n}"
  },
  {
    "function_name": "get_nx_auto_mode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6168-6172",
    "snippet": "static bool get_nx_auto_mode(void)\n{\n\t/* Return true when CPU has the bug, and mitigations are ON */\n\treturn boot_cpu_has_bug(X86_BUG_ITLB_MULTIHIT) && !cpu_mitigations_off();\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_mitigations_off",
          "args": [],
          "line": 6171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has_bug",
          "args": [
            "X86_BUG_ITLB_MULTIHIT"
          ],
          "line": 6171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool get_nx_auto_mode(void)\n{\n\t/* Return true when CPU has the bug, and mitigations are ON */\n\treturn boot_cpu_has_bug(X86_BUG_ITLB_MULTIHIT) && !cpu_mitigations_off();\n}"
  },
  {
    "function_name": "kvm_set_mmio_spte_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6140-6166",
    "snippet": "static void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\n\t/*\n\t * Mask the uppermost physical address bit, which would be reserved as\n\t * long as the supported physical address width is less than 52.\n\t */\n\tmask = 1ull << 51;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (shadow_phys_bits == 52)\n\t\tmask &= ~1ull;\n\n\tkvm_mmu_set_mmio_spte_mask(mask, mask, ACC_WRITE_MASK | ACC_USER_MASK);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_USER_MASK    PT_USER_MASK",
      "#define ACC_WRITE_MASK   PT_WRITABLE_MASK"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_set_mmio_spte_mask",
          "args": [
            "mask",
            "mask",
            "ACC_WRITE_MASK | ACC_USER_MASK"
          ],
          "line": 6165
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_set_mmio_spte_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "334-341",
          "snippet": "void kvm_mmu_set_mmio_spte_mask(u64 mmio_mask, u64 mmio_value, u64 access_mask)\n{\n\tBUG_ON((u64)(unsigned)access_mask != access_mask);\n\tBUG_ON((mmio_mask & mmio_value) != mmio_value);\n\tshadow_mmio_value = mmio_value | SPTE_MMIO_MASK;\n\tshadow_mmio_mask = mmio_mask | SPTE_SPECIAL_MASK;\n\tshadow_mmio_access_mask = access_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMIO_MASK (3ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMIO_MASK (3ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nvoid kvm_mmu_set_mmio_spte_mask(u64 mmio_mask, u64 mmio_value, u64 access_mask)\n{\n\tBUG_ON((u64)(unsigned)access_mask != access_mask);\n\tBUG_ON((mmio_mask & mmio_value) != mmio_value);\n\tshadow_mmio_value = mmio_value | SPTE_MMIO_MASK;\n\tshadow_mmio_mask = mmio_mask | SPTE_SPECIAL_MASK;\n\tshadow_mmio_access_mask = access_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n\nstatic void kvm_set_mmio_spte_mask(void)\n{\n\tu64 mask;\n\n\t/*\n\t * Set the reserved bits and the present bit of an paging-structure\n\t * entry to generate page fault with PFER.RSV = 1.\n\t */\n\n\t/*\n\t * Mask the uppermost physical address bit, which would be reserved as\n\t * long as the supported physical address width is less than 52.\n\t */\n\tmask = 1ull << 51;\n\n\t/* Set the present bit. */\n\tmask |= 1ull;\n\n\t/*\n\t * If reserved bit is not supported, clear the present bit to disable\n\t * mmio page fault.\n\t */\n\tif (shadow_phys_bits == 52)\n\t\tmask &= ~1ull;\n\n\tkvm_mmu_set_mmio_spte_mask(mask, mask, ACC_WRITE_MASK | ACC_USER_MASK);\n}"
  },
  {
    "function_name": "mmu_destroy_caches",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6134-6138",
    "snippet": "static void mmu_destroy_caches(void)\n{\n\tkmem_cache_destroy(pte_list_desc_cache);\n\tkmem_cache_destroy(mmu_page_header_cache);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pte_list_desc_cache;",
      "static struct kmem_cache *mmu_page_header_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "mmu_page_header_cache"
          ],
          "line": 6137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "pte_list_desc_cache"
          ],
          "line": 6136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void mmu_destroy_caches(void)\n{\n\tkmem_cache_destroy(pte_list_desc_cache);\n\tkmem_cache_destroy(mmu_page_header_cache);\n}"
  },
  {
    "function_name": "mmu_shrink_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6122-6126",
    "snippet": "static unsigned long\nmmu_shrink_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn percpu_counter_read_positive(&kvm_total_used_mmu_pages);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_counter kvm_total_used_mmu_pages;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_counter_read_positive",
          "args": [
            "&kvm_total_used_mmu_pages"
          ],
          "line": 6125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct percpu_counter kvm_total_used_mmu_pages;\n\nstatic unsigned long\nmmu_shrink_count(struct shrinker *shrink, struct shrink_control *sc)\n{\n\treturn percpu_counter_read_positive(&kvm_total_used_mmu_pages);\n}"
  },
  {
    "function_name": "mmu_shrink_scan",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6061-6120",
    "snippet": "static unsigned long\nmmu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tstruct kvm *kvm;\n\tint nr_to_scan = sc->nr_to_scan;\n\tunsigned long freed = 0;\n\n\tmutex_lock(&kvm_lock);\n\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tint idx;\n\t\tLIST_HEAD(invalid_list);\n\n\t\t/*\n\t\t * Never scan more than sc->nr_to_scan VM instances.\n\t\t * Will not hit this condition practically since we do not try\n\t\t * to shrink more than one VM and it is very unlikely to see\n\t\t * !n_used_mmu_pages so many times.\n\t\t */\n\t\tif (!nr_to_scan--)\n\t\t\tbreak;\n\t\t/*\n\t\t * n_used_mmu_pages is accessed without holding kvm->mmu_lock\n\t\t * here. We may skip a VM instance errorneosly, but we do not\n\t\t * want to shrink a VM that only started to populate its MMU\n\t\t * anyway.\n\t\t */\n\t\tif (!kvm->arch.n_used_mmu_pages &&\n\t\t    !kvm_has_zapped_obsolete_pages(kvm))\n\t\t\tcontinue;\n\n\t\tidx = srcu_read_lock(&kvm->srcu);\n\t\tspin_lock(&kvm->mmu_lock);\n\n\t\tif (kvm_has_zapped_obsolete_pages(kvm)) {\n\t\t\tkvm_mmu_commit_zap_page(kvm,\n\t\t\t      &kvm->arch.zapped_obsolete_pages);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\tfreed++;\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\nunlock:\n\t\tspin_unlock(&kvm->mmu_lock);\n\t\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\t\t/*\n\t\t * unfair on small ones\n\t\t * per-vm shrinkers cry out\n\t\t * sadness comes quickly\n\t\t */\n\t\tlist_move_tail(&kvm->vm_list, &vm_list);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&kvm_lock);\n\treturn freed;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm_lock"
          ],
          "line": 6118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_move_tail",
          "args": [
            "&kvm->vm_list",
            "&vm_list"
          ],
          "line": 6114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->srcu",
            "idx"
          ],
          "line": 6107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 6106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 6103
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2795-2818",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_zap_oldest_mmu_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 6101
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_zap_oldest_mmu_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2820-2831",
          "snippet": "static bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\treturn kvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\treturn kvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_has_zapped_obsolete_pages",
          "args": [
            "kvm"
          ],
          "line": 6095
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_has_zapped_obsolete_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5816-5819",
          "snippet": "static bool kvm_has_zapped_obsolete_pages(struct kvm *kvm)\n{\n\treturn unlikely(!list_empty_careful(&kvm->arch.zapped_obsolete_pages));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_has_zapped_obsolete_pages(struct kvm *kvm)\n{\n\treturn unlikely(!list_empty_careful(&kvm->arch.zapped_obsolete_pages));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 6093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->srcu"
          ],
          "line": 6092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 6072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "kvm",
            "&vm_list",
            "vm_list"
          ],
          "line": 6070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm_lock"
          ],
          "line": 6068
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic unsigned long\nmmu_shrink_scan(struct shrinker *shrink, struct shrink_control *sc)\n{\n\tstruct kvm *kvm;\n\tint nr_to_scan = sc->nr_to_scan;\n\tunsigned long freed = 0;\n\n\tmutex_lock(&kvm_lock);\n\n\tlist_for_each_entry(kvm, &vm_list, vm_list) {\n\t\tint idx;\n\t\tLIST_HEAD(invalid_list);\n\n\t\t/*\n\t\t * Never scan more than sc->nr_to_scan VM instances.\n\t\t * Will not hit this condition practically since we do not try\n\t\t * to shrink more than one VM and it is very unlikely to see\n\t\t * !n_used_mmu_pages so many times.\n\t\t */\n\t\tif (!nr_to_scan--)\n\t\t\tbreak;\n\t\t/*\n\t\t * n_used_mmu_pages is accessed without holding kvm->mmu_lock\n\t\t * here. We may skip a VM instance errorneosly, but we do not\n\t\t * want to shrink a VM that only started to populate its MMU\n\t\t * anyway.\n\t\t */\n\t\tif (!kvm->arch.n_used_mmu_pages &&\n\t\t    !kvm_has_zapped_obsolete_pages(kvm))\n\t\t\tcontinue;\n\n\t\tidx = srcu_read_lock(&kvm->srcu);\n\t\tspin_lock(&kvm->mmu_lock);\n\n\t\tif (kvm_has_zapped_obsolete_pages(kvm)) {\n\t\t\tkvm_mmu_commit_zap_page(kvm,\n\t\t\t      &kvm->arch.zapped_obsolete_pages);\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\tfreed++;\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\nunlock:\n\t\tspin_unlock(&kvm->mmu_lock);\n\t\tsrcu_read_unlock(&kvm->srcu, idx);\n\n\t\t/*\n\t\t * unfair on small ones\n\t\t * per-vm shrinkers cry out\n\t\t * sadness comes quickly\n\t\t */\n\t\tlist_move_tail(&kvm->vm_list, &vm_list);\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&kvm_lock);\n\treturn freed;\n}"
  },
  {
    "function_name": "kvm_mmu_invalidate_mmio_sptes",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6036-6059",
    "snippet": "void kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm, u64 gen)\n{\n\tWARN_ON(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS);\n\n\tgen &= MMIO_SPTE_GEN_MASK;\n\n\t/*\n\t * Generation numbers are incremented in multiples of the number of\n\t * address spaces in order to provide unique generations across all\n\t * address spaces.  Strip what is effectively the address space\n\t * modifier prior to checking for a wrap of the MMIO generation so\n\t * that a wrap in any address space is detected.\n\t */\n\tgen &= ~((u64)KVM_ADDRESS_SPACE_NUM - 1);\n\n\t/*\n\t * The very rare case: if the MMIO generation number has wrapped,\n\t * zap all shadow pages.\n\t */\n\tif (unlikely(gen == 0)) {\n\t\tkvm_debug_ratelimited(\"kvm: zapping shadow pages for mmio generation wraparound\\n\");\n\t\tkvm_mmu_zap_all_fast(kvm);\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_zap_all_fast",
          "args": [
            "kvm"
          ],
          "line": 6057
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_zap_all_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5786-5814",
          "snippet": "static void kvm_mmu_zap_all_fast(struct kvm *kvm)\n{\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_zap_all_fast(kvm);\n\n\t/*\n\t * Toggle mmu_valid_gen between '0' and '1'.  Because slots_lock is\n\t * held for the entire duration of zapping obsolete pages, it's\n\t * impossible for there to be multiple invalid generations associated\n\t * with *valid* shadow pages at any given time, i.e. there is exactly\n\t * one valid generation and (at most) one invalid generation.\n\t */\n\tkvm->arch.mmu_valid_gen = kvm->arch.mmu_valid_gen ? 0 : 1;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table and flush TLB.\n\t * Then all vcpus will switch to new shadow page table with the new\n\t * mmu_valid_gen.\n\t *\n\t * Note: we need to do this under the protection of mmu_lock,\n\t * otherwise, vcpu would purge shadow page but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_zap_all_fast(struct kvm *kvm)\n{\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_zap_all_fast(kvm);\n\n\t/*\n\t * Toggle mmu_valid_gen between '0' and '1'.  Because slots_lock is\n\t * held for the entire duration of zapping obsolete pages, it's\n\t * impossible for there to be multiple invalid generations associated\n\t * with *valid* shadow pages at any given time, i.e. there is exactly\n\t * one valid generation and (at most) one invalid generation.\n\t */\n\tkvm->arch.mmu_valid_gen = kvm->arch.mmu_valid_gen ? 0 : 1;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table and flush TLB.\n\t * Then all vcpus will switch to new shadow page table with the new\n\t * mmu_valid_gen.\n\t *\n\t * Note: we need to do this under the protection of mmu_lock,\n\t * otherwise, vcpu would purge shadow page but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_debug_ratelimited",
          "args": [
            "\"kvm: zapping shadow pages for mmio generation wraparound\\n\""
          ],
          "line": 6056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gen == 0"
          ],
          "line": 6055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS"
          ],
          "line": 6038
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)\n\nvoid kvm_mmu_invalidate_mmio_sptes(struct kvm *kvm, u64 gen)\n{\n\tWARN_ON(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS);\n\n\tgen &= MMIO_SPTE_GEN_MASK;\n\n\t/*\n\t * Generation numbers are incremented in multiples of the number of\n\t * address spaces in order to provide unique generations across all\n\t * address spaces.  Strip what is effectively the address space\n\t * modifier prior to checking for a wrap of the MMIO generation so\n\t * that a wrap in any address space is detected.\n\t */\n\tgen &= ~((u64)KVM_ADDRESS_SPACE_NUM - 1);\n\n\t/*\n\t * The very rare case: if the MMIO generation number has wrapped,\n\t * zap all shadow pages.\n\t */\n\tif (unlikely(gen == 0)) {\n\t\tkvm_debug_ratelimited(\"kvm: zapping shadow pages for mmio generation wraparound\\n\");\n\t\tkvm_mmu_zap_all_fast(kvm);\n\t}\n}"
  },
  {
    "function_name": "kvm_mmu_zap_all",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6015-6034",
    "snippet": "void kvm_mmu_zap_all(struct kvm *kvm)\n{\n\tstruct kvm_mmu_page *sp, *node;\n\tLIST_HEAD(invalid_list);\n\tint ign;\n\n\tspin_lock(&kvm->mmu_lock);\nrestart:\n\tlist_for_each_entry_safe(sp, node, &kvm->arch.active_mmu_pages, link) {\n\t\tif (sp->role.invalid && sp->root_count)\n\t\t\tcontinue;\n\t\tif (__kvm_mmu_prepare_zap_page(kvm, sp, &invalid_list, &ign))\n\t\t\tgoto restart;\n\t\tif (cond_resched_lock(&kvm->mmu_lock))\n\t\t\tgoto restart;\n\t}\n\n\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\tspin_unlock(&kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 6033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 6032
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2795-2818",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 6028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "&invalid_list",
            "&ign"
          ],
          "line": 6026
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2741-2784",
          "snippet": "static bool __kvm_mmu_prepare_zap_page(struct kvm *kvm,\n\t\t\t\t       struct kvm_mmu_page *sp,\n\t\t\t\t       struct list_head *invalid_list,\n\t\t\t\t       int *nr_zapped)\n{\n\tbool list_unstable;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\t*nr_zapped = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\t/* Zapping children means active_mmu_pages has become unstable. */\n\tlist_unstable = *nr_zapped;\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\t(*nr_zapped)++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * Obsolete pages cannot be used on any vCPUs, see the comment\n\t\t * in kvm_mmu_zap_all_fast().  Note, is_obsolete_sp() also\n\t\t * treats invalid shadow pages as being obsolete.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tif (sp->lpage_disallowed)\n\t\tunaccount_huge_nx_page(kvm, sp);\n\n\tsp->role.invalid = 1;\n\treturn list_unstable;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool __kvm_mmu_prepare_zap_page(struct kvm *kvm,\n\t\t\t\t       struct kvm_mmu_page *sp,\n\t\t\t\t       struct list_head *invalid_list,\n\t\t\t\t       int *nr_zapped)\n{\n\tbool list_unstable;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\t*nr_zapped = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\t/* Zapping children means active_mmu_pages has become unstable. */\n\tlist_unstable = *nr_zapped;\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\t(*nr_zapped)++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * Obsolete pages cannot be used on any vCPUs, see the comment\n\t\t * in kvm_mmu_zap_all_fast().  Note, is_obsolete_sp() also\n\t\t * treats invalid shadow pages as being obsolete.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tif (sp->lpage_disallowed)\n\t\tunaccount_huge_nx_page(kvm, sp);\n\n\tsp->role.invalid = 1;\n\treturn list_unstable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "sp",
            "node",
            "&kvm->arch.active_mmu_pages",
            "link"
          ],
          "line": 6023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 6021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 6018
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nvoid kvm_mmu_zap_all(struct kvm *kvm)\n{\n\tstruct kvm_mmu_page *sp, *node;\n\tLIST_HEAD(invalid_list);\n\tint ign;\n\n\tspin_lock(&kvm->mmu_lock);\nrestart:\n\tlist_for_each_entry_safe(sp, node, &kvm->arch.active_mmu_pages, link) {\n\t\tif (sp->role.invalid && sp->root_count)\n\t\t\tcontinue;\n\t\tif (__kvm_mmu_prepare_zap_page(kvm, sp, &invalid_list, &ign))\n\t\t\tgoto restart;\n\t\tif (cond_resched_lock(&kvm->mmu_lock))\n\t\t\tgoto restart;\n\t}\n\n\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\tspin_unlock(&kvm->mmu_lock);\n}"
  },
  {
    "function_name": "kvm_mmu_slot_set_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "6001-6012",
    "snippet": "void kvm_mmu_slot_set_dirty(struct kvm *kvm,\n\t\t\t    struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_all_level(kvm, memslot, __rmap_set_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_arch_flush_remote_tlbs_memslot",
          "args": [
            "kvm",
            "memslot"
          ],
          "line": 6011
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_flush_remote_tlbs_memslot",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5951-5964",
          "snippet": "void kvm_arch_flush_remote_tlbs_memslot(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\t/*\n\t * All current use cases for flushing the TLBs for a specific memslot\n\t * are related to dirty logging, and do the TLB flush out of mmu_lock.\n\t * The interaction between the various operations on memslot must be\n\t * serialized by slots_locks to ensure the TLB flush from one operation\n\t * is observed by any other operation on the same memslot.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tkvm_flush_remote_tlbs_with_address(kvm, memslot->base_gfn,\n\t\t\t\t\t   memslot->npages);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_arch_flush_remote_tlbs_memslot(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\t/*\n\t * All current use cases for flushing the TLBs for a specific memslot\n\t * are related to dirty logging, and do the TLB flush out of mmu_lock.\n\t * The interaction between the various operations on memslot must be\n\t * serialized by slots_locks to ensure the TLB flush from one operation\n\t * is observed by any other operation on the same memslot.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tkvm_flush_remote_tlbs_with_address(kvm, memslot->base_gfn,\n\t\t\t\t\t   memslot->npages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 6008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_all_level",
          "args": [
            "kvm",
            "memslot",
            "__rmap_set_dirty",
            "false"
          ],
          "line": 6007
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_all_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5631-5637",
          "snippet": "static __always_inline bool\nslot_handle_all_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t      slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_all_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t      slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 6006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_slot_set_dirty(struct kvm *kvm,\n\t\t\t    struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_all_level(kvm, memslot, __rmap_set_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}"
  },
  {
    "function_name": "kvm_mmu_slot_largepage_remove_write_access",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5986-5998",
    "snippet": "void kvm_mmu_slot_largepage_remove_write_access(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_large_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\t\tfalse);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_arch_flush_remote_tlbs_memslot",
          "args": [
            "kvm",
            "memslot"
          ],
          "line": 5997
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_flush_remote_tlbs_memslot",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5951-5964",
          "snippet": "void kvm_arch_flush_remote_tlbs_memslot(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\t/*\n\t * All current use cases for flushing the TLBs for a specific memslot\n\t * are related to dirty logging, and do the TLB flush out of mmu_lock.\n\t * The interaction between the various operations on memslot must be\n\t * serialized by slots_locks to ensure the TLB flush from one operation\n\t * is observed by any other operation on the same memslot.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tkvm_flush_remote_tlbs_with_address(kvm, memslot->base_gfn,\n\t\t\t\t\t   memslot->npages);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_arch_flush_remote_tlbs_memslot(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\t/*\n\t * All current use cases for flushing the TLBs for a specific memslot\n\t * are related to dirty logging, and do the TLB flush out of mmu_lock.\n\t * The interaction between the various operations on memslot must be\n\t * serialized by slots_locks to ensure the TLB flush from one operation\n\t * is observed by any other operation on the same memslot.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tkvm_flush_remote_tlbs_with_address(kvm, memslot->base_gfn,\n\t\t\t\t\t   memslot->npages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_large_level",
          "args": [
            "kvm",
            "memslot",
            "slot_rmap_write_protect",
            "false"
          ],
          "line": 5992
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_large_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5639-5645",
          "snippet": "static __always_inline bool\nslot_handle_large_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL + 1,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_large_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL + 1,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_slot_largepage_remove_write_access(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_large_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\t\tfalse);\n\tspin_unlock(&kvm->mmu_lock);\n\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}"
  },
  {
    "function_name": "kvm_mmu_slot_leaf_clear_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5966-5983",
    "snippet": "void kvm_mmu_slot_leaf_clear_dirty(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_leaf(kvm, memslot, __rmap_clear_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/*\n\t * It's also safe to flush TLBs out of mmu lock here as currently this\n\t * function is only used for dirty logging, in which case flushing TLB\n\t * out of mmu lock also guarantees no dirty pages will be lost in\n\t * dirty_bitmap.\n\t */\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_arch_flush_remote_tlbs_memslot",
          "args": [
            "kvm",
            "memslot"
          ],
          "line": 5982
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_flush_remote_tlbs_memslot",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5951-5964",
          "snippet": "void kvm_arch_flush_remote_tlbs_memslot(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\t/*\n\t * All current use cases for flushing the TLBs for a specific memslot\n\t * are related to dirty logging, and do the TLB flush out of mmu_lock.\n\t * The interaction between the various operations on memslot must be\n\t * serialized by slots_locks to ensure the TLB flush from one operation\n\t * is observed by any other operation on the same memslot.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tkvm_flush_remote_tlbs_with_address(kvm, memslot->base_gfn,\n\t\t\t\t\t   memslot->npages);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_arch_flush_remote_tlbs_memslot(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\t/*\n\t * All current use cases for flushing the TLBs for a specific memslot\n\t * are related to dirty logging, and do the TLB flush out of mmu_lock.\n\t * The interaction between the various operations on memslot must be\n\t * serialized by slots_locks to ensure the TLB flush from one operation\n\t * is observed by any other operation on the same memslot.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tkvm_flush_remote_tlbs_with_address(kvm, memslot->base_gfn,\n\t\t\t\t\t   memslot->npages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_leaf",
          "args": [
            "kvm",
            "memslot",
            "__rmap_clear_dirty",
            "false"
          ],
          "line": 5972
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_leaf",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5647-5653",
          "snippet": "static __always_inline bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5971
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_slot_leaf_clear_dirty(struct kvm *kvm,\n\t\t\t\t   struct kvm_memory_slot *memslot)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_leaf(kvm, memslot, __rmap_clear_dirty, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/*\n\t * It's also safe to flush TLBs out of mmu lock here as currently this\n\t * function is only used for dirty logging, in which case flushing TLB\n\t * out of mmu lock also guarantees no dirty pages will be lost in\n\t * dirty_bitmap.\n\t */\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}"
  },
  {
    "function_name": "kvm_arch_flush_remote_tlbs_memslot",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5951-5964",
    "snippet": "void kvm_arch_flush_remote_tlbs_memslot(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\t/*\n\t * All current use cases for flushing the TLBs for a specific memslot\n\t * are related to dirty logging, and do the TLB flush out of mmu_lock.\n\t * The interaction between the various operations on memslot must be\n\t * serialized by slots_locks to ensure the TLB flush from one operation\n\t * is observed by any other operation on the same memslot.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tkvm_flush_remote_tlbs_with_address(kvm, memslot->base_gfn,\n\t\t\t\t\t   memslot->npages);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs_with_address",
          "args": [
            "kvm",
            "memslot->base_gfn",
            "memslot->npages"
          ],
          "line": 5962
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_flush_remote_tlbs_with_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "323-332",
          "snippet": "static void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 5961
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_arch_flush_remote_tlbs_memslot(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\t/*\n\t * All current use cases for flushing the TLBs for a specific memslot\n\t * are related to dirty logging, and do the TLB flush out of mmu_lock.\n\t * The interaction between the various operations on memslot must be\n\t * serialized by slots_locks to ensure the TLB flush from one operation\n\t * is observed by any other operation on the same memslot.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tkvm_flush_remote_tlbs_with_address(kvm, memslot->base_gfn,\n\t\t\t\t\t   memslot->npages);\n}"
  },
  {
    "function_name": "kvm_mmu_zap_collapsible_sptes",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5941-5949",
    "snippet": "void kvm_mmu_zap_collapsible_sptes(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *memslot)\n{\n\t/* FIXME: const-ify all uses of struct kvm_memory_slot.  */\n\tspin_lock(&kvm->mmu_lock);\n\tslot_handle_leaf(kvm, (struct kvm_memory_slot *)memslot,\n\t\t\t kvm_mmu_zap_collapsible_spte, true);\n\tspin_unlock(&kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_leaf",
          "args": [
            "kvm",
            "(struct kvm_memory_slot *)memslot",
            "kvm_mmu_zap_collapsible_spte",
            "true"
          ],
          "line": 5946
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_leaf",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5647-5653",
          "snippet": "static __always_inline bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_zap_collapsible_sptes(struct kvm *kvm,\n\t\t\t\t   const struct kvm_memory_slot *memslot)\n{\n\t/* FIXME: const-ify all uses of struct kvm_memory_slot.  */\n\tspin_lock(&kvm->mmu_lock);\n\tslot_handle_leaf(kvm, (struct kvm_memory_slot *)memslot,\n\t\t\t kvm_mmu_zap_collapsible_spte, true);\n\tspin_unlock(&kvm->mmu_lock);\n}"
  },
  {
    "function_name": "kvm_mmu_zap_collapsible_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5902-5939",
    "snippet": "static bool kvm_mmu_zap_collapsible_spte(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tint need_tlb_flush = 0;\n\tkvm_pfn_t pfn;\n\tstruct kvm_mmu_page *sp;\n\nrestart:\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tsp = page_header(__pa(sptep));\n\t\tpfn = spte_to_pfn(*sptep);\n\n\t\t/*\n\t\t * We cannot do huge page mapping for indirect shadow pages,\n\t\t * which are found on the last rmap (level = 1) when not using\n\t\t * tdp; such shadow pages are synced with the page table in\n\t\t * the guest, and the guest page table is using 4K page size\n\t\t * mapping if the indirect sp has level = 1.\n\t\t */\n\t\tif (sp->role.direct && !kvm_is_reserved_pfn(pfn) &&\n\t\t    (kvm_is_zone_device_pfn(pfn) ||\n\t\t     PageCompound(pfn_to_page(pfn)))) {\n\t\t\tpte_list_remove(rmap_head, sptep);\n\n\t\t\tif (kvm_available_flush_tlb_with_range())\n\t\t\t\tkvm_flush_remote_tlbs_with_address(kvm, sp->gfn,\n\t\t\t\t\tKVM_PAGES_PER_HPAGE(sp->role.level));\n\t\t\telse\n\t\t\t\tneed_tlb_flush = 1;\n\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\treturn need_tlb_flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs_with_address",
          "args": [
            "kvm",
            "sp->gfn",
            "KVM_PAGES_PER_HPAGE(sp->role.level)"
          ],
          "line": 5929
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_flush_remote_tlbs_with_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "323-332",
          "snippet": "static void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "sp->role.level"
          ],
          "line": 5930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_available_flush_tlb_with_range",
          "args": [],
          "line": 5928
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_available_flush_tlb_with_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "306-309",
          "snippet": "static inline bool kvm_available_flush_tlb_with_range(void)\n{\n\treturn kvm_x86_ops.tlb_remote_flush_with_range;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool kvm_available_flush_tlb_with_range(void)\n{\n\treturn kvm_x86_ops.tlb_remote_flush_with_range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_list_remove",
          "args": [
            "rmap_head",
            "sptep"
          ],
          "line": 5926
        },
        "resolved": true,
        "details": {
          "function_name": "pte_list_remove",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1389-1393",
          "snippet": "static void pte_list_remove(struct kvm_rmap_head *rmap_head, u64 *sptep)\n{\n\tmmu_spte_clear_track_bits(sptep);\n\t__pte_list_remove(sptep, rmap_head);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void pte_list_remove(struct kvm_rmap_head *rmap_head, u64 *sptep)\n{\n\tmmu_spte_clear_track_bits(sptep);\n\t__pte_list_remove(sptep, rmap_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 5925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 5925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_zone_device_pfn",
          "args": [
            "pfn"
          ],
          "line": 5924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_reserved_pfn",
          "args": [
            "pfn"
          ],
          "line": 5923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_to_pfn",
          "args": [
            "*sptep"
          ],
          "line": 5914
        },
        "resolved": true,
        "details": {
          "function_name": "spte_to_pfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "635-638",
          "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 5913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 5913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 5912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_zap_collapsible_spte(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tint need_tlb_flush = 0;\n\tkvm_pfn_t pfn;\n\tstruct kvm_mmu_page *sp;\n\nrestart:\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\tsp = page_header(__pa(sptep));\n\t\tpfn = spte_to_pfn(*sptep);\n\n\t\t/*\n\t\t * We cannot do huge page mapping for indirect shadow pages,\n\t\t * which are found on the last rmap (level = 1) when not using\n\t\t * tdp; such shadow pages are synced with the page table in\n\t\t * the guest, and the guest page table is using 4K page size\n\t\t * mapping if the indirect sp has level = 1.\n\t\t */\n\t\tif (sp->role.direct && !kvm_is_reserved_pfn(pfn) &&\n\t\t    (kvm_is_zone_device_pfn(pfn) ||\n\t\t     PageCompound(pfn_to_page(pfn)))) {\n\t\t\tpte_list_remove(rmap_head, sptep);\n\n\t\t\tif (kvm_available_flush_tlb_with_range())\n\t\t\t\tkvm_flush_remote_tlbs_with_address(kvm, sp->gfn,\n\t\t\t\t\tKVM_PAGES_PER_HPAGE(sp->role.level));\n\t\t\telse\n\t\t\t\tneed_tlb_flush = 1;\n\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\treturn need_tlb_flush;\n}"
  },
  {
    "function_name": "kvm_mmu_slot_remove_write_access",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5876-5900",
    "snippet": "void kvm_mmu_slot_remove_write_access(struct kvm *kvm,\n\t\t\t\t      struct kvm_memory_slot *memslot,\n\t\t\t\t      int start_level)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\tstart_level, PT_MAX_HUGEPAGE_LEVEL, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/*\n\t * We can flush all the TLBs out of the mmu lock without TLB\n\t * corruption since we just change the spte from writable to\n\t * readonly so that we only need to care the case of changing\n\t * spte from present to present (changing the spte from present\n\t * to nonpresent will flush all the TLBs immediately), in other\n\t * words, the only case we care is mmu_spte_update() where we\n\t * have checked SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE\n\t * instead of PT_WRITABLE_MASK, that means it does not depend\n\t * on PT_WRITABLE_MASK anymore.\n\t */\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
      "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_arch_flush_remote_tlbs_memslot",
          "args": [
            "kvm",
            "memslot"
          ],
          "line": 5899
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_flush_remote_tlbs_memslot",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5951-5964",
          "snippet": "void kvm_arch_flush_remote_tlbs_memslot(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\t/*\n\t * All current use cases for flushing the TLBs for a specific memslot\n\t * are related to dirty logging, and do the TLB flush out of mmu_lock.\n\t * The interaction between the various operations on memslot must be\n\t * serialized by slots_locks to ensure the TLB flush from one operation\n\t * is observed by any other operation on the same memslot.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tkvm_flush_remote_tlbs_with_address(kvm, memslot->base_gfn,\n\t\t\t\t\t   memslot->npages);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_arch_flush_remote_tlbs_memslot(struct kvm *kvm,\n\t\t\t\t\tstruct kvm_memory_slot *memslot)\n{\n\t/*\n\t * All current use cases for flushing the TLBs for a specific memslot\n\t * are related to dirty logging, and do the TLB flush out of mmu_lock.\n\t * The interaction between the various operations on memslot must be\n\t * serialized by slots_locks to ensure the TLB flush from one operation\n\t * is observed by any other operation on the same memslot.\n\t */\n\tlockdep_assert_held(&kvm->slots_lock);\n\tkvm_flush_remote_tlbs_with_address(kvm, memslot->base_gfn,\n\t\t\t\t\t   memslot->npages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_level",
          "args": [
            "kvm",
            "memslot",
            "slot_rmap_write_protect",
            "start_level",
            "PT_MAX_HUGEPAGE_LEVEL",
            "false"
          ],
          "line": 5883
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5620-5629",
          "snippet": "static __always_inline bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nvoid kvm_mmu_slot_remove_write_access(struct kvm *kvm,\n\t\t\t\t      struct kvm_memory_slot *memslot,\n\t\t\t\t      int start_level)\n{\n\tbool flush;\n\n\tspin_lock(&kvm->mmu_lock);\n\tflush = slot_handle_level(kvm, memslot, slot_rmap_write_protect,\n\t\t\t\tstart_level, PT_MAX_HUGEPAGE_LEVEL, false);\n\tspin_unlock(&kvm->mmu_lock);\n\n\t/*\n\t * We can flush all the TLBs out of the mmu lock without TLB\n\t * corruption since we just change the spte from writable to\n\t * readonly so that we only need to care the case of changing\n\t * spte from present to present (changing the spte from present\n\t * to nonpresent will flush all the TLBs immediately), in other\n\t * words, the only case we care is mmu_spte_update() where we\n\t * have checked SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE\n\t * instead of PT_WRITABLE_MASK, that means it does not depend\n\t * on PT_WRITABLE_MASK anymore.\n\t */\n\tif (flush)\n\t\tkvm_arch_flush_remote_tlbs_memslot(kvm, memslot);\n}"
  },
  {
    "function_name": "slot_rmap_write_protect",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5870-5874",
    "snippet": "static bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rmap_write_protect",
          "args": [
            "kvm",
            "rmap_head",
            "false"
          ],
          "line": 5873
        },
        "resolved": true,
        "details": {
          "function_name": "__rmap_write_protect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1582-1594",
          "snippet": "static bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(sptep, pt_protect);\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(sptep, pt_protect);\n\n\treturn flush;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}"
  },
  {
    "function_name": "kvm_zap_gfn_range",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5844-5868",
    "snippet": "void kvm_zap_gfn_range(struct kvm *kvm, gfn_t gfn_start, gfn_t gfn_end)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tspin_lock(&kvm->mmu_lock);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tgfn_t start, end;\n\n\t\t\tstart = max(gfn_start, memslot->base_gfn);\n\t\t\tend = min(gfn_end, memslot->base_gfn + memslot->npages);\n\t\t\tif (start >= end)\n\t\t\t\tcontinue;\n\n\t\t\tslot_handle_level_range(kvm, memslot, kvm_zap_rmapp,\n\t\t\t\t\t\tPT_PAGE_TABLE_LEVEL, PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\tstart, end - 1, true);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slot_handle_level_range",
          "args": [
            "kvm",
            "memslot",
            "kvm_zap_rmapp",
            "PT_PAGE_TABLE_LEVEL",
            "PT_MAX_HUGEPAGE_LEVEL",
            "start",
            "end - 1",
            "true"
          ],
          "line": 5861
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_level_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5587-5618",
          "snippet": "static __always_inline bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs_with_address(kvm,\n\t\t\t\t\t\tstart_gfn,\n\t\t\t\t\t\titerator.gfn - start_gfn + 1);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs_with_address(kvm, start_gfn,\n\t\t\t\t\t\t   end_gfn - start_gfn + 1);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs_with_address(kvm,\n\t\t\t\t\t\tstart_gfn,\n\t\t\t\t\t\titerator.gfn - start_gfn + 1);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs_with_address(kvm, start_gfn,\n\t\t\t\t\t\t   end_gfn - start_gfn + 1);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "gfn_end",
            "memslot->base_gfn + memslot->npages"
          ],
          "line": 5857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "gfn_start",
            "memslot->base_gfn"
          ],
          "line": 5856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_memslot",
          "args": [
            "memslot",
            "slots"
          ],
          "line": 5853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_memslots",
          "args": [
            "kvm",
            "i"
          ],
          "line": 5852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_zap_gfn_range(struct kvm *kvm, gfn_t gfn_start, gfn_t gfn_end)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tint i;\n\n\tspin_lock(&kvm->mmu_lock);\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tgfn_t start, end;\n\n\t\t\tstart = max(gfn_start, memslot->base_gfn);\n\t\t\tend = min(gfn_end, memslot->base_gfn + memslot->npages);\n\t\t\tif (start >= end)\n\t\t\t\tcontinue;\n\n\t\t\tslot_handle_level_range(kvm, memslot, kvm_zap_rmapp,\n\t\t\t\t\t\tPT_PAGE_TABLE_LEVEL, PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\tstart, end - 1, true);\n\t\t}\n\t}\n\n\tspin_unlock(&kvm->mmu_lock);\n}"
  },
  {
    "function_name": "kvm_mmu_uninit_vm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5837-5842",
    "snippet": "void kvm_mmu_uninit_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tkvm_page_track_unregister_notifier(kvm, node);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_page_track_unregister_notifier",
          "args": [
            "kvm",
            "node"
          ],
          "line": 5841
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_unregister_notifier",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/page_track.c",
          "lines": "197-209",
          "snippet": "void\nkvm_page_track_unregister_notifier(struct kvm *kvm,\n\t\t\t\t   struct kvm_page_track_notifier_node *n)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\n\tspin_lock(&kvm->mmu_lock);\n\thlist_del_rcu(&n->node);\n\tspin_unlock(&kvm->mmu_lock);\n\tsynchronize_srcu(&head->track_srcu);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <linux/rculist.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <linux/rculist.h>\n#include <linux/kvm_host.h>\n\nvoid\nkvm_page_track_unregister_notifier(struct kvm *kvm,\n\t\t\t\t   struct kvm_page_track_notifier_node *n)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\n\tspin_lock(&kvm->mmu_lock);\n\thlist_del_rcu(&n->node);\n\tspin_unlock(&kvm->mmu_lock);\n\tsynchronize_srcu(&head->track_srcu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_uninit_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tkvm_page_track_unregister_notifier(kvm, node);\n}"
  },
  {
    "function_name": "kvm_mmu_init_vm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5828-5835",
    "snippet": "void kvm_mmu_init_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tnode->track_write = kvm_mmu_pte_write;\n\tnode->track_flush_slot = kvm_mmu_invalidate_zap_pages_in_memslot;\n\tkvm_page_track_register_notifier(kvm, node);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_page_track_register_notifier",
          "args": [
            "kvm",
            "node"
          ],
          "line": 5834
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_register_notifier",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/page_track.c",
          "lines": "179-190",
          "snippet": "void\nkvm_page_track_register_notifier(struct kvm *kvm,\n\t\t\t\t struct kvm_page_track_notifier_node *n)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\n\tspin_lock(&kvm->mmu_lock);\n\thlist_add_head_rcu(&n->node, &head->track_notifier_list);\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <linux/rculist.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <linux/rculist.h>\n#include <linux/kvm_host.h>\n\nvoid\nkvm_page_track_register_notifier(struct kvm *kvm,\n\t\t\t\t struct kvm_page_track_notifier_node *n)\n{\n\tstruct kvm_page_track_notifier_head *head;\n\n\thead = &kvm->arch.track_notifier_head;\n\n\tspin_lock(&kvm->mmu_lock);\n\thlist_add_head_rcu(&n->node, &head->track_notifier_list);\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_init_vm(struct kvm *kvm)\n{\n\tstruct kvm_page_track_notifier_node *node = &kvm->arch.mmu_sp_tracker;\n\n\tnode->track_write = kvm_mmu_pte_write;\n\tnode->track_flush_slot = kvm_mmu_invalidate_zap_pages_in_memslot;\n\tkvm_page_track_register_notifier(kvm, node);\n}"
  },
  {
    "function_name": "kvm_mmu_invalidate_zap_pages_in_memslot",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5821-5826",
    "snippet": "static void kvm_mmu_invalidate_zap_pages_in_memslot(struct kvm *kvm,\n\t\t\tstruct kvm_memory_slot *slot,\n\t\t\tstruct kvm_page_track_notifier_node *node)\n{\n\tkvm_mmu_zap_all_fast(kvm);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_zap_all_fast",
          "args": [
            "kvm"
          ],
          "line": 5825
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_zap_all_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5786-5814",
          "snippet": "static void kvm_mmu_zap_all_fast(struct kvm *kvm)\n{\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_zap_all_fast(kvm);\n\n\t/*\n\t * Toggle mmu_valid_gen between '0' and '1'.  Because slots_lock is\n\t * held for the entire duration of zapping obsolete pages, it's\n\t * impossible for there to be multiple invalid generations associated\n\t * with *valid* shadow pages at any given time, i.e. there is exactly\n\t * one valid generation and (at most) one invalid generation.\n\t */\n\tkvm->arch.mmu_valid_gen = kvm->arch.mmu_valid_gen ? 0 : 1;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table and flush TLB.\n\t * Then all vcpus will switch to new shadow page table with the new\n\t * mmu_valid_gen.\n\t *\n\t * Note: we need to do this under the protection of mmu_lock,\n\t * otherwise, vcpu would purge shadow page but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_zap_all_fast(struct kvm *kvm)\n{\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_zap_all_fast(kvm);\n\n\t/*\n\t * Toggle mmu_valid_gen between '0' and '1'.  Because slots_lock is\n\t * held for the entire duration of zapping obsolete pages, it's\n\t * impossible for there to be multiple invalid generations associated\n\t * with *valid* shadow pages at any given time, i.e. there is exactly\n\t * one valid generation and (at most) one invalid generation.\n\t */\n\tkvm->arch.mmu_valid_gen = kvm->arch.mmu_valid_gen ? 0 : 1;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table and flush TLB.\n\t * Then all vcpus will switch to new shadow page table with the new\n\t * mmu_valid_gen.\n\t *\n\t * Note: we need to do this under the protection of mmu_lock,\n\t * otherwise, vcpu would purge shadow page but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_invalidate_zap_pages_in_memslot(struct kvm *kvm,\n\t\t\tstruct kvm_memory_slot *slot,\n\t\t\tstruct kvm_page_track_notifier_node *node)\n{\n\tkvm_mmu_zap_all_fast(kvm);\n}"
  },
  {
    "function_name": "kvm_has_zapped_obsolete_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5816-5819",
    "snippet": "static bool kvm_has_zapped_obsolete_pages(struct kvm *kvm)\n{\n\treturn unlikely(!list_empty_careful(&kvm->arch.zapped_obsolete_pages));\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!list_empty_careful(&kvm->arch.zapped_obsolete_pages)"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty_careful",
          "args": [
            "&kvm->arch.zapped_obsolete_pages"
          ],
          "line": 5818
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_has_zapped_obsolete_pages(struct kvm *kvm)\n{\n\treturn unlikely(!list_empty_careful(&kvm->arch.zapped_obsolete_pages));\n}"
  },
  {
    "function_name": "kvm_mmu_zap_all_fast",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5786-5814",
    "snippet": "static void kvm_mmu_zap_all_fast(struct kvm *kvm)\n{\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_zap_all_fast(kvm);\n\n\t/*\n\t * Toggle mmu_valid_gen between '0' and '1'.  Because slots_lock is\n\t * held for the entire duration of zapping obsolete pages, it's\n\t * impossible for there to be multiple invalid generations associated\n\t * with *valid* shadow pages at any given time, i.e. there is exactly\n\t * one valid generation and (at most) one invalid generation.\n\t */\n\tkvm->arch.mmu_valid_gen = kvm->arch.mmu_valid_gen ? 0 : 1;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table and flush TLB.\n\t * Then all vcpus will switch to new shadow page table with the new\n\t * mmu_valid_gen.\n\t *\n\t * Note: we need to do this under the protection of mmu_lock,\n\t * otherwise, vcpu would purge shadow page but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_zap_obsolete_pages",
          "args": [
            "kvm"
          ],
          "line": 5812
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_zap_obsolete_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5726-5775",
          "snippet": "static void kvm_zap_obsolete_pages(struct kvm *kvm)\n{\n\tstruct kvm_mmu_page *sp, *node;\n\tint nr_zapped, batch = 0;\n\nrestart:\n\tlist_for_each_entry_safe_reverse(sp, node,\n\t      &kvm->arch.active_mmu_pages, link) {\n\t\t/*\n\t\t * No obsolete valid page exists before a newly created page\n\t\t * since active_mmu_pages is a FIFO list.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Skip invalid pages with a non-zero root count, zapping pages\n\t\t * with a non-zero root count will never succeed, i.e. the page\n\t\t * will get thrown back on active_mmu_pages and we'll get stuck\n\t\t * in an infinite loop.\n\t\t */\n\t\tif (sp->role.invalid && sp->root_count)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need to flush the TLB since we're only zapping shadow\n\t\t * pages with an obsolete generation number and all vCPUS have\n\t\t * loaded a new root, i.e. the shadow pages being zapped cannot\n\t\t * be in active use by the guest.\n\t\t */\n\t\tif (batch >= BATCH_ZAP_PAGES &&\n\t\t    cond_resched_lock(&kvm->mmu_lock)) {\n\t\t\tbatch = 0;\n\t\t\tgoto restart;\n\t\t}\n\n\t\tif (__kvm_mmu_prepare_zap_page(kvm, sp,\n\t\t\t\t&kvm->arch.zapped_obsolete_pages, &nr_zapped)) {\n\t\t\tbatch += nr_zapped;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger a remote TLB flush before freeing the page tables to ensure\n\t * KVM is not in the middle of a lockless shadow page table walk, which\n\t * may reference the pages.\n\t */\n\tkvm_mmu_commit_zap_page(kvm, &kvm->arch.zapped_obsolete_pages);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define BATCH_ZAP_PAGES\t10"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define BATCH_ZAP_PAGES\t10\n\nstatic void kvm_zap_obsolete_pages(struct kvm *kvm)\n{\n\tstruct kvm_mmu_page *sp, *node;\n\tint nr_zapped, batch = 0;\n\nrestart:\n\tlist_for_each_entry_safe_reverse(sp, node,\n\t      &kvm->arch.active_mmu_pages, link) {\n\t\t/*\n\t\t * No obsolete valid page exists before a newly created page\n\t\t * since active_mmu_pages is a FIFO list.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Skip invalid pages with a non-zero root count, zapping pages\n\t\t * with a non-zero root count will never succeed, i.e. the page\n\t\t * will get thrown back on active_mmu_pages and we'll get stuck\n\t\t * in an infinite loop.\n\t\t */\n\t\tif (sp->role.invalid && sp->root_count)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need to flush the TLB since we're only zapping shadow\n\t\t * pages with an obsolete generation number and all vCPUS have\n\t\t * loaded a new root, i.e. the shadow pages being zapped cannot\n\t\t * be in active use by the guest.\n\t\t */\n\t\tif (batch >= BATCH_ZAP_PAGES &&\n\t\t    cond_resched_lock(&kvm->mmu_lock)) {\n\t\t\tbatch = 0;\n\t\t\tgoto restart;\n\t\t}\n\n\t\tif (__kvm_mmu_prepare_zap_page(kvm, sp,\n\t\t\t\t&kvm->arch.zapped_obsolete_pages, &nr_zapped)) {\n\t\t\tbatch += nr_zapped;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger a remote TLB flush before freeing the page tables to ensure\n\t * KVM is not in the middle of a lockless shadow page table walk, which\n\t * may reference the pages.\n\t */\n\tkvm_mmu_commit_zap_page(kvm, &kvm->arch.zapped_obsolete_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_reload_remote_mmus",
          "args": [
            "kvm"
          ],
          "line": 5810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_zap_all_fast",
          "args": [
            "kvm"
          ],
          "line": 5791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 5788
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_zap_all_fast(struct kvm *kvm)\n{\n\tlockdep_assert_held(&kvm->slots_lock);\n\n\tspin_lock(&kvm->mmu_lock);\n\ttrace_kvm_mmu_zap_all_fast(kvm);\n\n\t/*\n\t * Toggle mmu_valid_gen between '0' and '1'.  Because slots_lock is\n\t * held for the entire duration of zapping obsolete pages, it's\n\t * impossible for there to be multiple invalid generations associated\n\t * with *valid* shadow pages at any given time, i.e. there is exactly\n\t * one valid generation and (at most) one invalid generation.\n\t */\n\tkvm->arch.mmu_valid_gen = kvm->arch.mmu_valid_gen ? 0 : 1;\n\n\t/*\n\t * Notify all vcpus to reload its shadow page table and flush TLB.\n\t * Then all vcpus will switch to new shadow page table with the new\n\t * mmu_valid_gen.\n\t *\n\t * Note: we need to do this under the protection of mmu_lock,\n\t * otherwise, vcpu would purge shadow page but miss tlb flush.\n\t */\n\tkvm_reload_remote_mmus(kvm);\n\n\tkvm_zap_obsolete_pages(kvm);\n\tspin_unlock(&kvm->mmu_lock);\n}"
  },
  {
    "function_name": "kvm_zap_obsolete_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5726-5775",
    "snippet": "static void kvm_zap_obsolete_pages(struct kvm *kvm)\n{\n\tstruct kvm_mmu_page *sp, *node;\n\tint nr_zapped, batch = 0;\n\nrestart:\n\tlist_for_each_entry_safe_reverse(sp, node,\n\t      &kvm->arch.active_mmu_pages, link) {\n\t\t/*\n\t\t * No obsolete valid page exists before a newly created page\n\t\t * since active_mmu_pages is a FIFO list.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Skip invalid pages with a non-zero root count, zapping pages\n\t\t * with a non-zero root count will never succeed, i.e. the page\n\t\t * will get thrown back on active_mmu_pages and we'll get stuck\n\t\t * in an infinite loop.\n\t\t */\n\t\tif (sp->role.invalid && sp->root_count)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need to flush the TLB since we're only zapping shadow\n\t\t * pages with an obsolete generation number and all vCPUS have\n\t\t * loaded a new root, i.e. the shadow pages being zapped cannot\n\t\t * be in active use by the guest.\n\t\t */\n\t\tif (batch >= BATCH_ZAP_PAGES &&\n\t\t    cond_resched_lock(&kvm->mmu_lock)) {\n\t\t\tbatch = 0;\n\t\t\tgoto restart;\n\t\t}\n\n\t\tif (__kvm_mmu_prepare_zap_page(kvm, sp,\n\t\t\t\t&kvm->arch.zapped_obsolete_pages, &nr_zapped)) {\n\t\t\tbatch += nr_zapped;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger a remote TLB flush before freeing the page tables to ensure\n\t * KVM is not in the middle of a lockless shadow page table walk, which\n\t * may reference the pages.\n\t */\n\tkvm_mmu_commit_zap_page(kvm, &kvm->arch.zapped_obsolete_pages);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define BATCH_ZAP_PAGES\t10"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "kvm",
            "&kvm->arch.zapped_obsolete_pages"
          ],
          "line": 5774
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2795-2818",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "&kvm->arch.zapped_obsolete_pages",
            "&nr_zapped"
          ],
          "line": 5762
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2741-2784",
          "snippet": "static bool __kvm_mmu_prepare_zap_page(struct kvm *kvm,\n\t\t\t\t       struct kvm_mmu_page *sp,\n\t\t\t\t       struct list_head *invalid_list,\n\t\t\t\t       int *nr_zapped)\n{\n\tbool list_unstable;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\t*nr_zapped = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\t/* Zapping children means active_mmu_pages has become unstable. */\n\tlist_unstable = *nr_zapped;\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\t(*nr_zapped)++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * Obsolete pages cannot be used on any vCPUs, see the comment\n\t\t * in kvm_mmu_zap_all_fast().  Note, is_obsolete_sp() also\n\t\t * treats invalid shadow pages as being obsolete.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tif (sp->lpage_disallowed)\n\t\tunaccount_huge_nx_page(kvm, sp);\n\n\tsp->role.invalid = 1;\n\treturn list_unstable;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool __kvm_mmu_prepare_zap_page(struct kvm *kvm,\n\t\t\t\t       struct kvm_mmu_page *sp,\n\t\t\t\t       struct list_head *invalid_list,\n\t\t\t\t       int *nr_zapped)\n{\n\tbool list_unstable;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\t*nr_zapped = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\t/* Zapping children means active_mmu_pages has become unstable. */\n\tlist_unstable = *nr_zapped;\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\t(*nr_zapped)++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * Obsolete pages cannot be used on any vCPUs, see the comment\n\t\t * in kvm_mmu_zap_all_fast().  Note, is_obsolete_sp() also\n\t\t * treats invalid shadow pages as being obsolete.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tif (sp->lpage_disallowed)\n\t\tunaccount_huge_nx_page(kvm, sp);\n\n\tsp->role.invalid = 1;\n\treturn list_unstable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_obsolete_sp",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 5738
        },
        "resolved": true,
        "details": {
          "function_name": "is_obsolete_sp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2326-2330",
          "snippet": "static bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn sp->role.invalid ||\n\t       unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn sp->role.invalid ||\n\t       unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe_reverse",
          "args": [
            "sp",
            "node",
            "&kvm->arch.active_mmu_pages",
            "link"
          ],
          "line": 5732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define BATCH_ZAP_PAGES\t10\n\nstatic void kvm_zap_obsolete_pages(struct kvm *kvm)\n{\n\tstruct kvm_mmu_page *sp, *node;\n\tint nr_zapped, batch = 0;\n\nrestart:\n\tlist_for_each_entry_safe_reverse(sp, node,\n\t      &kvm->arch.active_mmu_pages, link) {\n\t\t/*\n\t\t * No obsolete valid page exists before a newly created page\n\t\t * since active_mmu_pages is a FIFO list.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Skip invalid pages with a non-zero root count, zapping pages\n\t\t * with a non-zero root count will never succeed, i.e. the page\n\t\t * will get thrown back on active_mmu_pages and we'll get stuck\n\t\t * in an infinite loop.\n\t\t */\n\t\tif (sp->role.invalid && sp->root_count)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * No need to flush the TLB since we're only zapping shadow\n\t\t * pages with an obsolete generation number and all vCPUS have\n\t\t * loaded a new root, i.e. the shadow pages being zapped cannot\n\t\t * be in active use by the guest.\n\t\t */\n\t\tif (batch >= BATCH_ZAP_PAGES &&\n\t\t    cond_resched_lock(&kvm->mmu_lock)) {\n\t\t\tbatch = 0;\n\t\t\tgoto restart;\n\t\t}\n\n\t\tif (__kvm_mmu_prepare_zap_page(kvm, sp,\n\t\t\t\t&kvm->arch.zapped_obsolete_pages, &nr_zapped)) {\n\t\t\tbatch += nr_zapped;\n\t\t\tgoto restart;\n\t\t}\n\t}\n\n\t/*\n\t * Trigger a remote TLB flush before freeing the page tables to ensure\n\t * KVM is not in the middle of a lockless shadow page table walk, which\n\t * may reference the pages.\n\t */\n\tkvm_mmu_commit_zap_page(kvm, &kvm->arch.zapped_obsolete_pages);\n}"
  },
  {
    "function_name": "kvm_mmu_create",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5689-5723",
    "snippet": "int kvm_mmu_create(struct kvm_vcpu *vcpu)\n{\n\tuint i;\n\tint ret;\n\n\tvcpu->arch.mmu = &vcpu->arch.root_mmu;\n\tvcpu->arch.walk_mmu = &vcpu->arch.root_mmu;\n\n\tvcpu->arch.root_mmu.root_hpa = INVALID_PAGE;\n\tvcpu->arch.root_mmu.root_cr3 = 0;\n\tvcpu->arch.root_mmu.translate_gpa = translate_gpa;\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tvcpu->arch.root_mmu.prev_roots[i] = KVM_MMU_ROOT_INFO_INVALID;\n\n\tvcpu->arch.guest_mmu.root_hpa = INVALID_PAGE;\n\tvcpu->arch.guest_mmu.root_cr3 = 0;\n\tvcpu->arch.guest_mmu.translate_gpa = translate_gpa;\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tvcpu->arch.guest_mmu.prev_roots[i] = KVM_MMU_ROOT_INFO_INVALID;\n\n\tvcpu->arch.nested_mmu.translate_gpa = translate_nested_gpa;\n\n\tret = alloc_mmu_pages(vcpu, &vcpu->arch.guest_mmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = alloc_mmu_pages(vcpu, &vcpu->arch.root_mmu);\n\tif (ret)\n\t\tgoto fail_allocate_root;\n\n\treturn ret;\n fail_allocate_root:\n\tfree_mmu_pages(&vcpu->arch.guest_mmu);\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_mmu_pages",
          "args": [
            "&vcpu->arch.guest_mmu"
          ],
          "line": 5721
        },
        "resolved": true,
        "details": {
          "function_name": "free_mmu_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5655-5659",
          "snippet": "static void free_mmu_pages(struct kvm_mmu *mmu)\n{\n\tfree_page((unsigned long)mmu->pae_root);\n\tfree_page((unsigned long)mmu->lm_root);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void free_mmu_pages(struct kvm_mmu *mmu)\n{\n\tfree_page((unsigned long)mmu->pae_root);\n\tfree_page((unsigned long)mmu->lm_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_mmu_pages",
          "args": [
            "vcpu",
            "&vcpu->arch.root_mmu"
          ],
          "line": 5715
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_mmu_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5661-5687",
          "snippet": "static int alloc_mmu_pages(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tstruct page *page;\n\tint i;\n\n\t/*\n\t * When using PAE paging, the four PDPTEs are treated as 'root' pages,\n\t * while the PDP table is a per-vCPU construct that's allocated at MMU\n\t * creation.  When emulating 32-bit mode, cr3 is only 32 bits even on\n\t * x86_64.  Therefore we need to allocate the PDP table in the first\n\t * 4GB of memory, which happens to fit the DMA32 zone.  Except for\n\t * SVM's 32-bit NPT support, TDP paging doesn't use PAE paging and can\n\t * skip allocating the PDP table.\n\t */\n\tif (tdp_enabled && kvm_x86_ops.get_tdp_level(vcpu) > PT32E_ROOT_LEVEL)\n\t\treturn 0;\n\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_DMA32);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tmmu->pae_root = page_address(page);\n\tfor (i = 0; i < 4; ++i)\n\t\tmmu->pae_root[i] = INVALID_PAGE;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool tdp_enabled = false;",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int alloc_mmu_pages(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tstruct page *page;\n\tint i;\n\n\t/*\n\t * When using PAE paging, the four PDPTEs are treated as 'root' pages,\n\t * while the PDP table is a per-vCPU construct that's allocated at MMU\n\t * creation.  When emulating 32-bit mode, cr3 is only 32 bits even on\n\t * x86_64.  Therefore we need to allocate the PDP table in the first\n\t * 4GB of memory, which happens to fit the DMA32 zone.  Except for\n\t * SVM's 32-bit NPT support, TDP paging doesn't use PAE paging and can\n\t * skip allocating the PDP table.\n\t */\n\tif (tdp_enabled && kvm_x86_ops.get_tdp_level(vcpu) > PT32E_ROOT_LEVEL)\n\t\treturn 0;\n\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_DMA32);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tmmu->pae_root = page_address(page);\n\tfor (i = 0; i < 4; ++i)\n\t\tmmu->pae_root[i] = INVALID_PAGE;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_create(struct kvm_vcpu *vcpu)\n{\n\tuint i;\n\tint ret;\n\n\tvcpu->arch.mmu = &vcpu->arch.root_mmu;\n\tvcpu->arch.walk_mmu = &vcpu->arch.root_mmu;\n\n\tvcpu->arch.root_mmu.root_hpa = INVALID_PAGE;\n\tvcpu->arch.root_mmu.root_cr3 = 0;\n\tvcpu->arch.root_mmu.translate_gpa = translate_gpa;\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tvcpu->arch.root_mmu.prev_roots[i] = KVM_MMU_ROOT_INFO_INVALID;\n\n\tvcpu->arch.guest_mmu.root_hpa = INVALID_PAGE;\n\tvcpu->arch.guest_mmu.root_cr3 = 0;\n\tvcpu->arch.guest_mmu.translate_gpa = translate_gpa;\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tvcpu->arch.guest_mmu.prev_roots[i] = KVM_MMU_ROOT_INFO_INVALID;\n\n\tvcpu->arch.nested_mmu.translate_gpa = translate_nested_gpa;\n\n\tret = alloc_mmu_pages(vcpu, &vcpu->arch.guest_mmu);\n\tif (ret)\n\t\treturn ret;\n\n\tret = alloc_mmu_pages(vcpu, &vcpu->arch.root_mmu);\n\tif (ret)\n\t\tgoto fail_allocate_root;\n\n\treturn ret;\n fail_allocate_root:\n\tfree_mmu_pages(&vcpu->arch.guest_mmu);\n\treturn ret;\n}"
  },
  {
    "function_name": "alloc_mmu_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5661-5687",
    "snippet": "static int alloc_mmu_pages(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tstruct page *page;\n\tint i;\n\n\t/*\n\t * When using PAE paging, the four PDPTEs are treated as 'root' pages,\n\t * while the PDP table is a per-vCPU construct that's allocated at MMU\n\t * creation.  When emulating 32-bit mode, cr3 is only 32 bits even on\n\t * x86_64.  Therefore we need to allocate the PDP table in the first\n\t * 4GB of memory, which happens to fit the DMA32 zone.  Except for\n\t * SVM's 32-bit NPT support, TDP paging doesn't use PAE paging and can\n\t * skip allocating the PDP table.\n\t */\n\tif (tdp_enabled && kvm_x86_ops.get_tdp_level(vcpu) > PT32E_ROOT_LEVEL)\n\t\treturn 0;\n\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_DMA32);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tmmu->pae_root = page_address(page);\n\tfor (i = 0; i < 4; ++i)\n\t\tmmu->pae_root[i] = INVALID_PAGE;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool tdp_enabled = false;",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 5682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL_ACCOUNT | __GFP_DMA32"
          ],
          "line": 5678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.get_tdp_level",
          "args": [
            "vcpu"
          ],
          "line": 5675
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int alloc_mmu_pages(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tstruct page *page;\n\tint i;\n\n\t/*\n\t * When using PAE paging, the four PDPTEs are treated as 'root' pages,\n\t * while the PDP table is a per-vCPU construct that's allocated at MMU\n\t * creation.  When emulating 32-bit mode, cr3 is only 32 bits even on\n\t * x86_64.  Therefore we need to allocate the PDP table in the first\n\t * 4GB of memory, which happens to fit the DMA32 zone.  Except for\n\t * SVM's 32-bit NPT support, TDP paging doesn't use PAE paging and can\n\t * skip allocating the PDP table.\n\t */\n\tif (tdp_enabled && kvm_x86_ops.get_tdp_level(vcpu) > PT32E_ROOT_LEVEL)\n\t\treturn 0;\n\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT | __GFP_DMA32);\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tmmu->pae_root = page_address(page);\n\tfor (i = 0; i < 4; ++i)\n\t\tmmu->pae_root[i] = INVALID_PAGE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_mmu_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5655-5659",
    "snippet": "static void free_mmu_pages(struct kvm_mmu *mmu)\n{\n\tfree_page((unsigned long)mmu->pae_root);\n\tfree_page((unsigned long)mmu->lm_root);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)mmu->lm_root"
          ],
          "line": 5658
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2066-2075",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void free_mmu_pages(struct kvm_mmu *mmu)\n{\n\tfree_page((unsigned long)mmu->pae_root);\n\tfree_page((unsigned long)mmu->lm_root);\n}"
  },
  {
    "function_name": "slot_handle_leaf",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5647-5653",
    "snippet": "static __always_inline bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slot_handle_level",
          "args": [
            "kvm",
            "memslot",
            "fn",
            "PT_PAGE_TABLE_LEVEL",
            "PT_PAGE_TABLE_LEVEL",
            "lock_flush_tlb"
          ],
          "line": 5651
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5620-5629",
          "snippet": "static __always_inline bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_leaf(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_PAGE_TABLE_LEVEL, lock_flush_tlb);\n}"
  },
  {
    "function_name": "slot_handle_large_level",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5639-5645",
    "snippet": "static __always_inline bool\nslot_handle_large_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL + 1,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slot_handle_level",
          "args": [
            "kvm",
            "memslot",
            "fn",
            "PT_PAGE_TABLE_LEVEL + 1",
            "PT_MAX_HUGEPAGE_LEVEL",
            "lock_flush_tlb"
          ],
          "line": 5643
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5620-5629",
          "snippet": "static __always_inline bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_large_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL + 1,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}"
  },
  {
    "function_name": "slot_handle_all_level",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5631-5637",
    "snippet": "static __always_inline bool\nslot_handle_all_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t      slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slot_handle_level",
          "args": [
            "kvm",
            "memslot",
            "fn",
            "PT_PAGE_TABLE_LEVEL",
            "PT_MAX_HUGEPAGE_LEVEL",
            "lock_flush_tlb"
          ],
          "line": 5635
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5620-5629",
          "snippet": "static __always_inline bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_all_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t      slot_level_handler fn, bool lock_flush_tlb)\n{\n\treturn slot_handle_level(kvm, memslot, fn, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t PT_MAX_HUGEPAGE_LEVEL, lock_flush_tlb);\n}"
  },
  {
    "function_name": "slot_handle_level",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5620-5629",
    "snippet": "static __always_inline bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slot_handle_level_range",
          "args": [
            "kvm",
            "memslot",
            "fn",
            "start_level",
            "end_level",
            "memslot->base_gfn",
            "memslot->base_gfn + memslot->npages - 1",
            "lock_flush_tlb"
          ],
          "line": 5625
        },
        "resolved": true,
        "details": {
          "function_name": "slot_handle_level_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5587-5618",
          "snippet": "static __always_inline bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs_with_address(kvm,\n\t\t\t\t\t\tstart_gfn,\n\t\t\t\t\t\titerator.gfn - start_gfn + 1);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs_with_address(kvm, start_gfn,\n\t\t\t\t\t\t   end_gfn - start_gfn + 1);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs_with_address(kvm,\n\t\t\t\t\t\tstart_gfn,\n\t\t\t\t\t\titerator.gfn - start_gfn + 1);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs_with_address(kvm, start_gfn,\n\t\t\t\t\t\t   end_gfn - start_gfn + 1);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_level(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t  slot_level_handler fn, int start_level, int end_level,\n\t\t  bool lock_flush_tlb)\n{\n\treturn slot_handle_level_range(kvm, memslot, fn, start_level,\n\t\t\tend_level, memslot->base_gfn,\n\t\t\tmemslot->base_gfn + memslot->npages - 1,\n\t\t\tlock_flush_tlb);\n}"
  },
  {
    "function_name": "slot_handle_level_range",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5587-5618",
    "snippet": "static __always_inline bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs_with_address(kvm,\n\t\t\t\t\t\tstart_gfn,\n\t\t\t\t\t\titerator.gfn - start_gfn + 1);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs_with_address(kvm, start_gfn,\n\t\t\t\t\t\t   end_gfn - start_gfn + 1);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs_with_address",
          "args": [
            "kvm",
            "start_gfn",
            "end_gfn - start_gfn + 1"
          ],
          "line": 5612
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_flush_remote_tlbs_with_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "323-332",
          "snippet": "static void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 5600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 5600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "kvm",
            "iterator.rmap"
          ],
          "line": 5598
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gfn_allow_lpage",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1211-1214",
          "snippet": "void kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_slot_rmap_range",
          "args": [
            "memslot",
            "start_level",
            "end_level",
            "start_gfn",
            "end_gfn",
            "&iterator"
          ],
          "line": 5595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic __always_inline bool\nslot_handle_level_range(struct kvm *kvm, struct kvm_memory_slot *memslot,\n\t\t\tslot_level_handler fn, int start_level, int end_level,\n\t\t\tgfn_t start_gfn, gfn_t end_gfn, bool lock_flush_tlb)\n{\n\tstruct slot_rmap_walk_iterator iterator;\n\tbool flush = false;\n\n\tfor_each_slot_rmap_range(memslot, start_level, end_level, start_gfn,\n\t\t\tend_gfn, &iterator) {\n\t\tif (iterator.rmap)\n\t\t\tflush |= fn(kvm, iterator.rmap);\n\n\t\tif (need_resched() || spin_needbreak(&kvm->mmu_lock)) {\n\t\t\tif (flush && lock_flush_tlb) {\n\t\t\t\tkvm_flush_remote_tlbs_with_address(kvm,\n\t\t\t\t\t\tstart_gfn,\n\t\t\t\t\t\titerator.gfn - start_gfn + 1);\n\t\t\t\tflush = false;\n\t\t\t}\n\t\t\tcond_resched_lock(&kvm->mmu_lock);\n\t\t}\n\t}\n\n\tif (flush && lock_flush_tlb) {\n\t\tkvm_flush_remote_tlbs_with_address(kvm, start_gfn,\n\t\t\t\t\t\t   end_gfn - start_gfn + 1);\n\t\tflush = false;\n\t}\n\n\treturn flush;\n}"
  },
  {
    "function_name": "kvm_configure_mmu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5563-5580",
    "snippet": "void kvm_configure_mmu(bool enable_tdp, int tdp_page_level)\n{\n\ttdp_enabled = enable_tdp;\n\n\t/*\n\t * max_page_level reflects the capabilities of KVM's MMU irrespective\n\t * of kernel support, e.g. KVM may be capable of using 1GB pages when\n\t * the kernel is not.  But, KVM never creates a page size greater than\n\t * what is used by the kernel for any given HVA, i.e. the kernel's\n\t * capabilities are ultimately consulted by kvm_mmu_hugepage_adjust().\n\t */\n\tif (tdp_enabled)\n\t\tmax_page_level = tdp_page_level;\n\telse if (boot_cpu_has(X86_FEATURE_GBPAGES))\n\t\tmax_page_level = PT_PDPE_LEVEL;\n\telse\n\t\tmax_page_level = PT_DIRECTORY_LEVEL;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool tdp_enabled = false;",
      "static int max_page_level"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_GBPAGES"
          ],
          "line": 5576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic int max_page_level;\n\nvoid kvm_configure_mmu(bool enable_tdp, int tdp_page_level)\n{\n\ttdp_enabled = enable_tdp;\n\n\t/*\n\t * max_page_level reflects the capabilities of KVM's MMU irrespective\n\t * of kernel support, e.g. KVM may be capable of using 1GB pages when\n\t * the kernel is not.  But, KVM never creates a page size greater than\n\t * what is used by the kernel for any given HVA, i.e. the kernel's\n\t * capabilities are ultimately consulted by kvm_mmu_hugepage_adjust().\n\t */\n\tif (tdp_enabled)\n\t\tmax_page_level = tdp_page_level;\n\telse if (boot_cpu_has(X86_FEATURE_GBPAGES))\n\t\tmax_page_level = PT_PDPE_LEVEL;\n\telse\n\t\tmax_page_level = PT_DIRECTORY_LEVEL;\n}"
  },
  {
    "function_name": "kvm_mmu_invpcid_gva",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5531-5560",
    "snippet": "void kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\t\ttlb_flush = true;\n\t}\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].cr3)) {\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\n\tif (tlb_flush)\n\t\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\n\t++vcpu->stat.invlpg;\n\n\t/*\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops.tlb_flush_gva",
          "args": [
            "vcpu",
            "gva"
          ],
          "line": 5551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu->invlpg",
          "args": [
            "vcpu",
            "gva",
            "mmu->prev_roots[i].hpa"
          ],
          "line": 5545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_pcid",
          "args": [
            "vcpu",
            "mmu->prev_roots[i].cr3"
          ],
          "line": 5544
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_pcid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "84-91",
          "snippet": "static inline unsigned long kvm_get_pcid(struct kvm_vcpu *vcpu, gpa_t cr3)\n{\n\tBUILD_BUG_ON((X86_CR3_PCID_MASK & PAGE_MASK) != 0);\n\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)\n\t       ? cr3 & X86_CR3_PCID_MASK\n\t       : 0;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_get_pcid(struct kvm_vcpu *vcpu, gpa_t cr3)\n{\n\tBUILD_BUG_ON((X86_CR3_PCID_MASK & PAGE_MASK) != 0);\n\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE)\n\t       ? cr3 & X86_CR3_PCID_MASK\n\t       : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "mmu->prev_roots[i].hpa"
          ],
          "line": 5543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu->invlpg",
          "args": [
            "vcpu",
            "gva",
            "mmu->root_hpa"
          ],
          "line": 5538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_active_pcid",
          "args": [
            "vcpu"
          ],
          "line": 5537
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_active_pcid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "93-96",
          "snippet": "static inline unsigned long kvm_get_active_pcid(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_get_pcid(vcpu, kvm_read_cr3(vcpu));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_get_active_pcid(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_get_pcid(vcpu, kvm_read_cr3(vcpu));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invpcid_gva(struct kvm_vcpu *vcpu, gva_t gva, unsigned long pcid)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tbool tlb_flush = false;\n\tuint i;\n\n\tif (pcid == kvm_get_active_pcid(vcpu)) {\n\t\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\t\ttlb_flush = true;\n\t}\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa) &&\n\t\t    pcid == kvm_get_pcid(vcpu, mmu->prev_roots[i].cr3)) {\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\t\t\ttlb_flush = true;\n\t\t}\n\t}\n\n\tif (tlb_flush)\n\t\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\n\t++vcpu->stat.invlpg;\n\n\t/*\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n}"
  },
  {
    "function_name": "kvm_mmu_invlpg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5500-5528",
    "snippet": "void kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tint i;\n\n\t/* INVLPG on a * non-canonical address is a NOP according to the SDM.  */\n\tif (is_noncanonical_address(gva, vcpu))\n\t\treturn;\n\n\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\n\t/*\n\t * INVLPG is required to invalidate any global mappings for the VA,\n\t * irrespective of PCID. Since it would take us roughly similar amount\n\t * of work to determine whether any of the prev_root mappings of the VA\n\t * is marked global, or to just sync it blindly, so we might as well\n\t * just always sync it.\n\t *\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\n\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops.tlb_flush_gva",
          "args": [
            "vcpu",
            "gva"
          ],
          "line": 5526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu->invlpg",
          "args": [
            "vcpu",
            "gva",
            "mmu->prev_roots[i].hpa"
          ],
          "line": 5524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "mmu->prev_roots[i].hpa"
          ],
          "line": 5523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu->invlpg",
          "args": [
            "vcpu",
            "gva",
            "mmu->root_hpa"
          ],
          "line": 5509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_noncanonical_address",
          "args": [
            "gva",
            "vcpu"
          ],
          "line": 5506
        },
        "resolved": true,
        "details": {
          "function_name": "emul_is_noncanonical_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/emulate.c",
          "lines": "673-677",
          "snippet": "static inline bool emul_is_noncanonical_address(u64 la,\n\t\t\t\t\t\tstruct x86_emulate_ctxt *ctxt)\n{\n\treturn get_canonical(la, ctxt_virt_addr_bits(ctxt)) != la;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"mmu.h\"",
            "#include \"tss.h\"",
            "#include \"x86.h\"",
            "#include <asm/nospec-branch.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/fpu/api.h>",
            "#include <linux/stringify.h>",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"mmu.h\"\n#include \"tss.h\"\n#include \"x86.h\"\n#include <asm/nospec-branch.h>\n#include <asm/debugreg.h>\n#include <asm/fpu/api.h>\n#include <linux/stringify.h>\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool emul_is_noncanonical_address(u64 la,\n\t\t\t\t\t\tstruct x86_emulate_ctxt *ctxt)\n{\n\treturn get_canonical(la, ctxt_virt_addr_bits(ctxt)) != la;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tint i;\n\n\t/* INVLPG on a * non-canonical address is a NOP according to the SDM.  */\n\tif (is_noncanonical_address(gva, vcpu))\n\t\treturn;\n\n\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\n\t/*\n\t * INVLPG is required to invalidate any global mappings for the VA,\n\t * irrespective of PCID. Since it would take us roughly similar amount\n\t * of work to determine whether any of the prev_root mappings of the VA\n\t * is marked global, or to just sync it blindly, so we might as well\n\t * just always sync it.\n\t *\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\n\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}"
  },
  {
    "function_name": "kvm_mmu_page_fault",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5429-5497",
    "snippet": "int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_PF;\n\tbool direct = vcpu->arch.mmu->direct_map;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tr = RET_PF_INVALID;\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);\n\t\tif (r == RET_PF_EMULATE)\n\t\t\tgoto emulate;\n\t}\n\n\tif (r == RET_PF_INVALID) {\n\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,\n\t\t\t\t\t  lower_32_bits(error_code), false);\n\t\tWARN_ON(r == RET_PF_INVALID);\n\t}\n\n\tif (r == RET_PF_RETRY)\n\t\treturn 1;\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * Before emulating the instruction, check if the error code\n\t * was due to a RO violation while translating the guest page.\n\t * This can occur when using nested virtualization with nested\n\t * paging in both guests. If true, we simply unprotect the page\n\t * and resume the guest.\n\t */\n\tif (vcpu->arch.mmu->direct_map &&\n\t    (error_code & PFERR_NESTED_GUEST_PAGE) == PFERR_NESTED_GUEST_PAGE) {\n\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(cr2_or_gpa));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * vcpu->arch.mmu.page_fault returned RET_PF_EMULATE, but we can still\n\t * optimistically try to just unprotect the page and let the processor\n\t * re-execute the instruction that caused the page fault.  Do not allow\n\t * retrying MMIO emulation, as it's not only pointless but could also\n\t * cause us to enter an infinite loop because the processor will keep\n\t * faulting on the non-existent MMIO address.  Retrying an instruction\n\t * from a nested guest is also pointless and dangerous as we are only\n\t * explicitly shadowing L1's page tables, i.e. unprotecting something\n\t * for L1 isn't going to magically fix whatever issue cause L2 to fail.\n\t */\n\tif (!mmio_info_in_cache(vcpu, cr2_or_gpa, direct) && !is_guest_mode(vcpu))\n\t\temulation_type |= EMULTYPE_ALLOW_RETRY_PF;\nemulate:\n\t/*\n\t * On AMD platforms, under certain conditions insn_len may be zero on #NPF.\n\t * This can happen if a guest gets a page-fault on data access but the HW\n\t * table walker is not able to read the instruction page (e.g instruction\n\t * page is not present in memory). In those cases we simply restart the\n\t * guest, with the exception of AMD Erratum 1096 which is unrecoverable.\n\t */\n\tif (unlikely(insn && !insn_len)) {\n\t\tif (!kvm_x86_ops.need_emulation_on_page_fault(vcpu))\n\t\t\treturn 1;\n\t}\n\n\treturn x86_emulate_instruction(vcpu, cr2_or_gpa, emulation_type, insn,\n\t\t\t\t       insn_len);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "x86_emulate_instruction",
          "args": [
            "vcpu",
            "cr2_or_gpa",
            "emulation_type",
            "insn",
            "insn_len"
          ],
          "line": 5495
        },
        "resolved": true,
        "details": {
          "function_name": "x86_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6748-6920",
          "snippet": "int x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t    int emulation_type, void *insn, int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->exception.vector = -1;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif ((emulation_type & EMULTYPE_TRAP_UD) ||\n\t\t\t    (emulation_type & EMULTYPE_TRAP_UD_FORCED)) {\n\t\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (reexecute_instruction(vcpu, cr2_or_gpa,\n\t\t\t\t\t\t  write_fault_to_spt,\n\t\t\t\t\t\t  emulation_type))\n\t\t\t\treturn 1;\n\t\t\tif (ctxt->have_exception) {\n\t\t\t\t/*\n\t\t\t\t * #UD should result in just EMULATION_FAILED, and trap-like\n\t\t\t\t * exception should not be encountered during decode.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(ctxt->exception.vector == UD_VECTOR ||\n\t\t\t\t\t     exception_type(ctxt->exception.vector) == EXCPT_TRAP);\n\t\t\t\tinject_emulated_exception(vcpu);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t\t}\n\t}\n\n\tif ((emulation_type & EMULTYPE_VMWARE_GP) &&\n\t    !is_vmware_backdoor_opcode(ctxt)) {\n\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Note, EMULTYPE_SKIP is intended for use *only* by vendor callbacks\n\t * for kvm_skip_emulated_instruction().  The caller is responsible for\n\t * updating interruptibility state and injecting single-step #DBs.\n\t */\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn 1;\n\t}\n\n\tif (retry_instruction(ctxt, cr2_or_gpa, emulation_type))\n\t\treturn 1;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tif (emulation_type & EMULTYPE_PF) {\n\t\t/* Save the faulting GPA (cr2) in the address field */\n\t\tctxt->exception.address = cr2_or_gpa;\n\n\t\t/* With shadow page tables, cr2 contains a GVA or nGPA. */\n\t\tif (vcpu->arch.mmu->direct_map) {\n\t\t\tctxt->gpa_available = true;\n\t\t\tctxt->gpa_val = cr2_or_gpa;\n\t\t}\n\t} else {\n\t\t/* Sanitize the address out of an abundance of paranoia. */\n\t\tctxt->exception.address = 0;\n\t}\n\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn 1;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn 1;\n\n\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = 1;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = 0;\n\t} else if (vcpu->mmio_needed) {\n\t\t++vcpu->stat.mmio_exits;\n\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = 0;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = 1;\n\n\tif (writeback) {\n\t\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tif (!ctxt->have_exception ||\n\t\t    exception_type(ctxt->exception.vector) == EXCPT_TRAP) {\n\t\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\t\tif (r && ctxt->tf)\n\t\t\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\t\t\tif (kvm_x86_ops.update_emulated_instruction)\n\t\t\t\tkvm_x86_ops.update_emulated_instruction(vcpu);\n\t\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\t\t}\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define EXCPT_TRAP\t\t1"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static const struct x86_emulate_ops emulate_ops = {\n\t.read_gpr            = emulator_read_gpr,\n\t.write_gpr           = emulator_write_gpr,\n\t.read_std            = emulator_read_std,\n\t.write_std           = emulator_write_std,\n\t.read_phys           = kvm_read_guest_phys_system,\n\t.fetch               = kvm_fetch_guest_virt,\n\t.read_emulated       = emulator_read_emulated,\n\t.write_emulated      = emulator_write_emulated,\n\t.cmpxchg_emulated    = emulator_cmpxchg_emulated,\n\t.invlpg              = emulator_invlpg,\n\t.pio_in_emulated     = emulator_pio_in_emulated,\n\t.pio_out_emulated    = emulator_pio_out_emulated,\n\t.get_segment         = emulator_get_segment,\n\t.set_segment         = emulator_set_segment,\n\t.get_cached_segment_base = emulator_get_cached_segment_base,\n\t.get_gdt             = emulator_get_gdt,\n\t.get_idt\t     = emulator_get_idt,\n\t.set_gdt             = emulator_set_gdt,\n\t.set_idt\t     = emulator_set_idt,\n\t.get_cr              = emulator_get_cr,\n\t.set_cr              = emulator_set_cr,\n\t.cpl                 = emulator_get_cpl,\n\t.get_dr              = emulator_get_dr,\n\t.set_dr              = emulator_set_dr,\n\t.get_smbase          = emulator_get_smbase,\n\t.set_smbase          = emulator_set_smbase,\n\t.set_msr             = emulator_set_msr,\n\t.get_msr             = emulator_get_msr,\n\t.check_pmc\t     = emulator_check_pmc,\n\t.read_pmc            = emulator_read_pmc,\n\t.halt                = emulator_halt,\n\t.wbinvd              = emulator_wbinvd,\n\t.fix_hypercall       = emulator_fix_hypercall,\n\t.intercept           = emulator_intercept,\n\t.get_cpuid           = emulator_get_cpuid,\n\t.guest_has_long_mode = emulator_guest_has_long_mode,\n\t.guest_has_movbe     = emulator_guest_has_movbe,\n\t.guest_has_fxsr      = emulator_guest_has_fxsr,\n\t.set_nmi_mask        = emulator_set_nmi_mask,\n\t.get_hflags          = emulator_get_hflags,\n\t.set_hflags          = emulator_set_hflags,\n\t.pre_leave_smm       = emulator_pre_leave_smm,\n\t.post_leave_smm      = emulator_post_leave_smm,\n\t.set_xcr             = emulator_set_xcr,\n};",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define EXCPT_TRAP\t\t1\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic const struct x86_emulate_ops emulate_ops = {\n\t.read_gpr            = emulator_read_gpr,\n\t.write_gpr           = emulator_write_gpr,\n\t.read_std            = emulator_read_std,\n\t.write_std           = emulator_write_std,\n\t.read_phys           = kvm_read_guest_phys_system,\n\t.fetch               = kvm_fetch_guest_virt,\n\t.read_emulated       = emulator_read_emulated,\n\t.write_emulated      = emulator_write_emulated,\n\t.cmpxchg_emulated    = emulator_cmpxchg_emulated,\n\t.invlpg              = emulator_invlpg,\n\t.pio_in_emulated     = emulator_pio_in_emulated,\n\t.pio_out_emulated    = emulator_pio_out_emulated,\n\t.get_segment         = emulator_get_segment,\n\t.set_segment         = emulator_set_segment,\n\t.get_cached_segment_base = emulator_get_cached_segment_base,\n\t.get_gdt             = emulator_get_gdt,\n\t.get_idt\t     = emulator_get_idt,\n\t.set_gdt             = emulator_set_gdt,\n\t.set_idt\t     = emulator_set_idt,\n\t.get_cr              = emulator_get_cr,\n\t.set_cr              = emulator_set_cr,\n\t.cpl                 = emulator_get_cpl,\n\t.get_dr              = emulator_get_dr,\n\t.set_dr              = emulator_set_dr,\n\t.get_smbase          = emulator_get_smbase,\n\t.set_smbase          = emulator_set_smbase,\n\t.set_msr             = emulator_set_msr,\n\t.get_msr             = emulator_get_msr,\n\t.check_pmc\t     = emulator_check_pmc,\n\t.read_pmc            = emulator_read_pmc,\n\t.halt                = emulator_halt,\n\t.wbinvd              = emulator_wbinvd,\n\t.fix_hypercall       = emulator_fix_hypercall,\n\t.intercept           = emulator_intercept,\n\t.get_cpuid           = emulator_get_cpuid,\n\t.guest_has_long_mode = emulator_guest_has_long_mode,\n\t.guest_has_movbe     = emulator_guest_has_movbe,\n\t.guest_has_fxsr      = emulator_guest_has_fxsr,\n\t.set_nmi_mask        = emulator_set_nmi_mask,\n\t.get_hflags          = emulator_get_hflags,\n\t.set_hflags          = emulator_set_hflags,\n\t.pre_leave_smm       = emulator_pre_leave_smm,\n\t.post_leave_smm      = emulator_post_leave_smm,\n\t.set_xcr             = emulator_set_xcr,\n};\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint x86_emulate_instruction(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t    int emulation_type, void *insn, int insn_len)\n{\n\tint r;\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tbool writeback = true;\n\tbool write_fault_to_spt = vcpu->arch.write_fault_to_shadow_pgtable;\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\n\t/*\n\t * Clear write_fault_to_shadow_pgtable here to ensure it is\n\t * never reused.\n\t */\n\tvcpu->arch.write_fault_to_shadow_pgtable = false;\n\tkvm_clear_exception_queue(vcpu);\n\n\tif (!(emulation_type & EMULTYPE_NO_DECODE)) {\n\t\tinit_emulate_ctxt(vcpu);\n\n\t\t/*\n\t\t * We will reenter on the same instruction since\n\t\t * we do not set complete_userspace_io.  This does not\n\t\t * handle watchpoints yet, those would be handled in\n\t\t * the emulate_ops.\n\t\t */\n\t\tif (!(emulation_type & EMULTYPE_SKIP) &&\n\t\t    kvm_vcpu_check_breakpoint(vcpu, &r))\n\t\t\treturn r;\n\n\t\tctxt->interruptibility = 0;\n\t\tctxt->have_exception = false;\n\t\tctxt->exception.vector = -1;\n\t\tctxt->perm_ok = false;\n\n\t\tctxt->ud = emulation_type & EMULTYPE_TRAP_UD;\n\n\t\tr = x86_decode_insn(ctxt, insn, insn_len);\n\n\t\ttrace_kvm_emulate_insn_start(vcpu);\n\t\t++vcpu->stat.insn_emulation;\n\t\tif (r != EMULATION_OK)  {\n\t\t\tif ((emulation_type & EMULTYPE_TRAP_UD) ||\n\t\t\t    (emulation_type & EMULTYPE_TRAP_UD_FORCED)) {\n\t\t\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (reexecute_instruction(vcpu, cr2_or_gpa,\n\t\t\t\t\t\t  write_fault_to_spt,\n\t\t\t\t\t\t  emulation_type))\n\t\t\t\treturn 1;\n\t\t\tif (ctxt->have_exception) {\n\t\t\t\t/*\n\t\t\t\t * #UD should result in just EMULATION_FAILED, and trap-like\n\t\t\t\t * exception should not be encountered during decode.\n\t\t\t\t */\n\t\t\t\tWARN_ON_ONCE(ctxt->exception.vector == UD_VECTOR ||\n\t\t\t\t\t     exception_type(ctxt->exception.vector) == EXCPT_TRAP);\n\t\t\t\tinject_emulated_exception(vcpu);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t\t}\n\t}\n\n\tif ((emulation_type & EMULTYPE_VMWARE_GP) &&\n\t    !is_vmware_backdoor_opcode(ctxt)) {\n\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, 0);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Note, EMULTYPE_SKIP is intended for use *only* by vendor callbacks\n\t * for kvm_skip_emulated_instruction().  The caller is responsible for\n\t * updating interruptibility state and injecting single-step #DBs.\n\t */\n\tif (emulation_type & EMULTYPE_SKIP) {\n\t\tkvm_rip_write(vcpu, ctxt->_eip);\n\t\tif (ctxt->eflags & X86_EFLAGS_RF)\n\t\t\tkvm_set_rflags(vcpu, ctxt->eflags & ~X86_EFLAGS_RF);\n\t\treturn 1;\n\t}\n\n\tif (retry_instruction(ctxt, cr2_or_gpa, emulation_type))\n\t\treturn 1;\n\n\t/* this is needed for vmware backdoor interface to work since it\n\t   changes registers values  during IO operation */\n\tif (vcpu->arch.emulate_regs_need_sync_from_vcpu) {\n\t\tvcpu->arch.emulate_regs_need_sync_from_vcpu = false;\n\t\temulator_invalidate_register_cache(ctxt);\n\t}\n\nrestart:\n\tif (emulation_type & EMULTYPE_PF) {\n\t\t/* Save the faulting GPA (cr2) in the address field */\n\t\tctxt->exception.address = cr2_or_gpa;\n\n\t\t/* With shadow page tables, cr2 contains a GVA or nGPA. */\n\t\tif (vcpu->arch.mmu->direct_map) {\n\t\t\tctxt->gpa_available = true;\n\t\t\tctxt->gpa_val = cr2_or_gpa;\n\t\t}\n\t} else {\n\t\t/* Sanitize the address out of an abundance of paranoia. */\n\t\tctxt->exception.address = 0;\n\t}\n\n\tr = x86_emulate_insn(ctxt);\n\n\tif (r == EMULATION_INTERCEPTED)\n\t\treturn 1;\n\n\tif (r == EMULATION_FAILED) {\n\t\tif (reexecute_instruction(vcpu, cr2_or_gpa, write_fault_to_spt,\n\t\t\t\t\temulation_type))\n\t\t\treturn 1;\n\n\t\treturn handle_emulation_failure(vcpu, emulation_type);\n\t}\n\n\tif (ctxt->have_exception) {\n\t\tr = 1;\n\t\tif (inject_emulated_exception(vcpu))\n\t\t\treturn r;\n\t} else if (vcpu->arch.pio.count) {\n\t\tif (!vcpu->arch.pio.in) {\n\t\t\t/* FIXME: return into emulator if single-stepping.  */\n\t\t\tvcpu->arch.pio.count = 0;\n\t\t} else {\n\t\t\twriteback = false;\n\t\t\tvcpu->arch.complete_userspace_io = complete_emulated_pio;\n\t\t}\n\t\tr = 0;\n\t} else if (vcpu->mmio_needed) {\n\t\t++vcpu->stat.mmio_exits;\n\n\t\tif (!vcpu->mmio_is_write)\n\t\t\twriteback = false;\n\t\tr = 0;\n\t\tvcpu->arch.complete_userspace_io = complete_emulated_mmio;\n\t} else if (r == EMULATION_RESTART)\n\t\tgoto restart;\n\telse\n\t\tr = 1;\n\n\tif (writeback) {\n\t\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\t\ttoggle_interruptibility(vcpu, ctxt->interruptibility);\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = false;\n\t\tif (!ctxt->have_exception ||\n\t\t    exception_type(ctxt->exception.vector) == EXCPT_TRAP) {\n\t\t\tkvm_rip_write(vcpu, ctxt->eip);\n\t\t\tif (r && ctxt->tf)\n\t\t\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\t\t\tif (kvm_x86_ops.update_emulated_instruction)\n\t\t\t\tkvm_x86_ops.update_emulated_instruction(vcpu);\n\t\t\t__kvm_set_rflags(vcpu, ctxt->eflags);\n\t\t}\n\n\t\t/*\n\t\t * For STI, interrupts are shadowed; so KVM_REQ_EVENT will\n\t\t * do nothing, and it will be requested again as soon as\n\t\t * the shadow expires.  But we still need to check here,\n\t\t * because POPF has no interrupt shadow.\n\t\t */\n\t\tif (unlikely((ctxt->eflags & ~rflags) & X86_EFLAGS_IF))\n\t\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t} else\n\t\tvcpu->arch.emulate_regs_need_sync_to_vcpu = true;\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.need_emulation_on_page_fault",
          "args": [
            "vcpu"
          ],
          "line": 5491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "insn && !insn_len"
          ],
          "line": 5490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 5480
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmio_info_in_cache",
          "args": [
            "vcpu",
            "cr2_or_gpa",
            "direct"
          ],
          "line": 5480
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_info_in_cache",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3934-3947",
          "snippet": "static bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\t/*\n\t * A nested guest cannot use the MMIO cache if it is using nested\n\t * page tables, because cr2 is a nGPA while the cache stores GPAs.\n\t */\n\tif (mmu_is_nested(vcpu))\n\t\treturn false;\n\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\t/*\n\t * A nested guest cannot use the MMIO cache if it is using nested\n\t * page tables, because cr2 is a nGPA while the cache stores GPAs.\n\t */\n\tif (mmu_is_nested(vcpu))\n\t\treturn false;\n\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unprotect_page",
          "args": [
            "vcpu->kvm",
            "gpa_to_gfn(cr2_or_gpa)"
          ],
          "line": 5465
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unprotect_page_virt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5413-5426",
          "snippet": "int kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "cr2_or_gpa"
          ],
          "line": 5465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "r == RET_PF_INVALID"
          ],
          "line": 5448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_do_page_fault",
          "args": [
            "vcpu",
            "cr2_or_gpa",
            "lower_32_bits(error_code)",
            "false"
          ],
          "line": 5446
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_do_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "108-116",
          "snippet": "static inline int kvm_mmu_do_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t\t\tu32 err, bool prefault)\n{\n#ifdef CONFIG_RETPOLINE\n\tif (likely(vcpu->arch.mmu->page_fault == kvm_tdp_page_fault))\n\t\treturn kvm_tdp_page_fault(vcpu, cr2_or_gpa, err, prefault);\n#endif\n\treturn vcpu->arch.mmu->page_fault(vcpu, cr2_or_gpa, err, prefault);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline int kvm_mmu_do_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t\t\tu32 err, bool prefault)\n{\n#ifdef CONFIG_RETPOLINE\n\tif (likely(vcpu->arch.mmu->page_fault == kvm_tdp_page_fault))\n\t\treturn kvm_tdp_page_fault(vcpu, cr2_or_gpa, err, prefault);\n#endif\n\treturn vcpu->arch.mmu->page_fault(vcpu, cr2_or_gpa, err, prefault);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lower_32_bits",
          "args": [
            "error_code"
          ],
          "line": 5447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_mmio_page_fault",
          "args": [
            "vcpu",
            "cr2_or_gpa",
            "direct"
          ],
          "line": 5440
        },
        "resolved": true,
        "details": {
          "function_name": "handle_mmio_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4000-4032",
          "snippet": "static int handle_mmio_page_fault(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tu64 spte;\n\tbool reserved;\n\n\tif (mmio_info_in_cache(vcpu, addr, direct))\n\t\treturn RET_PF_EMULATE;\n\n\treserved = walk_shadow_page_get_mmio_spte(vcpu, addr, &spte);\n\tif (WARN_ON(reserved))\n\t\treturn -EINVAL;\n\n\tif (is_mmio_spte(spte)) {\n\t\tgfn_t gfn = get_mmio_spte_gfn(spte);\n\t\tunsigned int access = get_mmio_spte_access(spte);\n\n\t\tif (!check_mmio_spte(vcpu, spte))\n\t\t\treturn RET_PF_INVALID;\n\n\t\tif (direct)\n\t\t\taddr = 0;\n\n\t\ttrace_handle_mmio_page_fault(addr, gfn, access);\n\t\tvcpu_cache_mmio_info(vcpu, addr, gfn, access);\n\t\treturn RET_PF_EMULATE;\n\t}\n\n\t/*\n\t * If the page table is zapped by other cpus, let CPU fault again on\n\t * the address.\n\t */\n\treturn RET_PF_RETRY;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int handle_mmio_page_fault(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tu64 spte;\n\tbool reserved;\n\n\tif (mmio_info_in_cache(vcpu, addr, direct))\n\t\treturn RET_PF_EMULATE;\n\n\treserved = walk_shadow_page_get_mmio_spte(vcpu, addr, &spte);\n\tif (WARN_ON(reserved))\n\t\treturn -EINVAL;\n\n\tif (is_mmio_spte(spte)) {\n\t\tgfn_t gfn = get_mmio_spte_gfn(spte);\n\t\tunsigned int access = get_mmio_spte_access(spte);\n\n\t\tif (!check_mmio_spte(vcpu, spte))\n\t\t\treturn RET_PF_INVALID;\n\n\t\tif (direct)\n\t\t\taddr = 0;\n\n\t\ttrace_handle_mmio_page_fault(addr, gfn, access);\n\t\tvcpu_cache_mmio_info(vcpu, addr, gfn, access);\n\t\treturn RET_PF_EMULATE;\n\t}\n\n\t/*\n\t * If the page table is zapped by other cpus, let CPU fault again on\n\t * the address.\n\t */\n\treturn RET_PF_RETRY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error_code & PFERR_RSVD_MASK"
          ],
          "line": 5439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!VALID_PAGE(vcpu->arch.mmu->root_hpa)"
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu->root_hpa"
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_PF;\n\tbool direct = vcpu->arch.mmu->direct_map;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tr = RET_PF_INVALID;\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);\n\t\tif (r == RET_PF_EMULATE)\n\t\t\tgoto emulate;\n\t}\n\n\tif (r == RET_PF_INVALID) {\n\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,\n\t\t\t\t\t  lower_32_bits(error_code), false);\n\t\tWARN_ON(r == RET_PF_INVALID);\n\t}\n\n\tif (r == RET_PF_RETRY)\n\t\treturn 1;\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * Before emulating the instruction, check if the error code\n\t * was due to a RO violation while translating the guest page.\n\t * This can occur when using nested virtualization with nested\n\t * paging in both guests. If true, we simply unprotect the page\n\t * and resume the guest.\n\t */\n\tif (vcpu->arch.mmu->direct_map &&\n\t    (error_code & PFERR_NESTED_GUEST_PAGE) == PFERR_NESTED_GUEST_PAGE) {\n\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(cr2_or_gpa));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * vcpu->arch.mmu.page_fault returned RET_PF_EMULATE, but we can still\n\t * optimistically try to just unprotect the page and let the processor\n\t * re-execute the instruction that caused the page fault.  Do not allow\n\t * retrying MMIO emulation, as it's not only pointless but could also\n\t * cause us to enter an infinite loop because the processor will keep\n\t * faulting on the non-existent MMIO address.  Retrying an instruction\n\t * from a nested guest is also pointless and dangerous as we are only\n\t * explicitly shadowing L1's page tables, i.e. unprotecting something\n\t * for L1 isn't going to magically fix whatever issue cause L2 to fail.\n\t */\n\tif (!mmio_info_in_cache(vcpu, cr2_or_gpa, direct) && !is_guest_mode(vcpu))\n\t\temulation_type |= EMULTYPE_ALLOW_RETRY_PF;\nemulate:\n\t/*\n\t * On AMD platforms, under certain conditions insn_len may be zero on #NPF.\n\t * This can happen if a guest gets a page-fault on data access but the HW\n\t * table walker is not able to read the instruction page (e.g instruction\n\t * page is not present in memory). In those cases we simply restart the\n\t * guest, with the exception of AMD Erratum 1096 which is unrecoverable.\n\t */\n\tif (unlikely(insn && !insn_len)) {\n\t\tif (!kvm_x86_ops.need_emulation_on_page_fault(vcpu))\n\t\t\treturn 1;\n\t}\n\n\treturn x86_emulate_instruction(vcpu, cr2_or_gpa, emulation_type, insn,\n\t\t\t\t       insn_len);\n}"
  },
  {
    "function_name": "kvm_mmu_unprotect_page_virt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5413-5426",
    "snippet": "int kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_unprotect_page",
          "args": [
            "vcpu->kvm",
            "gpa >> PAGE_SHIFT"
          ],
          "line": 5423
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unprotect_page_virt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5413-5426",
          "snippet": "int kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_gva_to_gpa_read",
          "args": [
            "vcpu",
            "gva",
            "NULL"
          ],
          "line": 5421
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gva_to_gpa_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "5359-5364",
          "snippet": "gpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops.get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\ngpa_t kvm_mmu_gva_to_gpa_read(struct kvm_vcpu *vcpu, gva_t gva,\n\t\t\t      struct x86_exception *exception)\n{\n\tu32 access = (kvm_x86_ops.get_cpl(vcpu) == 3) ? PFERR_USER_MASK : 0;\n\treturn vcpu->arch.walk_mmu->gva_to_gpa(vcpu, gva, access, exception);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_mmu_pte_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5345-5411",
    "snippet": "static void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t      const u8 *new, int bytes,\n\t\t\t      struct kvm_page_track_notifier_node *node)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\tu64 entry, gentry, *spte;\n\tint npte;\n\tbool remote_flush, local_flush;\n\n\t/*\n\t * If we don't have indirect shadow pages, it means no page is\n\t * write-protected, so we can exit simply.\n\t */\n\tif (!READ_ONCE(vcpu->kvm->arch.indirect_shadow_pages))\n\t\treturn;\n\n\tremote_flush = local_flush = false;\n\n\tpgprintk(\"%s: gpa %llx bytes %d\\n\", __func__, gpa, bytes);\n\n\t/*\n\t * No need to care whether allocation memory is successful\n\t * or not since pte prefetch is skiped if it does not have\n\t * enough objects in the cache.\n\t */\n\tmmu_topup_memory_caches(vcpu);\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\n\tgentry = mmu_pte_write_fetch_gpte(vcpu, &gpa, &bytes);\n\n\t++vcpu->kvm->stat.mmu_pte_write;\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_PTE_WRITE);\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (detect_write_misaligned(sp, gpa, bytes) ||\n\t\t      detect_write_flooding(sp)) {\n\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);\n\t\t\t++vcpu->kvm->stat.mmu_flooded;\n\t\t\tcontinue;\n\t\t}\n\n\t\tspte = get_written_sptes(sp, gpa, &npte);\n\t\tif (!spte)\n\t\t\tcontinue;\n\n\t\tlocal_flush = true;\n\t\twhile (npte--) {\n\t\t\tu32 base_role = vcpu->arch.mmu->mmu_role.base.word;\n\n\t\t\tentry = *spte;\n\t\t\tmmu_page_zap_pte(vcpu->kvm, sp, spte);\n\t\t\tif (gentry &&\n\t\t\t    !((sp->role.word ^ base_role) & ~role_ign.word) &&\n\t\t\t    rmap_can_add(vcpu))\n\t\t\t\tmmu_pte_write_new_pte(vcpu, sp, spte, &gentry);\n\t\t\tif (need_remote_flush(entry, *spte))\n\t\t\t\tremote_flush = true;\n\t\t\t++spte;\n\t\t}\n\t}\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, remote_flush, local_flush);\n\tkvm_mmu_audit(vcpu, AUDIT_POST_PTE_WRITE);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);",
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);",
      "static const union kvm_mmu_page_role role_ign = {\n\t.level = 0xf,\n\t.access = 0x7,\n\t.quadrant = 0x3,\n\t.invalid = 0x1,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 5410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_audit",
          "args": [
            "vcpu",
            "AUDIT_POST_PTE_WRITE"
          ],
          "line": 5409
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_audit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2322-2322",
          "snippet": "static void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_flush_or_zap",
          "args": [
            "vcpu",
            "&invalid_list",
            "remote_flush",
            "local_flush"
          ],
          "line": 5408
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_flush_or_zap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2308-2317",
          "snippet": "static void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (kvm_mmu_remote_flush_or_zap(vcpu->kvm, invalid_list, remote_flush))\n\t\treturn;\n\n\tif (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (kvm_mmu_remote_flush_or_zap(vcpu->kvm, invalid_list, remote_flush))\n\t\treturn;\n\n\tif (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_remote_flush",
          "args": [
            "entry",
            "*spte"
          ],
          "line": 5403
        },
        "resolved": true,
        "details": {
          "function_name": "need_remote_flush",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5214-5225",
          "snippet": "static bool need_remote_flush(u64 old, u64 new)\n{\n\tif (!is_shadow_present_pte(old))\n\t\treturn false;\n\tif (!is_shadow_present_pte(new))\n\t\treturn true;\n\tif ((old ^ new) & PT64_BASE_ADDR_MASK)\n\t\treturn true;\n\told ^= shadow_nx_mask;\n\tnew ^= shadow_nx_mask;\n\treturn (old & ~new & PT64_PERM_MASK) != 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_PERM_MASK (PT_PRESENT_MASK | PT_WRITABLE_MASK | shadow_user_mask \\\n\t\t\t| shadow_x_mask | shadow_nx_mask | shadow_me_mask)",
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_PERM_MASK (PT_PRESENT_MASK | PT_WRITABLE_MASK | shadow_user_mask \\\n\t\t\t| shadow_x_mask | shadow_nx_mask | shadow_me_mask)\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic bool need_remote_flush(u64 old, u64 new)\n{\n\tif (!is_shadow_present_pte(old))\n\t\treturn false;\n\tif (!is_shadow_present_pte(new))\n\t\treturn true;\n\tif ((old ^ new) & PT64_BASE_ADDR_MASK)\n\t\treturn true;\n\told ^= shadow_nx_mask;\n\tnew ^= shadow_nx_mask;\n\treturn (old & ~new & PT64_PERM_MASK) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_pte_write_new_pte",
          "args": [
            "vcpu",
            "sp",
            "spte",
            "&gentry"
          ],
          "line": 5402
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pte_write_new_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5201-5212",
          "snippet": "static void mmu_pte_write_new_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  const void *new)\n{\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL) {\n\t\t++vcpu->kvm->stat.mmu_pde_zapped;\n\t\treturn;\n        }\n\n\t++vcpu->kvm->stat.mmu_pte_updated;\n\tvcpu->arch.mmu->update_pte(vcpu, sp, spte, new);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void mmu_pte_write_new_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  const void *new)\n{\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL) {\n\t\t++vcpu->kvm->stat.mmu_pde_zapped;\n\t\treturn;\n        }\n\n\t++vcpu->kvm->stat.mmu_pte_updated;\n\tvcpu->arch.mmu->update_pte(vcpu, sp, spte, new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_can_add",
          "args": [
            "vcpu"
          ],
          "line": 5401
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_can_add",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1415-1421",
          "snippet": "static bool rmap_can_add(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_memory_cache *cache;\n\n\tcache = &vcpu->arch.mmu_pte_list_desc_cache;\n\treturn mmu_memory_cache_free_objects(cache);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool rmap_can_add(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_memory_cache *cache;\n\n\tcache = &vcpu->arch.mmu_pte_list_desc_cache;\n\treturn mmu_memory_cache_free_objects(cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_page_zap_pte",
          "args": [
            "vcpu->kvm",
            "sp",
            "spte"
          ],
          "line": 5398
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_page_zap_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2674-2697",
          "snippet": "static bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_written_sptes",
          "args": [
            "sp",
            "gpa",
            "&npte"
          ],
          "line": 5389
        },
        "resolved": true,
        "details": {
          "function_name": "get_written_sptes",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5298-5327",
          "snippet": "static u64 *get_written_sptes(struct kvm_mmu_page *sp, gpa_t gpa, int *nspte)\n{\n\tunsigned page_offset, quadrant;\n\tu64 *spte;\n\tint level;\n\n\tpage_offset = offset_in_page(gpa);\n\tlevel = sp->role.level;\n\t*nspte = 1;\n\tif (!sp->role.gpte_is_8_bytes) {\n\t\tpage_offset <<= 1;\t/* 32->64 */\n\t\t/*\n\t\t * A 32-bit pde maps 4MB while the shadow pdes map\n\t\t * only 2MB.  So we need to double the offset again\n\t\t * and zap two pdes instead of one.\n\t\t */\n\t\tif (level == PT32_ROOT_LEVEL) {\n\t\t\tpage_offset &= ~7; /* kill rounding error */\n\t\t\tpage_offset <<= 1;\n\t\t\t*nspte = 2;\n\t\t}\n\t\tquadrant = page_offset >> PAGE_SHIFT;\n\t\tpage_offset &= ~PAGE_MASK;\n\t\tif (quadrant != sp->role.quadrant)\n\t\t\treturn NULL;\n\t}\n\n\tspte = &sp->spt[page_offset / sizeof(*spte)];\n\treturn spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 *get_written_sptes(struct kvm_mmu_page *sp, gpa_t gpa, int *nspte)\n{\n\tunsigned page_offset, quadrant;\n\tu64 *spte;\n\tint level;\n\n\tpage_offset = offset_in_page(gpa);\n\tlevel = sp->role.level;\n\t*nspte = 1;\n\tif (!sp->role.gpte_is_8_bytes) {\n\t\tpage_offset <<= 1;\t/* 32->64 */\n\t\t/*\n\t\t * A 32-bit pde maps 4MB while the shadow pdes map\n\t\t * only 2MB.  So we need to double the offset again\n\t\t * and zap two pdes instead of one.\n\t\t */\n\t\tif (level == PT32_ROOT_LEVEL) {\n\t\t\tpage_offset &= ~7; /* kill rounding error */\n\t\t\tpage_offset <<= 1;\n\t\t\t*nspte = 2;\n\t\t}\n\t\tquadrant = page_offset >> PAGE_SHIFT;\n\t\tpage_offset &= ~PAGE_MASK;\n\t\tif (quadrant != sp->role.quadrant)\n\t\t\treturn NULL;\n\t}\n\n\tspte = &sp->spt[page_offset / sizeof(*spte)];\n\treturn spte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "vcpu->kvm",
            "sp",
            "&invalid_list"
          ],
          "line": 5384
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2786-2793",
          "snippet": "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_write_flooding",
          "args": [
            "sp"
          ],
          "line": 5383
        },
        "resolved": true,
        "details": {
          "function_name": "detect_write_flooding",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5257-5268",
          "snippet": "static bool detect_write_flooding(struct kvm_mmu_page *sp)\n{\n\t/*\n\t * Skip write-flooding detected for the sp whose level is 1, because\n\t * it can become unsync, then the guest page is not write-protected.\n\t */\n\tif (sp->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\tatomic_inc(&sp->write_flooding_count);\n\treturn atomic_read(&sp->write_flooding_count) >= 3;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool detect_write_flooding(struct kvm_mmu_page *sp)\n{\n\t/*\n\t * Skip write-flooding detected for the sp whose level is 1, because\n\t * it can become unsync, then the guest page is not write-protected.\n\t */\n\tif (sp->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\tatomic_inc(&sp->write_flooding_count);\n\treturn atomic_read(&sp->write_flooding_count) >= 3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "detect_write_misaligned",
          "args": [
            "sp",
            "gpa",
            "bytes"
          ],
          "line": 5382
        },
        "resolved": true,
        "details": {
          "function_name": "detect_write_misaligned",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5274-5296",
          "snippet": "static bool detect_write_misaligned(struct kvm_mmu_page *sp, gpa_t gpa,\n\t\t\t\t    int bytes)\n{\n\tunsigned offset, pte_size, misaligned;\n\n\tpgprintk(\"misaligned: gpa %llx bytes %d role %x\\n\",\n\t\t gpa, bytes, sp->role.word);\n\n\toffset = offset_in_page(gpa);\n\tpte_size = sp->role.gpte_is_8_bytes ? 8 : 4;\n\n\t/*\n\t * Sometimes, the OS only writes the last one bytes to update status\n\t * bits, for example, in linux, andb instruction is used in clear_bit().\n\t */\n\tif (!(offset & (pte_size - 1)) && bytes == 1)\n\t\treturn false;\n\n\tmisaligned = (offset ^ (offset + bytes - 1)) & ~(pte_size - 1);\n\tmisaligned |= bytes < 4;\n\n\treturn misaligned;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool detect_write_misaligned(struct kvm_mmu_page *sp, gpa_t gpa,\n\t\t\t\t    int bytes)\n{\n\tunsigned offset, pte_size, misaligned;\n\n\tpgprintk(\"misaligned: gpa %llx bytes %d role %x\\n\",\n\t\t gpa, bytes, sp->role.word);\n\n\toffset = offset_in_page(gpa);\n\tpte_size = sp->role.gpte_is_8_bytes ? 8 : 4;\n\n\t/*\n\t * Sometimes, the OS only writes the last one bytes to update status\n\t * bits, for example, in linux, andb instruction is used in clear_bit().\n\t */\n\tif (!(offset & (pte_size - 1)) && bytes == 1)\n\t\treturn false;\n\n\tmisaligned = (offset ^ (offset + bytes - 1)) & ~(pte_size - 1);\n\tmisaligned |= bytes < 4;\n\n\treturn misaligned;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_gfn_indirect_valid_sp",
          "args": [
            "vcpu->kvm",
            "sp",
            "gfn"
          ],
          "line": 5381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_pte_write_fetch_gpte",
          "args": [
            "vcpu",
            "&gpa",
            "&bytes"
          ],
          "line": 5376
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pte_write_fetch_gpte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5227-5251",
          "snippet": "static u64 mmu_pte_write_fetch_gpte(struct kvm_vcpu *vcpu, gpa_t *gpa,\n\t\t\t\t    int *bytes)\n{\n\tu64 gentry = 0;\n\tint r;\n\n\t/*\n\t * Assume that the pte write on a page table of the same type\n\t * as the current vcpu paging mode since we update the sptes only\n\t * when they have the same mode.\n\t */\n\tif (is_pae(vcpu) && *bytes == 4) {\n\t\t/* Handle a 32-bit guest writing two halves of a 64-bit gpte */\n\t\t*gpa &= ~(gpa_t)7;\n\t\t*bytes = 8;\n\t}\n\n\tif (*bytes == 4 || *bytes == 8) {\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, *gpa, &gentry, *bytes);\n\t\tif (r)\n\t\t\tgentry = 0;\n\t}\n\n\treturn gentry;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic u64 mmu_pte_write_fetch_gpte(struct kvm_vcpu *vcpu, gpa_t *gpa,\n\t\t\t\t    int *bytes)\n{\n\tu64 gentry = 0;\n\tint r;\n\n\t/*\n\t * Assume that the pte write on a page table of the same type\n\t * as the current vcpu paging mode since we update the sptes only\n\t * when they have the same mode.\n\t */\n\tif (is_pae(vcpu) && *bytes == 4) {\n\t\t/* Handle a 32-bit guest writing two halves of a 64-bit gpte */\n\t\t*gpa &= ~(gpa_t)7;\n\t\t*bytes = 8;\n\t}\n\n\tif (*bytes == 4 || *bytes == 8) {\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, *gpa, &gentry, *bytes);\n\t\tif (r)\n\t\t\tgentry = 0;\n\t}\n\n\treturn gentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 5374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_topup_memory_caches",
          "args": [
            "vcpu"
          ],
          "line": 5372
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_topup_memory_caches",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1112-1127",
          "snippet": "static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_PREFETCH_NUM\t\t8"
          ],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: gpa %llx bytes %d\\n\"",
            "__func__",
            "gpa",
            "bytes"
          ],
          "line": 5365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "vcpu->kvm->arch.indirect_shadow_pages"
          ],
          "line": 5360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 5351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\nstatic const union kvm_mmu_page_role role_ign = {\n\t.level = 0xf,\n\t.access = 0x7,\n\t.quadrant = 0x3,\n\t.invalid = 0x1,\n};\n\nstatic void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t      const u8 *new, int bytes,\n\t\t\t      struct kvm_page_track_notifier_node *node)\n{\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\tu64 entry, gentry, *spte;\n\tint npte;\n\tbool remote_flush, local_flush;\n\n\t/*\n\t * If we don't have indirect shadow pages, it means no page is\n\t * write-protected, so we can exit simply.\n\t */\n\tif (!READ_ONCE(vcpu->kvm->arch.indirect_shadow_pages))\n\t\treturn;\n\n\tremote_flush = local_flush = false;\n\n\tpgprintk(\"%s: gpa %llx bytes %d\\n\", __func__, gpa, bytes);\n\n\t/*\n\t * No need to care whether allocation memory is successful\n\t * or not since pte prefetch is skiped if it does not have\n\t * enough objects in the cache.\n\t */\n\tmmu_topup_memory_caches(vcpu);\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\n\tgentry = mmu_pte_write_fetch_gpte(vcpu, &gpa, &bytes);\n\n\t++vcpu->kvm->stat.mmu_pte_write;\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_PTE_WRITE);\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (detect_write_misaligned(sp, gpa, bytes) ||\n\t\t      detect_write_flooding(sp)) {\n\t\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, &invalid_list);\n\t\t\t++vcpu->kvm->stat.mmu_flooded;\n\t\t\tcontinue;\n\t\t}\n\n\t\tspte = get_written_sptes(sp, gpa, &npte);\n\t\tif (!spte)\n\t\t\tcontinue;\n\n\t\tlocal_flush = true;\n\t\twhile (npte--) {\n\t\t\tu32 base_role = vcpu->arch.mmu->mmu_role.base.word;\n\n\t\t\tentry = *spte;\n\t\t\tmmu_page_zap_pte(vcpu->kvm, sp, spte);\n\t\t\tif (gentry &&\n\t\t\t    !((sp->role.word ^ base_role) & ~role_ign.word) &&\n\t\t\t    rmap_can_add(vcpu))\n\t\t\t\tmmu_pte_write_new_pte(vcpu, sp, spte, &gentry);\n\t\t\tif (need_remote_flush(entry, *spte))\n\t\t\t\tremote_flush = true;\n\t\t\t++spte;\n\t\t}\n\t}\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, remote_flush, local_flush);\n\tkvm_mmu_audit(vcpu, AUDIT_POST_PTE_WRITE);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
  },
  {
    "function_name": "get_written_sptes",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5298-5327",
    "snippet": "static u64 *get_written_sptes(struct kvm_mmu_page *sp, gpa_t gpa, int *nspte)\n{\n\tunsigned page_offset, quadrant;\n\tu64 *spte;\n\tint level;\n\n\tpage_offset = offset_in_page(gpa);\n\tlevel = sp->role.level;\n\t*nspte = 1;\n\tif (!sp->role.gpte_is_8_bytes) {\n\t\tpage_offset <<= 1;\t/* 32->64 */\n\t\t/*\n\t\t * A 32-bit pde maps 4MB while the shadow pdes map\n\t\t * only 2MB.  So we need to double the offset again\n\t\t * and zap two pdes instead of one.\n\t\t */\n\t\tif (level == PT32_ROOT_LEVEL) {\n\t\t\tpage_offset &= ~7; /* kill rounding error */\n\t\t\tpage_offset <<= 1;\n\t\t\t*nspte = 2;\n\t\t}\n\t\tquadrant = page_offset >> PAGE_SHIFT;\n\t\tpage_offset &= ~PAGE_MASK;\n\t\tif (quadrant != sp->role.quadrant)\n\t\t\treturn NULL;\n\t}\n\n\tspte = &sp->spt[page_offset / sizeof(*spte)];\n\treturn spte;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "gpa"
          ],
          "line": 5304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 *get_written_sptes(struct kvm_mmu_page *sp, gpa_t gpa, int *nspte)\n{\n\tunsigned page_offset, quadrant;\n\tu64 *spte;\n\tint level;\n\n\tpage_offset = offset_in_page(gpa);\n\tlevel = sp->role.level;\n\t*nspte = 1;\n\tif (!sp->role.gpte_is_8_bytes) {\n\t\tpage_offset <<= 1;\t/* 32->64 */\n\t\t/*\n\t\t * A 32-bit pde maps 4MB while the shadow pdes map\n\t\t * only 2MB.  So we need to double the offset again\n\t\t * and zap two pdes instead of one.\n\t\t */\n\t\tif (level == PT32_ROOT_LEVEL) {\n\t\t\tpage_offset &= ~7; /* kill rounding error */\n\t\t\tpage_offset <<= 1;\n\t\t\t*nspte = 2;\n\t\t}\n\t\tquadrant = page_offset >> PAGE_SHIFT;\n\t\tpage_offset &= ~PAGE_MASK;\n\t\tif (quadrant != sp->role.quadrant)\n\t\t\treturn NULL;\n\t}\n\n\tspte = &sp->spt[page_offset / sizeof(*spte)];\n\treturn spte;\n}"
  },
  {
    "function_name": "detect_write_misaligned",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5274-5296",
    "snippet": "static bool detect_write_misaligned(struct kvm_mmu_page *sp, gpa_t gpa,\n\t\t\t\t    int bytes)\n{\n\tunsigned offset, pte_size, misaligned;\n\n\tpgprintk(\"misaligned: gpa %llx bytes %d role %x\\n\",\n\t\t gpa, bytes, sp->role.word);\n\n\toffset = offset_in_page(gpa);\n\tpte_size = sp->role.gpte_is_8_bytes ? 8 : 4;\n\n\t/*\n\t * Sometimes, the OS only writes the last one bytes to update status\n\t * bits, for example, in linux, andb instruction is used in clear_bit().\n\t */\n\tif (!(offset & (pte_size - 1)) && bytes == 1)\n\t\treturn false;\n\n\tmisaligned = (offset ^ (offset + bytes - 1)) & ~(pte_size - 1);\n\tmisaligned |= bytes < 4;\n\n\treturn misaligned;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "gpa"
          ],
          "line": 5282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"misaligned: gpa %llx bytes %d role %x\\n\"",
            "gpa",
            "bytes",
            "sp->role.word"
          ],
          "line": 5279
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool detect_write_misaligned(struct kvm_mmu_page *sp, gpa_t gpa,\n\t\t\t\t    int bytes)\n{\n\tunsigned offset, pte_size, misaligned;\n\n\tpgprintk(\"misaligned: gpa %llx bytes %d role %x\\n\",\n\t\t gpa, bytes, sp->role.word);\n\n\toffset = offset_in_page(gpa);\n\tpte_size = sp->role.gpte_is_8_bytes ? 8 : 4;\n\n\t/*\n\t * Sometimes, the OS only writes the last one bytes to update status\n\t * bits, for example, in linux, andb instruction is used in clear_bit().\n\t */\n\tif (!(offset & (pte_size - 1)) && bytes == 1)\n\t\treturn false;\n\n\tmisaligned = (offset ^ (offset + bytes - 1)) & ~(pte_size - 1);\n\tmisaligned |= bytes < 4;\n\n\treturn misaligned;\n}"
  },
  {
    "function_name": "detect_write_flooding",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5257-5268",
    "snippet": "static bool detect_write_flooding(struct kvm_mmu_page *sp)\n{\n\t/*\n\t * Skip write-flooding detected for the sp whose level is 1, because\n\t * it can become unsync, then the guest page is not write-protected.\n\t */\n\tif (sp->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\tatomic_inc(&sp->write_flooding_count);\n\treturn atomic_read(&sp->write_flooding_count) >= 3;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&sp->write_flooding_count"
          ],
          "line": 5267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&sp->write_flooding_count"
          ],
          "line": 5266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool detect_write_flooding(struct kvm_mmu_page *sp)\n{\n\t/*\n\t * Skip write-flooding detected for the sp whose level is 1, because\n\t * it can become unsync, then the guest page is not write-protected.\n\t */\n\tif (sp->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\tatomic_inc(&sp->write_flooding_count);\n\treturn atomic_read(&sp->write_flooding_count) >= 3;\n}"
  },
  {
    "function_name": "mmu_pte_write_fetch_gpte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5227-5251",
    "snippet": "static u64 mmu_pte_write_fetch_gpte(struct kvm_vcpu *vcpu, gpa_t *gpa,\n\t\t\t\t    int *bytes)\n{\n\tu64 gentry = 0;\n\tint r;\n\n\t/*\n\t * Assume that the pte write on a page table of the same type\n\t * as the current vcpu paging mode since we update the sptes only\n\t * when they have the same mode.\n\t */\n\tif (is_pae(vcpu) && *bytes == 4) {\n\t\t/* Handle a 32-bit guest writing two halves of a 64-bit gpte */\n\t\t*gpa &= ~(gpa_t)7;\n\t\t*bytes = 8;\n\t}\n\n\tif (*bytes == 4 || *bytes == 8) {\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, *gpa, &gentry, *bytes);\n\t\tif (r)\n\t\t\tgentry = 0;\n\t}\n\n\treturn gentry;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest_atomic",
          "args": [
            "vcpu",
            "*gpa",
            "&gentry",
            "*bytes"
          ],
          "line": 5245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 5238
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "143-146",
          "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic u64 mmu_pte_write_fetch_gpte(struct kvm_vcpu *vcpu, gpa_t *gpa,\n\t\t\t\t    int *bytes)\n{\n\tu64 gentry = 0;\n\tint r;\n\n\t/*\n\t * Assume that the pte write on a page table of the same type\n\t * as the current vcpu paging mode since we update the sptes only\n\t * when they have the same mode.\n\t */\n\tif (is_pae(vcpu) && *bytes == 4) {\n\t\t/* Handle a 32-bit guest writing two halves of a 64-bit gpte */\n\t\t*gpa &= ~(gpa_t)7;\n\t\t*bytes = 8;\n\t}\n\n\tif (*bytes == 4 || *bytes == 8) {\n\t\tr = kvm_vcpu_read_guest_atomic(vcpu, *gpa, &gentry, *bytes);\n\t\tif (r)\n\t\t\tgentry = 0;\n\t}\n\n\treturn gentry;\n}"
  },
  {
    "function_name": "need_remote_flush",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5214-5225",
    "snippet": "static bool need_remote_flush(u64 old, u64 new)\n{\n\tif (!is_shadow_present_pte(old))\n\t\treturn false;\n\tif (!is_shadow_present_pte(new))\n\t\treturn true;\n\tif ((old ^ new) & PT64_BASE_ADDR_MASK)\n\t\treturn true;\n\told ^= shadow_nx_mask;\n\tnew ^= shadow_nx_mask;\n\treturn (old & ~new & PT64_PERM_MASK) != 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_PERM_MASK (PT_PRESENT_MASK | PT_WRITABLE_MASK | shadow_user_mask \\\n\t\t\t| shadow_x_mask | shadow_nx_mask | shadow_me_mask)",
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
      "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "new"
          ],
          "line": 5218
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_PERM_MASK (PT_PRESENT_MASK | PT_WRITABLE_MASK | shadow_user_mask \\\n\t\t\t| shadow_x_mask | shadow_nx_mask | shadow_me_mask)\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic bool need_remote_flush(u64 old, u64 new)\n{\n\tif (!is_shadow_present_pte(old))\n\t\treturn false;\n\tif (!is_shadow_present_pte(new))\n\t\treturn true;\n\tif ((old ^ new) & PT64_BASE_ADDR_MASK)\n\t\treturn true;\n\told ^= shadow_nx_mask;\n\tnew ^= shadow_nx_mask;\n\treturn (old & ~new & PT64_PERM_MASK) != 0;\n}"
  },
  {
    "function_name": "mmu_pte_write_new_pte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5201-5212",
    "snippet": "static void mmu_pte_write_new_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  const void *new)\n{\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL) {\n\t\t++vcpu->kvm->stat.mmu_pde_zapped;\n\t\treturn;\n        }\n\n\t++vcpu->kvm->stat.mmu_pte_updated;\n\tvcpu->arch.mmu->update_pte(vcpu, sp, spte, new);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.mmu->update_pte",
          "args": [
            "vcpu",
            "sp",
            "spte",
            "new"
          ],
          "line": 5211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void mmu_pte_write_new_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t  const void *new)\n{\n\tif (sp->role.level != PT_PAGE_TABLE_LEVEL) {\n\t\t++vcpu->kvm->stat.mmu_pde_zapped;\n\t\treturn;\n        }\n\n\t++vcpu->kvm->stat.mmu_pte_updated;\n\tvcpu->arch.mmu->update_pte(vcpu, sp, spte, new);\n}"
  },
  {
    "function_name": "kvm_mmu_unload",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5192-5198",
    "snippet": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.root_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.root_mmu.root_hpa));\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.guest_mmu.root_hpa));\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "VALID_PAGE(vcpu->arch.guest_mmu.root_hpa)"
          ],
          "line": 5197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.guest_mmu.root_hpa"
          ],
          "line": 5197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_free_roots",
          "args": [
            "vcpu",
            "&vcpu->arch.guest_mmu",
            "KVM_MMU_ROOTS_ALL"
          ],
          "line": 5196
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_roots",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3629-3674",
          "snippet": "void kvm_mmu_free_roots(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\tulong roots_to_free)\n{\n\tint i;\n\tLIST_HEAD(invalid_list);\n\tbool free_active_root = roots_to_free & KVM_MMU_ROOT_CURRENT;\n\n\tBUILD_BUG_ON(KVM_MMU_NUM_PREV_ROOTS >= BITS_PER_LONG);\n\n\t/* Before acquiring the MMU lock, see if we need to do any real work. */\n\tif (!(free_active_root && VALID_PAGE(mmu->root_hpa))) {\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tif ((roots_to_free & KVM_MMU_ROOT_PREVIOUS(i)) &&\n\t\t\t    VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\t\tbreak;\n\n\t\tif (i == KVM_MMU_NUM_PREV_ROOTS)\n\t\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (roots_to_free & KVM_MMU_ROOT_PREVIOUS(i))\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->prev_roots[i].hpa,\n\t\t\t\t\t   &invalid_list);\n\n\tif (free_active_root) {\n\t\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t\t    (mmu->root_level >= PT64_ROOT_4LEVEL || mmu->direct_map)) {\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->root_hpa,\n\t\t\t\t\t   &invalid_list);\n\t\t} else {\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tif (mmu->pae_root[i] != 0)\n\t\t\t\t\tmmu_free_root_page(vcpu->kvm,\n\t\t\t\t\t\t\t   &mmu->pae_root[i],\n\t\t\t\t\t\t\t   &invalid_list);\n\t\t\tmmu->root_hpa = INVALID_PAGE;\n\t\t}\n\t\tmmu->root_cr3 = 0;\n\t}\n\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nvoid kvm_mmu_free_roots(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\tulong roots_to_free)\n{\n\tint i;\n\tLIST_HEAD(invalid_list);\n\tbool free_active_root = roots_to_free & KVM_MMU_ROOT_CURRENT;\n\n\tBUILD_BUG_ON(KVM_MMU_NUM_PREV_ROOTS >= BITS_PER_LONG);\n\n\t/* Before acquiring the MMU lock, see if we need to do any real work. */\n\tif (!(free_active_root && VALID_PAGE(mmu->root_hpa))) {\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tif ((roots_to_free & KVM_MMU_ROOT_PREVIOUS(i)) &&\n\t\t\t    VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\t\tbreak;\n\n\t\tif (i == KVM_MMU_NUM_PREV_ROOTS)\n\t\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (roots_to_free & KVM_MMU_ROOT_PREVIOUS(i))\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->prev_roots[i].hpa,\n\t\t\t\t\t   &invalid_list);\n\n\tif (free_active_root) {\n\t\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t\t    (mmu->root_level >= PT64_ROOT_4LEVEL || mmu->direct_map)) {\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->root_hpa,\n\t\t\t\t\t   &invalid_list);\n\t\t} else {\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tif (mmu->pae_root[i] != 0)\n\t\t\t\t\tmmu_free_root_page(vcpu->kvm,\n\t\t\t\t\t\t\t   &mmu->pae_root[i],\n\t\t\t\t\t\t\t   &invalid_list);\n\t\t\tmmu->root_hpa = INVALID_PAGE;\n\t\t}\n\t\tmmu->root_cr3 = 0;\n\t}\n\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "VALID_PAGE(vcpu->arch.root_mmu.root_hpa)"
          ],
          "line": 5195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.root_mmu.root_hpa"
          ],
          "line": 5195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.root_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.root_mmu.root_hpa));\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.guest_mmu.root_hpa));\n}"
  },
  {
    "function_name": "kvm_mmu_load",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5174-5189",
    "snippet": "int kvm_mmu_load(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_alloc_roots(vcpu);\n\tkvm_mmu_sync_roots(vcpu);\n\tif (r)\n\t\tgoto out;\n\tkvm_mmu_load_pgd(vcpu);\n\tkvm_x86_ops.tlb_flush(vcpu, true);\nout:\n\treturn r;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops.tlb_flush",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 5186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_load_pgd",
          "args": [
            "vcpu"
          ],
          "line": 5185
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_load_pgd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "98-103",
          "snippet": "static inline void kvm_mmu_load_pgd(struct kvm_vcpu *vcpu)\n{\n\tif (VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\tkvm_x86_ops.load_mmu_pgd(vcpu, vcpu->arch.mmu->root_hpa |\n\t\t\t\t\t       kvm_get_active_pcid(vcpu));\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_mmu_load_pgd(struct kvm_vcpu *vcpu)\n{\n\tif (VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\tkvm_x86_ops.load_mmu_pgd(vcpu, vcpu->arch.mmu->root_hpa |\n\t\t\t\t\t       kvm_get_active_pcid(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_sync_roots",
          "args": [
            "vcpu"
          ],
          "line": 5182
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_sync_roots",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3845-3901",
          "snippet": "void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\treturn;\n\n\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\t\tsp = page_header(root);\n\n\t\t/*\n\t\t * Even if another CPU was marking the SP as unsync-ed\n\t\t * simultaneously, any guest page table changes are not\n\t\t * guaranteed to be visible anyway until this VCPU issues a TLB\n\t\t * flush strictly after those changes are made. We only need to\n\t\t * ensure that the other CPU sets these flags before any actual\n\t\t * changes to the page tables are made. The comments in\n\t\t * mmu_need_write_protect() describe what could go wrong if this\n\t\t * requirement isn't satisfied.\n\t\t */\n\t\tif (!smp_load_acquire(&sp->unsync) &&\n\t\t    !smp_load_acquire(&sp->unsync_children))\n\t\t\treturn;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\t\tmmu_sync_children(vcpu, sp);\n\n\t\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\tmmu_sync_children(vcpu, sp);\n\t\t}\n\t}\n\n\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\treturn;\n\n\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\t\tsp = page_header(root);\n\n\t\t/*\n\t\t * Even if another CPU was marking the SP as unsync-ed\n\t\t * simultaneously, any guest page table changes are not\n\t\t * guaranteed to be visible anyway until this VCPU issues a TLB\n\t\t * flush strictly after those changes are made. We only need to\n\t\t * ensure that the other CPU sets these flags before any actual\n\t\t * changes to the page tables are made. The comments in\n\t\t * mmu_need_write_protect() describe what could go wrong if this\n\t\t * requirement isn't satisfied.\n\t\t */\n\t\tif (!smp_load_acquire(&sp->unsync) &&\n\t\t    !smp_load_acquire(&sp->unsync_children))\n\t\t\treturn;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\t\tmmu_sync_children(vcpu, sp);\n\n\t\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\tmmu_sync_children(vcpu, sp);\n\t\t}\n\t}\n\n\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_alloc_roots",
          "args": [
            "vcpu"
          ],
          "line": 5181
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_alloc_roots",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3837-3843",
          "snippet": "static int mmu_alloc_roots(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn mmu_alloc_direct_roots(vcpu);\n\telse\n\t\treturn mmu_alloc_shadow_roots(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_roots(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn mmu_alloc_direct_roots(vcpu);\n\telse\n\t\treturn mmu_alloc_shadow_roots(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_topup_memory_caches",
          "args": [
            "vcpu"
          ],
          "line": 5178
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_topup_memory_caches",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1112-1127",
          "snippet": "static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_PREFETCH_NUM\t\t8"
          ],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_load(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_alloc_roots(vcpu);\n\tkvm_mmu_sync_roots(vcpu);\n\tif (r)\n\t\tgoto out;\n\tkvm_mmu_load_pgd(vcpu);\n\tkvm_x86_ops.tlb_flush(vcpu, true);\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_mmu_reset_context",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5167-5171",
    "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tkvm_init_mmu(vcpu, true);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_init_mmu",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 5170
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_init_mmu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5134-5151",
          "snippet": "void kvm_init_mmu(struct kvm_vcpu *vcpu, bool reset_roots)\n{\n\tif (reset_roots) {\n\t\tuint i;\n\n\t\tvcpu->arch.mmu->root_hpa = INVALID_PAGE;\n\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tvcpu->arch.mmu->prev_roots[i] = KVM_MMU_ROOT_INFO_INVALID;\n\t}\n\n\tif (mmu_is_nested(vcpu))\n\t\tinit_kvm_nested_mmu(vcpu);\n\telse if (tdp_enabled)\n\t\tinit_kvm_tdp_mmu(vcpu);\n\telse\n\t\tinit_kvm_softmmu(vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool tdp_enabled = false;",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_init_mmu(struct kvm_vcpu *vcpu, bool reset_roots)\n{\n\tif (reset_roots) {\n\t\tuint i;\n\n\t\tvcpu->arch.mmu->root_hpa = INVALID_PAGE;\n\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tvcpu->arch.mmu->prev_roots[i] = KVM_MMU_ROOT_INFO_INVALID;\n\t}\n\n\tif (mmu_is_nested(vcpu))\n\t\tinit_kvm_nested_mmu(vcpu);\n\telse if (tdp_enabled)\n\t\tinit_kvm_tdp_mmu(vcpu);\n\telse\n\t\tinit_kvm_softmmu(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unload",
          "args": [
            "vcpu"
          ],
          "line": 5169
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unload",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5192-5198",
          "snippet": "void kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.root_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.root_mmu.root_hpa));\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.guest_mmu.root_hpa));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_unload(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.root_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.root_mmu.root_hpa));\n\tkvm_mmu_free_roots(vcpu, &vcpu->arch.guest_mmu, KVM_MMU_ROOTS_ALL);\n\tWARN_ON(VALID_PAGE(vcpu->arch.guest_mmu.root_hpa));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tkvm_init_mmu(vcpu, true);\n}"
  },
  {
    "function_name": "kvm_mmu_calc_root_page_role",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5154-5165",
    "snippet": "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_role role;\n\n\tif (tdp_enabled)\n\t\trole = kvm_calc_tdp_mmu_root_page_role(vcpu, true);\n\telse\n\t\trole = kvm_calc_shadow_mmu_root_page_role(vcpu, true);\n\n\treturn role.base;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool tdp_enabled = false;",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_calc_shadow_mmu_root_page_role",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 5162
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_calc_shadow_mmu_root_page_role",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4967-4987",
          "snippet": "static union kvm_mmu_role\nkvm_calc_shadow_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.smep_andnot_wp = role.ext.cr4_smep &&\n\t\t!is_write_protection(vcpu);\n\trole.base.smap_andnot_wp = role.ext.cr4_smap &&\n\t\t!is_write_protection(vcpu);\n\trole.base.direct = !is_paging(vcpu);\n\trole.base.gpte_is_8_bytes = !!is_pae(vcpu);\n\n\tif (!is_long_mode(vcpu))\n\t\trole.base.level = PT32E_ROOT_LEVEL;\n\telse if (is_la57_mode(vcpu))\n\t\trole.base.level = PT64_ROOT_5LEVEL;\n\telse\n\t\trole.base.level = PT64_ROOT_4LEVEL;\n\n\treturn role;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role\nkvm_calc_shadow_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.smep_andnot_wp = role.ext.cr4_smep &&\n\t\t!is_write_protection(vcpu);\n\trole.base.smap_andnot_wp = role.ext.cr4_smap &&\n\t\t!is_write_protection(vcpu);\n\trole.base.direct = !is_paging(vcpu);\n\trole.base.gpte_is_8_bytes = !!is_pae(vcpu);\n\n\tif (!is_long_mode(vcpu))\n\t\trole.base.level = PT32E_ROOT_LEVEL;\n\telse if (is_la57_mode(vcpu))\n\t\trole.base.level = PT64_ROOT_5LEVEL;\n\telse\n\t\trole.base.level = PT64_ROOT_4LEVEL;\n\n\treturn role;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_calc_tdp_mmu_root_page_role",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 5160
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_calc_tdp_mmu_root_page_role",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4906-4917",
          "snippet": "static union kvm_mmu_role\nkvm_calc_tdp_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.ad_disabled = (shadow_accessed_mask == 0);\n\trole.base.level = kvm_x86_ops.get_tdp_level(vcpu);\n\trole.base.direct = true;\n\trole.base.gpte_is_8_bytes = true;\n\n\treturn role;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role\nkvm_calc_tdp_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.ad_disabled = (shadow_accessed_mask == 0);\n\trole.base.level = kvm_x86_ops.get_tdp_level(vcpu);\n\trole.base.direct = true;\n\trole.base.gpte_is_8_bytes = true;\n\n\treturn role;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_role role;\n\n\tif (tdp_enabled)\n\t\trole = kvm_calc_tdp_mmu_root_page_role(vcpu, true);\n\telse\n\t\trole = kvm_calc_shadow_mmu_root_page_role(vcpu, true);\n\n\treturn role.base;\n}"
  },
  {
    "function_name": "kvm_init_mmu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5134-5151",
    "snippet": "void kvm_init_mmu(struct kvm_vcpu *vcpu, bool reset_roots)\n{\n\tif (reset_roots) {\n\t\tuint i;\n\n\t\tvcpu->arch.mmu->root_hpa = INVALID_PAGE;\n\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tvcpu->arch.mmu->prev_roots[i] = KVM_MMU_ROOT_INFO_INVALID;\n\t}\n\n\tif (mmu_is_nested(vcpu))\n\t\tinit_kvm_nested_mmu(vcpu);\n\telse if (tdp_enabled)\n\t\tinit_kvm_tdp_mmu(vcpu);\n\telse\n\t\tinit_kvm_softmmu(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool tdp_enabled = false;",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_kvm_softmmu",
          "args": [
            "vcpu"
          ],
          "line": 5150
        },
        "resolved": true,
        "details": {
          "function_name": "init_kvm_softmmu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5076-5084",
          "snippet": "static void init_kvm_softmmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\n\tkvm_init_shadow_mmu(vcpu);\n\tcontext->get_guest_pgd     = get_cr3;\n\tcontext->get_pdptr         = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_softmmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\n\tkvm_init_shadow_mmu(vcpu);\n\tcontext->get_guest_pgd     = get_cr3;\n\tcontext->get_pdptr         = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_kvm_tdp_mmu",
          "args": [
            "vcpu"
          ],
          "line": 5148
        },
        "resolved": true,
        "details": {
          "function_name": "init_kvm_tdp_mmu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4919-4965",
          "snippet": "static void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_tdp_mmu_root_page_role(vcpu, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\tcontext->page_fault = kvm_tdp_page_fault;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->shadow_root_level = kvm_x86_ops.get_tdp_level(vcpu);\n\tcontext->direct_map = true;\n\tcontext->get_guest_pgd = get_cr3;\n\tcontext->get_pdptr = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n\n\tif (!is_paging(vcpu)) {\n\t\tcontext->nx = false;\n\t\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\t\tcontext->root_level = 0;\n\t} else if (is_long_mode(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = is_la57_mode(vcpu) ?\n\t\t\t\tPT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else if (is_pae(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else {\n\t\tcontext->nx = false;\n\t\tcontext->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\t}\n\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_tdp_shadow_zero_bits_mask(vcpu, context);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_tdp_mmu_root_page_role(vcpu, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\tcontext->page_fault = kvm_tdp_page_fault;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->shadow_root_level = kvm_x86_ops.get_tdp_level(vcpu);\n\tcontext->direct_map = true;\n\tcontext->get_guest_pgd = get_cr3;\n\tcontext->get_pdptr = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n\n\tif (!is_paging(vcpu)) {\n\t\tcontext->nx = false;\n\t\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\t\tcontext->root_level = 0;\n\t} else if (is_long_mode(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = is_la57_mode(vcpu) ?\n\t\t\t\tPT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else if (is_pae(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else {\n\t\tcontext->nx = false;\n\t\tcontext->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\t}\n\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_tdp_shadow_zero_bits_mask(vcpu, context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_kvm_nested_mmu",
          "args": [
            "vcpu"
          ],
          "line": 5146
        },
        "resolved": true,
        "details": {
          "function_name": "init_kvm_nested_mmu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5086-5132",
          "snippet": "static void init_kvm_nested_mmu(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_role new_role = kvm_calc_mmu_role_common(vcpu, false);\n\tstruct kvm_mmu *g_context = &vcpu->arch.nested_mmu;\n\n\tif (new_role.as_u64 == g_context->mmu_role.as_u64)\n\t\treturn;\n\n\tg_context->mmu_role.as_u64 = new_role.as_u64;\n\tg_context->get_guest_pgd     = get_cr3;\n\tg_context->get_pdptr         = kvm_pdptr_read;\n\tg_context->inject_page_fault = kvm_inject_page_fault;\n\n\t/*\n\t * Note that arch.mmu->gva_to_gpa translates l2_gpa to l1_gpa using\n\t * L1's nested page tables (e.g. EPT12). The nested translation\n\t * of l2_gva to l1_gpa is done by arch.nested_mmu.gva_to_gpa using\n\t * L2's page tables as the first level of translation and L1's\n\t * nested page tables as the second level of translation. Basically\n\t * the gva_to_gpa functions between mmu and nested_mmu are swapped.\n\t */\n\tif (!is_paging(vcpu)) {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = 0;\n\t\tg_context->gva_to_gpa = nonpaging_gva_to_gpa_nested;\n\t} else if (is_long_mode(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = is_la57_mode(vcpu) ?\n\t\t\t\t\tPT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else if (is_pae(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging32_gva_to_gpa_nested;\n\t}\n\n\tupdate_permission_bitmask(vcpu, g_context, false);\n\tupdate_pkru_bitmask(vcpu, g_context, false);\n\tupdate_last_nonleaf_level(vcpu, g_context);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_nested_mmu(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_role new_role = kvm_calc_mmu_role_common(vcpu, false);\n\tstruct kvm_mmu *g_context = &vcpu->arch.nested_mmu;\n\n\tif (new_role.as_u64 == g_context->mmu_role.as_u64)\n\t\treturn;\n\n\tg_context->mmu_role.as_u64 = new_role.as_u64;\n\tg_context->get_guest_pgd     = get_cr3;\n\tg_context->get_pdptr         = kvm_pdptr_read;\n\tg_context->inject_page_fault = kvm_inject_page_fault;\n\n\t/*\n\t * Note that arch.mmu->gva_to_gpa translates l2_gpa to l1_gpa using\n\t * L1's nested page tables (e.g. EPT12). The nested translation\n\t * of l2_gva to l1_gpa is done by arch.nested_mmu.gva_to_gpa using\n\t * L2's page tables as the first level of translation and L1's\n\t * nested page tables as the second level of translation. Basically\n\t * the gva_to_gpa functions between mmu and nested_mmu are swapped.\n\t */\n\tif (!is_paging(vcpu)) {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = 0;\n\t\tg_context->gva_to_gpa = nonpaging_gva_to_gpa_nested;\n\t} else if (is_long_mode(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = is_la57_mode(vcpu) ?\n\t\t\t\t\tPT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else if (is_pae(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging32_gva_to_gpa_nested;\n\t}\n\n\tupdate_permission_bitmask(vcpu, g_context, false);\n\tupdate_pkru_bitmask(vcpu, g_context, false);\n\tupdate_last_nonleaf_level(vcpu, g_context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_is_nested",
          "args": [
            "vcpu"
          ],
          "line": 5145
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_is_nested",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "123-126",
          "snippet": "static inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_init_mmu(struct kvm_vcpu *vcpu, bool reset_roots)\n{\n\tif (reset_roots) {\n\t\tuint i;\n\n\t\tvcpu->arch.mmu->root_hpa = INVALID_PAGE;\n\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tvcpu->arch.mmu->prev_roots[i] = KVM_MMU_ROOT_INFO_INVALID;\n\t}\n\n\tif (mmu_is_nested(vcpu))\n\t\tinit_kvm_nested_mmu(vcpu);\n\telse if (tdp_enabled)\n\t\tinit_kvm_tdp_mmu(vcpu);\n\telse\n\t\tinit_kvm_softmmu(vcpu);\n}"
  },
  {
    "function_name": "init_kvm_nested_mmu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5086-5132",
    "snippet": "static void init_kvm_nested_mmu(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_role new_role = kvm_calc_mmu_role_common(vcpu, false);\n\tstruct kvm_mmu *g_context = &vcpu->arch.nested_mmu;\n\n\tif (new_role.as_u64 == g_context->mmu_role.as_u64)\n\t\treturn;\n\n\tg_context->mmu_role.as_u64 = new_role.as_u64;\n\tg_context->get_guest_pgd     = get_cr3;\n\tg_context->get_pdptr         = kvm_pdptr_read;\n\tg_context->inject_page_fault = kvm_inject_page_fault;\n\n\t/*\n\t * Note that arch.mmu->gva_to_gpa translates l2_gpa to l1_gpa using\n\t * L1's nested page tables (e.g. EPT12). The nested translation\n\t * of l2_gva to l1_gpa is done by arch.nested_mmu.gva_to_gpa using\n\t * L2's page tables as the first level of translation and L1's\n\t * nested page tables as the second level of translation. Basically\n\t * the gva_to_gpa functions between mmu and nested_mmu are swapped.\n\t */\n\tif (!is_paging(vcpu)) {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = 0;\n\t\tg_context->gva_to_gpa = nonpaging_gva_to_gpa_nested;\n\t} else if (is_long_mode(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = is_la57_mode(vcpu) ?\n\t\t\t\t\tPT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else if (is_pae(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging32_gva_to_gpa_nested;\n\t}\n\n\tupdate_permission_bitmask(vcpu, g_context, false);\n\tupdate_pkru_bitmask(vcpu, g_context, false);\n\tupdate_last_nonleaf_level(vcpu, g_context);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_last_nonleaf_level",
          "args": [
            "vcpu",
            "g_context"
          ],
          "line": 5131
        },
        "resolved": true,
        "details": {
          "function_name": "update_last_nonleaf_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4804-4811",
          "snippet": "static void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pkru_bitmask",
          "args": [
            "vcpu",
            "g_context",
            "false"
          ],
          "line": 5130
        },
        "resolved": true,
        "details": {
          "function_name": "update_pkru_bitmask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4753-4802",
          "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_permission_bitmask",
          "args": [
            "vcpu",
            "g_context",
            "false"
          ],
          "line": 5129
        },
        "resolved": true,
        "details": {
          "function_name": "update_permission_bitmask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4657-4727",
          "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define ACC_EXEC_MASK    1"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "g_context"
          ],
          "line": 5125
        },
        "resolved": true,
        "details": {
          "function_name": "reset_rsvds_bits_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4506-4515",
          "snippet": "static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu),\n\t\t\t\tguest_cpuid_is_amd_or_hygon(vcpu));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu),\n\t\t\t\tguest_cpuid_is_amd_or_hygon(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nx",
          "args": [
            "vcpu"
          ],
          "line": 5118
        },
        "resolved": true,
        "details": {
          "function_name": "is_nx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "606-609",
          "snippet": "static int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 5117
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "143-146",
          "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_la57_mode",
          "args": [
            "vcpu"
          ],
          "line": 5113
        },
        "resolved": true,
        "details": {
          "function_name": "is_la57_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "104-112",
          "snippet": "static inline bool is_la57_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn (vcpu->arch.efer & EFER_LMA) &&\n\t\t kvm_read_cr4_bits(vcpu, X86_CR4_LA57);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_la57_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn (vcpu->arch.efer & EFER_LMA) &&\n\t\t kvm_read_cr4_bits(vcpu, X86_CR4_LA57);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 5111
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "85-92",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 5107
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_calc_mmu_role_common",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 5088
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_calc_mmu_role_common",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4887-4904",
          "snippet": "static union kvm_mmu_role kvm_calc_mmu_role_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t   bool base_only)\n{\n\tunion kvm_mmu_role role = {0};\n\n\trole.base.access = ACC_ALL;\n\trole.base.nxe = !!is_nx(vcpu);\n\trole.base.cr0_wp = is_write_protection(vcpu);\n\trole.base.smm = is_smm(vcpu);\n\trole.base.guest_mode = is_guest_mode(vcpu);\n\n\tif (base_only)\n\t\treturn role;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\n\treturn role;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role kvm_calc_mmu_role_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t   bool base_only)\n{\n\tunion kvm_mmu_role role = {0};\n\n\trole.base.access = ACC_ALL;\n\trole.base.nxe = !!is_nx(vcpu);\n\trole.base.cr0_wp = is_write_protection(vcpu);\n\trole.base.smm = is_smm(vcpu);\n\trole.base.guest_mode = is_guest_mode(vcpu);\n\n\tif (base_only)\n\t\treturn role;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\n\treturn role;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_nested_mmu(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_role new_role = kvm_calc_mmu_role_common(vcpu, false);\n\tstruct kvm_mmu *g_context = &vcpu->arch.nested_mmu;\n\n\tif (new_role.as_u64 == g_context->mmu_role.as_u64)\n\t\treturn;\n\n\tg_context->mmu_role.as_u64 = new_role.as_u64;\n\tg_context->get_guest_pgd     = get_cr3;\n\tg_context->get_pdptr         = kvm_pdptr_read;\n\tg_context->inject_page_fault = kvm_inject_page_fault;\n\n\t/*\n\t * Note that arch.mmu->gva_to_gpa translates l2_gpa to l1_gpa using\n\t * L1's nested page tables (e.g. EPT12). The nested translation\n\t * of l2_gva to l1_gpa is done by arch.nested_mmu.gva_to_gpa using\n\t * L2's page tables as the first level of translation and L1's\n\t * nested page tables as the second level of translation. Basically\n\t * the gva_to_gpa functions between mmu and nested_mmu are swapped.\n\t */\n\tif (!is_paging(vcpu)) {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = 0;\n\t\tg_context->gva_to_gpa = nonpaging_gva_to_gpa_nested;\n\t} else if (is_long_mode(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = is_la57_mode(vcpu) ?\n\t\t\t\t\tPT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else if (is_pae(vcpu)) {\n\t\tg_context->nx = is_nx(vcpu);\n\t\tg_context->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging64_gva_to_gpa_nested;\n\t} else {\n\t\tg_context->nx = false;\n\t\tg_context->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, g_context);\n\t\tg_context->gva_to_gpa = paging32_gva_to_gpa_nested;\n\t}\n\n\tupdate_permission_bitmask(vcpu, g_context, false);\n\tupdate_pkru_bitmask(vcpu, g_context, false);\n\tupdate_last_nonleaf_level(vcpu, g_context);\n}"
  },
  {
    "function_name": "init_kvm_softmmu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5076-5084",
    "snippet": "static void init_kvm_softmmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\n\tkvm_init_shadow_mmu(vcpu);\n\tcontext->get_guest_pgd     = get_cr3;\n\tcontext->get_pdptr         = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_init_shadow_mmu",
          "args": [
            "vcpu"
          ],
          "line": 5080
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_init_shadow_mmu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4989-5009",
          "snippet": "void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_shadow_mmu_root_page_role(vcpu, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tif (!is_paging(vcpu))\n\t\tnonpaging_init_context(vcpu, context);\n\telse if (is_long_mode(vcpu))\n\t\tpaging64_init_context(vcpu, context);\n\telse if (is_pae(vcpu))\n\t\tpaging32E_init_context(vcpu, context);\n\telse\n\t\tpaging32_init_context(vcpu, context);\n\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\treset_shadow_zero_bits_mask(vcpu, context);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_shadow_mmu_root_page_role(vcpu, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tif (!is_paging(vcpu))\n\t\tnonpaging_init_context(vcpu, context);\n\telse if (is_long_mode(vcpu))\n\t\tpaging64_init_context(vcpu, context);\n\telse if (is_pae(vcpu))\n\t\tpaging32E_init_context(vcpu, context);\n\telse\n\t\tpaging32_init_context(vcpu, context);\n\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\treset_shadow_zero_bits_mask(vcpu, context);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_softmmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\n\tkvm_init_shadow_mmu(vcpu);\n\tcontext->get_guest_pgd     = get_cr3;\n\tcontext->get_pdptr         = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n}"
  },
  {
    "function_name": "kvm_init_shadow_ept_mmu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5041-5073",
    "snippet": "void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly,\n\t\t\t     bool accessed_dirty, gpa_t new_eptp)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tu8 level = vmx_eptp_page_walk_level(new_eptp);\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_shadow_ept_root_page_role(vcpu, accessed_dirty,\n\t\t\t\t\t\t   execonly, level);\n\n\t__kvm_mmu_new_cr3(vcpu, new_eptp, new_role.base, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tcontext->shadow_root_level = level;\n\n\tcontext->nx = true;\n\tcontext->ept_ad = accessed_dirty;\n\tcontext->page_fault = ept_page_fault;\n\tcontext->gva_to_gpa = ept_gva_to_gpa;\n\tcontext->sync_page = ept_sync_page;\n\tcontext->invlpg = ept_invlpg;\n\tcontext->update_pte = ept_update_pte;\n\tcontext->root_level = level;\n\tcontext->direct_map = false;\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\n\tupdate_permission_bitmask(vcpu, context, true);\n\tupdate_pkru_bitmask(vcpu, context, true);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_rsvds_bits_mask_ept(vcpu, context, execonly);\n\treset_ept_shadow_zero_bits_mask(vcpu, context, execonly);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_ept_shadow_zero_bits_mask",
          "args": [
            "vcpu",
            "context",
            "execonly"
          ],
          "line": 5072
        },
        "resolved": true,
        "details": {
          "function_name": "reset_ept_shadow_zero_bits_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4639-4645",
          "snippet": "static void\nreset_ept_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t    shadow_phys_bits, execonly);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void\nreset_ept_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t    shadow_phys_bits, execonly);\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_rsvds_bits_mask_ept",
          "args": [
            "vcpu",
            "context",
            "execonly"
          ],
          "line": 5071
        },
        "resolved": true,
        "details": {
          "function_name": "reset_rsvds_bits_mask_ept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4554-4559",
          "snippet": "static void reset_rsvds_bits_mask_ept(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->guest_rsvd_check,\n\t\t\t\t    cpuid_maxphyaddr(vcpu), execonly);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask_ept(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->guest_rsvd_check,\n\t\t\t\t    cpuid_maxphyaddr(vcpu), execonly);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_last_nonleaf_level",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 5070
        },
        "resolved": true,
        "details": {
          "function_name": "update_last_nonleaf_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4804-4811",
          "snippet": "static void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pkru_bitmask",
          "args": [
            "vcpu",
            "context",
            "true"
          ],
          "line": 5069
        },
        "resolved": true,
        "details": {
          "function_name": "update_pkru_bitmask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4753-4802",
          "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_permission_bitmask",
          "args": [
            "vcpu",
            "context",
            "true"
          ],
          "line": 5068
        },
        "resolved": true,
        "details": {
          "function_name": "update_permission_bitmask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4657-4727",
          "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define ACC_EXEC_MASK    1"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kvm_mmu_new_cr3",
          "args": [
            "vcpu",
            "new_eptp",
            "new_role.base",
            "false"
          ],
          "line": 5050
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_mmu_new_cr3",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4339-4346",
          "snippet": "static void __kvm_mmu_new_cr3(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t      union kvm_mmu_page_role new_role,\n\t\t\t      bool skip_tlb_flush)\n{\n\tif (!fast_cr3_switch(vcpu, new_cr3, new_role, skip_tlb_flush))\n\t\tkvm_mmu_free_roots(vcpu, vcpu->arch.mmu,\n\t\t\t\t   KVM_MMU_ROOT_CURRENT);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void __kvm_mmu_new_cr3(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t      union kvm_mmu_page_role new_role,\n\t\t\t      bool skip_tlb_flush)\n{\n\tif (!fast_cr3_switch(vcpu, new_cr3, new_role, skip_tlb_flush))\n\t\tkvm_mmu_free_roots(vcpu, vcpu->arch.mmu,\n\t\t\t\t   KVM_MMU_ROOT_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_calc_shadow_ept_root_page_role",
          "args": [
            "vcpu",
            "accessed_dirty",
            "execonly",
            "level"
          ],
          "line": 5047
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_calc_shadow_ept_root_page_role",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5012-5039",
          "snippet": "static union kvm_mmu_role\nkvm_calc_shadow_ept_root_page_role(struct kvm_vcpu *vcpu, bool accessed_dirty,\n\t\t\t\t   bool execonly, u8 level)\n{\n\tunion kvm_mmu_role role = {0};\n\n\t/* SMM flag is inherited from root_mmu */\n\trole.base.smm = vcpu->arch.root_mmu.mmu_role.base.smm;\n\n\trole.base.level = level;\n\trole.base.gpte_is_8_bytes = true;\n\trole.base.direct = false;\n\trole.base.ad_disabled = !accessed_dirty;\n\trole.base.guest_mode = true;\n\trole.base.access = ACC_ALL;\n\n\t/*\n\t * WP=1 and NOT_WP=1 is an impossible combination, use WP and the\n\t * SMAP variation to denote shadow EPT entries.\n\t */\n\trole.base.cr0_wp = true;\n\trole.base.smap_andnot_wp = true;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\trole.ext.execonly = execonly;\n\n\treturn role;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role\nkvm_calc_shadow_ept_root_page_role(struct kvm_vcpu *vcpu, bool accessed_dirty,\n\t\t\t\t   bool execonly, u8 level)\n{\n\tunion kvm_mmu_role role = {0};\n\n\t/* SMM flag is inherited from root_mmu */\n\trole.base.smm = vcpu->arch.root_mmu.mmu_role.base.smm;\n\n\trole.base.level = level;\n\trole.base.gpte_is_8_bytes = true;\n\trole.base.direct = false;\n\trole.base.ad_disabled = !accessed_dirty;\n\trole.base.guest_mode = true;\n\trole.base.access = ACC_ALL;\n\n\t/*\n\t * WP=1 and NOT_WP=1 is an impossible combination, use WP and the\n\t * SMAP variation to denote shadow EPT entries.\n\t */\n\trole.base.cr0_wp = true;\n\trole.base.smap_andnot_wp = true;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\trole.ext.execonly = execonly;\n\n\treturn role;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmx_eptp_page_walk_level",
          "args": [
            "new_eptp"
          ],
          "line": 5045
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly,\n\t\t\t     bool accessed_dirty, gpa_t new_eptp)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tu8 level = vmx_eptp_page_walk_level(new_eptp);\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_shadow_ept_root_page_role(vcpu, accessed_dirty,\n\t\t\t\t\t\t   execonly, level);\n\n\t__kvm_mmu_new_cr3(vcpu, new_eptp, new_role.base, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tcontext->shadow_root_level = level;\n\n\tcontext->nx = true;\n\tcontext->ept_ad = accessed_dirty;\n\tcontext->page_fault = ept_page_fault;\n\tcontext->gva_to_gpa = ept_gva_to_gpa;\n\tcontext->sync_page = ept_sync_page;\n\tcontext->invlpg = ept_invlpg;\n\tcontext->update_pte = ept_update_pte;\n\tcontext->root_level = level;\n\tcontext->direct_map = false;\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\n\tupdate_permission_bitmask(vcpu, context, true);\n\tupdate_pkru_bitmask(vcpu, context, true);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_rsvds_bits_mask_ept(vcpu, context, execonly);\n\treset_ept_shadow_zero_bits_mask(vcpu, context, execonly);\n}"
  },
  {
    "function_name": "kvm_calc_shadow_ept_root_page_role",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "5012-5039",
    "snippet": "static union kvm_mmu_role\nkvm_calc_shadow_ept_root_page_role(struct kvm_vcpu *vcpu, bool accessed_dirty,\n\t\t\t\t   bool execonly, u8 level)\n{\n\tunion kvm_mmu_role role = {0};\n\n\t/* SMM flag is inherited from root_mmu */\n\trole.base.smm = vcpu->arch.root_mmu.mmu_role.base.smm;\n\n\trole.base.level = level;\n\trole.base.gpte_is_8_bytes = true;\n\trole.base.direct = false;\n\trole.base.ad_disabled = !accessed_dirty;\n\trole.base.guest_mode = true;\n\trole.base.access = ACC_ALL;\n\n\t/*\n\t * WP=1 and NOT_WP=1 is an impossible combination, use WP and the\n\t * SMAP variation to denote shadow EPT entries.\n\t */\n\trole.base.cr0_wp = true;\n\trole.base.smap_andnot_wp = true;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\trole.ext.execonly = execonly;\n\n\treturn role;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_calc_mmu_role_ext",
          "args": [
            "vcpu"
          ],
          "line": 5035
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_calc_mmu_role_ext",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4870-4885",
          "snippet": "static union kvm_mmu_extended_role kvm_calc_mmu_role_ext(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_extended_role ext = {0};\n\n\text.cr0_pg = !!is_paging(vcpu);\n\text.cr4_pae = !!is_pae(vcpu);\n\text.cr4_smep = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\text.cr4_smap = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\text.cr4_pse = !!is_pse(vcpu);\n\text.cr4_pke = !!kvm_read_cr4_bits(vcpu, X86_CR4_PKE);\n\text.maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\text.valid = 1;\n\n\treturn ext;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_extended_role kvm_calc_mmu_role_ext(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_extended_role ext = {0};\n\n\text.cr0_pg = !!is_paging(vcpu);\n\text.cr4_pae = !!is_pae(vcpu);\n\text.cr4_smep = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\text.cr4_smap = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\text.cr4_pse = !!is_pse(vcpu);\n\text.cr4_pke = !!kvm_read_cr4_bits(vcpu, X86_CR4_PKE);\n\text.maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\text.valid = 1;\n\n\treturn ext;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role\nkvm_calc_shadow_ept_root_page_role(struct kvm_vcpu *vcpu, bool accessed_dirty,\n\t\t\t\t   bool execonly, u8 level)\n{\n\tunion kvm_mmu_role role = {0};\n\n\t/* SMM flag is inherited from root_mmu */\n\trole.base.smm = vcpu->arch.root_mmu.mmu_role.base.smm;\n\n\trole.base.level = level;\n\trole.base.gpte_is_8_bytes = true;\n\trole.base.direct = false;\n\trole.base.ad_disabled = !accessed_dirty;\n\trole.base.guest_mode = true;\n\trole.base.access = ACC_ALL;\n\n\t/*\n\t * WP=1 and NOT_WP=1 is an impossible combination, use WP and the\n\t * SMAP variation to denote shadow EPT entries.\n\t */\n\trole.base.cr0_wp = true;\n\trole.base.smap_andnot_wp = true;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\trole.ext.execonly = execonly;\n\n\treturn role;\n}"
  },
  {
    "function_name": "kvm_init_shadow_mmu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4989-5009",
    "snippet": "void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_shadow_mmu_root_page_role(vcpu, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tif (!is_paging(vcpu))\n\t\tnonpaging_init_context(vcpu, context);\n\telse if (is_long_mode(vcpu))\n\t\tpaging64_init_context(vcpu, context);\n\telse if (is_pae(vcpu))\n\t\tpaging32E_init_context(vcpu, context);\n\telse\n\t\tpaging32_init_context(vcpu, context);\n\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\treset_shadow_zero_bits_mask(vcpu, context);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_shadow_zero_bits_mask",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 5008
        },
        "resolved": true,
        "details": {
          "function_name": "reset_shadow_zero_bits_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4566-4593",
          "snippet": "void\nreset_shadow_zero_bits_mask(struct kvm_vcpu *vcpu, struct kvm_mmu *context)\n{\n\tbool uses_nx = context->nx ||\n\t\tcontext->mmu_role.base.smep_andnot_wp;\n\tstruct rsvd_bits_validate *shadow_zero_check;\n\tint i;\n\n\t/*\n\t * Passing \"true\" to the last argument is okay; it adds a check\n\t * on bit 8 of the SPTEs which KVM doesn't use anyway.\n\t */\n\tshadow_zero_check = &context->shadow_zero_check;\n\t__reset_rsvds_bits_mask(vcpu, shadow_zero_check,\n\t\t\t\tshadow_phys_bits,\n\t\t\t\tcontext->shadow_root_level, uses_nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu), true);\n\n\tif (!shadow_me_mask)\n\t\treturn;\n\n\tfor (i = context->shadow_root_level; --i >= 0;) {\n\t\tshadow_zero_check->rsvd_bits_mask[0][i] &= ~shadow_me_mask;\n\t\tshadow_zero_check->rsvd_bits_mask[1][i] &= ~shadow_me_mask;\n\t}\n\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid\nreset_shadow_zero_bits_mask(struct kvm_vcpu *vcpu, struct kvm_mmu *context)\n{\n\tbool uses_nx = context->nx ||\n\t\tcontext->mmu_role.base.smep_andnot_wp;\n\tstruct rsvd_bits_validate *shadow_zero_check;\n\tint i;\n\n\t/*\n\t * Passing \"true\" to the last argument is okay; it adds a check\n\t * on bit 8 of the SPTEs which KVM doesn't use anyway.\n\t */\n\tshadow_zero_check = &context->shadow_zero_check;\n\t__reset_rsvds_bits_mask(vcpu, shadow_zero_check,\n\t\t\t\tshadow_phys_bits,\n\t\t\t\tcontext->shadow_root_level, uses_nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu), true);\n\n\tif (!shadow_me_mask)\n\t\treturn;\n\n\tfor (i = context->shadow_root_level; --i >= 0;) {\n\t\tshadow_zero_check->rsvd_bits_mask[0][i] &= ~shadow_me_mask;\n\t\tshadow_zero_check->rsvd_bits_mask[1][i] &= ~shadow_me_mask;\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "paging32_init_context",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 5005
        },
        "resolved": true,
        "details": {
          "function_name": "paging32_init_context",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4844-4862",
          "snippet": "static void paging32_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tcontext->nx = false;\n\tcontext->root_level = PT32_ROOT_LEVEL;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tcontext->page_fault = paging32_page_fault;\n\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\tcontext->sync_page = paging32_sync_page;\n\tcontext->invlpg = paging32_invlpg;\n\tcontext->update_pte = paging32_update_pte;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->direct_map = false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void paging32_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tcontext->nx = false;\n\tcontext->root_level = PT32_ROOT_LEVEL;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tcontext->page_fault = paging32_page_fault;\n\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\tcontext->sync_page = paging32_sync_page;\n\tcontext->invlpg = paging32_invlpg;\n\tcontext->update_pte = paging32_update_pte;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->direct_map = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "paging32E_init_context",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 5003
        },
        "resolved": true,
        "details": {
          "function_name": "paging32E_init_context",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4864-4868",
          "snippet": "static void paging32E_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT32E_ROOT_LEVEL);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void paging32E_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT32E_ROOT_LEVEL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 5002
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "143-146",
          "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "paging64_init_context",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 5001
        },
        "resolved": true,
        "details": {
          "function_name": "paging64_init_context",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4835-4842",
          "snippet": "static void paging64_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tint root_level = is_la57_mode(vcpu) ?\n\t\t\t PT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\n\tpaging64_init_context_common(vcpu, context, root_level);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void paging64_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tint root_level = is_la57_mode(vcpu) ?\n\t\t\t PT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\n\tpaging64_init_context_common(vcpu, context, root_level);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 5000
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "85-92",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "nonpaging_init_context",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4999
        },
        "resolved": true,
        "details": {
          "function_name": "nonpaging_init_context",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4234-4246",
          "snippet": "static void nonpaging_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tcontext->page_fault = nonpaging_page_fault;\n\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->root_level = 0;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->direct_map = true;\n\tcontext->nx = false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void nonpaging_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tcontext->page_fault = nonpaging_page_fault;\n\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->root_level = 0;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->direct_map = true;\n\tcontext->nx = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 4998
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_calc_shadow_mmu_root_page_role",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 4993
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_calc_shadow_mmu_root_page_role",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4967-4987",
          "snippet": "static union kvm_mmu_role\nkvm_calc_shadow_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.smep_andnot_wp = role.ext.cr4_smep &&\n\t\t!is_write_protection(vcpu);\n\trole.base.smap_andnot_wp = role.ext.cr4_smap &&\n\t\t!is_write_protection(vcpu);\n\trole.base.direct = !is_paging(vcpu);\n\trole.base.gpte_is_8_bytes = !!is_pae(vcpu);\n\n\tif (!is_long_mode(vcpu))\n\t\trole.base.level = PT32E_ROOT_LEVEL;\n\telse if (is_la57_mode(vcpu))\n\t\trole.base.level = PT64_ROOT_5LEVEL;\n\telse\n\t\trole.base.level = PT64_ROOT_4LEVEL;\n\n\treturn role;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role\nkvm_calc_shadow_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.smep_andnot_wp = role.ext.cr4_smep &&\n\t\t!is_write_protection(vcpu);\n\trole.base.smap_andnot_wp = role.ext.cr4_smap &&\n\t\t!is_write_protection(vcpu);\n\trole.base.direct = !is_paging(vcpu);\n\trole.base.gpte_is_8_bytes = !!is_pae(vcpu);\n\n\tif (!is_long_mode(vcpu))\n\t\trole.base.level = PT32E_ROOT_LEVEL;\n\telse if (is_la57_mode(vcpu))\n\t\trole.base.level = PT64_ROOT_5LEVEL;\n\telse\n\t\trole.base.level = PT64_ROOT_4LEVEL;\n\n\treturn role;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_init_shadow_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_shadow_mmu_root_page_role(vcpu, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tif (!is_paging(vcpu))\n\t\tnonpaging_init_context(vcpu, context);\n\telse if (is_long_mode(vcpu))\n\t\tpaging64_init_context(vcpu, context);\n\telse if (is_pae(vcpu))\n\t\tpaging32E_init_context(vcpu, context);\n\telse\n\t\tpaging32_init_context(vcpu, context);\n\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\treset_shadow_zero_bits_mask(vcpu, context);\n}"
  },
  {
    "function_name": "kvm_calc_shadow_mmu_root_page_role",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4967-4987",
    "snippet": "static union kvm_mmu_role\nkvm_calc_shadow_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.smep_andnot_wp = role.ext.cr4_smep &&\n\t\t!is_write_protection(vcpu);\n\trole.base.smap_andnot_wp = role.ext.cr4_smap &&\n\t\t!is_write_protection(vcpu);\n\trole.base.direct = !is_paging(vcpu);\n\trole.base.gpte_is_8_bytes = !!is_pae(vcpu);\n\n\tif (!is_long_mode(vcpu))\n\t\trole.base.level = PT32E_ROOT_LEVEL;\n\telse if (is_la57_mode(vcpu))\n\t\trole.base.level = PT64_ROOT_5LEVEL;\n\telse\n\t\trole.base.level = PT64_ROOT_4LEVEL;\n\n\treturn role;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_la57_mode",
          "args": [
            "vcpu"
          ],
          "line": 4981
        },
        "resolved": true,
        "details": {
          "function_name": "is_la57_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "104-112",
          "snippet": "static inline bool is_la57_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn (vcpu->arch.efer & EFER_LMA) &&\n\t\t kvm_read_cr4_bits(vcpu, X86_CR4_LA57);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_la57_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn (vcpu->arch.efer & EFER_LMA) &&\n\t\t kvm_read_cr4_bits(vcpu, X86_CR4_LA57);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 4979
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "85-92",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 4977
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "143-146",
          "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 4976
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_write_protection",
          "args": [
            "vcpu"
          ],
          "line": 4975
        },
        "resolved": true,
        "details": {
          "function_name": "is_write_protection",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "156-159",
          "snippet": "static inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_calc_mmu_role_common",
          "args": [
            "vcpu",
            "base_only"
          ],
          "line": 4970
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_calc_mmu_role_common",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4887-4904",
          "snippet": "static union kvm_mmu_role kvm_calc_mmu_role_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t   bool base_only)\n{\n\tunion kvm_mmu_role role = {0};\n\n\trole.base.access = ACC_ALL;\n\trole.base.nxe = !!is_nx(vcpu);\n\trole.base.cr0_wp = is_write_protection(vcpu);\n\trole.base.smm = is_smm(vcpu);\n\trole.base.guest_mode = is_guest_mode(vcpu);\n\n\tif (base_only)\n\t\treturn role;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\n\treturn role;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role kvm_calc_mmu_role_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t   bool base_only)\n{\n\tunion kvm_mmu_role role = {0};\n\n\trole.base.access = ACC_ALL;\n\trole.base.nxe = !!is_nx(vcpu);\n\trole.base.cr0_wp = is_write_protection(vcpu);\n\trole.base.smm = is_smm(vcpu);\n\trole.base.guest_mode = is_guest_mode(vcpu);\n\n\tif (base_only)\n\t\treturn role;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\n\treturn role;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role\nkvm_calc_shadow_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.smep_andnot_wp = role.ext.cr4_smep &&\n\t\t!is_write_protection(vcpu);\n\trole.base.smap_andnot_wp = role.ext.cr4_smap &&\n\t\t!is_write_protection(vcpu);\n\trole.base.direct = !is_paging(vcpu);\n\trole.base.gpte_is_8_bytes = !!is_pae(vcpu);\n\n\tif (!is_long_mode(vcpu))\n\t\trole.base.level = PT32E_ROOT_LEVEL;\n\telse if (is_la57_mode(vcpu))\n\t\trole.base.level = PT64_ROOT_5LEVEL;\n\telse\n\t\trole.base.level = PT64_ROOT_4LEVEL;\n\n\treturn role;\n}"
  },
  {
    "function_name": "init_kvm_tdp_mmu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4919-4965",
    "snippet": "static void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_tdp_mmu_root_page_role(vcpu, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\tcontext->page_fault = kvm_tdp_page_fault;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->shadow_root_level = kvm_x86_ops.get_tdp_level(vcpu);\n\tcontext->direct_map = true;\n\tcontext->get_guest_pgd = get_cr3;\n\tcontext->get_pdptr = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n\n\tif (!is_paging(vcpu)) {\n\t\tcontext->nx = false;\n\t\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\t\tcontext->root_level = 0;\n\t} else if (is_long_mode(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = is_la57_mode(vcpu) ?\n\t\t\t\tPT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else if (is_pae(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else {\n\t\tcontext->nx = false;\n\t\tcontext->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\t}\n\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_tdp_shadow_zero_bits_mask(vcpu, context);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "reset_tdp_shadow_zero_bits_mask",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4964
        },
        "resolved": true,
        "details": {
          "function_name": "reset_tdp_shadow_zero_bits_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4606-4633",
          "snippet": "static void\nreset_tdp_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context)\n{\n\tstruct rsvd_bits_validate *shadow_zero_check;\n\tint i;\n\n\tshadow_zero_check = &context->shadow_zero_check;\n\n\tif (boot_cpu_is_amd())\n\t\t__reset_rsvds_bits_mask(vcpu, shadow_zero_check,\n\t\t\t\t\tshadow_phys_bits,\n\t\t\t\t\tcontext->shadow_root_level, false,\n\t\t\t\t\tboot_cpu_has(X86_FEATURE_GBPAGES),\n\t\t\t\t\ttrue, true);\n\telse\n\t\t__reset_rsvds_bits_mask_ept(shadow_zero_check,\n\t\t\t\t\t    shadow_phys_bits,\n\t\t\t\t\t    false);\n\n\tif (!shadow_me_mask)\n\t\treturn;\n\n\tfor (i = context->shadow_root_level; --i >= 0;) {\n\t\tshadow_zero_check->rsvd_bits_mask[0][i] &= ~shadow_me_mask;\n\t\tshadow_zero_check->rsvd_bits_mask[1][i] &= ~shadow_me_mask;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void\nreset_tdp_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context)\n{\n\tstruct rsvd_bits_validate *shadow_zero_check;\n\tint i;\n\n\tshadow_zero_check = &context->shadow_zero_check;\n\n\tif (boot_cpu_is_amd())\n\t\t__reset_rsvds_bits_mask(vcpu, shadow_zero_check,\n\t\t\t\t\tshadow_phys_bits,\n\t\t\t\t\tcontext->shadow_root_level, false,\n\t\t\t\t\tboot_cpu_has(X86_FEATURE_GBPAGES),\n\t\t\t\t\ttrue, true);\n\telse\n\t\t__reset_rsvds_bits_mask_ept(shadow_zero_check,\n\t\t\t\t\t    shadow_phys_bits,\n\t\t\t\t\t    false);\n\n\tif (!shadow_me_mask)\n\t\treturn;\n\n\tfor (i = context->shadow_root_level; --i >= 0;) {\n\t\tshadow_zero_check->rsvd_bits_mask[0][i] &= ~shadow_me_mask;\n\t\tshadow_zero_check->rsvd_bits_mask[1][i] &= ~shadow_me_mask;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_last_nonleaf_level",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4963
        },
        "resolved": true,
        "details": {
          "function_name": "update_last_nonleaf_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4804-4811",
          "snippet": "static void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pkru_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4962
        },
        "resolved": true,
        "details": {
          "function_name": "update_pkru_bitmask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4753-4802",
          "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_permission_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4961
        },
        "resolved": true,
        "details": {
          "function_name": "update_permission_bitmask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4657-4727",
          "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define ACC_EXEC_MASK    1"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4957
        },
        "resolved": true,
        "details": {
          "function_name": "reset_rsvds_bits_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4506-4515",
          "snippet": "static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu),\n\t\t\t\tguest_cpuid_is_amd_or_hygon(vcpu));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu),\n\t\t\t\tguest_cpuid_is_amd_or_hygon(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nx",
          "args": [
            "vcpu"
          ],
          "line": 4950
        },
        "resolved": true,
        "details": {
          "function_name": "is_nx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "606-609",
          "snippet": "static int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 4949
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "143-146",
          "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_la57_mode",
          "args": [
            "vcpu"
          ],
          "line": 4945
        },
        "resolved": true,
        "details": {
          "function_name": "is_la57_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "104-112",
          "snippet": "static inline bool is_la57_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn (vcpu->arch.efer & EFER_LMA) &&\n\t\t kvm_read_cr4_bits(vcpu, X86_CR4_LA57);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_la57_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn (vcpu->arch.efer & EFER_LMA) &&\n\t\t kvm_read_cr4_bits(vcpu, X86_CR4_LA57);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 4943
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "85-92",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 4939
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.get_tdp_level",
          "args": [
            "vcpu"
          ],
          "line": 4933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_calc_tdp_mmu_root_page_role",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 4923
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_calc_tdp_mmu_root_page_role",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4906-4917",
          "snippet": "static union kvm_mmu_role\nkvm_calc_tdp_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.ad_disabled = (shadow_accessed_mask == 0);\n\trole.base.level = kvm_x86_ops.get_tdp_level(vcpu);\n\trole.base.direct = true;\n\trole.base.gpte_is_8_bytes = true;\n\n\treturn role;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role\nkvm_calc_tdp_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.ad_disabled = (shadow_accessed_mask == 0);\n\trole.base.level = kvm_x86_ops.get_tdp_level(vcpu);\n\trole.base.direct = true;\n\trole.base.gpte_is_8_bytes = true;\n\n\treturn role;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_tdp_mmu_root_page_role(vcpu, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\tcontext->page_fault = kvm_tdp_page_fault;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->shadow_root_level = kvm_x86_ops.get_tdp_level(vcpu);\n\tcontext->direct_map = true;\n\tcontext->get_guest_pgd = get_cr3;\n\tcontext->get_pdptr = kvm_pdptr_read;\n\tcontext->inject_page_fault = kvm_inject_page_fault;\n\n\tif (!is_paging(vcpu)) {\n\t\tcontext->nx = false;\n\t\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\t\tcontext->root_level = 0;\n\t} else if (is_long_mode(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = is_la57_mode(vcpu) ?\n\t\t\t\tPT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else if (is_pae(vcpu)) {\n\t\tcontext->nx = is_nx(vcpu);\n\t\tcontext->root_level = PT32E_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\t} else {\n\t\tcontext->nx = false;\n\t\tcontext->root_level = PT32_ROOT_LEVEL;\n\t\treset_rsvds_bits_mask(vcpu, context);\n\t\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\t}\n\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_tdp_shadow_zero_bits_mask(vcpu, context);\n}"
  },
  {
    "function_name": "kvm_calc_tdp_mmu_root_page_role",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4906-4917",
    "snippet": "static union kvm_mmu_role\nkvm_calc_tdp_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.ad_disabled = (shadow_accessed_mask == 0);\n\trole.base.level = kvm_x86_ops.get_tdp_level(vcpu);\n\trole.base.direct = true;\n\trole.base.gpte_is_8_bytes = true;\n\n\treturn role;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops.get_tdp_level",
          "args": [
            "vcpu"
          ],
          "line": 4912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_calc_mmu_role_common",
          "args": [
            "vcpu",
            "base_only"
          ],
          "line": 4909
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_calc_mmu_role_common",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4887-4904",
          "snippet": "static union kvm_mmu_role kvm_calc_mmu_role_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t   bool base_only)\n{\n\tunion kvm_mmu_role role = {0};\n\n\trole.base.access = ACC_ALL;\n\trole.base.nxe = !!is_nx(vcpu);\n\trole.base.cr0_wp = is_write_protection(vcpu);\n\trole.base.smm = is_smm(vcpu);\n\trole.base.guest_mode = is_guest_mode(vcpu);\n\n\tif (base_only)\n\t\treturn role;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\n\treturn role;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role kvm_calc_mmu_role_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t   bool base_only)\n{\n\tunion kvm_mmu_role role = {0};\n\n\trole.base.access = ACC_ALL;\n\trole.base.nxe = !!is_nx(vcpu);\n\trole.base.cr0_wp = is_write_protection(vcpu);\n\trole.base.smm = is_smm(vcpu);\n\trole.base.guest_mode = is_guest_mode(vcpu);\n\n\tif (base_only)\n\t\treturn role;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\n\treturn role;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role\nkvm_calc_tdp_mmu_root_page_role(struct kvm_vcpu *vcpu, bool base_only)\n{\n\tunion kvm_mmu_role role = kvm_calc_mmu_role_common(vcpu, base_only);\n\n\trole.base.ad_disabled = (shadow_accessed_mask == 0);\n\trole.base.level = kvm_x86_ops.get_tdp_level(vcpu);\n\trole.base.direct = true;\n\trole.base.gpte_is_8_bytes = true;\n\n\treturn role;\n}"
  },
  {
    "function_name": "kvm_calc_mmu_role_common",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4887-4904",
    "snippet": "static union kvm_mmu_role kvm_calc_mmu_role_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t   bool base_only)\n{\n\tunion kvm_mmu_role role = {0};\n\n\trole.base.access = ACC_ALL;\n\trole.base.nxe = !!is_nx(vcpu);\n\trole.base.cr0_wp = is_write_protection(vcpu);\n\trole.base.smm = is_smm(vcpu);\n\trole.base.guest_mode = is_guest_mode(vcpu);\n\n\tif (base_only)\n\t\treturn role;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\n\treturn role;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_calc_mmu_role_ext",
          "args": [
            "vcpu"
          ],
          "line": 4901
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_calc_mmu_role_ext",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4870-4885",
          "snippet": "static union kvm_mmu_extended_role kvm_calc_mmu_role_ext(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_extended_role ext = {0};\n\n\text.cr0_pg = !!is_paging(vcpu);\n\text.cr4_pae = !!is_pae(vcpu);\n\text.cr4_smep = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\text.cr4_smap = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\text.cr4_pse = !!is_pse(vcpu);\n\text.cr4_pke = !!kvm_read_cr4_bits(vcpu, X86_CR4_PKE);\n\text.maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\text.valid = 1;\n\n\treturn ext;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_extended_role kvm_calc_mmu_role_ext(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_extended_role ext = {0};\n\n\text.cr0_pg = !!is_paging(vcpu);\n\text.cr4_pae = !!is_pae(vcpu);\n\text.cr4_smep = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\text.cr4_smap = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\text.cr4_pse = !!is_pse(vcpu);\n\text.cr4_pke = !!kvm_read_cr4_bits(vcpu, X86_CR4_PKE);\n\text.maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\text.valid = 1;\n\n\treturn ext;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 4896
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_smm",
          "args": [
            "vcpu"
          ],
          "line": 4895
        },
        "resolved": true,
        "details": {
          "function_name": "is_smm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "175-178",
          "snippet": "static inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_smm(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_SMM_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_write_protection",
          "args": [
            "vcpu"
          ],
          "line": 4894
        },
        "resolved": true,
        "details": {
          "function_name": "is_write_protection",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "156-159",
          "snippet": "static inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nx",
          "args": [
            "vcpu"
          ],
          "line": 4893
        },
        "resolved": true,
        "details": {
          "function_name": "is_nx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "606-609",
          "snippet": "static int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_role kvm_calc_mmu_role_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t   bool base_only)\n{\n\tunion kvm_mmu_role role = {0};\n\n\trole.base.access = ACC_ALL;\n\trole.base.nxe = !!is_nx(vcpu);\n\trole.base.cr0_wp = is_write_protection(vcpu);\n\trole.base.smm = is_smm(vcpu);\n\trole.base.guest_mode = is_guest_mode(vcpu);\n\n\tif (base_only)\n\t\treturn role;\n\n\trole.ext = kvm_calc_mmu_role_ext(vcpu);\n\n\treturn role;\n}"
  },
  {
    "function_name": "kvm_calc_mmu_role_ext",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4870-4885",
    "snippet": "static union kvm_mmu_extended_role kvm_calc_mmu_role_ext(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_extended_role ext = {0};\n\n\text.cr0_pg = !!is_paging(vcpu);\n\text.cr4_pae = !!is_pae(vcpu);\n\text.cr4_smep = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\text.cr4_smap = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\text.cr4_pse = !!is_pse(vcpu);\n\text.cr4_pke = !!kvm_read_cr4_bits(vcpu, X86_CR4_PKE);\n\text.maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\text.valid = 1;\n\n\treturn ext;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuid_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 4880
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_maxphyaddr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "32-35",
          "snippet": "static inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_PKE"
          ],
          "line": 4879
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "129-135",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pse",
          "args": [
            "vcpu"
          ],
          "line": 4878
        },
        "resolved": true,
        "details": {
          "function_name": "is_pse",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "133-136",
          "snippet": "static inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 4875
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "143-146",
          "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 4874
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_extended_role kvm_calc_mmu_role_ext(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_extended_role ext = {0};\n\n\text.cr0_pg = !!is_paging(vcpu);\n\text.cr4_pae = !!is_pae(vcpu);\n\text.cr4_smep = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);\n\text.cr4_smap = !!kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);\n\text.cr4_pse = !!is_pse(vcpu);\n\text.cr4_pke = !!kvm_read_cr4_bits(vcpu, X86_CR4_PKE);\n\text.maxphyaddr = cpuid_maxphyaddr(vcpu);\n\n\text.valid = 1;\n\n\treturn ext;\n}"
  },
  {
    "function_name": "paging32E_init_context",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4864-4868",
    "snippet": "static void paging32E_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT32E_ROOT_LEVEL);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "paging64_init_context_common",
          "args": [
            "vcpu",
            "context",
            "PT32E_ROOT_LEVEL"
          ],
          "line": 4867
        },
        "resolved": true,
        "details": {
          "function_name": "paging64_init_context_common",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4813-4833",
          "snippet": "static void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->direct_map = false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->direct_map = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void paging32E_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tpaging64_init_context_common(vcpu, context, PT32E_ROOT_LEVEL);\n}"
  },
  {
    "function_name": "paging32_init_context",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4844-4862",
    "snippet": "static void paging32_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tcontext->nx = false;\n\tcontext->root_level = PT32_ROOT_LEVEL;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tcontext->page_fault = paging32_page_fault;\n\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\tcontext->sync_page = paging32_sync_page;\n\tcontext->invlpg = paging32_invlpg;\n\tcontext->update_pte = paging32_update_pte;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->direct_map = false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_last_nonleaf_level",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4853
        },
        "resolved": true,
        "details": {
          "function_name": "update_last_nonleaf_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4804-4811",
          "snippet": "static void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pkru_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4852
        },
        "resolved": true,
        "details": {
          "function_name": "update_pkru_bitmask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4753-4802",
          "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_permission_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4851
        },
        "resolved": true,
        "details": {
          "function_name": "update_permission_bitmask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4657-4727",
          "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define ACC_EXEC_MASK    1"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4850
        },
        "resolved": true,
        "details": {
          "function_name": "reset_rsvds_bits_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4506-4515",
          "snippet": "static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu),\n\t\t\t\tguest_cpuid_is_amd_or_hygon(vcpu));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu),\n\t\t\t\tguest_cpuid_is_amd_or_hygon(vcpu));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void paging32_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tcontext->nx = false;\n\tcontext->root_level = PT32_ROOT_LEVEL;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tcontext->page_fault = paging32_page_fault;\n\tcontext->gva_to_gpa = paging32_gva_to_gpa;\n\tcontext->sync_page = paging32_sync_page;\n\tcontext->invlpg = paging32_invlpg;\n\tcontext->update_pte = paging32_update_pte;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->direct_map = false;\n}"
  },
  {
    "function_name": "paging64_init_context",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4835-4842",
    "snippet": "static void paging64_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tint root_level = is_la57_mode(vcpu) ?\n\t\t\t PT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\n\tpaging64_init_context_common(vcpu, context, root_level);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "paging64_init_context_common",
          "args": [
            "vcpu",
            "context",
            "root_level"
          ],
          "line": 4841
        },
        "resolved": true,
        "details": {
          "function_name": "paging64_init_context_common",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4813-4833",
          "snippet": "static void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->direct_map = false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->direct_map = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_la57_mode",
          "args": [
            "vcpu"
          ],
          "line": 4838
        },
        "resolved": true,
        "details": {
          "function_name": "is_la57_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "104-112",
          "snippet": "static inline bool is_la57_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn (vcpu->arch.efer & EFER_LMA) &&\n\t\t kvm_read_cr4_bits(vcpu, X86_CR4_LA57);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_la57_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn (vcpu->arch.efer & EFER_LMA) &&\n\t\t kvm_read_cr4_bits(vcpu, X86_CR4_LA57);\n#else\n\treturn 0;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void paging64_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\tint root_level = is_la57_mode(vcpu) ?\n\t\t\t PT64_ROOT_5LEVEL : PT64_ROOT_4LEVEL;\n\n\tpaging64_init_context_common(vcpu, context, root_level);\n}"
  },
  {
    "function_name": "paging64_init_context_common",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4813-4833",
    "snippet": "static void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->direct_map = false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "!is_pae(vcpu)"
          ],
          "line": 4825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 4825
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "143-146",
          "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_last_nonleaf_level",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4823
        },
        "resolved": true,
        "details": {
          "function_name": "update_last_nonleaf_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4804-4811",
          "snippet": "static void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_pkru_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4822
        },
        "resolved": true,
        "details": {
          "function_name": "update_pkru_bitmask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4753-4802",
          "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_permission_bitmask",
          "args": [
            "vcpu",
            "context",
            "false"
          ],
          "line": 4821
        },
        "resolved": true,
        "details": {
          "function_name": "update_permission_bitmask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4657-4727",
          "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_USER_MASK    PT_USER_MASK",
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define ACC_EXEC_MASK    1"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "context"
          ],
          "line": 4820
        },
        "resolved": true,
        "details": {
          "function_name": "reset_rsvds_bits_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4506-4515",
          "snippet": "static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu),\n\t\t\t\tguest_cpuid_is_amd_or_hygon(vcpu));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu),\n\t\t\t\tguest_cpuid_is_amd_or_hygon(vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nx",
          "args": [
            "vcpu"
          ],
          "line": 4817
        },
        "resolved": true,
        "details": {
          "function_name": "is_nx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "606-609",
          "snippet": "static int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void paging64_init_context_common(struct kvm_vcpu *vcpu,\n\t\t\t\t\t struct kvm_mmu *context,\n\t\t\t\t\t int level)\n{\n\tcontext->nx = is_nx(vcpu);\n\tcontext->root_level = level;\n\n\treset_rsvds_bits_mask(vcpu, context);\n\tupdate_permission_bitmask(vcpu, context, false);\n\tupdate_pkru_bitmask(vcpu, context, false);\n\tupdate_last_nonleaf_level(vcpu, context);\n\n\tMMU_WARN_ON(!is_pae(vcpu));\n\tcontext->page_fault = paging64_page_fault;\n\tcontext->gva_to_gpa = paging64_gva_to_gpa;\n\tcontext->sync_page = paging64_sync_page;\n\tcontext->invlpg = paging64_invlpg;\n\tcontext->update_pte = paging64_update_pte;\n\tcontext->shadow_root_level = level;\n\tcontext->direct_map = false;\n}"
  },
  {
    "function_name": "update_last_nonleaf_level",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4804-4811",
    "snippet": "static void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_pse",
          "args": [
            "vcpu"
          ],
          "line": 4809
        },
        "resolved": true,
        "details": {
          "function_name": "is_pse",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "133-136",
          "snippet": "static inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_last_nonleaf_level(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu)\n{\n\tunsigned root_level = mmu->root_level;\n\n\tmmu->last_nonleaf_level = root_level;\n\tif (root_level == PT32_ROOT_LEVEL && is_pse(vcpu))\n\t\tmmu->last_nonleaf_level++;\n}"
  },
  {
    "function_name": "update_pkru_bitmask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4753-4802",
    "snippet": "static void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_USER_MASK    PT_USER_MASK"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mmu->permissions"
          ],
          "line": 4772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_protection",
          "args": [
            "vcpu"
          ],
          "line": 4770
        },
        "resolved": true,
        "details": {
          "function_name": "is_write_protection",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "156-159",
          "snippet": "static inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_long_mode",
          "args": [
            "vcpu"
          ],
          "line": 4765
        },
        "resolved": true,
        "details": {
          "function_name": "is_long_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "85-92",
          "snippet": "static inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_long_mode(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn vcpu->arch.efer & EFER_LMA;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_PKE"
          ],
          "line": 4765
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "129-135",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_pkru_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\tbool ept)\n{\n\tunsigned bit;\n\tbool wp;\n\n\tif (ept) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\t/* PKEY is enabled only if CR4.PKE and EFER.LMA are both set. */\n\tif (!kvm_read_cr4_bits(vcpu, X86_CR4_PKE) || !is_long_mode(vcpu)) {\n\t\tmmu->pkru_mask = 0;\n\t\treturn;\n\t}\n\n\twp = is_write_protection(vcpu);\n\n\tfor (bit = 0; bit < ARRAY_SIZE(mmu->permissions); ++bit) {\n\t\tunsigned pfec, pkey_bits;\n\t\tbool check_pkey, check_write, ff, uf, wf, pte_user;\n\n\t\tpfec = bit << 1;\n\t\tff = pfec & PFERR_FETCH_MASK;\n\t\tuf = pfec & PFERR_USER_MASK;\n\t\twf = pfec & PFERR_WRITE_MASK;\n\n\t\t/* PFEC.RSVD is replaced by ACC_USER_MASK. */\n\t\tpte_user = pfec & PFERR_RSVD_MASK;\n\n\t\t/*\n\t\t * Only need to check the access which is not an\n\t\t * instruction fetch and is to a user page.\n\t\t */\n\t\tcheck_pkey = (!ff && pte_user);\n\t\t/*\n\t\t * write access is controlled by PKRU if it is a\n\t\t * user access or CR0.WP = 1.\n\t\t */\n\t\tcheck_write = check_pkey && wf && (uf || wp);\n\n\t\t/* PKRU.AD stops both read and write access. */\n\t\tpkey_bits = !!check_pkey;\n\t\t/* PKRU.WD stops write access. */\n\t\tpkey_bits |= (!!check_write) << 1;\n\n\t\tmmu->pkru_mask |= (pkey_bits & 3) << pfec;\n\t}\n}"
  },
  {
    "function_name": "update_permission_bitmask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4657-4727",
    "snippet": "static void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_USER_MASK    PT_USER_MASK",
      "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
      "#define ACC_EXEC_MASK    1"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "mmu->permissions"
          ],
          "line": 4670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_write_protection",
          "args": [
            "vcpu"
          ],
          "line": 4668
        },
        "resolved": true,
        "details": {
          "function_name": "is_write_protection",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "156-159",
          "snippet": "static inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline bool is_write_protection(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_WP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4_bits",
          "args": [
            "vcpu",
            "X86_CR4_SMAP"
          ],
          "line": 4667
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "129-135",
          "snippet": "static inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\n#define KVM_POSSIBLE_CR4_GUEST_BITS\t\t\t\t  \\\n\t(X86_CR4_PVI | X86_CR4_DE | X86_CR4_PCE | X86_CR4_OSFXSR  \\\n\t | X86_CR4_OSXMMEXCPT | X86_CR4_LA57 | X86_CR4_PGE)\n\nstatic inline ulong kvm_read_cr4_bits(struct kvm_vcpu *vcpu, ulong mask)\n{\n\tulong tmask = mask & KVM_POSSIBLE_CR4_GUEST_BITS;\n\tif (tmask & vcpu->arch.cr4_guest_owned_bits)\n\t\tkvm_x86_ops.decache_cr4_guest_bits(vcpu);\n\treturn vcpu->arch.cr4 & mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BYTE_MASK",
          "args": [
            "ACC_USER_MASK"
          ],
          "line": 4664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BYTE_MASK",
          "args": [
            "ACC_WRITE_MASK"
          ],
          "line": 4663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BYTE_MASK",
          "args": [
            "ACC_EXEC_MASK"
          ],
          "line": 4662
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void update_permission_bitmask(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_mmu *mmu, bool ept)\n{\n\tunsigned byte;\n\n\tconst u8 x = BYTE_MASK(ACC_EXEC_MASK);\n\tconst u8 w = BYTE_MASK(ACC_WRITE_MASK);\n\tconst u8 u = BYTE_MASK(ACC_USER_MASK);\n\n\tbool cr4_smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP) != 0;\n\tbool cr4_smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP) != 0;\n\tbool cr0_wp = is_write_protection(vcpu);\n\n\tfor (byte = 0; byte < ARRAY_SIZE(mmu->permissions); ++byte) {\n\t\tunsigned pfec = byte << 1;\n\n\t\t/*\n\t\t * Each \"*f\" variable has a 1 bit for each UWX value\n\t\t * that causes a fault with the given PFEC.\n\t\t */\n\n\t\t/* Faults from writes to non-writable pages */\n\t\tu8 wf = (pfec & PFERR_WRITE_MASK) ? (u8)~w : 0;\n\t\t/* Faults from user mode accesses to supervisor pages */\n\t\tu8 uf = (pfec & PFERR_USER_MASK) ? (u8)~u : 0;\n\t\t/* Faults from fetches of non-executable pages*/\n\t\tu8 ff = (pfec & PFERR_FETCH_MASK) ? (u8)~x : 0;\n\t\t/* Faults from kernel mode fetches of user pages */\n\t\tu8 smepf = 0;\n\t\t/* Faults from kernel mode accesses of user pages */\n\t\tu8 smapf = 0;\n\n\t\tif (!ept) {\n\t\t\t/* Faults from kernel mode accesses to user pages */\n\t\t\tu8 kf = (pfec & PFERR_USER_MASK) ? 0 : u;\n\n\t\t\t/* Not really needed: !nx will cause pte.nx to fault */\n\t\t\tif (!mmu->nx)\n\t\t\t\tff = 0;\n\n\t\t\t/* Allow supervisor writes if !cr0.wp */\n\t\t\tif (!cr0_wp)\n\t\t\t\twf = (pfec & PFERR_USER_MASK) ? wf : 0;\n\n\t\t\t/* Disallow supervisor fetches of user code if cr4.smep */\n\t\t\tif (cr4_smep)\n\t\t\t\tsmepf = (pfec & PFERR_FETCH_MASK) ? kf : 0;\n\n\t\t\t/*\n\t\t\t * SMAP:kernel-mode data accesses from user-mode\n\t\t\t * mappings should fault. A fault is considered\n\t\t\t * as a SMAP violation if all of the following\n\t\t\t * conditions are true:\n\t\t\t *   - X86_CR4_SMAP is set in CR4\n\t\t\t *   - A user page is accessed\n\t\t\t *   - The access is not a fetch\n\t\t\t *   - Page fault in kernel mode\n\t\t\t *   - if CPL = 3 or X86_EFLAGS_AC is clear\n\t\t\t *\n\t\t\t * Here, we cover the first three conditions.\n\t\t\t * The fourth is computed dynamically in permission_fault();\n\t\t\t * PFERR_RSVD_MASK bit will be set in PFEC if the access is\n\t\t\t * *not* subject to SMAP restrictions.\n\t\t\t */\n\t\t\tif (cr4_smap)\n\t\t\t\tsmapf = (pfec & (PFERR_RSVD_MASK|PFERR_FETCH_MASK)) ? 0 : kf;\n\t\t}\n\n\t\tmmu->permissions[byte] = ff | uf | wf | smepf | smapf;\n\t}\n}"
  },
  {
    "function_name": "reset_ept_shadow_zero_bits_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4639-4645",
    "snippet": "static void\nreset_ept_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t    shadow_phys_bits, execonly);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask_ept",
          "args": [
            "&context->shadow_zero_check",
            "shadow_phys_bits",
            "execonly"
          ],
          "line": 4643
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask_ept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4517-4552",
          "snippet": "static void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][4] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][4] = rsvd_check->rsvd_bits_mask[0][4];\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][4] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][4] = rsvd_check->rsvd_bits_mask[0][4];\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void\nreset_ept_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->shadow_zero_check,\n\t\t\t\t    shadow_phys_bits, execonly);\n}"
  },
  {
    "function_name": "reset_tdp_shadow_zero_bits_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4606-4633",
    "snippet": "static void\nreset_tdp_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context)\n{\n\tstruct rsvd_bits_validate *shadow_zero_check;\n\tint i;\n\n\tshadow_zero_check = &context->shadow_zero_check;\n\n\tif (boot_cpu_is_amd())\n\t\t__reset_rsvds_bits_mask(vcpu, shadow_zero_check,\n\t\t\t\t\tshadow_phys_bits,\n\t\t\t\t\tcontext->shadow_root_level, false,\n\t\t\t\t\tboot_cpu_has(X86_FEATURE_GBPAGES),\n\t\t\t\t\ttrue, true);\n\telse\n\t\t__reset_rsvds_bits_mask_ept(shadow_zero_check,\n\t\t\t\t\t    shadow_phys_bits,\n\t\t\t\t\t    false);\n\n\tif (!shadow_me_mask)\n\t\treturn;\n\n\tfor (i = context->shadow_root_level; --i >= 0;) {\n\t\tshadow_zero_check->rsvd_bits_mask[0][i] &= ~shadow_me_mask;\n\t\tshadow_zero_check->rsvd_bits_mask[1][i] &= ~shadow_me_mask;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask_ept",
          "args": [
            "shadow_zero_check",
            "shadow_phys_bits",
            "false"
          ],
          "line": 4622
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask_ept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4517-4552",
          "snippet": "static void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][4] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][4] = rsvd_check->rsvd_bits_mask[0][4];\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][4] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][4] = rsvd_check->rsvd_bits_mask[0][4];\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "shadow_zero_check",
            "shadow_phys_bits",
            "context->shadow_root_level",
            "false",
            "boot_cpu_has(X86_FEATURE_GBPAGES)",
            "true",
            "true"
          ],
          "line": 4616
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4416-4504",
          "snippet": "static void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_5LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][4] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][4] =\n\t\t\trsvd_check->rsvd_bits_mask[0][4];\n\t\t/* fall through */\n\tcase PT64_ROOT_4LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_5LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][4] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][4] =\n\t\t\trsvd_check->rsvd_bits_mask[0][4];\n\t\t/* fall through */\n\tcase PT64_ROOT_4LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_GBPAGES"
          ],
          "line": 4619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_is_amd",
          "args": [],
          "line": 4615
        },
        "resolved": true,
        "details": {
          "function_name": "boot_cpu_is_amd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4596-4600",
          "snippet": "static inline bool boot_cpu_is_amd(void)\n{\n\tWARN_ON_ONCE(!tdp_enabled);\n\treturn shadow_x_mask == 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool tdp_enabled = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\n\nstatic inline bool boot_cpu_is_amd(void)\n{\n\tWARN_ON_ONCE(!tdp_enabled);\n\treturn shadow_x_mask == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void\nreset_tdp_shadow_zero_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\tstruct kvm_mmu *context)\n{\n\tstruct rsvd_bits_validate *shadow_zero_check;\n\tint i;\n\n\tshadow_zero_check = &context->shadow_zero_check;\n\n\tif (boot_cpu_is_amd())\n\t\t__reset_rsvds_bits_mask(vcpu, shadow_zero_check,\n\t\t\t\t\tshadow_phys_bits,\n\t\t\t\t\tcontext->shadow_root_level, false,\n\t\t\t\t\tboot_cpu_has(X86_FEATURE_GBPAGES),\n\t\t\t\t\ttrue, true);\n\telse\n\t\t__reset_rsvds_bits_mask_ept(shadow_zero_check,\n\t\t\t\t\t    shadow_phys_bits,\n\t\t\t\t\t    false);\n\n\tif (!shadow_me_mask)\n\t\treturn;\n\n\tfor (i = context->shadow_root_level; --i >= 0;) {\n\t\tshadow_zero_check->rsvd_bits_mask[0][i] &= ~shadow_me_mask;\n\t\tshadow_zero_check->rsvd_bits_mask[1][i] &= ~shadow_me_mask;\n\t}\n}"
  },
  {
    "function_name": "boot_cpu_is_amd",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4596-4600",
    "snippet": "static inline bool boot_cpu_is_amd(void)\n{\n\tWARN_ON_ONCE(!tdp_enabled);\n\treturn shadow_x_mask == 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool tdp_enabled = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!tdp_enabled"
          ],
          "line": 4598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\n\nstatic inline bool boot_cpu_is_amd(void)\n{\n\tWARN_ON_ONCE(!tdp_enabled);\n\treturn shadow_x_mask == 0;\n}"
  },
  {
    "function_name": "reset_shadow_zero_bits_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4566-4593",
    "snippet": "void\nreset_shadow_zero_bits_mask(struct kvm_vcpu *vcpu, struct kvm_mmu *context)\n{\n\tbool uses_nx = context->nx ||\n\t\tcontext->mmu_role.base.smep_andnot_wp;\n\tstruct rsvd_bits_validate *shadow_zero_check;\n\tint i;\n\n\t/*\n\t * Passing \"true\" to the last argument is okay; it adds a check\n\t * on bit 8 of the SPTEs which KVM doesn't use anyway.\n\t */\n\tshadow_zero_check = &context->shadow_zero_check;\n\t__reset_rsvds_bits_mask(vcpu, shadow_zero_check,\n\t\t\t\tshadow_phys_bits,\n\t\t\t\tcontext->shadow_root_level, uses_nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu), true);\n\n\tif (!shadow_me_mask)\n\t\treturn;\n\n\tfor (i = context->shadow_root_level; --i >= 0;) {\n\t\tshadow_zero_check->rsvd_bits_mask[0][i] &= ~shadow_me_mask;\n\t\tshadow_zero_check->rsvd_bits_mask[1][i] &= ~shadow_me_mask;\n\t}\n\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "shadow_zero_check",
            "shadow_phys_bits",
            "context->shadow_root_level",
            "uses_nx",
            "guest_cpuid_has(vcpu, X86_FEATURE_GBPAGES)",
            "is_pse(vcpu)",
            "true"
          ],
          "line": 4579
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4416-4504",
          "snippet": "static void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_5LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][4] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][4] =\n\t\t\trsvd_check->rsvd_bits_mask[0][4];\n\t\t/* fall through */\n\tcase PT64_ROOT_4LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_5LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][4] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][4] =\n\t\t\trsvd_check->rsvd_bits_mask[0][4];\n\t\t/* fall through */\n\tcase PT64_ROOT_4LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pse",
          "args": [
            "vcpu"
          ],
          "line": 4583
        },
        "resolved": true,
        "details": {
          "function_name": "is_pse",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "133-136",
          "snippet": "static inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_GBPAGES"
          ],
          "line": 4582
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid\nreset_shadow_zero_bits_mask(struct kvm_vcpu *vcpu, struct kvm_mmu *context)\n{\n\tbool uses_nx = context->nx ||\n\t\tcontext->mmu_role.base.smep_andnot_wp;\n\tstruct rsvd_bits_validate *shadow_zero_check;\n\tint i;\n\n\t/*\n\t * Passing \"true\" to the last argument is okay; it adds a check\n\t * on bit 8 of the SPTEs which KVM doesn't use anyway.\n\t */\n\tshadow_zero_check = &context->shadow_zero_check;\n\t__reset_rsvds_bits_mask(vcpu, shadow_zero_check,\n\t\t\t\tshadow_phys_bits,\n\t\t\t\tcontext->shadow_root_level, uses_nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu), true);\n\n\tif (!shadow_me_mask)\n\t\treturn;\n\n\tfor (i = context->shadow_root_level; --i >= 0;) {\n\t\tshadow_zero_check->rsvd_bits_mask[0][i] &= ~shadow_me_mask;\n\t\tshadow_zero_check->rsvd_bits_mask[1][i] &= ~shadow_me_mask;\n\t}\n\n}"
  },
  {
    "function_name": "reset_rsvds_bits_mask_ept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4554-4559",
    "snippet": "static void reset_rsvds_bits_mask_ept(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->guest_rsvd_check,\n\t\t\t\t    cpuid_maxphyaddr(vcpu), execonly);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask_ept",
          "args": [
            "&context->guest_rsvd_check",
            "cpuid_maxphyaddr(vcpu)",
            "execonly"
          ],
          "line": 4557
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask_ept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4517-4552",
          "snippet": "static void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][4] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][4] = rsvd_check->rsvd_bits_mask[0][4];\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][4] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][4] = rsvd_check->rsvd_bits_mask[0][4];\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuid_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 4558
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_maxphyaddr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "32-35",
          "snippet": "static inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask_ept(struct kvm_vcpu *vcpu,\n\t\tstruct kvm_mmu *context, bool execonly)\n{\n\t__reset_rsvds_bits_mask_ept(&context->guest_rsvd_check,\n\t\t\t\t    cpuid_maxphyaddr(vcpu), execonly);\n}"
  },
  {
    "function_name": "__reset_rsvds_bits_mask_ept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4517-4552",
    "snippet": "static void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][4] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][4] = rsvd_check->rsvd_bits_mask[0][4];\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "REPEAT_BYTE",
          "args": [
            "1ull << 4"
          ],
          "line": 4549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REPEAT_BYTE",
          "args": [
            "1ull << 6"
          ],
          "line": 4546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "REPEAT_BYTE",
          "args": [
            "1ull << 2"
          ],
          "line": 4545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsvd_bits",
          "args": [
            "12",
            "20"
          ],
          "line": 4539
        },
        "resolved": true,
        "details": {
          "function_name": "rsvd_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "46-52",
          "snippet": "static inline u64 rsvd_bits(int s, int e)\n{\n\tif (e < s)\n\t\treturn 0;\n\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 rsvd_bits(int s, int e)\n{\n\tif (e < s)\n\t\treturn 0;\n\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\n__reset_rsvds_bits_mask_ept(struct rsvd_bits_validate *rsvd_check,\n\t\t\t    int maxphyaddr, bool execonly)\n{\n\tu64 bad_mt_xwr;\n\n\trsvd_check->rsvd_bits_mask[0][4] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][3] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 7);\n\trsvd_check->rsvd_bits_mask[0][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(3, 6);\n\trsvd_check->rsvd_bits_mask[0][0] = rsvd_bits(maxphyaddr, 51);\n\n\t/* large page */\n\trsvd_check->rsvd_bits_mask[1][4] = rsvd_check->rsvd_bits_mask[0][4];\n\trsvd_check->rsvd_bits_mask[1][3] = rsvd_check->rsvd_bits_mask[0][3];\n\trsvd_check->rsvd_bits_mask[1][2] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 29);\n\trsvd_check->rsvd_bits_mask[1][1] =\n\t\trsvd_bits(maxphyaddr, 51) | rsvd_bits(12, 20);\n\trsvd_check->rsvd_bits_mask[1][0] = rsvd_check->rsvd_bits_mask[0][0];\n\n\tbad_mt_xwr = 0xFFull << (2 * 8);\t/* bits 3..5 must not be 2 */\n\tbad_mt_xwr |= 0xFFull << (3 * 8);\t/* bits 3..5 must not be 3 */\n\tbad_mt_xwr |= 0xFFull << (7 * 8);\t/* bits 3..5 must not be 7 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 2);\t/* bits 0..2 must not be 010 */\n\tbad_mt_xwr |= REPEAT_BYTE(1ull << 6);\t/* bits 0..2 must not be 110 */\n\tif (!execonly) {\n\t\t/* bits 0..2 must not be 100 unless VMX capabilities allow it */\n\t\tbad_mt_xwr |= REPEAT_BYTE(1ull << 4);\n\t}\n\trsvd_check->bad_mt_xwr = bad_mt_xwr;\n}"
  },
  {
    "function_name": "reset_rsvds_bits_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4506-4515",
    "snippet": "static void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu),\n\t\t\t\tguest_cpuid_is_amd_or_hygon(vcpu));\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__reset_rsvds_bits_mask",
          "args": [
            "vcpu",
            "&context->guest_rsvd_check",
            "cpuid_maxphyaddr(vcpu)",
            "context->root_level",
            "context->nx",
            "guest_cpuid_has(vcpu, X86_FEATURE_GBPAGES)",
            "is_pse(vcpu)",
            "guest_cpuid_is_amd_or_hygon(vcpu)"
          ],
          "line": 4509
        },
        "resolved": true,
        "details": {
          "function_name": "__reset_rsvds_bits_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4416-4504",
          "snippet": "static void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_5LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][4] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][4] =\n\t\t\trsvd_check->rsvd_bits_mask[0][4];\n\t\t/* fall through */\n\tcase PT64_ROOT_4LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_5LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][4] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][4] =\n\t\t\trsvd_check->rsvd_bits_mask[0][4];\n\t\t/* fall through */\n\tcase PT64_ROOT_4LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_is_amd_or_hygon",
          "args": [
            "vcpu"
          ],
          "line": 4514
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_is_amd_or_hygon",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "217-225",
          "snippet": "static inline bool guest_cpuid_is_amd_or_hygon(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0, 0);\n\treturn best &&\n\t       (is_guest_vendor_amd(best->ebx, best->ecx, best->edx) ||\n\t\tis_guest_vendor_hygon(best->ebx, best->ecx, best->edx));\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline bool guest_cpuid_is_amd_or_hygon(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0, 0);\n\treturn best &&\n\t       (is_guest_vendor_amd(best->ebx, best->ecx, best->edx) ||\n\t\tis_guest_vendor_hygon(best->ebx, best->ecx, best->edx));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_pse",
          "args": [
            "vcpu"
          ],
          "line": 4513
        },
        "resolved": true,
        "details": {
          "function_name": "is_pse",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "133-136",
          "snippet": "static inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_pse(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, X86_CR4_PSE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_GBPAGES"
          ],
          "line": 4512
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuid_maxphyaddr",
          "args": [
            "vcpu"
          ],
          "line": 4510
        },
        "resolved": true,
        "details": {
          "function_name": "cpuid_maxphyaddr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "32-35",
          "snippet": "static inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int cpuid_maxphyaddr(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.maxphyaddr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu *context)\n{\n\t__reset_rsvds_bits_mask(vcpu, &context->guest_rsvd_check,\n\t\t\t\tcpuid_maxphyaddr(vcpu), context->root_level,\n\t\t\t\tcontext->nx,\n\t\t\t\tguest_cpuid_has(vcpu, X86_FEATURE_GBPAGES),\n\t\t\t\tis_pse(vcpu),\n\t\t\t\tguest_cpuid_is_amd_or_hygon(vcpu));\n}"
  },
  {
    "function_name": "__reset_rsvds_bits_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4416-4504",
    "snippet": "static void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_5LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][4] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][4] =\n\t\t\trsvd_check->rsvd_bits_mask[0][4];\n\t\t/* fall through */\n\tcase PT64_ROOT_4LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rsvd_bits",
          "args": [
            "13",
            "20"
          ],
          "line": 4499
        },
        "resolved": true,
        "details": {
          "function_name": "rsvd_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "46-52",
          "snippet": "static inline u64 rsvd_bits(int s, int e)\n{\n\tif (e < s)\n\t\treturn 0;\n\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 rsvd_bits(int s, int e)\n{\n\tif (e < s)\n\t\treturn 0;\n\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cpuid_PSE36",
          "args": [],
          "line": 4453
        },
        "resolved": true,
        "details": {
          "function_name": "is_cpuid_PSE36",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "601-604",
          "snippet": "static int is_cpuid_PSE36(void)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_cpuid_PSE36(void)\n{\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void\n__reset_rsvds_bits_mask(struct kvm_vcpu *vcpu,\n\t\t\tstruct rsvd_bits_validate *rsvd_check,\n\t\t\tint maxphyaddr, int level, bool nx, bool gbpages,\n\t\t\tbool pse, bool amd)\n{\n\tu64 exb_bit_rsvd = 0;\n\tu64 gbpages_bit_rsvd = 0;\n\tu64 nonleaf_bit8_rsvd = 0;\n\n\trsvd_check->bad_mt_xwr = 0;\n\n\tif (!nx)\n\t\texb_bit_rsvd = rsvd_bits(63, 63);\n\tif (!gbpages)\n\t\tgbpages_bit_rsvd = rsvd_bits(7, 7);\n\n\t/*\n\t * Non-leaf PML4Es and PDPEs reserve bit 8 (which would be the G bit for\n\t * leaf entries) on AMD CPUs only.\n\t */\n\tif (amd)\n\t\tnonleaf_bit8_rsvd = rsvd_bits(8, 8);\n\n\tswitch (level) {\n\tcase PT32_ROOT_LEVEL:\n\t\t/* no rsvd bits for 2 level 4K page table entries */\n\t\trsvd_check->rsvd_bits_mask[0][1] = 0;\n\t\trsvd_check->rsvd_bits_mask[0][0] = 0;\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\n\t\tif (!pse) {\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (is_cpuid_PSE36())\n\t\t\t/* 36bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(17, 21);\n\t\telse\n\t\t\t/* 32 bits PSE 4MB page */\n\t\t\trsvd_check->rsvd_bits_mask[1][1] = rsvd_bits(13, 21);\n\t\tbreak;\n\tcase PT32E_ROOT_LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][2] =\n\t\t\trsvd_bits(maxphyaddr, 63) |\n\t\t\trsvd_bits(5, 8) | rsvd_bits(1, 2);\t/* PDPTE */\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62);\t/* PDE */\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62); \t/* PTE */\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 62) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\tcase PT64_ROOT_5LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][4] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][4] =\n\t\t\trsvd_check->rsvd_bits_mask[0][4];\n\t\t/* fall through */\n\tcase PT64_ROOT_4LEVEL:\n\t\trsvd_check->rsvd_bits_mask[0][3] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | rsvd_bits(7, 7) |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][2] = exb_bit_rsvd |\n\t\t\tnonleaf_bit8_rsvd | gbpages_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[0][0] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51);\n\t\trsvd_check->rsvd_bits_mask[1][3] =\n\t\t\trsvd_check->rsvd_bits_mask[0][3];\n\t\trsvd_check->rsvd_bits_mask[1][2] = exb_bit_rsvd |\n\t\t\tgbpages_bit_rsvd | rsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 29);\n\t\trsvd_check->rsvd_bits_mask[1][1] = exb_bit_rsvd |\n\t\t\trsvd_bits(maxphyaddr, 51) |\n\t\t\trsvd_bits(13, 20);\t\t/* large page */\n\t\trsvd_check->rsvd_bits_mask[1][0] =\n\t\t\trsvd_check->rsvd_bits_mask[0][0];\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "is_last_gpte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4383-4401",
    "snippet": "static inline bool is_last_gpte(struct kvm_mmu *mmu,\n\t\t\t\tunsigned level, unsigned gpte)\n{\n\t/*\n\t * The RHS has bit 7 set iff level < mmu->last_nonleaf_level.\n\t * If it is clear, there are no large pages at this level, so clear\n\t * PT_PAGE_SIZE_MASK in gpte if that is the case.\n\t */\n\tgpte &= level - mmu->last_nonleaf_level;\n\n\t/*\n\t * PT_PAGE_TABLE_LEVEL always terminates.  The RHS has bit 7 set\n\t * iff level <= PT_PAGE_TABLE_LEVEL, which for our purpose means\n\t * level == PT_PAGE_TABLE_LEVEL; set PT_PAGE_SIZE_MASK in gpte then.\n\t */\n\tgpte |= level - PT_PAGE_TABLE_LEVEL - 1;\n\n\treturn gpte & PT_PAGE_SIZE_MASK;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool is_last_gpte(struct kvm_mmu *mmu,\n\t\t\t\tunsigned level, unsigned gpte)\n{\n\t/*\n\t * The RHS has bit 7 set iff level < mmu->last_nonleaf_level.\n\t * If it is clear, there are no large pages at this level, so clear\n\t * PT_PAGE_SIZE_MASK in gpte if that is the case.\n\t */\n\tgpte &= level - mmu->last_nonleaf_level;\n\n\t/*\n\t * PT_PAGE_TABLE_LEVEL always terminates.  The RHS has bit 7 set\n\t * iff level <= PT_PAGE_TABLE_LEVEL, which for our purpose means\n\t * level == PT_PAGE_TABLE_LEVEL; set PT_PAGE_SIZE_MASK in gpte then.\n\t */\n\tgpte |= level - PT_PAGE_TABLE_LEVEL - 1;\n\n\treturn gpte & PT_PAGE_SIZE_MASK;\n}"
  },
  {
    "function_name": "sync_mmio_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4366-4381",
    "snippet": "static bool sync_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t   unsigned int access, int *nr_present)\n{\n\tif (unlikely(is_mmio_spte(*sptep))) {\n\t\tif (gfn != get_mmio_spte_gfn(*sptep)) {\n\t\t\tmmu_spte_clear_no_track(sptep);\n\t\t\treturn true;\n\t\t}\n\n\t\t(*nr_present)++;\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_mmio_spte",
          "args": [
            "vcpu",
            "sptep",
            "gfn",
            "access"
          ],
          "line": 4376
        },
        "resolved": true,
        "details": {
          "function_name": "mark_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "462-472",
          "snippet": "static void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned int access)\n{\n\tu64 mask = make_mmio_spte(vcpu, gfn, access);\n\tunsigned int gen = get_mmio_spte_generation(mask);\n\n\taccess = mask & ACC_ALL;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned int access)\n{\n\tu64 mask = make_mmio_spte(vcpu, gfn, access);\n\tunsigned int gen = get_mmio_spte_generation(mask);\n\n\taccess = mask & ACC_ALL;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_clear_no_track",
          "args": [
            "sptep"
          ],
          "line": 4371
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_clear_no_track",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "954-957",
          "snippet": "static void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mmio_spte_gfn",
          "args": [
            "*sptep"
          ],
          "line": 4370
        },
        "resolved": true,
        "details": {
          "function_name": "get_mmio_spte_gfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "474-482",
          "snippet": "static gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 gpa = spte & shadow_nonpresent_or_rsvd_lower_gfn_mask;\n\n\tgpa |= (spte >> shadow_nonpresent_or_rsvd_mask_len)\n\t       & shadow_nonpresent_or_rsvd_mask;\n\n\treturn gpa >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u64 shadow_nonpresent_or_rsvd_mask_len = 5;",
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic const u64 shadow_nonpresent_or_rsvd_mask_len = 5;\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 gpa = spte & shadow_nonpresent_or_rsvd_lower_gfn_mask;\n\n\tgpa |= (spte >> shadow_nonpresent_or_rsvd_mask_len)\n\t       & shadow_nonpresent_or_rsvd_mask;\n\n\treturn gpa >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_mmio_spte(*sptep)"
          ],
          "line": 4369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "*sptep"
          ],
          "line": 4369
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "344-347",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool sync_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t   unsigned int access, int *nr_present)\n{\n\tif (unlikely(is_mmio_spte(*sptep))) {\n\t\tif (gfn != get_mmio_spte_gfn(*sptep)) {\n\t\t\tmmu_spte_clear_no_track(sptep);\n\t\t\treturn true;\n\t\t}\n\n\t\t(*nr_present)++;\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "inject_page_fault",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4360-4364",
    "snippet": "static void inject_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t      struct x86_exception *fault)\n{\n\tvcpu->arch.mmu->inject_page_fault(vcpu, fault);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.mmu->inject_page_fault",
          "args": [
            "vcpu",
            "fault"
          ],
          "line": 4363
        },
        "resolved": true,
        "details": {
          "function_name": "inject_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4360-4364",
          "snippet": "static void inject_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t      struct x86_exception *fault)\n{\n\tvcpu->arch.mmu->inject_page_fault(vcpu, fault);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void inject_page_fault(struct kvm_vcpu *vcpu,\n\t\t\t      struct x86_exception *fault)\n{\n\tvcpu->arch.mmu->inject_page_fault(vcpu, fault);\n}"
  },
  {
    "function_name": "get_cr3",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4355-4358",
    "snippet": "static unsigned long get_cr3(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr3(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 4357
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "137-142",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tkvm_x86_ops.cache_reg(vcpu, VCPU_EXREG_CR3);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tkvm_x86_ops.cache_reg(vcpu, VCPU_EXREG_CR3);\n\treturn vcpu->arch.cr3;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic unsigned long get_cr3(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr3(vcpu);\n}"
  },
  {
    "function_name": "kvm_mmu_new_cr3",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4348-4352",
    "snippet": "void kvm_mmu_new_cr3(struct kvm_vcpu *vcpu, gpa_t new_cr3, bool skip_tlb_flush)\n{\n\t__kvm_mmu_new_cr3(vcpu, new_cr3, kvm_mmu_calc_root_page_role(vcpu),\n\t\t\t  skip_tlb_flush);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kvm_mmu_new_cr3",
          "args": [
            "vcpu",
            "new_cr3",
            "kvm_mmu_calc_root_page_role(vcpu)",
            "skip_tlb_flush"
          ],
          "line": 4350
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_mmu_new_cr3",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4339-4346",
          "snippet": "static void __kvm_mmu_new_cr3(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t      union kvm_mmu_page_role new_role,\n\t\t\t      bool skip_tlb_flush)\n{\n\tif (!fast_cr3_switch(vcpu, new_cr3, new_role, skip_tlb_flush))\n\t\tkvm_mmu_free_roots(vcpu, vcpu->arch.mmu,\n\t\t\t\t   KVM_MMU_ROOT_CURRENT);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void __kvm_mmu_new_cr3(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t      union kvm_mmu_page_role new_role,\n\t\t\t      bool skip_tlb_flush)\n{\n\tif (!fast_cr3_switch(vcpu, new_cr3, new_role, skip_tlb_flush))\n\t\tkvm_mmu_free_roots(vcpu, vcpu->arch.mmu,\n\t\t\t\t   KVM_MMU_ROOT_CURRENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_calc_root_page_role",
          "args": [
            "vcpu"
          ],
          "line": 4350
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_calc_root_page_role",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5154-5165",
          "snippet": "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_role role;\n\n\tif (tdp_enabled)\n\t\trole = kvm_calc_tdp_mmu_root_page_role(vcpu, true);\n\telse\n\t\trole = kvm_calc_shadow_mmu_root_page_role(vcpu, true);\n\n\treturn role.base;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool tdp_enabled = false;",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu)\n{\n\tunion kvm_mmu_role role;\n\n\tif (tdp_enabled)\n\t\trole = kvm_calc_tdp_mmu_root_page_role(vcpu, true);\n\telse\n\t\trole = kvm_calc_shadow_mmu_root_page_role(vcpu, true);\n\n\treturn role.base;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_new_cr3(struct kvm_vcpu *vcpu, gpa_t new_cr3, bool skip_tlb_flush)\n{\n\t__kvm_mmu_new_cr3(vcpu, new_cr3, kvm_mmu_calc_root_page_role(vcpu),\n\t\t\t  skip_tlb_flush);\n}"
  },
  {
    "function_name": "__kvm_mmu_new_cr3",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4339-4346",
    "snippet": "static void __kvm_mmu_new_cr3(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t      union kvm_mmu_page_role new_role,\n\t\t\t      bool skip_tlb_flush)\n{\n\tif (!fast_cr3_switch(vcpu, new_cr3, new_role, skip_tlb_flush))\n\t\tkvm_mmu_free_roots(vcpu, vcpu->arch.mmu,\n\t\t\t\t   KVM_MMU_ROOT_CURRENT);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_free_roots",
          "args": [
            "vcpu",
            "vcpu->arch.mmu",
            "KVM_MMU_ROOT_CURRENT"
          ],
          "line": 4344
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_roots",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3629-3674",
          "snippet": "void kvm_mmu_free_roots(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\tulong roots_to_free)\n{\n\tint i;\n\tLIST_HEAD(invalid_list);\n\tbool free_active_root = roots_to_free & KVM_MMU_ROOT_CURRENT;\n\n\tBUILD_BUG_ON(KVM_MMU_NUM_PREV_ROOTS >= BITS_PER_LONG);\n\n\t/* Before acquiring the MMU lock, see if we need to do any real work. */\n\tif (!(free_active_root && VALID_PAGE(mmu->root_hpa))) {\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tif ((roots_to_free & KVM_MMU_ROOT_PREVIOUS(i)) &&\n\t\t\t    VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\t\tbreak;\n\n\t\tif (i == KVM_MMU_NUM_PREV_ROOTS)\n\t\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (roots_to_free & KVM_MMU_ROOT_PREVIOUS(i))\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->prev_roots[i].hpa,\n\t\t\t\t\t   &invalid_list);\n\n\tif (free_active_root) {\n\t\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t\t    (mmu->root_level >= PT64_ROOT_4LEVEL || mmu->direct_map)) {\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->root_hpa,\n\t\t\t\t\t   &invalid_list);\n\t\t} else {\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tif (mmu->pae_root[i] != 0)\n\t\t\t\t\tmmu_free_root_page(vcpu->kvm,\n\t\t\t\t\t\t\t   &mmu->pae_root[i],\n\t\t\t\t\t\t\t   &invalid_list);\n\t\t\tmmu->root_hpa = INVALID_PAGE;\n\t\t}\n\t\tmmu->root_cr3 = 0;\n\t}\n\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nvoid kvm_mmu_free_roots(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\tulong roots_to_free)\n{\n\tint i;\n\tLIST_HEAD(invalid_list);\n\tbool free_active_root = roots_to_free & KVM_MMU_ROOT_CURRENT;\n\n\tBUILD_BUG_ON(KVM_MMU_NUM_PREV_ROOTS >= BITS_PER_LONG);\n\n\t/* Before acquiring the MMU lock, see if we need to do any real work. */\n\tif (!(free_active_root && VALID_PAGE(mmu->root_hpa))) {\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tif ((roots_to_free & KVM_MMU_ROOT_PREVIOUS(i)) &&\n\t\t\t    VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\t\tbreak;\n\n\t\tif (i == KVM_MMU_NUM_PREV_ROOTS)\n\t\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (roots_to_free & KVM_MMU_ROOT_PREVIOUS(i))\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->prev_roots[i].hpa,\n\t\t\t\t\t   &invalid_list);\n\n\tif (free_active_root) {\n\t\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t\t    (mmu->root_level >= PT64_ROOT_4LEVEL || mmu->direct_map)) {\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->root_hpa,\n\t\t\t\t\t   &invalid_list);\n\t\t} else {\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tif (mmu->pae_root[i] != 0)\n\t\t\t\t\tmmu_free_root_page(vcpu->kvm,\n\t\t\t\t\t\t\t   &mmu->pae_root[i],\n\t\t\t\t\t\t\t   &invalid_list);\n\t\t\tmmu->root_hpa = INVALID_PAGE;\n\t\t}\n\t\tmmu->root_cr3 = 0;\n\t}\n\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fast_cr3_switch",
          "args": [
            "vcpu",
            "new_cr3",
            "new_role",
            "skip_tlb_flush"
          ],
          "line": 4343
        },
        "resolved": true,
        "details": {
          "function_name": "fast_cr3_switch",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4290-4337",
          "snippet": "static bool fast_cr3_switch(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t    union kvm_mmu_page_role new_role,\n\t\t\t    bool skip_tlb_flush)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\n\t/*\n\t * For now, limit the fast switch to 64-bit hosts+VMs in order to avoid\n\t * having to deal with PDPTEs. We may add support for 32-bit hosts/VMs\n\t * later if necessary.\n\t */\n\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t    mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\tif (mmu_check_root(vcpu, new_cr3 >> PAGE_SHIFT))\n\t\t\treturn false;\n\n\t\tif (cached_root_available(vcpu, new_cr3, new_role)) {\n\t\t\t/*\n\t\t\t * It is possible that the cached previous root page is\n\t\t\t * obsolete because of a change in the MMU generation\n\t\t\t * number. However, changing the generation number is\n\t\t\t * accompanied by KVM_REQ_MMU_RELOAD, which will free\n\t\t\t * the root set here and allocate a new one.\n\t\t\t */\n\t\t\tkvm_make_request(KVM_REQ_LOAD_MMU_PGD, vcpu);\n\t\t\tif (!skip_tlb_flush) {\n\t\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\t\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The last MMIO access's GVA and GPA are cached in the\n\t\t\t * VCPU. When switching to a new CR3, that GVA->GPA\n\t\t\t * mapping may no longer be valid. So clear any cached\n\t\t\t * MMIO info even when we don't need to sync the shadow\n\t\t\t * page tables.\n\t\t\t */\n\t\t\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\n\t\t\t__clear_sp_write_flooding_count(\n\t\t\t\tpage_header(mmu->root_hpa));\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool fast_cr3_switch(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t    union kvm_mmu_page_role new_role,\n\t\t\t    bool skip_tlb_flush)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\n\t/*\n\t * For now, limit the fast switch to 64-bit hosts+VMs in order to avoid\n\t * having to deal with PDPTEs. We may add support for 32-bit hosts/VMs\n\t * later if necessary.\n\t */\n\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t    mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\tif (mmu_check_root(vcpu, new_cr3 >> PAGE_SHIFT))\n\t\t\treturn false;\n\n\t\tif (cached_root_available(vcpu, new_cr3, new_role)) {\n\t\t\t/*\n\t\t\t * It is possible that the cached previous root page is\n\t\t\t * obsolete because of a change in the MMU generation\n\t\t\t * number. However, changing the generation number is\n\t\t\t * accompanied by KVM_REQ_MMU_RELOAD, which will free\n\t\t\t * the root set here and allocate a new one.\n\t\t\t */\n\t\t\tkvm_make_request(KVM_REQ_LOAD_MMU_PGD, vcpu);\n\t\t\tif (!skip_tlb_flush) {\n\t\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\t\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The last MMIO access's GVA and GPA are cached in the\n\t\t\t * VCPU. When switching to a new CR3, that GVA->GPA\n\t\t\t * mapping may no longer be valid. So clear any cached\n\t\t\t * MMIO info even when we don't need to sync the shadow\n\t\t\t * page tables.\n\t\t\t */\n\t\t\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\n\t\t\t__clear_sp_write_flooding_count(\n\t\t\t\tpage_header(mmu->root_hpa));\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void __kvm_mmu_new_cr3(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t      union kvm_mmu_page_role new_role,\n\t\t\t      bool skip_tlb_flush)\n{\n\tif (!fast_cr3_switch(vcpu, new_cr3, new_role, skip_tlb_flush))\n\t\tkvm_mmu_free_roots(vcpu, vcpu->arch.mmu,\n\t\t\t\t   KVM_MMU_ROOT_CURRENT);\n}"
  },
  {
    "function_name": "fast_cr3_switch",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4290-4337",
    "snippet": "static bool fast_cr3_switch(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t    union kvm_mmu_page_role new_role,\n\t\t\t    bool skip_tlb_flush)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\n\t/*\n\t * For now, limit the fast switch to 64-bit hosts+VMs in order to avoid\n\t * having to deal with PDPTEs. We may add support for 32-bit hosts/VMs\n\t * later if necessary.\n\t */\n\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t    mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\tif (mmu_check_root(vcpu, new_cr3 >> PAGE_SHIFT))\n\t\t\treturn false;\n\n\t\tif (cached_root_available(vcpu, new_cr3, new_role)) {\n\t\t\t/*\n\t\t\t * It is possible that the cached previous root page is\n\t\t\t * obsolete because of a change in the MMU generation\n\t\t\t * number. However, changing the generation number is\n\t\t\t * accompanied by KVM_REQ_MMU_RELOAD, which will free\n\t\t\t * the root set here and allocate a new one.\n\t\t\t */\n\t\t\tkvm_make_request(KVM_REQ_LOAD_MMU_PGD, vcpu);\n\t\t\tif (!skip_tlb_flush) {\n\t\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\t\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The last MMIO access's GVA and GPA are cached in the\n\t\t\t * VCPU. When switching to a new CR3, that GVA->GPA\n\t\t\t * mapping may no longer be valid. So clear any cached\n\t\t\t * MMIO info even when we don't need to sync the shadow\n\t\t\t * page tables.\n\t\t\t */\n\t\t\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\n\t\t\t__clear_sp_write_flooding_count(\n\t\t\t\tpage_header(mmu->root_hpa));\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_sp_write_flooding_count",
          "args": [
            "page_header(mmu->root_hpa)"
          ],
          "line": 4329
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_sp_write_flooding_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2464-2467",
          "snippet": "static void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "mmu->root_hpa"
          ],
          "line": 4330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_clear_mmio_info",
          "args": [
            "vcpu",
            "MMIO_GVA_ANY"
          ],
          "line": 4327
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_clear_mmio_info",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "192-198",
          "snippet": "static inline void vcpu_clear_mmio_info(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tif (gva != MMIO_GVA_ANY && vcpu->arch.mmio_gva != (gva & PAGE_MASK))\n\t\treturn;\n\n\tvcpu->arch.mmio_gva = 0;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MMIO_GVA_ANY (~(gva_t)0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\n#define MMIO_GVA_ANY (~(gva_t)0)\n\nstatic inline void vcpu_clear_mmio_info(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tif (gva != MMIO_GVA_ANY && vcpu->arch.mmio_gva != (gva & PAGE_MASK))\n\t\treturn;\n\n\tvcpu->arch.mmio_gva = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 4317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_MMU_SYNC",
            "vcpu"
          ],
          "line": 4316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_LOAD_MMU_PGD",
            "vcpu"
          ],
          "line": 4314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cached_root_available",
          "args": [
            "vcpu",
            "new_cr3",
            "new_role"
          ],
          "line": 4306
        },
        "resolved": true,
        "details": {
          "function_name": "cached_root_available",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4264-4288",
          "snippet": "static bool cached_root_available(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t\t  union kvm_mmu_page_role new_role)\n{\n\tuint i;\n\tstruct kvm_mmu_root_info root;\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\n\troot.cr3 = mmu->root_cr3;\n\troot.hpa = mmu->root_hpa;\n\n\tif (is_root_usable(&root, new_cr3, new_role))\n\t\treturn true;\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tswap(root, mmu->prev_roots[i]);\n\n\t\tif (is_root_usable(&root, new_cr3, new_role))\n\t\t\tbreak;\n\t}\n\n\tmmu->root_hpa = root.hpa;\n\tmmu->root_cr3 = root.cr3;\n\n\treturn i < KVM_MMU_NUM_PREV_ROOTS;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool cached_root_available(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t\t  union kvm_mmu_page_role new_role)\n{\n\tuint i;\n\tstruct kvm_mmu_root_info root;\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\n\troot.cr3 = mmu->root_cr3;\n\troot.hpa = mmu->root_hpa;\n\n\tif (is_root_usable(&root, new_cr3, new_role))\n\t\treturn true;\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tswap(root, mmu->prev_roots[i]);\n\n\t\tif (is_root_usable(&root, new_cr3, new_role))\n\t\t\tbreak;\n\t}\n\n\tmmu->root_hpa = root.hpa;\n\tmmu->root_cr3 = root.cr3;\n\n\treturn i < KVM_MMU_NUM_PREV_ROOTS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_check_root",
          "args": [
            "vcpu",
            "new_cr3 >> PAGE_SHIFT"
          ],
          "line": 4303
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_check_root",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3677-3687",
          "snippet": "static int mmu_check_root(struct kvm_vcpu *vcpu, gfn_t root_gfn)\n{\n\tint ret = 0;\n\n\tif (!kvm_is_visible_gfn(vcpu->kvm, root_gfn)) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_check_root(struct kvm_vcpu *vcpu, gfn_t root_gfn)\n{\n\tint ret = 0;\n\n\tif (!kvm_is_visible_gfn(vcpu->kvm, root_gfn)) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool fast_cr3_switch(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t    union kvm_mmu_page_role new_role,\n\t\t\t    bool skip_tlb_flush)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\n\t/*\n\t * For now, limit the fast switch to 64-bit hosts+VMs in order to avoid\n\t * having to deal with PDPTEs. We may add support for 32-bit hosts/VMs\n\t * later if necessary.\n\t */\n\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t    mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\tif (mmu_check_root(vcpu, new_cr3 >> PAGE_SHIFT))\n\t\t\treturn false;\n\n\t\tif (cached_root_available(vcpu, new_cr3, new_role)) {\n\t\t\t/*\n\t\t\t * It is possible that the cached previous root page is\n\t\t\t * obsolete because of a change in the MMU generation\n\t\t\t * number. However, changing the generation number is\n\t\t\t * accompanied by KVM_REQ_MMU_RELOAD, which will free\n\t\t\t * the root set here and allocate a new one.\n\t\t\t */\n\t\t\tkvm_make_request(KVM_REQ_LOAD_MMU_PGD, vcpu);\n\t\t\tif (!skip_tlb_flush) {\n\t\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\t\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The last MMIO access's GVA and GPA are cached in the\n\t\t\t * VCPU. When switching to a new CR3, that GVA->GPA\n\t\t\t * mapping may no longer be valid. So clear any cached\n\t\t\t * MMIO info even when we don't need to sync the shadow\n\t\t\t * page tables.\n\t\t\t */\n\t\t\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\n\t\t\t__clear_sp_write_flooding_count(\n\t\t\t\tpage_header(mmu->root_hpa));\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "cached_root_available",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4264-4288",
    "snippet": "static bool cached_root_available(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t\t  union kvm_mmu_page_role new_role)\n{\n\tuint i;\n\tstruct kvm_mmu_root_info root;\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\n\troot.cr3 = mmu->root_cr3;\n\troot.hpa = mmu->root_hpa;\n\n\tif (is_root_usable(&root, new_cr3, new_role))\n\t\treturn true;\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tswap(root, mmu->prev_roots[i]);\n\n\t\tif (is_root_usable(&root, new_cr3, new_role))\n\t\t\tbreak;\n\t}\n\n\tmmu->root_hpa = root.hpa;\n\tmmu->root_cr3 = root.cr3;\n\n\treturn i < KVM_MMU_NUM_PREV_ROOTS;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_root_usable",
          "args": [
            "&root",
            "new_cr3",
            "new_role"
          ],
          "line": 4280
        },
        "resolved": true,
        "details": {
          "function_name": "is_root_usable",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4248-4254",
          "snippet": "static inline bool is_root_usable(struct kvm_mmu_root_info *root, gpa_t cr3,\n\t\t\t\t  union kvm_mmu_page_role role)\n{\n\treturn (role.direct || cr3 == root->cr3) &&\n\t       VALID_PAGE(root->hpa) && page_header(root->hpa) &&\n\t       role.word == page_header(root->hpa)->role.word;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool is_root_usable(struct kvm_mmu_root_info *root, gpa_t cr3,\n\t\t\t\t  union kvm_mmu_page_role role)\n{\n\treturn (role.direct || cr3 == root->cr3) &&\n\t       VALID_PAGE(root->hpa) && page_header(root->hpa) &&\n\t       role.word == page_header(root->hpa)->role.word;\n}"
        }
      },
      {
        "call_info": {
          "callee": "swap",
          "args": [
            "root",
            "mmu->prev_roots[i]"
          ],
          "line": 4278
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool cached_root_available(struct kvm_vcpu *vcpu, gpa_t new_cr3,\n\t\t\t\t  union kvm_mmu_page_role new_role)\n{\n\tuint i;\n\tstruct kvm_mmu_root_info root;\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\n\troot.cr3 = mmu->root_cr3;\n\troot.hpa = mmu->root_hpa;\n\n\tif (is_root_usable(&root, new_cr3, new_role))\n\t\treturn true;\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++) {\n\t\tswap(root, mmu->prev_roots[i]);\n\n\t\tif (is_root_usable(&root, new_cr3, new_role))\n\t\t\tbreak;\n\t}\n\n\tmmu->root_hpa = root.hpa;\n\tmmu->root_cr3 = root.cr3;\n\n\treturn i < KVM_MMU_NUM_PREV_ROOTS;\n}"
  },
  {
    "function_name": "is_root_usable",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4248-4254",
    "snippet": "static inline bool is_root_usable(struct kvm_mmu_root_info *root, gpa_t cr3,\n\t\t\t\t  union kvm_mmu_page_role role)\n{\n\treturn (role.direct || cr3 == root->cr3) &&\n\t       VALID_PAGE(root->hpa) && page_header(root->hpa) &&\n\t       role.word == page_header(root->hpa)->role.word;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root->hpa"
          ],
          "line": 4253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root->hpa"
          ],
          "line": 4252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "root->hpa"
          ],
          "line": 4252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool is_root_usable(struct kvm_mmu_root_info *root, gpa_t cr3,\n\t\t\t\t  union kvm_mmu_page_role role)\n{\n\treturn (role.direct || cr3 == root->cr3) &&\n\t       VALID_PAGE(root->hpa) && page_header(root->hpa) &&\n\t       role.word == page_header(root->hpa)->role.word;\n}"
  },
  {
    "function_name": "nonpaging_init_context",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4234-4246",
    "snippet": "static void nonpaging_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tcontext->page_fault = nonpaging_page_fault;\n\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->root_level = 0;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->direct_map = true;\n\tcontext->nx = false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void nonpaging_init_context(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct kvm_mmu *context)\n{\n\tcontext->page_fault = nonpaging_page_fault;\n\tcontext->gva_to_gpa = nonpaging_gva_to_gpa;\n\tcontext->sync_page = nonpaging_sync_page;\n\tcontext->invlpg = nonpaging_invlpg;\n\tcontext->update_pte = nonpaging_update_pte;\n\tcontext->root_level = 0;\n\tcontext->shadow_root_level = PT32E_ROOT_LEVEL;\n\tcontext->direct_map = true;\n\tcontext->nx = false;\n}"
  },
  {
    "function_name": "kvm_tdp_page_fault",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4215-4232",
    "snippet": "int kvm_tdp_page_fault(struct kvm_vcpu *vcpu, gpa_t gpa, u32 error_code,\n\t\t       bool prefault)\n{\n\tint max_level;\n\n\tfor (max_level = PT_MAX_HUGEPAGE_LEVEL;\n\t     max_level > PT_PAGE_TABLE_LEVEL;\n\t     max_level--) {\n\t\tint page_num = KVM_PAGES_PER_HPAGE(max_level);\n\t\tgfn_t base = (gpa >> PAGE_SHIFT) & ~(page_num - 1);\n\n\t\tif (kvm_mtrr_check_gfn_range_consistency(vcpu, base, page_num))\n\t\t\tbreak;\n\t}\n\n\treturn direct_page_fault(vcpu, gpa, error_code, prefault,\n\t\t\t\t max_level, true);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "direct_page_fault",
          "args": [
            "vcpu",
            "gpa",
            "error_code",
            "prefault",
            "max_level",
            "true"
          ],
          "line": 4230
        },
        "resolved": true,
        "details": {
          "function_name": "direct_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4117-4165",
          "snippet": "static int direct_page_fault(struct kvm_vcpu *vcpu, gpa_t gpa, u32 error_code,\n\t\t\t     bool prefault, int max_level, bool is_tdp)\n{\n\tbool write = error_code & PFERR_WRITE_MASK;\n\tbool exec = error_code & PFERR_FETCH_MASK;\n\tbool lpage_disallowed = exec && is_nx_huge_page_enabled();\n\tbool map_writable;\n\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tunsigned long mmu_seq;\n\tkvm_pfn_t pfn;\n\tint r;\n\n\tif (page_fault_handle_page_track(vcpu, error_code, gfn))\n\t\treturn RET_PF_EMULATE;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tif (lpage_disallowed)\n\t\tmax_level = PT_PAGE_TABLE_LEVEL;\n\n\tif (fast_page_fault(vcpu, gpa, error_code))\n\t\treturn RET_PF_RETRY;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n\t\treturn RET_PF_RETRY;\n\n\tif (handle_abnormal_pfn(vcpu, is_tdp ? 0 : gpa, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tr = RET_PF_RETRY;\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tif (make_mmu_pages_available(vcpu) < 0)\n\t\tgoto out_unlock;\n\tr = __direct_map(vcpu, gpa, write, map_writable, max_level, pfn,\n\t\t\t prefault, is_tdp && lpage_disallowed);\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int direct_page_fault(struct kvm_vcpu *vcpu, gpa_t gpa, u32 error_code,\n\t\t\t     bool prefault, int max_level, bool is_tdp)\n{\n\tbool write = error_code & PFERR_WRITE_MASK;\n\tbool exec = error_code & PFERR_FETCH_MASK;\n\tbool lpage_disallowed = exec && is_nx_huge_page_enabled();\n\tbool map_writable;\n\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tunsigned long mmu_seq;\n\tkvm_pfn_t pfn;\n\tint r;\n\n\tif (page_fault_handle_page_track(vcpu, error_code, gfn))\n\t\treturn RET_PF_EMULATE;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tif (lpage_disallowed)\n\t\tmax_level = PT_PAGE_TABLE_LEVEL;\n\n\tif (fast_page_fault(vcpu, gpa, error_code))\n\t\treturn RET_PF_RETRY;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n\t\treturn RET_PF_RETRY;\n\n\tif (handle_abnormal_pfn(vcpu, is_tdp ? 0 : gpa, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tr = RET_PF_RETRY;\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tif (make_mmu_pages_available(vcpu) < 0)\n\t\tgoto out_unlock;\n\tr = __direct_map(vcpu, gpa, write, map_writable, max_level, pfn,\n\t\t\t prefault, is_tdp && lpage_disallowed);\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mtrr_check_gfn_range_consistency",
          "args": [
            "vcpu",
            "base",
            "page_num"
          ],
          "line": 4226
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mtrr_check_gfn_range_consistency",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mtrr.c",
          "lines": "695-725",
          "snippet": "bool kvm_mtrr_check_gfn_range_consistency(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\t  int page_num)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\n\tstart = gfn_to_gpa(gfn);\n\tend = gfn_to_gpa(gfn + page_num);\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tif (type == -1) {\n\t\t\ttype = iter.mem_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type != iter.mem_type)\n\t\t\treturn false;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn true;\n\n\tif (!iter.partial_map)\n\t\treturn true;\n\n\tif (type == -1)\n\t\treturn true;\n\n\treturn type == mtrr_default_type(mtrr_state);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nbool kvm_mtrr_check_gfn_range_consistency(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t\t  int page_num)\n{\n\tstruct kvm_mtrr *mtrr_state = &vcpu->arch.mtrr_state;\n\tstruct mtrr_iter iter;\n\tu64 start, end;\n\tint type = -1;\n\n\tstart = gfn_to_gpa(gfn);\n\tend = gfn_to_gpa(gfn + page_num);\n\tmtrr_for_each_mem_type(&iter, mtrr_state, start, end) {\n\t\tif (type == -1) {\n\t\t\ttype = iter.mem_type;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (type != iter.mem_type)\n\t\t\treturn false;\n\t}\n\n\tif (iter.mtrr_disabled)\n\t\treturn true;\n\n\tif (!iter.partial_map)\n\t\treturn true;\n\n\tif (type == -1)\n\t\treturn true;\n\n\treturn type == mtrr_default_type(mtrr_state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "max_level"
          ],
          "line": 4223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_tdp_page_fault(struct kvm_vcpu *vcpu, gpa_t gpa, u32 error_code,\n\t\t       bool prefault)\n{\n\tint max_level;\n\n\tfor (max_level = PT_MAX_HUGEPAGE_LEVEL;\n\t     max_level > PT_PAGE_TABLE_LEVEL;\n\t     max_level--) {\n\t\tint page_num = KVM_PAGES_PER_HPAGE(max_level);\n\t\tgfn_t base = (gpa >> PAGE_SHIFT) & ~(page_num - 1);\n\n\t\tif (kvm_mtrr_check_gfn_range_consistency(vcpu, base, page_num))\n\t\t\tbreak;\n\t}\n\n\treturn direct_page_fault(vcpu, gpa, error_code, prefault,\n\t\t\t\t max_level, true);\n}"
  },
  {
    "function_name": "kvm_handle_page_fault",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4177-4212",
    "snippet": "int kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code,\n\t\t\t\tu64 fault_address, char *insn, int insn_len)\n{\n\tint r = 1;\n\n#ifndef CONFIG_X86_64\n\t/* A 64-bit CR2 should be impossible on 32-bit KVM. */\n\tif (WARN_ON_ONCE(fault_address >> 32))\n\t\treturn -EFAULT;\n#endif\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tswitch (vcpu->arch.apf.host_apf_reason) {\n\tdefault:\n\t\ttrace_kvm_page_fault(fault_address, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, fault_address);\n\t\tr = kvm_mmu_page_fault(vcpu, fault_address, error_code, insn,\n\t\t\t\tinsn_len);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_NOT_PRESENT:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wait(fault_address, 0);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_READY:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wake(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\t}\n\treturn r;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 4208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_task_wake",
          "args": [
            "fault_address"
          ],
          "line": 4207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 4206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 4202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_async_pf_task_wait",
          "args": [
            "fault_address",
            "0"
          ],
          "line": 4201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 4200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_fault",
          "args": [
            "vcpu",
            "fault_address",
            "error_code",
            "insn",
            "insn_len"
          ],
          "line": 4195
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5429-5497",
          "snippet": "int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_PF;\n\tbool direct = vcpu->arch.mmu->direct_map;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tr = RET_PF_INVALID;\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);\n\t\tif (r == RET_PF_EMULATE)\n\t\t\tgoto emulate;\n\t}\n\n\tif (r == RET_PF_INVALID) {\n\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,\n\t\t\t\t\t  lower_32_bits(error_code), false);\n\t\tWARN_ON(r == RET_PF_INVALID);\n\t}\n\n\tif (r == RET_PF_RETRY)\n\t\treturn 1;\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * Before emulating the instruction, check if the error code\n\t * was due to a RO violation while translating the guest page.\n\t * This can occur when using nested virtualization with nested\n\t * paging in both guests. If true, we simply unprotect the page\n\t * and resume the guest.\n\t */\n\tif (vcpu->arch.mmu->direct_map &&\n\t    (error_code & PFERR_NESTED_GUEST_PAGE) == PFERR_NESTED_GUEST_PAGE) {\n\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(cr2_or_gpa));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * vcpu->arch.mmu.page_fault returned RET_PF_EMULATE, but we can still\n\t * optimistically try to just unprotect the page and let the processor\n\t * re-execute the instruction that caused the page fault.  Do not allow\n\t * retrying MMIO emulation, as it's not only pointless but could also\n\t * cause us to enter an infinite loop because the processor will keep\n\t * faulting on the non-existent MMIO address.  Retrying an instruction\n\t * from a nested guest is also pointless and dangerous as we are only\n\t * explicitly shadowing L1's page tables, i.e. unprotecting something\n\t * for L1 isn't going to magically fix whatever issue cause L2 to fail.\n\t */\n\tif (!mmio_info_in_cache(vcpu, cr2_or_gpa, direct) && !is_guest_mode(vcpu))\n\t\temulation_type |= EMULTYPE_ALLOW_RETRY_PF;\nemulate:\n\t/*\n\t * On AMD platforms, under certain conditions insn_len may be zero on #NPF.\n\t * This can happen if a guest gets a page-fault on data access but the HW\n\t * table walker is not able to read the instruction page (e.g instruction\n\t * page is not present in memory). In those cases we simply restart the\n\t * guest, with the exception of AMD Erratum 1096 which is unrecoverable.\n\t */\n\tif (unlikely(insn && !insn_len)) {\n\t\tif (!kvm_x86_ops.need_emulation_on_page_fault(vcpu))\n\t\t\treturn 1;\n\t}\n\n\treturn x86_emulate_instruction(vcpu, cr2_or_gpa, emulation_type, insn,\n\t\t\t\t       insn_len);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_PF;\n\tbool direct = vcpu->arch.mmu->direct_map;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tr = RET_PF_INVALID;\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);\n\t\tif (r == RET_PF_EMULATE)\n\t\t\tgoto emulate;\n\t}\n\n\tif (r == RET_PF_INVALID) {\n\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,\n\t\t\t\t\t  lower_32_bits(error_code), false);\n\t\tWARN_ON(r == RET_PF_INVALID);\n\t}\n\n\tif (r == RET_PF_RETRY)\n\t\treturn 1;\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * Before emulating the instruction, check if the error code\n\t * was due to a RO violation while translating the guest page.\n\t * This can occur when using nested virtualization with nested\n\t * paging in both guests. If true, we simply unprotect the page\n\t * and resume the guest.\n\t */\n\tif (vcpu->arch.mmu->direct_map &&\n\t    (error_code & PFERR_NESTED_GUEST_PAGE) == PFERR_NESTED_GUEST_PAGE) {\n\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(cr2_or_gpa));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * vcpu->arch.mmu.page_fault returned RET_PF_EMULATE, but we can still\n\t * optimistically try to just unprotect the page and let the processor\n\t * re-execute the instruction that caused the page fault.  Do not allow\n\t * retrying MMIO emulation, as it's not only pointless but could also\n\t * cause us to enter an infinite loop because the processor will keep\n\t * faulting on the non-existent MMIO address.  Retrying an instruction\n\t * from a nested guest is also pointless and dangerous as we are only\n\t * explicitly shadowing L1's page tables, i.e. unprotecting something\n\t * for L1 isn't going to magically fix whatever issue cause L2 to fail.\n\t */\n\tif (!mmio_info_in_cache(vcpu, cr2_or_gpa, direct) && !is_guest_mode(vcpu))\n\t\temulation_type |= EMULTYPE_ALLOW_RETRY_PF;\nemulate:\n\t/*\n\t * On AMD platforms, under certain conditions insn_len may be zero on #NPF.\n\t * This can happen if a guest gets a page-fault on data access but the HW\n\t * table walker is not able to read the instruction page (e.g instruction\n\t * page is not present in memory). In those cases we simply restart the\n\t * guest, with the exception of AMD Erratum 1096 which is unrecoverable.\n\t */\n\tif (unlikely(insn && !insn_len)) {\n\t\tif (!kvm_x86_ops.need_emulation_on_page_fault(vcpu))\n\t\t\treturn 1;\n\t}\n\n\treturn x86_emulate_instruction(vcpu, cr2_or_gpa, emulation_type, insn,\n\t\t\t\t       insn_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unprotect_page_virt",
          "args": [
            "vcpu",
            "fault_address"
          ],
          "line": 4194
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unprotect_page_virt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5413-5426",
          "snippet": "int kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_unprotect_page_virt(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tgpa_t gpa;\n\tint r;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn 0;\n\n\tgpa = kvm_mmu_gva_to_gpa_read(vcpu, gva, NULL);\n\n\tr = kvm_mmu_unprotect_page(vcpu->kvm, gpa >> PAGE_SHIFT);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_event_needs_reinjection",
          "args": [
            "vcpu"
          ],
          "line": 4193
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_event_needs_reinjection",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "69-73",
          "snippet": "static inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.injected || vcpu->arch.interrupt.injected ||\n\t\tvcpu->arch.nmi_injected;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_event_needs_reinjection(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.exception.injected || vcpu->arch.interrupt.injected ||\n\t\tvcpu->arch.nmi_injected;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_page_fault",
          "args": [
            "fault_address",
            "error_code"
          ],
          "line": 4191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "fault_address >> 32"
          ],
          "line": 4184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code,\n\t\t\t\tu64 fault_address, char *insn, int insn_len)\n{\n\tint r = 1;\n\n#ifndef CONFIG_X86_64\n\t/* A 64-bit CR2 should be impossible on 32-bit KVM. */\n\tif (WARN_ON_ONCE(fault_address >> 32))\n\t\treturn -EFAULT;\n#endif\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tswitch (vcpu->arch.apf.host_apf_reason) {\n\tdefault:\n\t\ttrace_kvm_page_fault(fault_address, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, fault_address);\n\t\tr = kvm_mmu_page_fault(vcpu, fault_address, error_code, insn,\n\t\t\t\tinsn_len);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_NOT_PRESENT:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wait(fault_address, 0);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_READY:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wake(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\t}\n\treturn r;\n}"
  },
  {
    "function_name": "nonpaging_page_fault",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4167-4175",
    "snippet": "static int nonpaging_page_fault(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\tu32 error_code, bool prefault)\n{\n\tpgprintk(\"%s: gva %lx error %x\\n\", __func__, gpa, error_code);\n\n\t/* This path builds a PAE pagetable, we can map 2mb pages at maximum. */\n\treturn direct_page_fault(vcpu, gpa & PAGE_MASK, error_code, prefault,\n\t\t\t\t PT_DIRECTORY_LEVEL, false);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "direct_page_fault",
          "args": [
            "vcpu",
            "gpa & PAGE_MASK",
            "error_code",
            "prefault",
            "PT_DIRECTORY_LEVEL",
            "false"
          ],
          "line": 4173
        },
        "resolved": true,
        "details": {
          "function_name": "direct_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4117-4165",
          "snippet": "static int direct_page_fault(struct kvm_vcpu *vcpu, gpa_t gpa, u32 error_code,\n\t\t\t     bool prefault, int max_level, bool is_tdp)\n{\n\tbool write = error_code & PFERR_WRITE_MASK;\n\tbool exec = error_code & PFERR_FETCH_MASK;\n\tbool lpage_disallowed = exec && is_nx_huge_page_enabled();\n\tbool map_writable;\n\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tunsigned long mmu_seq;\n\tkvm_pfn_t pfn;\n\tint r;\n\n\tif (page_fault_handle_page_track(vcpu, error_code, gfn))\n\t\treturn RET_PF_EMULATE;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tif (lpage_disallowed)\n\t\tmax_level = PT_PAGE_TABLE_LEVEL;\n\n\tif (fast_page_fault(vcpu, gpa, error_code))\n\t\treturn RET_PF_RETRY;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n\t\treturn RET_PF_RETRY;\n\n\tif (handle_abnormal_pfn(vcpu, is_tdp ? 0 : gpa, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tr = RET_PF_RETRY;\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tif (make_mmu_pages_available(vcpu) < 0)\n\t\tgoto out_unlock;\n\tr = __direct_map(vcpu, gpa, write, map_writable, max_level, pfn,\n\t\t\t prefault, is_tdp && lpage_disallowed);\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int direct_page_fault(struct kvm_vcpu *vcpu, gpa_t gpa, u32 error_code,\n\t\t\t     bool prefault, int max_level, bool is_tdp)\n{\n\tbool write = error_code & PFERR_WRITE_MASK;\n\tbool exec = error_code & PFERR_FETCH_MASK;\n\tbool lpage_disallowed = exec && is_nx_huge_page_enabled();\n\tbool map_writable;\n\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tunsigned long mmu_seq;\n\tkvm_pfn_t pfn;\n\tint r;\n\n\tif (page_fault_handle_page_track(vcpu, error_code, gfn))\n\t\treturn RET_PF_EMULATE;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tif (lpage_disallowed)\n\t\tmax_level = PT_PAGE_TABLE_LEVEL;\n\n\tif (fast_page_fault(vcpu, gpa, error_code))\n\t\treturn RET_PF_RETRY;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n\t\treturn RET_PF_RETRY;\n\n\tif (handle_abnormal_pfn(vcpu, is_tdp ? 0 : gpa, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tr = RET_PF_RETRY;\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tif (make_mmu_pages_available(vcpu) < 0)\n\t\tgoto out_unlock;\n\tr = __direct_map(vcpu, gpa, write, map_writable, max_level, pfn,\n\t\t\t prefault, is_tdp && lpage_disallowed);\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: gva %lx error %x\\n\"",
            "__func__",
            "gpa",
            "error_code"
          ],
          "line": 4170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int nonpaging_page_fault(struct kvm_vcpu *vcpu, gpa_t gpa,\n\t\t\t\tu32 error_code, bool prefault)\n{\n\tpgprintk(\"%s: gva %lx error %x\\n\", __func__, gpa, error_code);\n\n\t/* This path builds a PAE pagetable, we can map 2mb pages at maximum. */\n\treturn direct_page_fault(vcpu, gpa & PAGE_MASK, error_code, prefault,\n\t\t\t\t PT_DIRECTORY_LEVEL, false);\n}"
  },
  {
    "function_name": "direct_page_fault",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4117-4165",
    "snippet": "static int direct_page_fault(struct kvm_vcpu *vcpu, gpa_t gpa, u32 error_code,\n\t\t\t     bool prefault, int max_level, bool is_tdp)\n{\n\tbool write = error_code & PFERR_WRITE_MASK;\n\tbool exec = error_code & PFERR_FETCH_MASK;\n\tbool lpage_disallowed = exec && is_nx_huge_page_enabled();\n\tbool map_writable;\n\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tunsigned long mmu_seq;\n\tkvm_pfn_t pfn;\n\tint r;\n\n\tif (page_fault_handle_page_track(vcpu, error_code, gfn))\n\t\treturn RET_PF_EMULATE;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tif (lpage_disallowed)\n\t\tmax_level = PT_PAGE_TABLE_LEVEL;\n\n\tif (fast_page_fault(vcpu, gpa, error_code))\n\t\treturn RET_PF_RETRY;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n\t\treturn RET_PF_RETRY;\n\n\tif (handle_abnormal_pfn(vcpu, is_tdp ? 0 : gpa, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tr = RET_PF_RETRY;\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tif (make_mmu_pages_available(vcpu) < 0)\n\t\tgoto out_unlock;\n\tr = __direct_map(vcpu, gpa, write, map_writable, max_level, pfn,\n\t\t\t prefault, is_tdp && lpage_disallowed);\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn r;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_release_pfn_clean",
          "args": [
            "pfn"
          ],
          "line": 4163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 4162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__direct_map",
          "args": [
            "vcpu",
            "gpa",
            "write",
            "map_writable",
            "max_level",
            "pfn",
            "prefault",
            "is_tdp && lpage_disallowed"
          ],
          "line": 4158
        },
        "resolved": true,
        "details": {
          "function_name": "__direct_map",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3337-3381",
          "snippet": "static int __direct_map(struct kvm_vcpu *vcpu, gpa_t gpa, int write,\n\t\t\tint map_writable, int max_level, kvm_pfn_t pfn,\n\t\t\tbool prefault, bool account_disallowed_nx_lpage)\n{\n\tstruct kvm_shadow_walk_iterator it;\n\tstruct kvm_mmu_page *sp;\n\tint level, ret;\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tgfn_t base_gfn = gfn;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tlevel = kvm_mmu_hugepage_adjust(vcpu, gfn, max_level, &pfn);\n\n\ttrace_kvm_mmu_spte_requested(gpa, level, pfn);\n\tfor_each_shadow_entry(vcpu, gpa, it) {\n\t\t/*\n\t\t * We cannot overwrite existing page tables with an NX\n\t\t * large page, as the leaf could be executable.\n\t\t */\n\t\tdisallowed_hugepage_adjust(it, gfn, &pfn, &level);\n\n\t\tbase_gfn = gfn & ~(KVM_PAGES_PER_HPAGE(it.level) - 1);\n\t\tif (it.level == level)\n\t\t\tbreak;\n\n\t\tdrop_large_spte(vcpu, it.sptep);\n\t\tif (!is_shadow_present_pte(*it.sptep)) {\n\t\t\tsp = kvm_mmu_get_page(vcpu, base_gfn, it.addr,\n\t\t\t\t\t      it.level - 1, true, ACC_ALL);\n\n\t\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\t\t\tif (account_disallowed_nx_lpage)\n\t\t\t\taccount_huge_nx_page(vcpu->kvm, sp);\n\t\t}\n\t}\n\n\tret = mmu_set_spte(vcpu, it.sptep, ACC_ALL,\n\t\t\t   write, level, base_gfn, pfn, prefault,\n\t\t\t   map_writable);\n\tdirect_pte_prefetch(vcpu, it.sptep);\n\t++vcpu->stat.pf_fixed;\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int __direct_map(struct kvm_vcpu *vcpu, gpa_t gpa, int write,\n\t\t\tint map_writable, int max_level, kvm_pfn_t pfn,\n\t\t\tbool prefault, bool account_disallowed_nx_lpage)\n{\n\tstruct kvm_shadow_walk_iterator it;\n\tstruct kvm_mmu_page *sp;\n\tint level, ret;\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tgfn_t base_gfn = gfn;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tlevel = kvm_mmu_hugepage_adjust(vcpu, gfn, max_level, &pfn);\n\n\ttrace_kvm_mmu_spte_requested(gpa, level, pfn);\n\tfor_each_shadow_entry(vcpu, gpa, it) {\n\t\t/*\n\t\t * We cannot overwrite existing page tables with an NX\n\t\t * large page, as the leaf could be executable.\n\t\t */\n\t\tdisallowed_hugepage_adjust(it, gfn, &pfn, &level);\n\n\t\tbase_gfn = gfn & ~(KVM_PAGES_PER_HPAGE(it.level) - 1);\n\t\tif (it.level == level)\n\t\t\tbreak;\n\n\t\tdrop_large_spte(vcpu, it.sptep);\n\t\tif (!is_shadow_present_pte(*it.sptep)) {\n\t\t\tsp = kvm_mmu_get_page(vcpu, base_gfn, it.addr,\n\t\t\t\t\t      it.level - 1, true, ACC_ALL);\n\n\t\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\t\t\tif (account_disallowed_nx_lpage)\n\t\t\t\taccount_huge_nx_page(vcpu->kvm, sp);\n\t\t}\n\t}\n\n\tret = mmu_set_spte(vcpu, it.sptep, ACC_ALL,\n\t\t\t   write, level, base_gfn, pfn, prefault,\n\t\t\t   map_writable);\n\tdirect_pte_prefetch(vcpu, it.sptep);\n\t++vcpu->stat.pf_fixed;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_mmu_pages_available",
          "args": [
            "vcpu"
          ],
          "line": 4156
        },
        "resolved": true,
        "details": {
          "function_name": "make_mmu_pages_available",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2833-2851",
          "snippet": "static int make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn 0;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\n\tif (!kvm_mmu_available_pages(vcpu->kvm))\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn 0;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\n\tif (!kvm_mmu_available_pages(vcpu->kvm))\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_notifier_retry",
          "args": [
            "vcpu->kvm",
            "mmu_seq"
          ],
          "line": 4154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 4153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_abnormal_pfn",
          "args": [
            "vcpu",
            "is_tdp ? 0 : gpa",
            "gfn",
            "pfn",
            "ACC_ALL",
            "&r"
          ],
          "line": 4149
        },
        "resolved": true,
        "details": {
          "function_name": "handle_abnormal_pfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3406-3421",
          "snippet": "static bool handle_abnormal_pfn(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,\n\t\t\t\tkvm_pfn_t pfn, unsigned int access,\n\t\t\t\tint *ret_val)\n{\n\t/* The pfn is invalid, report the error! */\n\tif (unlikely(is_error_pfn(pfn))) {\n\t\t*ret_val = kvm_handle_bad_page(vcpu, gfn, pfn);\n\t\treturn true;\n\t}\n\n\tif (unlikely(is_noslot_pfn(pfn)))\n\t\tvcpu_cache_mmio_info(vcpu, gva, gfn,\n\t\t\t\t     access & shadow_mmio_access_mask);\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool handle_abnormal_pfn(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,\n\t\t\t\tkvm_pfn_t pfn, unsigned int access,\n\t\t\t\tint *ret_val)\n{\n\t/* The pfn is invalid, report the error! */\n\tif (unlikely(is_error_pfn(pfn))) {\n\t\t*ret_val = kvm_handle_bad_page(vcpu, gfn, pfn);\n\t\treturn true;\n\t}\n\n\tif (unlikely(is_noslot_pfn(pfn)))\n\t\tvcpu_cache_mmio_info(vcpu, gva, gfn,\n\t\t\t\t     access & shadow_mmio_access_mask);\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_async_pf",
          "args": [
            "vcpu",
            "prefault",
            "gfn",
            "gpa",
            "&pfn",
            "write",
            "&map_writable"
          ],
          "line": 4146
        },
        "resolved": true,
        "details": {
          "function_name": "try_async_pf",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4082-4115",
          "snippet": "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gpa_t cr2_or_gpa, kvm_pfn_t *pfn, bool write,\n\t\t\t bool *writable)\n{\n\tstruct kvm_memory_slot *slot;\n\tbool async;\n\n\t/*\n\t * Don't expose private memslots to L2.\n\t */\n\tif (is_guest_mode(vcpu) && !kvm_is_visible_gfn(vcpu->kvm, gfn)) {\n\t\t*pfn = KVM_PFN_NOSLOT;\n\t\treturn false;\n\t}\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tasync = false;\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);\n\tif (!async)\n\t\treturn false; /* *pfn has correct page already */\n\n\tif (!prefault && kvm_can_do_async_pf(vcpu)) {\n\t\ttrace_kvm_try_async_get_page(cr2_or_gpa, gfn);\n\t\tif (kvm_find_async_pf_gfn(vcpu, gfn)) {\n\t\t\ttrace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);\n\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\t\treturn true;\n\t\t} else if (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))\n\t\t\treturn true;\n\t}\n\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gpa_t cr2_or_gpa, kvm_pfn_t *pfn, bool write,\n\t\t\t bool *writable)\n{\n\tstruct kvm_memory_slot *slot;\n\tbool async;\n\n\t/*\n\t * Don't expose private memslots to L2.\n\t */\n\tif (is_guest_mode(vcpu) && !kvm_is_visible_gfn(vcpu->kvm, gfn)) {\n\t\t*pfn = KVM_PFN_NOSLOT;\n\t\treturn false;\n\t}\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tasync = false;\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);\n\tif (!async)\n\t\treturn false; /* *pfn has correct page already */\n\n\tif (!prefault && kvm_can_do_async_pf(vcpu)) {\n\t\ttrace_kvm_try_async_get_page(cr2_or_gpa, gfn);\n\t\tif (kvm_find_async_pf_gfn(vcpu, gfn)) {\n\t\t\ttrace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);\n\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\t\treturn true;\n\t\t} else if (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))\n\t\t\treturn true;\n\t}\n\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 4144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fast_page_fault",
          "args": [
            "vcpu",
            "gpa",
            "error_code"
          ],
          "line": 4140
        },
        "resolved": true,
        "details": {
          "function_name": "fast_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3512-3610",
          "snippet": "static bool fast_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t    u32 error_code)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tbool fault_handled = false;\n\tu64 spte = 0ull;\n\tuint retry_count = 0;\n\n\tif (!page_fault_can_be_fast(error_code))\n\t\treturn false;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tdo {\n\t\tu64 new_spte;\n\n\t\tfor_each_shadow_entry_lockless(vcpu, cr2_or_gpa, iterator, spte)\n\t\t\tif (!is_shadow_present_pte(spte))\n\t\t\t\tbreak;\n\n\t\tsp = page_header(__pa(iterator.sptep));\n\t\tif (!is_last_spte(spte, sp->role.level))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check whether the memory access that caused the fault would\n\t\t * still cause it if it were to be performed right now. If not,\n\t\t * then this is a spurious fault caused by TLB lazily flushed,\n\t\t * or some other CPU has already fixed the PTE after the\n\t\t * current CPU took the fault.\n\t\t *\n\t\t * Need not check the access of upper level table entries since\n\t\t * they are always ACC_ALL.\n\t\t */\n\t\tif (is_access_allowed(error_code, spte)) {\n\t\t\tfault_handled = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tnew_spte = spte;\n\n\t\tif (is_access_track_spte(spte))\n\t\t\tnew_spte = restore_acc_track_spte(new_spte);\n\n\t\t/*\n\t\t * Currently, to simplify the code, write-protection can\n\t\t * be removed in the fast path only if the SPTE was\n\t\t * write-protected for dirty-logging or access tracking.\n\t\t */\n\t\tif ((error_code & PFERR_WRITE_MASK) &&\n\t\t    spte_can_locklessly_be_made_writable(spte)) {\n\t\t\tnew_spte |= PT_WRITABLE_MASK;\n\n\t\t\t/*\n\t\t\t * Do not fix write-permission on the large spte.  Since\n\t\t\t * we only dirty the first page into the dirty-bitmap in\n\t\t\t * fast_pf_fix_direct_spte(), other pages are missed\n\t\t\t * if its slot has dirty logging enabled.\n\t\t\t *\n\t\t\t * Instead, we let the slow page fault path create a\n\t\t\t * normal spte to fix the access.\n\t\t\t *\n\t\t\t * See the comments in kvm_arch_commit_memory_region().\n\t\t\t */\n\t\t\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Verify that the fault can be handled in the fast path */\n\t\tif (new_spte == spte ||\n\t\t    !is_access_allowed(error_code, new_spte))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Currently, fast page fault only works for direct mapping\n\t\t * since the gfn is not stable for indirect shadow page. See\n\t\t * Documentation/virt/kvm/locking.txt to get more detail.\n\t\t */\n\t\tfault_handled = fast_pf_fix_direct_spte(vcpu, sp,\n\t\t\t\t\t\t\titerator.sptep, spte,\n\t\t\t\t\t\t\tnew_spte);\n\t\tif (fault_handled)\n\t\t\tbreak;\n\n\t\tif (++retry_count > 4) {\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"kvm: Fast #PF retrying more than 4 times.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t} while (true);\n\n\ttrace_fast_page_fault(vcpu, cr2_or_gpa, error_code, iterator.sptep,\n\t\t\t      spte, fault_handled);\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn fault_handled;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool fast_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t    u32 error_code)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tbool fault_handled = false;\n\tu64 spte = 0ull;\n\tuint retry_count = 0;\n\n\tif (!page_fault_can_be_fast(error_code))\n\t\treturn false;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tdo {\n\t\tu64 new_spte;\n\n\t\tfor_each_shadow_entry_lockless(vcpu, cr2_or_gpa, iterator, spte)\n\t\t\tif (!is_shadow_present_pte(spte))\n\t\t\t\tbreak;\n\n\t\tsp = page_header(__pa(iterator.sptep));\n\t\tif (!is_last_spte(spte, sp->role.level))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check whether the memory access that caused the fault would\n\t\t * still cause it if it were to be performed right now. If not,\n\t\t * then this is a spurious fault caused by TLB lazily flushed,\n\t\t * or some other CPU has already fixed the PTE after the\n\t\t * current CPU took the fault.\n\t\t *\n\t\t * Need not check the access of upper level table entries since\n\t\t * they are always ACC_ALL.\n\t\t */\n\t\tif (is_access_allowed(error_code, spte)) {\n\t\t\tfault_handled = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tnew_spte = spte;\n\n\t\tif (is_access_track_spte(spte))\n\t\t\tnew_spte = restore_acc_track_spte(new_spte);\n\n\t\t/*\n\t\t * Currently, to simplify the code, write-protection can\n\t\t * be removed in the fast path only if the SPTE was\n\t\t * write-protected for dirty-logging or access tracking.\n\t\t */\n\t\tif ((error_code & PFERR_WRITE_MASK) &&\n\t\t    spte_can_locklessly_be_made_writable(spte)) {\n\t\t\tnew_spte |= PT_WRITABLE_MASK;\n\n\t\t\t/*\n\t\t\t * Do not fix write-permission on the large spte.  Since\n\t\t\t * we only dirty the first page into the dirty-bitmap in\n\t\t\t * fast_pf_fix_direct_spte(), other pages are missed\n\t\t\t * if its slot has dirty logging enabled.\n\t\t\t *\n\t\t\t * Instead, we let the slow page fault path create a\n\t\t\t * normal spte to fix the access.\n\t\t\t *\n\t\t\t * See the comments in kvm_arch_commit_memory_region().\n\t\t\t */\n\t\t\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Verify that the fault can be handled in the fast path */\n\t\tif (new_spte == spte ||\n\t\t    !is_access_allowed(error_code, new_spte))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Currently, fast page fault only works for direct mapping\n\t\t * since the gfn is not stable for indirect shadow page. See\n\t\t * Documentation/virt/kvm/locking.txt to get more detail.\n\t\t */\n\t\tfault_handled = fast_pf_fix_direct_spte(vcpu, sp,\n\t\t\t\t\t\t\titerator.sptep, spte,\n\t\t\t\t\t\t\tnew_spte);\n\t\tif (fault_handled)\n\t\t\tbreak;\n\n\t\tif (++retry_count > 4) {\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"kvm: Fast #PF retrying more than 4 times.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t} while (true);\n\n\ttrace_fast_page_fault(vcpu, cr2_or_gpa, error_code, iterator.sptep,\n\t\t\t      spte, fault_handled);\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn fault_handled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_topup_memory_caches",
          "args": [
            "vcpu"
          ],
          "line": 4133
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_topup_memory_caches",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1112-1127",
          "snippet": "static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_PREFETCH_NUM\t\t8"
          ],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;",
            "static struct kmem_cache *mmu_page_header_cache;",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_fault_handle_page_track",
          "args": [
            "vcpu",
            "error_code",
            "gfn"
          ],
          "line": 4130
        },
        "resolved": true,
        "details": {
          "function_name": "page_fault_handle_page_track",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4034-4052",
          "snippet": "static bool page_fault_handle_page_track(struct kvm_vcpu *vcpu,\n\t\t\t\t\t u32 error_code, gfn_t gfn)\n{\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\t/*\n\t * guest is writing the page which is write tracked which can\n\t * not be fixed by page fault handler.\n\t */\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool page_fault_handle_page_track(struct kvm_vcpu *vcpu,\n\t\t\t\t\t u32 error_code, gfn_t gfn)\n{\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\t/*\n\t * guest is writing the page which is write tracked which can\n\t * not be fixed by page fault handler.\n\t */\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nx_huge_page_enabled",
          "args": [],
          "line": 4122
        },
        "resolved": true,
        "details": {
          "function_name": "is_nx_huge_page_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "377-380",
          "snippet": "static bool is_nx_huge_page_enabled(void)\n{\n\treturn READ_ONCE(nx_huge_pages);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool is_nx_huge_page_enabled(void)\n{\n\treturn READ_ONCE(nx_huge_pages);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int direct_page_fault(struct kvm_vcpu *vcpu, gpa_t gpa, u32 error_code,\n\t\t\t     bool prefault, int max_level, bool is_tdp)\n{\n\tbool write = error_code & PFERR_WRITE_MASK;\n\tbool exec = error_code & PFERR_FETCH_MASK;\n\tbool lpage_disallowed = exec && is_nx_huge_page_enabled();\n\tbool map_writable;\n\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tunsigned long mmu_seq;\n\tkvm_pfn_t pfn;\n\tint r;\n\n\tif (page_fault_handle_page_track(vcpu, error_code, gfn))\n\t\treturn RET_PF_EMULATE;\n\n\tr = mmu_topup_memory_caches(vcpu);\n\tif (r)\n\t\treturn r;\n\n\tif (lpage_disallowed)\n\t\tmax_level = PT_PAGE_TABLE_LEVEL;\n\n\tif (fast_page_fault(vcpu, gpa, error_code))\n\t\treturn RET_PF_RETRY;\n\n\tmmu_seq = vcpu->kvm->mmu_notifier_seq;\n\tsmp_rmb();\n\n\tif (try_async_pf(vcpu, prefault, gfn, gpa, &pfn, write, &map_writable))\n\t\treturn RET_PF_RETRY;\n\n\tif (handle_abnormal_pfn(vcpu, is_tdp ? 0 : gpa, gfn, pfn, ACC_ALL, &r))\n\t\treturn r;\n\n\tr = RET_PF_RETRY;\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tif (mmu_notifier_retry(vcpu->kvm, mmu_seq))\n\t\tgoto out_unlock;\n\tif (make_mmu_pages_available(vcpu) < 0)\n\t\tgoto out_unlock;\n\tr = __direct_map(vcpu, gpa, write, map_writable, max_level, pfn,\n\t\t\t prefault, is_tdp && lpage_disallowed);\n\nout_unlock:\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n\tkvm_release_pfn_clean(pfn);\n\treturn r;\n}"
  },
  {
    "function_name": "try_async_pf",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4082-4115",
    "snippet": "static bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gpa_t cr2_or_gpa, kvm_pfn_t *pfn, bool write,\n\t\t\t bool *writable)\n{\n\tstruct kvm_memory_slot *slot;\n\tbool async;\n\n\t/*\n\t * Don't expose private memslots to L2.\n\t */\n\tif (is_guest_mode(vcpu) && !kvm_is_visible_gfn(vcpu->kvm, gfn)) {\n\t\t*pfn = KVM_PFN_NOSLOT;\n\t\treturn false;\n\t}\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tasync = false;\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);\n\tif (!async)\n\t\treturn false; /* *pfn has correct page already */\n\n\tif (!prefault && kvm_can_do_async_pf(vcpu)) {\n\t\ttrace_kvm_try_async_get_page(cr2_or_gpa, gfn);\n\t\tif (kvm_find_async_pf_gfn(vcpu, gfn)) {\n\t\t\ttrace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);\n\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\t\treturn true;\n\t\t} else if (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))\n\t\t\treturn true;\n\t}\n\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfn_to_pfn_memslot",
          "args": [
            "slot",
            "gfn",
            "false",
            "NULL",
            "write",
            "writable"
          ],
          "line": 4113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_setup_async_pf",
          "args": [
            "vcpu",
            "cr2_or_gpa",
            "gfn"
          ],
          "line": 4109
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_setup_async_pf",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4068-4080",
          "snippet": "static int kvm_arch_setup_async_pf(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t\t   gfn_t gfn)\n{\n\tstruct kvm_arch_async_pf arch;\n\n\tarch.token = (vcpu->arch.apf.id++ << 12) | vcpu->vcpu_id;\n\tarch.gfn = gfn;\n\tarch.direct_map = vcpu->arch.mmu->direct_map;\n\tarch.cr3 = vcpu->arch.mmu->get_guest_pgd(vcpu);\n\n\treturn kvm_setup_async_pf(vcpu, cr2_or_gpa,\n\t\t\t\t  kvm_vcpu_gfn_to_hva(vcpu, gfn), &arch);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int kvm_arch_setup_async_pf(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t\t   gfn_t gfn)\n{\n\tstruct kvm_arch_async_pf arch;\n\n\tarch.token = (vcpu->arch.apf.id++ << 12) | vcpu->vcpu_id;\n\tarch.gfn = gfn;\n\tarch.direct_map = vcpu->arch.mmu->direct_map;\n\tarch.cr3 = vcpu->arch.mmu->get_guest_pgd(vcpu);\n\n\treturn kvm_setup_async_pf(vcpu, cr2_or_gpa,\n\t\t\t\t  kvm_vcpu_gfn_to_hva(vcpu, gfn), &arch);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_APF_HALT",
            "vcpu"
          ],
          "line": 4107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_async_pf_doublefault",
          "args": [
            "cr2_or_gpa",
            "gfn"
          ],
          "line": 4106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_find_async_pf_gfn",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 4105
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_find_async_pf_gfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10299-10302",
          "snippet": "bool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_find_async_pf_gfn(struct kvm_vcpu *vcpu, gfn_t gfn)\n{\n\treturn vcpu->arch.apf.gfns[kvm_async_pf_gfn_slot(vcpu, gfn)] == gfn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_try_async_get_page",
          "args": [
            "cr2_or_gpa",
            "gfn"
          ],
          "line": 4104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_can_do_async_pf",
          "args": [
            "vcpu"
          ],
          "line": 4103
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_can_do_async_pf",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10354-10369",
          "snippet": "bool kvm_can_do_async_pf(struct kvm_vcpu *vcpu)\n{\n\tif (unlikely(!lapic_in_kernel(vcpu) ||\n\t\t     kvm_event_needs_reinjection(vcpu) ||\n\t\t     vcpu->arch.exception.pending))\n\t\treturn false;\n\n\tif (kvm_hlt_in_guest(vcpu->kvm) && !kvm_can_deliver_async_pf(vcpu))\n\t\treturn false;\n\n\t/*\n\t * If interrupts are off we cannot even use an artificial\n\t * halt state.\n\t */\n\treturn kvm_x86_ops.interrupt_allowed(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_can_do_async_pf(struct kvm_vcpu *vcpu)\n{\n\tif (unlikely(!lapic_in_kernel(vcpu) ||\n\t\t     kvm_event_needs_reinjection(vcpu) ||\n\t\t     vcpu->arch.exception.pending))\n\t\treturn false;\n\n\tif (kvm_hlt_in_guest(vcpu->kvm) && !kvm_can_deliver_async_pf(vcpu))\n\t\treturn false;\n\n\t/*\n\t * If interrupts are off we cannot even use an artificial\n\t * halt state.\n\t */\n\treturn kvm_x86_ops.interrupt_allowed(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_pfn_memslot",
          "args": [
            "slot",
            "gfn",
            "false",
            "&async",
            "write",
            "writable"
          ],
          "line": 4099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_memslot",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 4097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_visible_gfn",
          "args": [
            "vcpu->kvm",
            "gfn"
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool try_async_pf(struct kvm_vcpu *vcpu, bool prefault, gfn_t gfn,\n\t\t\t gpa_t cr2_or_gpa, kvm_pfn_t *pfn, bool write,\n\t\t\t bool *writable)\n{\n\tstruct kvm_memory_slot *slot;\n\tbool async;\n\n\t/*\n\t * Don't expose private memslots to L2.\n\t */\n\tif (is_guest_mode(vcpu) && !kvm_is_visible_gfn(vcpu->kvm, gfn)) {\n\t\t*pfn = KVM_PFN_NOSLOT;\n\t\treturn false;\n\t}\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tasync = false;\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, &async, write, writable);\n\tif (!async)\n\t\treturn false; /* *pfn has correct page already */\n\n\tif (!prefault && kvm_can_do_async_pf(vcpu)) {\n\t\ttrace_kvm_try_async_get_page(cr2_or_gpa, gfn);\n\t\tif (kvm_find_async_pf_gfn(vcpu, gfn)) {\n\t\t\ttrace_kvm_async_pf_doublefault(cr2_or_gpa, gfn);\n\t\t\tkvm_make_request(KVM_REQ_APF_HALT, vcpu);\n\t\t\treturn true;\n\t\t} else if (kvm_arch_setup_async_pf(vcpu, cr2_or_gpa, gfn))\n\t\t\treturn true;\n\t}\n\n\t*pfn = __gfn_to_pfn_memslot(slot, gfn, false, NULL, write, writable);\n\treturn false;\n}"
  },
  {
    "function_name": "kvm_arch_setup_async_pf",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4068-4080",
    "snippet": "static int kvm_arch_setup_async_pf(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t\t   gfn_t gfn)\n{\n\tstruct kvm_arch_async_pf arch;\n\n\tarch.token = (vcpu->arch.apf.id++ << 12) | vcpu->vcpu_id;\n\tarch.gfn = gfn;\n\tarch.direct_map = vcpu->arch.mmu->direct_map;\n\tarch.cr3 = vcpu->arch.mmu->get_guest_pgd(vcpu);\n\n\treturn kvm_setup_async_pf(vcpu, cr2_or_gpa,\n\t\t\t\t  kvm_vcpu_gfn_to_hva(vcpu, gfn), &arch);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_setup_async_pf",
          "args": [
            "vcpu",
            "cr2_or_gpa",
            "kvm_vcpu_gfn_to_hva(vcpu, gfn)",
            "&arch"
          ],
          "line": 4078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_hva",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu->arch.mmu->get_guest_pgd",
          "args": [
            "vcpu"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int kvm_arch_setup_async_pf(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t\t   gfn_t gfn)\n{\n\tstruct kvm_arch_async_pf arch;\n\n\tarch.token = (vcpu->arch.apf.id++ << 12) | vcpu->vcpu_id;\n\tarch.gfn = gfn;\n\tarch.direct_map = vcpu->arch.mmu->direct_map;\n\tarch.cr3 = vcpu->arch.mmu->get_guest_pgd(vcpu);\n\n\treturn kvm_setup_async_pf(vcpu, cr2_or_gpa,\n\t\t\t\t  kvm_vcpu_gfn_to_hva(vcpu, gfn), &arch);\n}"
  },
  {
    "function_name": "shadow_page_table_clear_flood",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4054-4066",
    "snippet": "static void shadow_page_table_clear_flood(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 spte;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, addr, iterator, spte) {\n\t\tclear_sp_write_flooding_count(iterator.sptep);\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\t}\n\twalk_shadow_page_lockless_end(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_end",
          "args": [
            "vcpu"
          ],
          "line": 4065
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_end",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1051-1060",
          "snippet": "static void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_mmu_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_mmu_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "spte"
          ],
          "line": 4062
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_sp_write_flooding_count",
          "args": [
            "iterator.sptep"
          ],
          "line": 4061
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sp_write_flooding_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2469-2474",
          "snippet": "static void clear_sp_write_flooding_count(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(spte));\n\n\t__clear_sp_write_flooding_count(sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void clear_sp_write_flooding_count(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(spte));\n\n\t__clear_sp_write_flooding_count(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_shadow_entry_lockless",
          "args": [
            "vcpu",
            "addr",
            "iterator",
            "spte"
          ],
          "line": 4060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_begin",
          "args": [
            "vcpu"
          ],
          "line": 4059
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_begin",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1036-1049",
          "snippet": "static void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void shadow_page_table_clear_flood(struct kvm_vcpu *vcpu, gva_t addr)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 spte;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\tfor_each_shadow_entry_lockless(vcpu, addr, iterator, spte) {\n\t\tclear_sp_write_flooding_count(iterator.sptep);\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\t}\n\twalk_shadow_page_lockless_end(vcpu);\n}"
  },
  {
    "function_name": "page_fault_handle_page_track",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4034-4052",
    "snippet": "static bool page_fault_handle_page_track(struct kvm_vcpu *vcpu,\n\t\t\t\t\t u32 error_code, gfn_t gfn)\n{\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\t/*\n\t * guest is writing the page which is write tracked which can\n\t * not be fixed by page fault handler.\n\t */\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_page_track_is_active",
          "args": [
            "vcpu",
            "gfn",
            "KVM_PAGE_TRACK_WRITE"
          ],
          "line": 4048
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_is_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/page_track.c",
          "lines": "141-156",
          "snippet": "bool kvm_page_track_is_active(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t      enum kvm_page_track_mode mode)\n{\n\tstruct kvm_memory_slot *slot;\n\tint index;\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn false;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot)\n\t\treturn false;\n\n\tindex = gfn_to_index(gfn, slot->base_gfn, PT_PAGE_TABLE_LEVEL);\n\treturn !!READ_ONCE(slot->arch.gfn_track[mode][index]);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <linux/rculist.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <linux/rculist.h>\n#include <linux/kvm_host.h>\n\nbool kvm_page_track_is_active(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t      enum kvm_page_track_mode mode)\n{\n\tstruct kvm_memory_slot *slot;\n\tint index;\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn false;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot)\n\t\treturn false;\n\n\tindex = gfn_to_index(gfn, slot->base_gfn, PT_PAGE_TABLE_LEVEL);\n\treturn !!READ_ONCE(slot->arch.gfn_track[mode][index]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error_code & PFERR_RSVD_MASK"
          ],
          "line": 4037
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool page_fault_handle_page_track(struct kvm_vcpu *vcpu,\n\t\t\t\t\t u32 error_code, gfn_t gfn)\n{\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\tif (!(error_code & PFERR_PRESENT_MASK) ||\n\t      !(error_code & PFERR_WRITE_MASK))\n\t\treturn false;\n\n\t/*\n\t * guest is writing the page which is write tracked which can\n\t * not be fixed by page fault handler.\n\t */\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "handle_mmio_page_fault",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "4000-4032",
    "snippet": "static int handle_mmio_page_fault(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tu64 spte;\n\tbool reserved;\n\n\tif (mmio_info_in_cache(vcpu, addr, direct))\n\t\treturn RET_PF_EMULATE;\n\n\treserved = walk_shadow_page_get_mmio_spte(vcpu, addr, &spte);\n\tif (WARN_ON(reserved))\n\t\treturn -EINVAL;\n\n\tif (is_mmio_spte(spte)) {\n\t\tgfn_t gfn = get_mmio_spte_gfn(spte);\n\t\tunsigned int access = get_mmio_spte_access(spte);\n\n\t\tif (!check_mmio_spte(vcpu, spte))\n\t\t\treturn RET_PF_INVALID;\n\n\t\tif (direct)\n\t\t\taddr = 0;\n\n\t\ttrace_handle_mmio_page_fault(addr, gfn, access);\n\t\tvcpu_cache_mmio_info(vcpu, addr, gfn, access);\n\t\treturn RET_PF_EMULATE;\n\t}\n\n\t/*\n\t * If the page table is zapped by other cpus, let CPU fault again on\n\t * the address.\n\t */\n\treturn RET_PF_RETRY;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_cache_mmio_info",
          "args": [
            "vcpu",
            "addr",
            "gfn",
            "access"
          ],
          "line": 4023
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_cache_mmio_info",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "163-179",
          "snippet": "static inline void vcpu_cache_mmio_info(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgva_t gva, gfn_t gfn, unsigned access)\n{\n\tu64 gen = kvm_memslots(vcpu->kvm)->generation;\n\n\tif (unlikely(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS))\n\t\treturn;\n\n\t/*\n\t * If this is a shadow nested page table, the \"GVA\" is\n\t * actually a nGPA.\n\t */\n\tvcpu->arch.mmio_gva = mmu_is_nested(vcpu) ? 0 : gva & PAGE_MASK;\n\tvcpu->arch.mmio_access = access;\n\tvcpu->arch.mmio_gfn = gfn;\n\tvcpu->arch.mmio_gen = gen;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void vcpu_cache_mmio_info(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgva_t gva, gfn_t gfn, unsigned access)\n{\n\tu64 gen = kvm_memslots(vcpu->kvm)->generation;\n\n\tif (unlikely(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS))\n\t\treturn;\n\n\t/*\n\t * If this is a shadow nested page table, the \"GVA\" is\n\t * actually a nGPA.\n\t */\n\tvcpu->arch.mmio_gva = mmu_is_nested(vcpu) ? 0 : gva & PAGE_MASK;\n\tvcpu->arch.mmio_access = access;\n\tvcpu->arch.mmio_gfn = gfn;\n\tvcpu->arch.mmio_gen = gen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_handle_mmio_page_fault",
          "args": [
            "addr",
            "gfn",
            "access"
          ],
          "line": 4022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_mmio_spte",
          "args": [
            "vcpu",
            "spte"
          ],
          "line": 4016
        },
        "resolved": true,
        "details": {
          "function_name": "check_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "500-513",
          "snippet": "static bool check_mmio_spte(struct kvm_vcpu *vcpu, u64 spte)\n{\n\tu64 kvm_gen, spte_gen, gen;\n\n\tgen = kvm_vcpu_memslots(vcpu)->generation;\n\tif (unlikely(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS))\n\t\treturn false;\n\n\tkvm_gen = gen & MMIO_SPTE_GEN_MASK;\n\tspte_gen = get_mmio_spte_generation(spte);\n\n\ttrace_check_mmio_spte(spte, kvm_gen, spte_gen);\n\treturn likely(kvm_gen == spte_gen);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool check_mmio_spte(struct kvm_vcpu *vcpu, u64 spte)\n{\n\tu64 kvm_gen, spte_gen, gen;\n\n\tgen = kvm_vcpu_memslots(vcpu)->generation;\n\tif (unlikely(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS))\n\t\treturn false;\n\n\tkvm_gen = gen & MMIO_SPTE_GEN_MASK;\n\tspte_gen = get_mmio_spte_generation(spte);\n\n\ttrace_check_mmio_spte(spte, kvm_gen, spte_gen);\n\treturn likely(kvm_gen == spte_gen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mmio_spte_access",
          "args": [
            "spte"
          ],
          "line": 4014
        },
        "resolved": true,
        "details": {
          "function_name": "get_mmio_spte_access",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "484-487",
          "snippet": "static unsigned get_mmio_spte_access(u64 spte)\n{\n\treturn spte & shadow_mmio_access_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic unsigned get_mmio_spte_access(u64 spte)\n{\n\treturn spte & shadow_mmio_access_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_mmio_spte_gfn",
          "args": [
            "spte"
          ],
          "line": 4013
        },
        "resolved": true,
        "details": {
          "function_name": "get_mmio_spte_gfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "474-482",
          "snippet": "static gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 gpa = spte & shadow_nonpresent_or_rsvd_lower_gfn_mask;\n\n\tgpa |= (spte >> shadow_nonpresent_or_rsvd_mask_len)\n\t       & shadow_nonpresent_or_rsvd_mask;\n\n\treturn gpa >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u64 shadow_nonpresent_or_rsvd_mask_len = 5;",
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic const u64 shadow_nonpresent_or_rsvd_mask_len = 5;\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 gpa = spte & shadow_nonpresent_or_rsvd_lower_gfn_mask;\n\n\tgpa |= (spte >> shadow_nonpresent_or_rsvd_mask_len)\n\t       & shadow_nonpresent_or_rsvd_mask;\n\n\treturn gpa >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "spte"
          ],
          "line": 4012
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "344-347",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "reserved"
          ],
          "line": 4009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_shadow_page_get_mmio_spte",
          "args": [
            "vcpu",
            "addr",
            "&spte"
          ],
          "line": 4008
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_get_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3950-3998",
          "snippet": "static bool\nwalk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr, u64 *sptep)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 sptes[PT64_ROOT_MAX_LEVEL], spte = 0ull;\n\tstruct rsvd_bits_validate *rsvd_check;\n\tint root, leaf;\n\tbool reserved = false;\n\n\trsvd_check = &vcpu->arch.mmu->shadow_zero_check;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tfor (shadow_walk_init(&iterator, vcpu, addr),\n\t\t leaf = root = iterator.level;\n\t     shadow_walk_okay(&iterator);\n\t     __shadow_walk_next(&iterator, spte)) {\n\t\tspte = mmu_spte_get_lockless(iterator.sptep);\n\n\t\tsptes[leaf - 1] = spte;\n\t\tleaf--;\n\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Use a bitwise-OR instead of a logical-OR to aggregate the\n\t\t * reserved bit and EPT's invalid memtype/XWR checks to avoid\n\t\t * adding a Jcc in the loop.\n\t\t */\n\t\treserved |= __is_bad_mt_xwr(rsvd_check, spte) |\n\t\t\t    __is_rsvd_bits_set(rsvd_check, spte, iterator.level);\n\t}\n\n\twalk_shadow_page_lockless_end(vcpu);\n\n\tif (reserved) {\n\t\tpr_err(\"%s: detect reserved bits on spte, addr 0x%llx, dump hierarchy:\\n\",\n\t\t       __func__, addr);\n\t\twhile (root > leaf) {\n\t\t\tpr_err(\"------ spte 0x%llx level %d.\\n\",\n\t\t\t       sptes[root - 1], root);\n\t\t\troot--;\n\t\t}\n\t}\n\n\t*sptep = spte;\n\treturn reserved;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool\nwalk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr, u64 *sptep)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 sptes[PT64_ROOT_MAX_LEVEL], spte = 0ull;\n\tstruct rsvd_bits_validate *rsvd_check;\n\tint root, leaf;\n\tbool reserved = false;\n\n\trsvd_check = &vcpu->arch.mmu->shadow_zero_check;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tfor (shadow_walk_init(&iterator, vcpu, addr),\n\t\t leaf = root = iterator.level;\n\t     shadow_walk_okay(&iterator);\n\t     __shadow_walk_next(&iterator, spte)) {\n\t\tspte = mmu_spte_get_lockless(iterator.sptep);\n\n\t\tsptes[leaf - 1] = spte;\n\t\tleaf--;\n\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Use a bitwise-OR instead of a logical-OR to aggregate the\n\t\t * reserved bit and EPT's invalid memtype/XWR checks to avoid\n\t\t * adding a Jcc in the loop.\n\t\t */\n\t\treserved |= __is_bad_mt_xwr(rsvd_check, spte) |\n\t\t\t    __is_rsvd_bits_set(rsvd_check, spte, iterator.level);\n\t}\n\n\twalk_shadow_page_lockless_end(vcpu);\n\n\tif (reserved) {\n\t\tpr_err(\"%s: detect reserved bits on spte, addr 0x%llx, dump hierarchy:\\n\",\n\t\t       __func__, addr);\n\t\twhile (root > leaf) {\n\t\t\tpr_err(\"------ spte 0x%llx level %d.\\n\",\n\t\t\t       sptes[root - 1], root);\n\t\t\troot--;\n\t\t}\n\t}\n\n\t*sptep = spte;\n\treturn reserved;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmio_info_in_cache",
          "args": [
            "vcpu",
            "addr",
            "direct"
          ],
          "line": 4005
        },
        "resolved": true,
        "details": {
          "function_name": "mmio_info_in_cache",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3934-3947",
          "snippet": "static bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\t/*\n\t * A nested guest cannot use the MMIO cache if it is using nested\n\t * page tables, because cr2 is a nGPA while the cache stores GPAs.\n\t */\n\tif (mmu_is_nested(vcpu))\n\t\treturn false;\n\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\t/*\n\t * A nested guest cannot use the MMIO cache if it is using nested\n\t * page tables, because cr2 is a nGPA while the cache stores GPAs.\n\t */\n\tif (mmu_is_nested(vcpu))\n\t\treturn false;\n\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int handle_mmio_page_fault(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\tu64 spte;\n\tbool reserved;\n\n\tif (mmio_info_in_cache(vcpu, addr, direct))\n\t\treturn RET_PF_EMULATE;\n\n\treserved = walk_shadow_page_get_mmio_spte(vcpu, addr, &spte);\n\tif (WARN_ON(reserved))\n\t\treturn -EINVAL;\n\n\tif (is_mmio_spte(spte)) {\n\t\tgfn_t gfn = get_mmio_spte_gfn(spte);\n\t\tunsigned int access = get_mmio_spte_access(spte);\n\n\t\tif (!check_mmio_spte(vcpu, spte))\n\t\t\treturn RET_PF_INVALID;\n\n\t\tif (direct)\n\t\t\taddr = 0;\n\n\t\ttrace_handle_mmio_page_fault(addr, gfn, access);\n\t\tvcpu_cache_mmio_info(vcpu, addr, gfn, access);\n\t\treturn RET_PF_EMULATE;\n\t}\n\n\t/*\n\t * If the page table is zapped by other cpus, let CPU fault again on\n\t * the address.\n\t */\n\treturn RET_PF_RETRY;\n}"
  },
  {
    "function_name": "walk_shadow_page_get_mmio_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3950-3998",
    "snippet": "static bool\nwalk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr, u64 *sptep)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 sptes[PT64_ROOT_MAX_LEVEL], spte = 0ull;\n\tstruct rsvd_bits_validate *rsvd_check;\n\tint root, leaf;\n\tbool reserved = false;\n\n\trsvd_check = &vcpu->arch.mmu->shadow_zero_check;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tfor (shadow_walk_init(&iterator, vcpu, addr),\n\t\t leaf = root = iterator.level;\n\t     shadow_walk_okay(&iterator);\n\t     __shadow_walk_next(&iterator, spte)) {\n\t\tspte = mmu_spte_get_lockless(iterator.sptep);\n\n\t\tsptes[leaf - 1] = spte;\n\t\tleaf--;\n\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Use a bitwise-OR instead of a logical-OR to aggregate the\n\t\t * reserved bit and EPT's invalid memtype/XWR checks to avoid\n\t\t * adding a Jcc in the loop.\n\t\t */\n\t\treserved |= __is_bad_mt_xwr(rsvd_check, spte) |\n\t\t\t    __is_rsvd_bits_set(rsvd_check, spte, iterator.level);\n\t}\n\n\twalk_shadow_page_lockless_end(vcpu);\n\n\tif (reserved) {\n\t\tpr_err(\"%s: detect reserved bits on spte, addr 0x%llx, dump hierarchy:\\n\",\n\t\t       __func__, addr);\n\t\twhile (root > leaf) {\n\t\t\tpr_err(\"------ spte 0x%llx level %d.\\n\",\n\t\t\t       sptes[root - 1], root);\n\t\t\troot--;\n\t\t}\n\t}\n\n\t*sptep = spte;\n\treturn reserved;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"------ spte 0x%llx level %d.\\n\"",
            "sptes[root - 1]",
            "root"
          ],
          "line": 3990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: detect reserved bits on spte, addr 0x%llx, dump hierarchy:\\n\"",
            "__func__",
            "addr"
          ],
          "line": 3987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_end",
          "args": [
            "vcpu"
          ],
          "line": 3984
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_end",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1051-1060",
          "snippet": "static void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_mmu_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_mmu_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__is_rsvd_bits_set",
          "args": [
            "rsvd_check",
            "spte",
            "iterator.level"
          ],
          "line": 3981
        },
        "resolved": true,
        "details": {
          "function_name": "__is_rsvd_bits_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3921-3927",
          "snippet": "static bool\n__is_rsvd_bits_set(struct rsvd_bits_validate *rsvd_check, u64 pte, int level)\n{\n\tint bit7 = (pte >> 7) & 1;\n\n\treturn pte & rsvd_check->rsvd_bits_mask[bit7][level-1];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\n__is_rsvd_bits_set(struct rsvd_bits_validate *rsvd_check, u64 pte, int level)\n{\n\tint bit7 = (pte >> 7) & 1;\n\n\treturn pte & rsvd_check->rsvd_bits_mask[bit7][level-1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__is_bad_mt_xwr",
          "args": [
            "rsvd_check",
            "spte"
          ],
          "line": 3980
        },
        "resolved": true,
        "details": {
          "function_name": "__is_bad_mt_xwr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3929-3932",
          "snippet": "static bool __is_bad_mt_xwr(struct rsvd_bits_validate *rsvd_check, u64 pte)\n{\n\treturn rsvd_check->bad_mt_xwr & BIT_ULL(pte & 0x3f);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __is_bad_mt_xwr(struct rsvd_bits_validate *rsvd_check, u64 pte)\n{\n\treturn rsvd_check->bad_mt_xwr & BIT_ULL(pte & 0x3f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "spte"
          ],
          "line": 3972
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_get_lockless",
          "args": [
            "iterator.sptep"
          ],
          "line": 3967
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_get_lockless",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "959-962",
          "snippet": "static u64 mmu_spte_get_lockless(u64 *sptep)\n{\n\treturn __get_spte_lockless(sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 mmu_spte_get_lockless(u64 *sptep)\n{\n\treturn __get_spte_lockless(sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__shadow_walk_next",
          "args": [
            "&iterator",
            "spte"
          ],
          "line": 3966
        },
        "resolved": true,
        "details": {
          "function_name": "__shadow_walk_next",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2612-2622",
          "snippet": "static void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shadow_walk_okay",
          "args": [
            "&iterator"
          ],
          "line": 3965
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_walk_okay",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2602-2610",
          "snippet": "static bool shadow_walk_okay(struct kvm_shadow_walk_iterator *iterator)\n{\n\tif (iterator->level < PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\titerator->index = SHADOW_PT_INDEX(iterator->addr, iterator->level);\n\titerator->sptep\t= ((u64 *)__va(iterator->shadow_addr)) + iterator->index;\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool shadow_walk_okay(struct kvm_shadow_walk_iterator *iterator)\n{\n\tif (iterator->level < PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\titerator->index = SHADOW_PT_INDEX(iterator->addr, iterator->level);\n\titerator->sptep\t= ((u64 *)__va(iterator->shadow_addr)) + iterator->index;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shadow_walk_init",
          "args": [
            "&iterator",
            "vcpu",
            "addr"
          ],
          "line": 3963
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_walk_init",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2595-2600",
          "snippet": "static void shadow_walk_init(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t     struct kvm_vcpu *vcpu, u64 addr)\n{\n\tshadow_walk_init_using_root(iterator, vcpu, vcpu->arch.mmu->root_hpa,\n\t\t\t\t    addr);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void shadow_walk_init(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t     struct kvm_vcpu *vcpu, u64 addr)\n{\n\tshadow_walk_init_using_root(iterator, vcpu, vcpu->arch.mmu->root_hpa,\n\t\t\t\t    addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_begin",
          "args": [
            "vcpu"
          ],
          "line": 3961
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_begin",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1036-1049",
          "snippet": "static void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool\nwalk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr, u64 *sptep)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tu64 sptes[PT64_ROOT_MAX_LEVEL], spte = 0ull;\n\tstruct rsvd_bits_validate *rsvd_check;\n\tint root, leaf;\n\tbool reserved = false;\n\n\trsvd_check = &vcpu->arch.mmu->shadow_zero_check;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tfor (shadow_walk_init(&iterator, vcpu, addr),\n\t\t leaf = root = iterator.level;\n\t     shadow_walk_okay(&iterator);\n\t     __shadow_walk_next(&iterator, spte)) {\n\t\tspte = mmu_spte_get_lockless(iterator.sptep);\n\n\t\tsptes[leaf - 1] = spte;\n\t\tleaf--;\n\n\t\tif (!is_shadow_present_pte(spte))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Use a bitwise-OR instead of a logical-OR to aggregate the\n\t\t * reserved bit and EPT's invalid memtype/XWR checks to avoid\n\t\t * adding a Jcc in the loop.\n\t\t */\n\t\treserved |= __is_bad_mt_xwr(rsvd_check, spte) |\n\t\t\t    __is_rsvd_bits_set(rsvd_check, spte, iterator.level);\n\t}\n\n\twalk_shadow_page_lockless_end(vcpu);\n\n\tif (reserved) {\n\t\tpr_err(\"%s: detect reserved bits on spte, addr 0x%llx, dump hierarchy:\\n\",\n\t\t       __func__, addr);\n\t\twhile (root > leaf) {\n\t\t\tpr_err(\"------ spte 0x%llx level %d.\\n\",\n\t\t\t       sptes[root - 1], root);\n\t\t\troot--;\n\t\t}\n\t}\n\n\t*sptep = spte;\n\treturn reserved;\n}"
  },
  {
    "function_name": "mmio_info_in_cache",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3934-3947",
    "snippet": "static bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\t/*\n\t * A nested guest cannot use the MMIO cache if it is using nested\n\t * page tables, because cr2 is a nGPA while the cache stores GPAs.\n\t */\n\tif (mmu_is_nested(vcpu))\n\t\treturn false;\n\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_match_mmio_gva",
          "args": [
            "vcpu",
            "addr"
          ],
          "line": 3946
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_match_mmio_gva",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "200-207",
          "snippet": "static inline bool vcpu_match_mmio_gva(struct kvm_vcpu *vcpu, unsigned long gva)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gva &&\n\t      vcpu->arch.mmio_gva == (gva & PAGE_MASK))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool vcpu_match_mmio_gva(struct kvm_vcpu *vcpu, unsigned long gva)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gva &&\n\t      vcpu->arch.mmio_gva == (gva & PAGE_MASK))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_match_mmio_gpa",
          "args": [
            "vcpu",
            "addr"
          ],
          "line": 3944
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_match_mmio_gpa",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "209-216",
          "snippet": "static inline bool vcpu_match_mmio_gpa(struct kvm_vcpu *vcpu, gpa_t gpa)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gfn &&\n\t      vcpu->arch.mmio_gfn == gpa >> PAGE_SHIFT)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool vcpu_match_mmio_gpa(struct kvm_vcpu *vcpu, gpa_t gpa)\n{\n\tif (vcpu_match_mmio_gen(vcpu) && vcpu->arch.mmio_gfn &&\n\t      vcpu->arch.mmio_gfn == gpa >> PAGE_SHIFT)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_is_nested",
          "args": [
            "vcpu"
          ],
          "line": 3940
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_is_nested",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "123-126",
          "snippet": "static inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool mmu_is_nested(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.walk_mmu == &vcpu->arch.nested_mmu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool mmio_info_in_cache(struct kvm_vcpu *vcpu, u64 addr, bool direct)\n{\n\t/*\n\t * A nested guest cannot use the MMIO cache if it is using nested\n\t * page tables, because cr2 is a nGPA while the cache stores GPAs.\n\t */\n\tif (mmu_is_nested(vcpu))\n\t\treturn false;\n\n\tif (direct)\n\t\treturn vcpu_match_mmio_gpa(vcpu, addr);\n\n\treturn vcpu_match_mmio_gva(vcpu, addr);\n}"
  },
  {
    "function_name": "__is_bad_mt_xwr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3929-3932",
    "snippet": "static bool __is_bad_mt_xwr(struct rsvd_bits_validate *rsvd_check, u64 pte)\n{\n\treturn rsvd_check->bad_mt_xwr & BIT_ULL(pte & 0x3f);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BIT_ULL",
          "args": [
            "pte & 0x3f"
          ],
          "line": 3931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __is_bad_mt_xwr(struct rsvd_bits_validate *rsvd_check, u64 pte)\n{\n\treturn rsvd_check->bad_mt_xwr & BIT_ULL(pte & 0x3f);\n}"
  },
  {
    "function_name": "__is_rsvd_bits_set",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3921-3927",
    "snippet": "static bool\n__is_rsvd_bits_set(struct rsvd_bits_validate *rsvd_check, u64 pte, int level)\n{\n\tint bit7 = (pte >> 7) & 1;\n\n\treturn pte & rsvd_check->rsvd_bits_mask[bit7][level-1];\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool\n__is_rsvd_bits_set(struct rsvd_bits_validate *rsvd_check, u64 pte, int level)\n{\n\tint bit7 = (pte >> 7) & 1;\n\n\treturn pte & rsvd_check->rsvd_bits_mask[bit7][level-1];\n}"
  },
  {
    "function_name": "nonpaging_gva_to_gpa_nested",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3912-3919",
    "snippet": "static gpa_t nonpaging_gva_to_gpa_nested(struct kvm_vcpu *vcpu, gpa_t vaddr,\n\t\t\t\t\t u32 access,\n\t\t\t\t\t struct x86_exception *exception)\n{\n\tif (exception)\n\t\texception->error_code = 0;\n\treturn vcpu->arch.nested_mmu.translate_gpa(vcpu, vaddr, access, exception);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu->arch.nested_mmu.translate_gpa",
          "args": [
            "vcpu",
            "vaddr",
            "access",
            "exception"
          ],
          "line": 3918
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic gpa_t nonpaging_gva_to_gpa_nested(struct kvm_vcpu *vcpu, gpa_t vaddr,\n\t\t\t\t\t u32 access,\n\t\t\t\t\t struct x86_exception *exception)\n{\n\tif (exception)\n\t\texception->error_code = 0;\n\treturn vcpu->arch.nested_mmu.translate_gpa(vcpu, vaddr, access, exception);\n}"
  },
  {
    "function_name": "nonpaging_gva_to_gpa",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3904-3910",
    "snippet": "static gpa_t nonpaging_gva_to_gpa(struct kvm_vcpu *vcpu, gpa_t vaddr,\n\t\t\t\t  u32 access, struct x86_exception *exception)\n{\n\tif (exception)\n\t\texception->error_code = 0;\n\treturn vaddr;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic gpa_t nonpaging_gva_to_gpa(struct kvm_vcpu *vcpu, gpa_t vaddr,\n\t\t\t\t  u32 access, struct x86_exception *exception)\n{\n\tif (exception)\n\t\texception->error_code = 0;\n\treturn vaddr;\n}"
  },
  {
    "function_name": "kvm_mmu_sync_roots",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3845-3901",
    "snippet": "void kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\treturn;\n\n\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\t\tsp = page_header(root);\n\n\t\t/*\n\t\t * Even if another CPU was marking the SP as unsync-ed\n\t\t * simultaneously, any guest page table changes are not\n\t\t * guaranteed to be visible anyway until this VCPU issues a TLB\n\t\t * flush strictly after those changes are made. We only need to\n\t\t * ensure that the other CPU sets these flags before any actual\n\t\t * changes to the page tables are made. The comments in\n\t\t * mmu_need_write_protect() describe what could go wrong if this\n\t\t * requirement isn't satisfied.\n\t\t */\n\t\tif (!smp_load_acquire(&sp->unsync) &&\n\t\t    !smp_load_acquire(&sp->unsync_children))\n\t\t\treturn;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\t\tmmu_sync_children(vcpu, sp);\n\n\t\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\tmmu_sync_children(vcpu, sp);\n\t\t}\n\t}\n\n\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
      "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_audit",
          "args": [
            "vcpu",
            "AUDIT_POST_SYNC"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_audit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2322-2322",
          "snippet": "static void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }"
        }
      },
      {
        "call_info": {
          "callee": "mmu_sync_children",
          "args": [
            "vcpu",
            "sp"
          ],
          "line": 3895
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_sync_children",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2429-2462",
          "snippet": "static void mmu_sync_children(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_mmu_page *parent)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\tLIST_HEAD(invalid_list);\n\tbool flush = false;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tbool protected = false;\n\n\t\tfor_each_sp(pages, sp, parents, i)\n\t\t\tprotected |= rmap_write_protect(vcpu, sp->gfn);\n\n\t\tif (protected) {\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t\tflush = false;\n\t\t}\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tflush |= kvm_sync_page(vcpu, sp, &invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t}\n\t\tif (need_resched() || spin_needbreak(&vcpu->kvm->mmu_lock)) {\n\t\t\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\t\t\tcond_resched_lock(&vcpu->kvm->mmu_lock);\n\t\t\tflush = false;\n\t\t}\n\t}\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void mmu_sync_children(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_mmu_page *parent)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\tLIST_HEAD(invalid_list);\n\tbool flush = false;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tbool protected = false;\n\n\t\tfor_each_sp(pages, sp, parents, i)\n\t\t\tprotected |= rmap_write_protect(vcpu, sp->gfn);\n\n\t\tif (protected) {\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t\tflush = false;\n\t\t}\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tflush |= kvm_sync_page(vcpu, sp, &invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t}\n\t\tif (need_resched() || spin_needbreak(&vcpu->kvm->mmu_lock)) {\n\t\t\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\t\t\tcond_resched_lock(&vcpu->kvm->mmu_lock);\n\t\t\tflush = false;\n\t\t}\n\t}\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root"
          ],
          "line": 3894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "root"
          ],
          "line": 3892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&sp->unsync_children"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_load_acquire",
          "args": [
            "&sp->unsync"
          ],
          "line": 3872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "root"
          ],
          "line": 3860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_clear_mmio_info",
          "args": [
            "vcpu",
            "MMIO_GVA_ANY"
          ],
          "line": 3856
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_clear_mmio_info",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "192-198",
          "snippet": "static inline void vcpu_clear_mmio_info(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tif (gva != MMIO_GVA_ANY && vcpu->arch.mmio_gva != (gva & PAGE_MASK))\n\t\treturn;\n\n\tvcpu->arch.mmio_gva = 0;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MMIO_GVA_ANY (~(gva_t)0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\n#define MMIO_GVA_ANY (~(gva_t)0)\n\nstatic inline void vcpu_clear_mmio_info(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tif (gva != MMIO_GVA_ANY && vcpu->arch.mmio_gva != (gva & PAGE_MASK))\n\t\treturn;\n\n\tvcpu->arch.mmio_gva = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu->root_hpa"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_sync_roots(struct kvm_vcpu *vcpu)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn;\n\n\tif (!VALID_PAGE(vcpu->arch.mmu->root_hpa))\n\t\treturn;\n\n\tvcpu_clear_mmio_info(vcpu, MMIO_GVA_ANY);\n\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\t\tsp = page_header(root);\n\n\t\t/*\n\t\t * Even if another CPU was marking the SP as unsync-ed\n\t\t * simultaneously, any guest page table changes are not\n\t\t * guaranteed to be visible anyway until this VCPU issues a TLB\n\t\t * flush strictly after those changes are made. We only need to\n\t\t * ensure that the other CPU sets these flags before any actual\n\t\t * changes to the page tables are made. The comments in\n\t\t * mmu_need_write_protect() describe what could go wrong if this\n\t\t * requirement isn't satisfied.\n\t\t */\n\t\tif (!smp_load_acquire(&sp->unsync) &&\n\t\t    !smp_load_acquire(&sp->unsync_children))\n\t\t\treturn;\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\t\tmmu_sync_children(vcpu, sp);\n\n\t\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\tkvm_mmu_audit(vcpu, AUDIT_PRE_SYNC);\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tif (root && VALID_PAGE(root)) {\n\t\t\troot &= PT64_BASE_ADDR_MASK;\n\t\t\tsp = page_header(root);\n\t\t\tmmu_sync_children(vcpu, sp);\n\t\t}\n\t}\n\n\tkvm_mmu_audit(vcpu, AUDIT_POST_SYNC);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
  },
  {
    "function_name": "mmu_alloc_roots",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3837-3843",
    "snippet": "static int mmu_alloc_roots(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn mmu_alloc_direct_roots(vcpu);\n\telse\n\t\treturn mmu_alloc_shadow_roots(vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_alloc_shadow_roots",
          "args": [
            "vcpu"
          ],
          "line": 3842
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_alloc_shadow_roots",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3732-3835",
          "snippet": "static int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tu64 pdptr, pm_mask;\n\tgfn_t root_gfn, root_cr3;\n\tint i;\n\n\troot_cr3 = vcpu->arch.mmu->get_guest_pgd(vcpu);\n\troot_gfn = root_cr3 >> PAGE_SHIFT;\n\n\tif (mmu_check_root(vcpu, root_gfn))\n\t\treturn 1;\n\n\t/*\n\t * Do we shadow a long mode page table? If so we need to\n\t * write-protect the guests page table root.\n\t */\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, 0,\n\t\t\t\tvcpu->arch.mmu->shadow_root_level, 0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu->root_hpa = root;\n\t\tgoto set_root_cr3;\n\t}\n\n\t/*\n\t * We shadow a 32 bit page table. This may be a legacy 2-level\n\t * or a PAE 3-level page table. In either case we need to be aware that\n\t * the shadow page table may be a PAE or a long mode page table.\n\t */\n\tpm_mask = PT_PRESENT_MASK;\n\tif (vcpu->arch.mmu->shadow_root_level == PT64_ROOT_4LEVEL)\n\t\tpm_mask |= PT_ACCESSED_MASK | PT_WRITABLE_MASK | PT_USER_MASK;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\tif (vcpu->arch.mmu->root_level == PT32E_ROOT_LEVEL) {\n\t\t\tpdptr = vcpu->arch.mmu->get_pdptr(vcpu, i);\n\t\t\tif (!(pdptr & PT_PRESENT_MASK)) {\n\t\t\t\tvcpu->arch.mmu->pae_root[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\troot_gfn = pdptr >> PAGE_SHIFT;\n\t\t\tif (mmu_check_root(vcpu, root_gfn))\n\t\t\t\treturn 1;\n\t\t}\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, i << 30, PT32_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tvcpu->arch.mmu->pae_root[i] = root | pm_mask;\n\t}\n\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->pae_root);\n\n\t/*\n\t * If we shadow a 32 bit page table with a long mode page\n\t * table we enter this path.\n\t */\n\tif (vcpu->arch.mmu->shadow_root_level == PT64_ROOT_4LEVEL) {\n\t\tif (vcpu->arch.mmu->lm_root == NULL) {\n\t\t\t/*\n\t\t\t * The additional page necessary for this is only\n\t\t\t * allocated on demand.\n\t\t\t */\n\n\t\t\tu64 *lm_root;\n\n\t\t\tlm_root = (void*)get_zeroed_page(GFP_KERNEL_ACCOUNT);\n\t\t\tif (lm_root == NULL)\n\t\t\t\treturn 1;\n\n\t\t\tlm_root[0] = __pa(vcpu->arch.mmu->pae_root) | pm_mask;\n\n\t\t\tvcpu->arch.mmu->lm_root = lm_root;\n\t\t}\n\n\t\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->lm_root);\n\t}\n\nset_root_cr3:\n\tvcpu->arch.mmu->root_cr3 = root_cr3;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tu64 pdptr, pm_mask;\n\tgfn_t root_gfn, root_cr3;\n\tint i;\n\n\troot_cr3 = vcpu->arch.mmu->get_guest_pgd(vcpu);\n\troot_gfn = root_cr3 >> PAGE_SHIFT;\n\n\tif (mmu_check_root(vcpu, root_gfn))\n\t\treturn 1;\n\n\t/*\n\t * Do we shadow a long mode page table? If so we need to\n\t * write-protect the guests page table root.\n\t */\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, 0,\n\t\t\t\tvcpu->arch.mmu->shadow_root_level, 0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu->root_hpa = root;\n\t\tgoto set_root_cr3;\n\t}\n\n\t/*\n\t * We shadow a 32 bit page table. This may be a legacy 2-level\n\t * or a PAE 3-level page table. In either case we need to be aware that\n\t * the shadow page table may be a PAE or a long mode page table.\n\t */\n\tpm_mask = PT_PRESENT_MASK;\n\tif (vcpu->arch.mmu->shadow_root_level == PT64_ROOT_4LEVEL)\n\t\tpm_mask |= PT_ACCESSED_MASK | PT_WRITABLE_MASK | PT_USER_MASK;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\tif (vcpu->arch.mmu->root_level == PT32E_ROOT_LEVEL) {\n\t\t\tpdptr = vcpu->arch.mmu->get_pdptr(vcpu, i);\n\t\t\tif (!(pdptr & PT_PRESENT_MASK)) {\n\t\t\t\tvcpu->arch.mmu->pae_root[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\troot_gfn = pdptr >> PAGE_SHIFT;\n\t\t\tif (mmu_check_root(vcpu, root_gfn))\n\t\t\t\treturn 1;\n\t\t}\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, i << 30, PT32_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tvcpu->arch.mmu->pae_root[i] = root | pm_mask;\n\t}\n\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->pae_root);\n\n\t/*\n\t * If we shadow a 32 bit page table with a long mode page\n\t * table we enter this path.\n\t */\n\tif (vcpu->arch.mmu->shadow_root_level == PT64_ROOT_4LEVEL) {\n\t\tif (vcpu->arch.mmu->lm_root == NULL) {\n\t\t\t/*\n\t\t\t * The additional page necessary for this is only\n\t\t\t * allocated on demand.\n\t\t\t */\n\n\t\t\tu64 *lm_root;\n\n\t\t\tlm_root = (void*)get_zeroed_page(GFP_KERNEL_ACCOUNT);\n\t\t\tif (lm_root == NULL)\n\t\t\t\treturn 1;\n\n\t\t\tlm_root[0] = __pa(vcpu->arch.mmu->pae_root) | pm_mask;\n\n\t\t\tvcpu->arch.mmu->lm_root = lm_root;\n\t\t}\n\n\t\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->lm_root);\n\t}\n\nset_root_cr3:\n\tvcpu->arch.mmu->root_cr3 = root_cr3;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_alloc_direct_roots",
          "args": [
            "vcpu"
          ],
          "line": 3840
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_alloc_direct_roots",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3689-3730",
          "snippet": "static int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned i;\n\n\tif (vcpu->arch.mmu->shadow_root_level >= PT64_ROOT_4LEVEL) {\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif(make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, 0, 0,\n\t\t\t\tvcpu->arch.mmu->shadow_root_level, 1, ACC_ALL);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu->root_hpa = __pa(sp->spt);\n\t} else if (vcpu->arch.mmu->shadow_root_level == PT32E_ROOT_LEVEL) {\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\t\t\tsp = kvm_mmu_get_page(vcpu, i << (30 - PAGE_SHIFT),\n\t\t\t\t\ti << 30, PT32_ROOT_LEVEL, 1, ACC_ALL);\n\t\t\troot = __pa(sp->spt);\n\t\t\t++sp->root_count;\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\tvcpu->arch.mmu->pae_root[i] = root | PT_PRESENT_MASK;\n\t\t}\n\t\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->pae_root);\n\t} else\n\t\tBUG();\n\n\t/* root_cr3 is ignored for direct MMUs. */\n\tvcpu->arch.mmu->root_cr3 = 0;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned i;\n\n\tif (vcpu->arch.mmu->shadow_root_level >= PT64_ROOT_4LEVEL) {\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif(make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, 0, 0,\n\t\t\t\tvcpu->arch.mmu->shadow_root_level, 1, ACC_ALL);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu->root_hpa = __pa(sp->spt);\n\t} else if (vcpu->arch.mmu->shadow_root_level == PT32E_ROOT_LEVEL) {\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\t\t\tsp = kvm_mmu_get_page(vcpu, i << (30 - PAGE_SHIFT),\n\t\t\t\t\ti << 30, PT32_ROOT_LEVEL, 1, ACC_ALL);\n\t\t\troot = __pa(sp->spt);\n\t\t\t++sp->root_count;\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\tvcpu->arch.mmu->pae_root[i] = root | PT_PRESENT_MASK;\n\t\t}\n\t\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->pae_root);\n\t} else\n\t\tBUG();\n\n\t/* root_cr3 is ignored for direct MMUs. */\n\tvcpu->arch.mmu->root_cr3 = 0;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_roots(struct kvm_vcpu *vcpu)\n{\n\tif (vcpu->arch.mmu->direct_map)\n\t\treturn mmu_alloc_direct_roots(vcpu);\n\telse\n\t\treturn mmu_alloc_shadow_roots(vcpu);\n}"
  },
  {
    "function_name": "mmu_alloc_shadow_roots",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3732-3835",
    "snippet": "static int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tu64 pdptr, pm_mask;\n\tgfn_t root_gfn, root_cr3;\n\tint i;\n\n\troot_cr3 = vcpu->arch.mmu->get_guest_pgd(vcpu);\n\troot_gfn = root_cr3 >> PAGE_SHIFT;\n\n\tif (mmu_check_root(vcpu, root_gfn))\n\t\treturn 1;\n\n\t/*\n\t * Do we shadow a long mode page table? If so we need to\n\t * write-protect the guests page table root.\n\t */\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, 0,\n\t\t\t\tvcpu->arch.mmu->shadow_root_level, 0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu->root_hpa = root;\n\t\tgoto set_root_cr3;\n\t}\n\n\t/*\n\t * We shadow a 32 bit page table. This may be a legacy 2-level\n\t * or a PAE 3-level page table. In either case we need to be aware that\n\t * the shadow page table may be a PAE or a long mode page table.\n\t */\n\tpm_mask = PT_PRESENT_MASK;\n\tif (vcpu->arch.mmu->shadow_root_level == PT64_ROOT_4LEVEL)\n\t\tpm_mask |= PT_ACCESSED_MASK | PT_WRITABLE_MASK | PT_USER_MASK;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\tif (vcpu->arch.mmu->root_level == PT32E_ROOT_LEVEL) {\n\t\t\tpdptr = vcpu->arch.mmu->get_pdptr(vcpu, i);\n\t\t\tif (!(pdptr & PT_PRESENT_MASK)) {\n\t\t\t\tvcpu->arch.mmu->pae_root[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\troot_gfn = pdptr >> PAGE_SHIFT;\n\t\t\tif (mmu_check_root(vcpu, root_gfn))\n\t\t\t\treturn 1;\n\t\t}\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, i << 30, PT32_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tvcpu->arch.mmu->pae_root[i] = root | pm_mask;\n\t}\n\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->pae_root);\n\n\t/*\n\t * If we shadow a 32 bit page table with a long mode page\n\t * table we enter this path.\n\t */\n\tif (vcpu->arch.mmu->shadow_root_level == PT64_ROOT_4LEVEL) {\n\t\tif (vcpu->arch.mmu->lm_root == NULL) {\n\t\t\t/*\n\t\t\t * The additional page necessary for this is only\n\t\t\t * allocated on demand.\n\t\t\t */\n\n\t\t\tu64 *lm_root;\n\n\t\t\tlm_root = (void*)get_zeroed_page(GFP_KERNEL_ACCOUNT);\n\t\t\tif (lm_root == NULL)\n\t\t\t\treturn 1;\n\n\t\t\tlm_root[0] = __pa(vcpu->arch.mmu->pae_root) | pm_mask;\n\n\t\t\tvcpu->arch.mmu->lm_root = lm_root;\n\t\t}\n\n\t\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->lm_root);\n\t}\n\nset_root_cr3:\n\tvcpu->arch.mmu->root_cr3 = root_cr3;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vcpu->arch.mmu->lm_root"
          ],
          "line": 3828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vcpu->arch.mmu->pae_root"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_zeroed_page",
          "args": [
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vcpu->arch.mmu->pae_root"
          ],
          "line": 3804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sp->spt"
          ],
          "line": 3798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_get_page",
          "args": [
            "vcpu",
            "root_gfn",
            "i << 30",
            "PT32_ROOT_LEVEL",
            "0",
            "ACC_ALL"
          ],
          "line": 3796
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_get_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2476-2564",
          "snippet": "static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned int access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tint collisions = 0;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu->mmu_role.base;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.gpte_is_8_bytes = true;\n\trole.access = access;\n\tif (!vcpu->arch.mmu->direct_map\n\t    && vcpu->arch.mmu->root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (sp->gfn != gfn) {\n\t\t\tcollisions++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\tgoto out;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn, 1);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\nout:\n\tif (collisions > vcpu->kvm->stat.max_mmu_page_hash_collisions)\n\t\tvcpu->kvm->stat.max_mmu_page_hash_collisions = collisions;\n\treturn sp;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned int access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tint collisions = 0;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu->mmu_role.base;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.gpte_is_8_bytes = true;\n\trole.access = access;\n\tif (!vcpu->arch.mmu->direct_map\n\t    && vcpu->arch.mmu->root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (sp->gfn != gfn) {\n\t\t\tcollisions++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\tgoto out;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn, 1);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\nout:\n\tif (collisions > vcpu->kvm->stat.max_mmu_page_hash_collisions)\n\t\tvcpu->kvm->stat.max_mmu_page_hash_collisions = collisions;\n\treturn sp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_mmu_pages_available",
          "args": [
            "vcpu"
          ],
          "line": 3792
        },
        "resolved": true,
        "details": {
          "function_name": "make_mmu_pages_available",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2833-2851",
          "snippet": "static int make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn 0;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\n\tif (!kvm_mmu_available_pages(vcpu->kvm))\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn 0;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\n\tif (!kvm_mmu_available_pages(vcpu->kvm))\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_check_root",
          "args": [
            "vcpu",
            "root_gfn"
          ],
          "line": 3788
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_check_root",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3677-3687",
          "snippet": "static int mmu_check_root(struct kvm_vcpu *vcpu, gfn_t root_gfn)\n{\n\tint ret = 0;\n\n\tif (!kvm_is_visible_gfn(vcpu->kvm, root_gfn)) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_check_root(struct kvm_vcpu *vcpu, gfn_t root_gfn)\n{\n\tint ret = 0;\n\n\tif (!kvm_is_visible_gfn(vcpu->kvm, root_gfn)) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu->arch.mmu->get_pdptr",
          "args": [
            "vcpu",
            "i"
          ],
          "line": 3782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "VALID_PAGE(root)"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "root"
          ],
          "line": 3780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sp->spt"
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "VALID_PAGE(root)"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "root"
          ],
          "line": 3752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu->arch.mmu->get_guest_pgd",
          "args": [
            "vcpu"
          ],
          "line": 3739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_shadow_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tu64 pdptr, pm_mask;\n\tgfn_t root_gfn, root_cr3;\n\tint i;\n\n\troot_cr3 = vcpu->arch.mmu->get_guest_pgd(vcpu);\n\troot_gfn = root_cr3 >> PAGE_SHIFT;\n\n\tif (mmu_check_root(vcpu, root_gfn))\n\t\treturn 1;\n\n\t/*\n\t * Do we shadow a long mode page table? If so we need to\n\t * write-protect the guests page table root.\n\t */\n\tif (vcpu->arch.mmu->root_level >= PT64_ROOT_4LEVEL) {\n\t\thpa_t root = vcpu->arch.mmu->root_hpa;\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, 0,\n\t\t\t\tvcpu->arch.mmu->shadow_root_level, 0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu->root_hpa = root;\n\t\tgoto set_root_cr3;\n\t}\n\n\t/*\n\t * We shadow a 32 bit page table. This may be a legacy 2-level\n\t * or a PAE 3-level page table. In either case we need to be aware that\n\t * the shadow page table may be a PAE or a long mode page table.\n\t */\n\tpm_mask = PT_PRESENT_MASK;\n\tif (vcpu->arch.mmu->shadow_root_level == PT64_ROOT_4LEVEL)\n\t\tpm_mask |= PT_ACCESSED_MASK | PT_WRITABLE_MASK | PT_USER_MASK;\n\n\tfor (i = 0; i < 4; ++i) {\n\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\tif (vcpu->arch.mmu->root_level == PT32E_ROOT_LEVEL) {\n\t\t\tpdptr = vcpu->arch.mmu->get_pdptr(vcpu, i);\n\t\t\tif (!(pdptr & PT_PRESENT_MASK)) {\n\t\t\t\tvcpu->arch.mmu->pae_root[i] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\troot_gfn = pdptr >> PAGE_SHIFT;\n\t\t\tif (mmu_check_root(vcpu, root_gfn))\n\t\t\t\treturn 1;\n\t\t}\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, root_gfn, i << 30, PT32_ROOT_LEVEL,\n\t\t\t\t      0, ACC_ALL);\n\t\troot = __pa(sp->spt);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\n\t\tvcpu->arch.mmu->pae_root[i] = root | pm_mask;\n\t}\n\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->pae_root);\n\n\t/*\n\t * If we shadow a 32 bit page table with a long mode page\n\t * table we enter this path.\n\t */\n\tif (vcpu->arch.mmu->shadow_root_level == PT64_ROOT_4LEVEL) {\n\t\tif (vcpu->arch.mmu->lm_root == NULL) {\n\t\t\t/*\n\t\t\t * The additional page necessary for this is only\n\t\t\t * allocated on demand.\n\t\t\t */\n\n\t\t\tu64 *lm_root;\n\n\t\t\tlm_root = (void*)get_zeroed_page(GFP_KERNEL_ACCOUNT);\n\t\t\tif (lm_root == NULL)\n\t\t\t\treturn 1;\n\n\t\t\tlm_root[0] = __pa(vcpu->arch.mmu->pae_root) | pm_mask;\n\n\t\t\tvcpu->arch.mmu->lm_root = lm_root;\n\t\t}\n\n\t\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->lm_root);\n\t}\n\nset_root_cr3:\n\tvcpu->arch.mmu->root_cr3 = root_cr3;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mmu_alloc_direct_roots",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3689-3730",
    "snippet": "static int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned i;\n\n\tif (vcpu->arch.mmu->shadow_root_level >= PT64_ROOT_4LEVEL) {\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif(make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, 0, 0,\n\t\t\t\tvcpu->arch.mmu->shadow_root_level, 1, ACC_ALL);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu->root_hpa = __pa(sp->spt);\n\t} else if (vcpu->arch.mmu->shadow_root_level == PT32E_ROOT_LEVEL) {\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\t\t\tsp = kvm_mmu_get_page(vcpu, i << (30 - PAGE_SHIFT),\n\t\t\t\t\ti << 30, PT32_ROOT_LEVEL, 1, ACC_ALL);\n\t\t\troot = __pa(sp->spt);\n\t\t\t++sp->root_count;\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\tvcpu->arch.mmu->pae_root[i] = root | PT_PRESENT_MASK;\n\t\t}\n\t\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->pae_root);\n\t} else\n\t\tBUG();\n\n\t/* root_cr3 is ignored for direct MMUs. */\n\tvcpu->arch.mmu->root_cr3 = 0;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 3724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "vcpu->arch.mmu->pae_root"
          ],
          "line": 3722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sp->spt"
          ],
          "line": 3717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_get_page",
          "args": [
            "vcpu",
            "i << (30 - PAGE_SHIFT)",
            "i << 30",
            "PT32_ROOT_LEVEL",
            "1",
            "ACC_ALL"
          ],
          "line": 3715
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_get_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2476-2564",
          "snippet": "static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned int access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tint collisions = 0;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu->mmu_role.base;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.gpte_is_8_bytes = true;\n\trole.access = access;\n\tif (!vcpu->arch.mmu->direct_map\n\t    && vcpu->arch.mmu->root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (sp->gfn != gfn) {\n\t\t\tcollisions++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\tgoto out;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn, 1);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\nout:\n\tif (collisions > vcpu->kvm->stat.max_mmu_page_hash_collisions)\n\t\tvcpu->kvm->stat.max_mmu_page_hash_collisions = collisions;\n\treturn sp;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned int access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tint collisions = 0;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu->mmu_role.base;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.gpte_is_8_bytes = true;\n\trole.access = access;\n\tif (!vcpu->arch.mmu->direct_map\n\t    && vcpu->arch.mmu->root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (sp->gfn != gfn) {\n\t\t\tcollisions++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\tgoto out;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn, 1);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\nout:\n\tif (collisions > vcpu->kvm->stat.max_mmu_page_hash_collisions)\n\t\tvcpu->kvm->stat.max_mmu_page_hash_collisions = collisions;\n\treturn sp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3712
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_mmu_pages_available",
          "args": [
            "vcpu"
          ],
          "line": 3711
        },
        "resolved": true,
        "details": {
          "function_name": "make_mmu_pages_available",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2833-2851",
          "snippet": "static int make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn 0;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\n\tif (!kvm_mmu_available_pages(vcpu->kvm))\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn 0;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\n\tif (!kvm_mmu_available_pages(vcpu->kvm))\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "VALID_PAGE(root)"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "root"
          ],
          "line": 3709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sp->spt"
          ],
          "line": 3704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3695
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_alloc_direct_roots(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned i;\n\n\tif (vcpu->arch.mmu->shadow_root_level >= PT64_ROOT_4LEVEL) {\n\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\tif(make_mmu_pages_available(vcpu) < 0) {\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\treturn -ENOSPC;\n\t\t}\n\t\tsp = kvm_mmu_get_page(vcpu, 0, 0,\n\t\t\t\tvcpu->arch.mmu->shadow_root_level, 1, ACC_ALL);\n\t\t++sp->root_count;\n\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\tvcpu->arch.mmu->root_hpa = __pa(sp->spt);\n\t} else if (vcpu->arch.mmu->shadow_root_level == PT32E_ROOT_LEVEL) {\n\t\tfor (i = 0; i < 4; ++i) {\n\t\t\thpa_t root = vcpu->arch.mmu->pae_root[i];\n\n\t\t\tMMU_WARN_ON(VALID_PAGE(root));\n\t\t\tspin_lock(&vcpu->kvm->mmu_lock);\n\t\t\tif (make_mmu_pages_available(vcpu) < 0) {\n\t\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\t\treturn -ENOSPC;\n\t\t\t}\n\t\t\tsp = kvm_mmu_get_page(vcpu, i << (30 - PAGE_SHIFT),\n\t\t\t\t\ti << 30, PT32_ROOT_LEVEL, 1, ACC_ALL);\n\t\t\troot = __pa(sp->spt);\n\t\t\t++sp->root_count;\n\t\t\tspin_unlock(&vcpu->kvm->mmu_lock);\n\t\t\tvcpu->arch.mmu->pae_root[i] = root | PT_PRESENT_MASK;\n\t\t}\n\t\tvcpu->arch.mmu->root_hpa = __pa(vcpu->arch.mmu->pae_root);\n\t} else\n\t\tBUG();\n\n\t/* root_cr3 is ignored for direct MMUs. */\n\tvcpu->arch.mmu->root_cr3 = 0;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mmu_check_root",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3677-3687",
    "snippet": "static int mmu_check_root(struct kvm_vcpu *vcpu, gfn_t root_gfn)\n{\n\tint ret = 0;\n\n\tif (!kvm_is_visible_gfn(vcpu->kvm, root_gfn)) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TRIPLE_FAULT",
            "vcpu"
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_visible_gfn",
          "args": [
            "vcpu->kvm",
            "root_gfn"
          ],
          "line": 3681
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_check_root(struct kvm_vcpu *vcpu, gfn_t root_gfn)\n{\n\tint ret = 0;\n\n\tif (!kvm_is_visible_gfn(vcpu->kvm, root_gfn)) {\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t\tret = 1;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_mmu_free_roots",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3629-3674",
    "snippet": "void kvm_mmu_free_roots(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\tulong roots_to_free)\n{\n\tint i;\n\tLIST_HEAD(invalid_list);\n\tbool free_active_root = roots_to_free & KVM_MMU_ROOT_CURRENT;\n\n\tBUILD_BUG_ON(KVM_MMU_NUM_PREV_ROOTS >= BITS_PER_LONG);\n\n\t/* Before acquiring the MMU lock, see if we need to do any real work. */\n\tif (!(free_active_root && VALID_PAGE(mmu->root_hpa))) {\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tif ((roots_to_free & KVM_MMU_ROOT_PREVIOUS(i)) &&\n\t\t\t    VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\t\tbreak;\n\n\t\tif (i == KVM_MMU_NUM_PREV_ROOTS)\n\t\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (roots_to_free & KVM_MMU_ROOT_PREVIOUS(i))\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->prev_roots[i].hpa,\n\t\t\t\t\t   &invalid_list);\n\n\tif (free_active_root) {\n\t\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t\t    (mmu->root_level >= PT64_ROOT_4LEVEL || mmu->direct_map)) {\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->root_hpa,\n\t\t\t\t\t   &invalid_list);\n\t\t} else {\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tif (mmu->pae_root[i] != 0)\n\t\t\t\t\tmmu_free_root_page(vcpu->kvm,\n\t\t\t\t\t\t\t   &mmu->pae_root[i],\n\t\t\t\t\t\t\t   &invalid_list);\n\t\t\tmmu->root_hpa = INVALID_PAGE;\n\t\t}\n\t\tmmu->root_cr3 = 0;\n\t}\n\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "vcpu->kvm",
            "&invalid_list"
          ],
          "line": 3672
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2795-2818",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_free_root_page",
          "args": [
            "vcpu->kvm",
            "&mmu->pae_root[i]",
            "&invalid_list"
          ],
          "line": 3664
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_free_root_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3612-3626",
          "snippet": "static void mmu_free_root_page(struct kvm *kvm, hpa_t *root_hpa,\n\t\t\t       struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(*root_hpa))\n\t\treturn;\n\n\tsp = page_header(*root_hpa & PT64_BASE_ADDR_MASK);\n\t--sp->root_count;\n\tif (!sp->root_count && sp->role.invalid)\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\t*root_hpa = INVALID_PAGE;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void mmu_free_root_page(struct kvm *kvm, hpa_t *root_hpa,\n\t\t\t       struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(*root_hpa))\n\t\treturn;\n\n\tsp = page_header(*root_hpa & PT64_BASE_ADDR_MASK);\n\t--sp->root_count;\n\tif (!sp->root_count && sp->role.invalid)\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\t*root_hpa = INVALID_PAGE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_MMU_ROOT_PREVIOUS",
          "args": [
            "i"
          ],
          "line": 3652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 3649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "mmu->prev_roots[i].hpa"
          ],
          "line": 3642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_MMU_ROOT_PREVIOUS",
          "args": [
            "i"
          ],
          "line": 3641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "mmu->root_hpa"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "KVM_MMU_NUM_PREV_ROOTS >= BITS_PER_LONG"
          ],
          "line": 3636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 3633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nvoid kvm_mmu_free_roots(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\tulong roots_to_free)\n{\n\tint i;\n\tLIST_HEAD(invalid_list);\n\tbool free_active_root = roots_to_free & KVM_MMU_ROOT_CURRENT;\n\n\tBUILD_BUG_ON(KVM_MMU_NUM_PREV_ROOTS >= BITS_PER_LONG);\n\n\t/* Before acquiring the MMU lock, see if we need to do any real work. */\n\tif (!(free_active_root && VALID_PAGE(mmu->root_hpa))) {\n\t\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\t\tif ((roots_to_free & KVM_MMU_ROOT_PREVIOUS(i)) &&\n\t\t\t    VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\t\tbreak;\n\n\t\tif (i == KVM_MMU_NUM_PREV_ROOTS)\n\t\t\treturn;\n\t}\n\n\tspin_lock(&vcpu->kvm->mmu_lock);\n\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (roots_to_free & KVM_MMU_ROOT_PREVIOUS(i))\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->prev_roots[i].hpa,\n\t\t\t\t\t   &invalid_list);\n\n\tif (free_active_root) {\n\t\tif (mmu->shadow_root_level >= PT64_ROOT_4LEVEL &&\n\t\t    (mmu->root_level >= PT64_ROOT_4LEVEL || mmu->direct_map)) {\n\t\t\tmmu_free_root_page(vcpu->kvm, &mmu->root_hpa,\n\t\t\t\t\t   &invalid_list);\n\t\t} else {\n\t\t\tfor (i = 0; i < 4; ++i)\n\t\t\t\tif (mmu->pae_root[i] != 0)\n\t\t\t\t\tmmu_free_root_page(vcpu->kvm,\n\t\t\t\t\t\t\t   &mmu->pae_root[i],\n\t\t\t\t\t\t\t   &invalid_list);\n\t\t\tmmu->root_hpa = INVALID_PAGE;\n\t\t}\n\t\tmmu->root_cr3 = 0;\n\t}\n\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\tspin_unlock(&vcpu->kvm->mmu_lock);\n}"
  },
  {
    "function_name": "mmu_free_root_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3612-3626",
    "snippet": "static void mmu_free_root_page(struct kvm *kvm, hpa_t *root_hpa,\n\t\t\t       struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(*root_hpa))\n\t\treturn;\n\n\tsp = page_header(*root_hpa & PT64_BASE_ADDR_MASK);\n\t--sp->root_count;\n\tif (!sp->root_count && sp->role.invalid)\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\t*root_hpa = INVALID_PAGE;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
      "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "invalid_list"
          ],
          "line": 3623
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2786-2793",
          "snippet": "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "*root_hpa & PT64_BASE_ADDR_MASK"
          ],
          "line": 3620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "*root_hpa"
          ],
          "line": 3617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void mmu_free_root_page(struct kvm *kvm, hpa_t *root_hpa,\n\t\t\t       struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (!VALID_PAGE(*root_hpa))\n\t\treturn;\n\n\tsp = page_header(*root_hpa & PT64_BASE_ADDR_MASK);\n\t--sp->root_count;\n\tif (!sp->root_count && sp->role.invalid)\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\n\t*root_hpa = INVALID_PAGE;\n}"
  },
  {
    "function_name": "fast_page_fault",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3512-3610",
    "snippet": "static bool fast_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t    u32 error_code)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tbool fault_handled = false;\n\tu64 spte = 0ull;\n\tuint retry_count = 0;\n\n\tif (!page_fault_can_be_fast(error_code))\n\t\treturn false;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tdo {\n\t\tu64 new_spte;\n\n\t\tfor_each_shadow_entry_lockless(vcpu, cr2_or_gpa, iterator, spte)\n\t\t\tif (!is_shadow_present_pte(spte))\n\t\t\t\tbreak;\n\n\t\tsp = page_header(__pa(iterator.sptep));\n\t\tif (!is_last_spte(spte, sp->role.level))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check whether the memory access that caused the fault would\n\t\t * still cause it if it were to be performed right now. If not,\n\t\t * then this is a spurious fault caused by TLB lazily flushed,\n\t\t * or some other CPU has already fixed the PTE after the\n\t\t * current CPU took the fault.\n\t\t *\n\t\t * Need not check the access of upper level table entries since\n\t\t * they are always ACC_ALL.\n\t\t */\n\t\tif (is_access_allowed(error_code, spte)) {\n\t\t\tfault_handled = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tnew_spte = spte;\n\n\t\tif (is_access_track_spte(spte))\n\t\t\tnew_spte = restore_acc_track_spte(new_spte);\n\n\t\t/*\n\t\t * Currently, to simplify the code, write-protection can\n\t\t * be removed in the fast path only if the SPTE was\n\t\t * write-protected for dirty-logging or access tracking.\n\t\t */\n\t\tif ((error_code & PFERR_WRITE_MASK) &&\n\t\t    spte_can_locklessly_be_made_writable(spte)) {\n\t\t\tnew_spte |= PT_WRITABLE_MASK;\n\n\t\t\t/*\n\t\t\t * Do not fix write-permission on the large spte.  Since\n\t\t\t * we only dirty the first page into the dirty-bitmap in\n\t\t\t * fast_pf_fix_direct_spte(), other pages are missed\n\t\t\t * if its slot has dirty logging enabled.\n\t\t\t *\n\t\t\t * Instead, we let the slow page fault path create a\n\t\t\t * normal spte to fix the access.\n\t\t\t *\n\t\t\t * See the comments in kvm_arch_commit_memory_region().\n\t\t\t */\n\t\t\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Verify that the fault can be handled in the fast path */\n\t\tif (new_spte == spte ||\n\t\t    !is_access_allowed(error_code, new_spte))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Currently, fast page fault only works for direct mapping\n\t\t * since the gfn is not stable for indirect shadow page. See\n\t\t * Documentation/virt/kvm/locking.txt to get more detail.\n\t\t */\n\t\tfault_handled = fast_pf_fix_direct_spte(vcpu, sp,\n\t\t\t\t\t\t\titerator.sptep, spte,\n\t\t\t\t\t\t\tnew_spte);\n\t\tif (fault_handled)\n\t\t\tbreak;\n\n\t\tif (++retry_count > 4) {\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"kvm: Fast #PF retrying more than 4 times.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t} while (true);\n\n\ttrace_fast_page_fault(vcpu, cr2_or_gpa, error_code, iterator.sptep,\n\t\t\t      spte, fault_handled);\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn fault_handled;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_end",
          "args": [
            "vcpu"
          ],
          "line": 3607
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_end",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1051-1060",
          "snippet": "static void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_mmu_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_mmu_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_fast_page_fault",
          "args": [
            "vcpu",
            "cr2_or_gpa",
            "error_code",
            "iterator.sptep",
            "spte",
            "fault_handled"
          ],
          "line": 3605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"kvm: Fast #PF retrying more than 4 times.\\n\""
          ],
          "line": 3598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fast_pf_fix_direct_spte",
          "args": [
            "vcpu",
            "sp",
            "iterator.sptep",
            "spte",
            "new_spte"
          ],
          "line": 3591
        },
        "resolved": true,
        "details": {
          "function_name": "fast_pf_fix_direct_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3460-3493",
          "snippet": "static bool\nfast_pf_fix_direct_spte(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\tu64 *sptep, u64 old_spte, u64 new_spte)\n{\n\tgfn_t gfn;\n\n\tWARN_ON(!sp->role.direct);\n\n\t/*\n\t * Theoretically we could also set dirty bit (and flush TLB) here in\n\t * order to eliminate unnecessary PML logging. See comments in\n\t * set_spte. But fast_page_fault is very unlikely to happen with PML\n\t * enabled, so we do not do this. This might result in the same GPA\n\t * to be logged in PML buffer again when the write really happens, and\n\t * eventually to be called by mark_page_dirty twice. But it's also no\n\t * harm. This also avoids the TLB flush needed after setting dirty bit\n\t * so non-PML cases won't be impacted.\n\t *\n\t * Compare with set_spte where instead shadow_dirty_mask is set.\n\t */\n\tif (cmpxchg64(sptep, old_spte, new_spte) != old_spte)\n\t\treturn false;\n\n\tif (is_writable_pte(new_spte) && !is_writable_pte(old_spte)) {\n\t\t/*\n\t\t * The gfn of direct spte is stable since it is\n\t\t * calculated by sp->gfn.\n\t\t */\n\t\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool\nfast_pf_fix_direct_spte(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\tu64 *sptep, u64 old_spte, u64 new_spte)\n{\n\tgfn_t gfn;\n\n\tWARN_ON(!sp->role.direct);\n\n\t/*\n\t * Theoretically we could also set dirty bit (and flush TLB) here in\n\t * order to eliminate unnecessary PML logging. See comments in\n\t * set_spte. But fast_page_fault is very unlikely to happen with PML\n\t * enabled, so we do not do this. This might result in the same GPA\n\t * to be logged in PML buffer again when the write really happens, and\n\t * eventually to be called by mark_page_dirty twice. But it's also no\n\t * harm. This also avoids the TLB flush needed after setting dirty bit\n\t * so non-PML cases won't be impacted.\n\t *\n\t * Compare with set_spte where instead shadow_dirty_mask is set.\n\t */\n\tif (cmpxchg64(sptep, old_spte, new_spte) != old_spte)\n\t\treturn false;\n\n\tif (is_writable_pte(new_spte) && !is_writable_pte(old_spte)) {\n\t\t/*\n\t\t * The gfn of direct spte is stable since it is\n\t\t * calculated by sp->gfn.\n\t\t */\n\t\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_access_allowed",
          "args": [
            "error_code",
            "new_spte"
          ],
          "line": 3583
        },
        "resolved": true,
        "details": {
          "function_name": "is_access_allowed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3495-3505",
          "snippet": "static bool is_access_allowed(u32 fault_err_code, u64 spte)\n{\n\tif (fault_err_code & PFERR_FETCH_MASK)\n\t\treturn is_executable_pte(spte);\n\n\tif (fault_err_code & PFERR_WRITE_MASK)\n\t\treturn is_writable_pte(spte);\n\n\t/* Fault was on Read access */\n\treturn spte & PT_PRESENT_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_access_allowed(u32 fault_err_code, u64 spte)\n{\n\tif (fault_err_code & PFERR_FETCH_MASK)\n\t\treturn is_executable_pte(spte);\n\n\tif (fault_err_code & PFERR_WRITE_MASK)\n\t\treturn is_writable_pte(spte);\n\n\t/* Fault was on Read access */\n\treturn spte & PT_PRESENT_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_can_locklessly_be_made_writable",
          "args": [
            "spte"
          ],
          "line": 3563
        },
        "resolved": true,
        "details": {
          "function_name": "spte_can_locklessly_be_made_writable",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "784-788",
          "snippet": "static bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
            "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_acc_track_spte",
          "args": [
            "new_spte"
          ],
          "line": 3555
        },
        "resolved": true,
        "details": {
          "function_name": "restore_acc_track_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "993-1008",
          "snippet": "static u64 restore_acc_track_spte(u64 spte)\n{\n\tu64 new_spte = spte;\n\tu64 saved_bits = (spte >> shadow_acc_track_saved_bits_shift)\n\t\t\t & shadow_acc_track_saved_bits_mask;\n\n\tWARN_ON_ONCE(spte_ad_enabled(spte));\n\tWARN_ON_ONCE(!is_access_track_spte(spte));\n\n\tnew_spte &= ~shadow_acc_track_mask;\n\tnew_spte &= ~(shadow_acc_track_saved_bits_mask <<\n\t\t      shadow_acc_track_saved_bits_shift);\n\tnew_spte |= saved_bits;\n\n\treturn new_spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;",
            "static const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;",
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;\nstatic const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 restore_acc_track_spte(u64 spte)\n{\n\tu64 new_spte = spte;\n\tu64 saved_bits = (spte >> shadow_acc_track_saved_bits_shift)\n\t\t\t & shadow_acc_track_saved_bits_mask;\n\n\tWARN_ON_ONCE(spte_ad_enabled(spte));\n\tWARN_ON_ONCE(!is_access_track_spte(spte));\n\n\tnew_spte &= ~shadow_acc_track_mask;\n\tnew_spte &= ~(shadow_acc_track_saved_bits_mask <<\n\t\t      shadow_acc_track_saved_bits_shift);\n\tnew_spte |= saved_bits;\n\n\treturn new_spte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_access_track_spte",
          "args": [
            "spte"
          ],
          "line": 3554
        },
        "resolved": true,
        "details": {
          "function_name": "is_access_track_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "394-397",
          "snippet": "static inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "spte",
            "sp->role.level"
          ],
          "line": 3534
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "621-628",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(iterator.sptep)"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "iterator.sptep"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "spte"
          ],
          "line": 3530
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_shadow_entry_lockless",
          "args": [
            "vcpu",
            "cr2_or_gpa",
            "iterator",
            "spte"
          ],
          "line": 3529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "walk_shadow_page_lockless_begin",
          "args": [
            "vcpu"
          ],
          "line": 3524
        },
        "resolved": true,
        "details": {
          "function_name": "walk_shadow_page_lockless_begin",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1036-1049",
          "snippet": "static void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_fault_can_be_fast",
          "args": [
            "error_code"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "page_fault_can_be_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3423-3454",
          "snippet": "static bool page_fault_can_be_fast(u32 error_code)\n{\n\t/*\n\t * Do not fix the mmio spte with invalid generation number which\n\t * need to be updated by slow page fault path.\n\t */\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\t/* See if the page fault is due to an NX violation */\n\tif (unlikely(((error_code & (PFERR_FETCH_MASK | PFERR_PRESENT_MASK))\n\t\t      == (PFERR_FETCH_MASK | PFERR_PRESENT_MASK))))\n\t\treturn false;\n\n\t/*\n\t * #PF can be fast if:\n\t * 1. The shadow page table entry is not present, which could mean that\n\t *    the fault is potentially caused by access tracking (if enabled).\n\t * 2. The shadow page table entry is present and the fault\n\t *    is caused by write-protect, that means we just need change the W\n\t *    bit of the spte which can be done out of mmu-lock.\n\t *\n\t * However, if access tracking is disabled we know that a non-present\n\t * page must be a genuine page fault where we have to create a new SPTE.\n\t * So, if access tracking is disabled, we return true only for write\n\t * accesses to a present page.\n\t */\n\n\treturn shadow_acc_track_mask != 0 ||\n\t       ((error_code & (PFERR_WRITE_MASK | PFERR_PRESENT_MASK))\n\t\t== (PFERR_WRITE_MASK | PFERR_PRESENT_MASK));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool page_fault_can_be_fast(u32 error_code)\n{\n\t/*\n\t * Do not fix the mmio spte with invalid generation number which\n\t * need to be updated by slow page fault path.\n\t */\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\t/* See if the page fault is due to an NX violation */\n\tif (unlikely(((error_code & (PFERR_FETCH_MASK | PFERR_PRESENT_MASK))\n\t\t      == (PFERR_FETCH_MASK | PFERR_PRESENT_MASK))))\n\t\treturn false;\n\n\t/*\n\t * #PF can be fast if:\n\t * 1. The shadow page table entry is not present, which could mean that\n\t *    the fault is potentially caused by access tracking (if enabled).\n\t * 2. The shadow page table entry is present and the fault\n\t *    is caused by write-protect, that means we just need change the W\n\t *    bit of the spte which can be done out of mmu-lock.\n\t *\n\t * However, if access tracking is disabled we know that a non-present\n\t * page must be a genuine page fault where we have to create a new SPTE.\n\t * So, if access tracking is disabled, we return true only for write\n\t * accesses to a present page.\n\t */\n\n\treturn shadow_acc_track_mask != 0 ||\n\t       ((error_code & (PFERR_WRITE_MASK | PFERR_PRESENT_MASK))\n\t\t== (PFERR_WRITE_MASK | PFERR_PRESENT_MASK));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool fast_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa,\n\t\t\t    u32 error_code)\n{\n\tstruct kvm_shadow_walk_iterator iterator;\n\tstruct kvm_mmu_page *sp;\n\tbool fault_handled = false;\n\tu64 spte = 0ull;\n\tuint retry_count = 0;\n\n\tif (!page_fault_can_be_fast(error_code))\n\t\treturn false;\n\n\twalk_shadow_page_lockless_begin(vcpu);\n\n\tdo {\n\t\tu64 new_spte;\n\n\t\tfor_each_shadow_entry_lockless(vcpu, cr2_or_gpa, iterator, spte)\n\t\t\tif (!is_shadow_present_pte(spte))\n\t\t\t\tbreak;\n\n\t\tsp = page_header(__pa(iterator.sptep));\n\t\tif (!is_last_spte(spte, sp->role.level))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Check whether the memory access that caused the fault would\n\t\t * still cause it if it were to be performed right now. If not,\n\t\t * then this is a spurious fault caused by TLB lazily flushed,\n\t\t * or some other CPU has already fixed the PTE after the\n\t\t * current CPU took the fault.\n\t\t *\n\t\t * Need not check the access of upper level table entries since\n\t\t * they are always ACC_ALL.\n\t\t */\n\t\tif (is_access_allowed(error_code, spte)) {\n\t\t\tfault_handled = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tnew_spte = spte;\n\n\t\tif (is_access_track_spte(spte))\n\t\t\tnew_spte = restore_acc_track_spte(new_spte);\n\n\t\t/*\n\t\t * Currently, to simplify the code, write-protection can\n\t\t * be removed in the fast path only if the SPTE was\n\t\t * write-protected for dirty-logging or access tracking.\n\t\t */\n\t\tif ((error_code & PFERR_WRITE_MASK) &&\n\t\t    spte_can_locklessly_be_made_writable(spte)) {\n\t\t\tnew_spte |= PT_WRITABLE_MASK;\n\n\t\t\t/*\n\t\t\t * Do not fix write-permission on the large spte.  Since\n\t\t\t * we only dirty the first page into the dirty-bitmap in\n\t\t\t * fast_pf_fix_direct_spte(), other pages are missed\n\t\t\t * if its slot has dirty logging enabled.\n\t\t\t *\n\t\t\t * Instead, we let the slow page fault path create a\n\t\t\t * normal spte to fix the access.\n\t\t\t *\n\t\t\t * See the comments in kvm_arch_commit_memory_region().\n\t\t\t */\n\t\t\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Verify that the fault can be handled in the fast path */\n\t\tif (new_spte == spte ||\n\t\t    !is_access_allowed(error_code, new_spte))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Currently, fast page fault only works for direct mapping\n\t\t * since the gfn is not stable for indirect shadow page. See\n\t\t * Documentation/virt/kvm/locking.txt to get more detail.\n\t\t */\n\t\tfault_handled = fast_pf_fix_direct_spte(vcpu, sp,\n\t\t\t\t\t\t\titerator.sptep, spte,\n\t\t\t\t\t\t\tnew_spte);\n\t\tif (fault_handled)\n\t\t\tbreak;\n\n\t\tif (++retry_count > 4) {\n\t\t\tprintk_once(KERN_WARNING\n\t\t\t\t\"kvm: Fast #PF retrying more than 4 times.\\n\");\n\t\t\tbreak;\n\t\t}\n\n\t} while (true);\n\n\ttrace_fast_page_fault(vcpu, cr2_or_gpa, error_code, iterator.sptep,\n\t\t\t      spte, fault_handled);\n\twalk_shadow_page_lockless_end(vcpu);\n\n\treturn fault_handled;\n}"
  },
  {
    "function_name": "is_access_allowed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3495-3505",
    "snippet": "static bool is_access_allowed(u32 fault_err_code, u64 spte)\n{\n\tif (fault_err_code & PFERR_FETCH_MASK)\n\t\treturn is_executable_pte(spte);\n\n\tif (fault_err_code & PFERR_WRITE_MASK)\n\t\treturn is_writable_pte(spte);\n\n\t/* Fault was on Read access */\n\treturn spte & PT_PRESENT_MASK;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "spte"
          ],
          "line": 3501
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "151-154",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_executable_pte",
          "args": [
            "spte"
          ],
          "line": 3498
        },
        "resolved": true,
        "details": {
          "function_name": "is_executable_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "630-633",
          "snippet": "static bool is_executable_pte(u64 spte)\n{\n\treturn (spte & (shadow_x_mask | shadow_nx_mask)) == shadow_x_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_executable_pte(u64 spte)\n{\n\treturn (spte & (shadow_x_mask | shadow_nx_mask)) == shadow_x_mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_access_allowed(u32 fault_err_code, u64 spte)\n{\n\tif (fault_err_code & PFERR_FETCH_MASK)\n\t\treturn is_executable_pte(spte);\n\n\tif (fault_err_code & PFERR_WRITE_MASK)\n\t\treturn is_writable_pte(spte);\n\n\t/* Fault was on Read access */\n\treturn spte & PT_PRESENT_MASK;\n}"
  },
  {
    "function_name": "fast_pf_fix_direct_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3460-3493",
    "snippet": "static bool\nfast_pf_fix_direct_spte(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\tu64 *sptep, u64 old_spte, u64 new_spte)\n{\n\tgfn_t gfn;\n\n\tWARN_ON(!sp->role.direct);\n\n\t/*\n\t * Theoretically we could also set dirty bit (and flush TLB) here in\n\t * order to eliminate unnecessary PML logging. See comments in\n\t * set_spte. But fast_page_fault is very unlikely to happen with PML\n\t * enabled, so we do not do this. This might result in the same GPA\n\t * to be logged in PML buffer again when the write really happens, and\n\t * eventually to be called by mark_page_dirty twice. But it's also no\n\t * harm. This also avoids the TLB flush needed after setting dirty bit\n\t * so non-PML cases won't be impacted.\n\t *\n\t * Compare with set_spte where instead shadow_dirty_mask is set.\n\t */\n\tif (cmpxchg64(sptep, old_spte, new_spte) != old_spte)\n\t\treturn false;\n\n\tif (is_writable_pte(new_spte) && !is_writable_pte(old_spte)) {\n\t\t/*\n\t\t * The gfn of direct spte is stable since it is\n\t\t * calculated by sp->gfn.\n\t\t */\n\t\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_mark_page_dirty",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 3489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "sp",
            "sptep - sp->spt"
          ],
          "line": 3488
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1157-1163",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "old_spte"
          ],
          "line": 3483
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "151-154",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg64",
          "args": [
            "sptep",
            "old_spte",
            "new_spte"
          ],
          "line": 3480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sp->role.direct"
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool\nfast_pf_fix_direct_spte(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\tu64 *sptep, u64 old_spte, u64 new_spte)\n{\n\tgfn_t gfn;\n\n\tWARN_ON(!sp->role.direct);\n\n\t/*\n\t * Theoretically we could also set dirty bit (and flush TLB) here in\n\t * order to eliminate unnecessary PML logging. See comments in\n\t * set_spte. But fast_page_fault is very unlikely to happen with PML\n\t * enabled, so we do not do this. This might result in the same GPA\n\t * to be logged in PML buffer again when the write really happens, and\n\t * eventually to be called by mark_page_dirty twice. But it's also no\n\t * harm. This also avoids the TLB flush needed after setting dirty bit\n\t * so non-PML cases won't be impacted.\n\t *\n\t * Compare with set_spte where instead shadow_dirty_mask is set.\n\t */\n\tif (cmpxchg64(sptep, old_spte, new_spte) != old_spte)\n\t\treturn false;\n\n\tif (is_writable_pte(new_spte) && !is_writable_pte(old_spte)) {\n\t\t/*\n\t\t * The gfn of direct spte is stable since it is\n\t\t * calculated by sp->gfn.\n\t\t */\n\t\tgfn = kvm_mmu_page_get_gfn(sp, sptep - sp->spt);\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "page_fault_can_be_fast",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3423-3454",
    "snippet": "static bool page_fault_can_be_fast(u32 error_code)\n{\n\t/*\n\t * Do not fix the mmio spte with invalid generation number which\n\t * need to be updated by slow page fault path.\n\t */\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\t/* See if the page fault is due to an NX violation */\n\tif (unlikely(((error_code & (PFERR_FETCH_MASK | PFERR_PRESENT_MASK))\n\t\t      == (PFERR_FETCH_MASK | PFERR_PRESENT_MASK))))\n\t\treturn false;\n\n\t/*\n\t * #PF can be fast if:\n\t * 1. The shadow page table entry is not present, which could mean that\n\t *    the fault is potentially caused by access tracking (if enabled).\n\t * 2. The shadow page table entry is present and the fault\n\t *    is caused by write-protect, that means we just need change the W\n\t *    bit of the spte which can be done out of mmu-lock.\n\t *\n\t * However, if access tracking is disabled we know that a non-present\n\t * page must be a genuine page fault where we have to create a new SPTE.\n\t * So, if access tracking is disabled, we return true only for write\n\t * accesses to a present page.\n\t */\n\n\treturn shadow_acc_track_mask != 0 ||\n\t       ((error_code & (PFERR_WRITE_MASK | PFERR_PRESENT_MASK))\n\t\t== (PFERR_WRITE_MASK | PFERR_PRESENT_MASK));\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "((error_code & (PFERR_FETCH_MASK | PFERR_PRESENT_MASK))\n\t\t      == (PFERR_FETCH_MASK | PFERR_PRESENT_MASK))"
          ],
          "line": 3433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error_code & PFERR_RSVD_MASK"
          ],
          "line": 3429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool page_fault_can_be_fast(u32 error_code)\n{\n\t/*\n\t * Do not fix the mmio spte with invalid generation number which\n\t * need to be updated by slow page fault path.\n\t */\n\tif (unlikely(error_code & PFERR_RSVD_MASK))\n\t\treturn false;\n\n\t/* See if the page fault is due to an NX violation */\n\tif (unlikely(((error_code & (PFERR_FETCH_MASK | PFERR_PRESENT_MASK))\n\t\t      == (PFERR_FETCH_MASK | PFERR_PRESENT_MASK))))\n\t\treturn false;\n\n\t/*\n\t * #PF can be fast if:\n\t * 1. The shadow page table entry is not present, which could mean that\n\t *    the fault is potentially caused by access tracking (if enabled).\n\t * 2. The shadow page table entry is present and the fault\n\t *    is caused by write-protect, that means we just need change the W\n\t *    bit of the spte which can be done out of mmu-lock.\n\t *\n\t * However, if access tracking is disabled we know that a non-present\n\t * page must be a genuine page fault where we have to create a new SPTE.\n\t * So, if access tracking is disabled, we return true only for write\n\t * accesses to a present page.\n\t */\n\n\treturn shadow_acc_track_mask != 0 ||\n\t       ((error_code & (PFERR_WRITE_MASK | PFERR_PRESENT_MASK))\n\t\t== (PFERR_WRITE_MASK | PFERR_PRESENT_MASK));\n}"
  },
  {
    "function_name": "handle_abnormal_pfn",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3406-3421",
    "snippet": "static bool handle_abnormal_pfn(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,\n\t\t\t\tkvm_pfn_t pfn, unsigned int access,\n\t\t\t\tint *ret_val)\n{\n\t/* The pfn is invalid, report the error! */\n\tif (unlikely(is_error_pfn(pfn))) {\n\t\t*ret_val = kvm_handle_bad_page(vcpu, gfn, pfn);\n\t\treturn true;\n\t}\n\n\tif (unlikely(is_noslot_pfn(pfn)))\n\t\tvcpu_cache_mmio_info(vcpu, gva, gfn,\n\t\t\t\t     access & shadow_mmio_access_mask);\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_cache_mmio_info",
          "args": [
            "vcpu",
            "gva",
            "gfn",
            "access & shadow_mmio_access_mask"
          ],
          "line": 3417
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_cache_mmio_info",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "163-179",
          "snippet": "static inline void vcpu_cache_mmio_info(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgva_t gva, gfn_t gfn, unsigned access)\n{\n\tu64 gen = kvm_memslots(vcpu->kvm)->generation;\n\n\tif (unlikely(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS))\n\t\treturn;\n\n\t/*\n\t * If this is a shadow nested page table, the \"GVA\" is\n\t * actually a nGPA.\n\t */\n\tvcpu->arch.mmio_gva = mmu_is_nested(vcpu) ? 0 : gva & PAGE_MASK;\n\tvcpu->arch.mmio_access = access;\n\tvcpu->arch.mmio_gfn = gfn;\n\tvcpu->arch.mmio_gen = gen;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void vcpu_cache_mmio_info(struct kvm_vcpu *vcpu,\n\t\t\t\t\tgva_t gva, gfn_t gfn, unsigned access)\n{\n\tu64 gen = kvm_memslots(vcpu->kvm)->generation;\n\n\tif (unlikely(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS))\n\t\treturn;\n\n\t/*\n\t * If this is a shadow nested page table, the \"GVA\" is\n\t * actually a nGPA.\n\t */\n\tvcpu->arch.mmio_gva = mmu_is_nested(vcpu) ? 0 : gva & PAGE_MASK;\n\tvcpu->arch.mmio_access = access;\n\tvcpu->arch.mmio_gfn = gfn;\n\tvcpu->arch.mmio_gen = gen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_noslot_pfn(pfn)"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_noslot_pfn",
          "args": [
            "pfn"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_handle_bad_page",
          "args": [
            "vcpu",
            "gfn",
            "pfn"
          ],
          "line": 3412
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_bad_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3388-3404",
          "snippet": "static int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, kvm_pfn_t pfn)\n{\n\t/*\n\t * Do not cache the mmio info caused by writing the readonly gfn\n\t * into the spte otherwise read access on readonly gfn also can\n\t * caused mmio page fault and treat it as mmio access.\n\t */\n\tif (pfn == KVM_PFN_ERR_RO_FAULT)\n\t\treturn RET_PF_EMULATE;\n\n\tif (pfn == KVM_PFN_ERR_HWPOISON) {\n\t\tkvm_send_hwpoison_signal(kvm_vcpu_gfn_to_hva(vcpu, gfn), current);\n\t\treturn RET_PF_RETRY;\n\t}\n\n\treturn -EFAULT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, kvm_pfn_t pfn)\n{\n\t/*\n\t * Do not cache the mmio info caused by writing the readonly gfn\n\t * into the spte otherwise read access on readonly gfn also can\n\t * caused mmio page fault and treat it as mmio access.\n\t */\n\tif (pfn == KVM_PFN_ERR_RO_FAULT)\n\t\treturn RET_PF_EMULATE;\n\n\tif (pfn == KVM_PFN_ERR_HWPOISON) {\n\t\tkvm_send_hwpoison_signal(kvm_vcpu_gfn_to_hva(vcpu, gfn), current);\n\t\treturn RET_PF_RETRY;\n\t}\n\n\treturn -EFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_error_pfn(pfn)"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_pfn",
          "args": [
            "pfn"
          ],
          "line": 3411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool handle_abnormal_pfn(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,\n\t\t\t\tkvm_pfn_t pfn, unsigned int access,\n\t\t\t\tint *ret_val)\n{\n\t/* The pfn is invalid, report the error! */\n\tif (unlikely(is_error_pfn(pfn))) {\n\t\t*ret_val = kvm_handle_bad_page(vcpu, gfn, pfn);\n\t\treturn true;\n\t}\n\n\tif (unlikely(is_noslot_pfn(pfn)))\n\t\tvcpu_cache_mmio_info(vcpu, gva, gfn,\n\t\t\t\t     access & shadow_mmio_access_mask);\n\n\treturn false;\n}"
  },
  {
    "function_name": "kvm_handle_bad_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3388-3404",
    "snippet": "static int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, kvm_pfn_t pfn)\n{\n\t/*\n\t * Do not cache the mmio info caused by writing the readonly gfn\n\t * into the spte otherwise read access on readonly gfn also can\n\t * caused mmio page fault and treat it as mmio access.\n\t */\n\tif (pfn == KVM_PFN_ERR_RO_FAULT)\n\t\treturn RET_PF_EMULATE;\n\n\tif (pfn == KVM_PFN_ERR_HWPOISON) {\n\t\tkvm_send_hwpoison_signal(kvm_vcpu_gfn_to_hva(vcpu, gfn), current);\n\t\treturn RET_PF_RETRY;\n\t}\n\n\treturn -EFAULT;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_send_hwpoison_signal",
          "args": [
            "kvm_vcpu_gfn_to_hva(vcpu, gfn)",
            "current"
          ],
          "line": 3399
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_send_hwpoison_signal",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3383-3386",
          "snippet": "static void kvm_send_hwpoison_signal(unsigned long address, struct task_struct *tsk)\n{\n\tsend_sig_mceerr(BUS_MCEERR_AR, (void __user *)address, PAGE_SHIFT, tsk);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_send_hwpoison_signal(unsigned long address, struct task_struct *tsk)\n{\n\tsend_sig_mceerr(BUS_MCEERR_AR, (void __user *)address, PAGE_SHIFT, tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_hva",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 3399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, kvm_pfn_t pfn)\n{\n\t/*\n\t * Do not cache the mmio info caused by writing the readonly gfn\n\t * into the spte otherwise read access on readonly gfn also can\n\t * caused mmio page fault and treat it as mmio access.\n\t */\n\tif (pfn == KVM_PFN_ERR_RO_FAULT)\n\t\treturn RET_PF_EMULATE;\n\n\tif (pfn == KVM_PFN_ERR_HWPOISON) {\n\t\tkvm_send_hwpoison_signal(kvm_vcpu_gfn_to_hva(vcpu, gfn), current);\n\t\treturn RET_PF_RETRY;\n\t}\n\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "kvm_send_hwpoison_signal",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3383-3386",
    "snippet": "static void kvm_send_hwpoison_signal(unsigned long address, struct task_struct *tsk)\n{\n\tsend_sig_mceerr(BUS_MCEERR_AR, (void __user *)address, PAGE_SHIFT, tsk);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sig_mceerr",
          "args": [
            "BUS_MCEERR_AR",
            "(void __user *)address",
            "PAGE_SHIFT",
            "tsk"
          ],
          "line": 3385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_send_hwpoison_signal(unsigned long address, struct task_struct *tsk)\n{\n\tsend_sig_mceerr(BUS_MCEERR_AR, (void __user *)address, PAGE_SHIFT, tsk);\n}"
  },
  {
    "function_name": "__direct_map",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3337-3381",
    "snippet": "static int __direct_map(struct kvm_vcpu *vcpu, gpa_t gpa, int write,\n\t\t\tint map_writable, int max_level, kvm_pfn_t pfn,\n\t\t\tbool prefault, bool account_disallowed_nx_lpage)\n{\n\tstruct kvm_shadow_walk_iterator it;\n\tstruct kvm_mmu_page *sp;\n\tint level, ret;\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tgfn_t base_gfn = gfn;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tlevel = kvm_mmu_hugepage_adjust(vcpu, gfn, max_level, &pfn);\n\n\ttrace_kvm_mmu_spte_requested(gpa, level, pfn);\n\tfor_each_shadow_entry(vcpu, gpa, it) {\n\t\t/*\n\t\t * We cannot overwrite existing page tables with an NX\n\t\t * large page, as the leaf could be executable.\n\t\t */\n\t\tdisallowed_hugepage_adjust(it, gfn, &pfn, &level);\n\n\t\tbase_gfn = gfn & ~(KVM_PAGES_PER_HPAGE(it.level) - 1);\n\t\tif (it.level == level)\n\t\t\tbreak;\n\n\t\tdrop_large_spte(vcpu, it.sptep);\n\t\tif (!is_shadow_present_pte(*it.sptep)) {\n\t\t\tsp = kvm_mmu_get_page(vcpu, base_gfn, it.addr,\n\t\t\t\t\t      it.level - 1, true, ACC_ALL);\n\n\t\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\t\t\tif (account_disallowed_nx_lpage)\n\t\t\t\taccount_huge_nx_page(vcpu->kvm, sp);\n\t\t}\n\t}\n\n\tret = mmu_set_spte(vcpu, it.sptep, ACC_ALL,\n\t\t\t   write, level, base_gfn, pfn, prefault,\n\t\t\t   map_writable);\n\tdirect_pte_prefetch(vcpu, it.sptep);\n\t++vcpu->stat.pf_fixed;\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "direct_pte_prefetch",
          "args": [
            "vcpu",
            "it.sptep"
          ],
          "line": 3378
        },
        "resolved": true,
        "details": {
          "function_name": "direct_pte_prefetch",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3217-3235",
          "snippet": "static void direct_pte_prefetch(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(sptep));\n\n\t/*\n\t * Without accessed bits, there's no way to distinguish between\n\t * actually accessed translations and prefetched, so disable pte\n\t * prefetch if accessed bits aren't available.\n\t */\n\tif (sp_ad_disabled(sp))\n\t\treturn;\n\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\t__direct_pte_prefetch(vcpu, sp, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void direct_pte_prefetch(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(sptep));\n\n\t/*\n\t * Without accessed bits, there's no way to distinguish between\n\t * actually accessed translations and prefetched, so disable pte\n\t * prefetch if accessed bits aren't available.\n\t */\n\tif (sp_ad_disabled(sp))\n\t\treturn;\n\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\t__direct_pte_prefetch(vcpu, sp, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_set_spte",
          "args": [
            "vcpu",
            "it.sptep",
            "ACC_ALL",
            "write",
            "level",
            "base_gfn",
            "pfn",
            "prefault",
            "map_writable"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_set_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3087-3152",
          "snippet": "static int mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\tunsigned int pte_access, int write_fault, int level,\n\t\t\tgfn_t gfn, kvm_pfn_t pfn, bool speculative,\n\t\t\tbool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tint set_spte_ret;\n\tint ret = RET_PF_RETRY;\n\tbool flush = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tflush = true;\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tflush = true;\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tset_spte_ret = set_spte(vcpu, sptep, pte_access, level, gfn, pfn,\n\t\t\t\tspeculative, true, host_writable);\n\tif (set_spte_ret & SET_SPTE_WRITE_PROTECTED_PT) {\n\t\tif (write_fault)\n\t\t\tret = RET_PF_EMULATE;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (set_spte_ret & SET_SPTE_NEED_REMOTE_TLB_FLUSH || flush)\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn,\n\t\t\t\tKVM_PAGES_PER_HPAGE(level));\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\tret = RET_PF_EMULATE;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\ttrace_kvm_mmu_set_spte(level, gfn, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SET_SPTE_NEED_REMOTE_TLB_FLUSH\tBIT(1)",
            "#define SET_SPTE_WRITE_PROTECTED_PT\tBIT(0)",
            "#define RMAP_RECYCLE_THRESHOLD 1000",
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SET_SPTE_NEED_REMOTE_TLB_FLUSH\tBIT(1)\n#define SET_SPTE_WRITE_PROTECTED_PT\tBIT(0)\n#define RMAP_RECYCLE_THRESHOLD 1000\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\tunsigned int pte_access, int write_fault, int level,\n\t\t\tgfn_t gfn, kvm_pfn_t pfn, bool speculative,\n\t\t\tbool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tint set_spte_ret;\n\tint ret = RET_PF_RETRY;\n\tbool flush = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tflush = true;\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tflush = true;\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tset_spte_ret = set_spte(vcpu, sptep, pte_access, level, gfn, pfn,\n\t\t\t\tspeculative, true, host_writable);\n\tif (set_spte_ret & SET_SPTE_WRITE_PROTECTED_PT) {\n\t\tif (write_fault)\n\t\t\tret = RET_PF_EMULATE;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (set_spte_ret & SET_SPTE_NEED_REMOTE_TLB_FLUSH || flush)\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn,\n\t\t\t\tKVM_PAGES_PER_HPAGE(level));\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\tret = RET_PF_EMULATE;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\ttrace_kvm_mmu_set_spte(level, gfn, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_huge_nx_page",
          "args": [
            "vcpu->kvm",
            "sp"
          ],
          "line": 3371
        },
        "resolved": true,
        "details": {
          "function_name": "unaccount_huge_nx_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1263-1268",
          "snippet": "static void unaccount_huge_nx_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\t--kvm->stat.nx_lpage_splits;\n\tsp->lpage_disallowed = false;\n\tlist_del(&sp->lpage_disallowed_link);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void unaccount_huge_nx_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\t--kvm->stat.nx_lpage_splits;\n\tsp->lpage_disallowed = false;\n\tlist_del(&sp->lpage_disallowed_link);\n}"
        }
      },
      {
        "call_info": {
          "callee": "link_shadow_page",
          "args": [
            "vcpu",
            "it.sptep",
            "sp"
          ],
          "line": 3369
        },
        "resolved": true,
        "details": {
          "function_name": "link_shadow_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2629-2650",
          "snippet": "static void link_shadow_page(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t     struct kvm_mmu_page *sp)\n{\n\tu64 spte;\n\n\tBUILD_BUG_ON(VMX_EPT_WRITABLE_MASK != PT_WRITABLE_MASK);\n\n\tspte = __pa(sp->spt) | shadow_present_mask | PT_WRITABLE_MASK |\n\t       shadow_user_mask | shadow_x_mask | shadow_me_mask;\n\n\tif (sp_ad_disabled(sp))\n\t\tspte |= SPTE_AD_DISABLED_MASK;\n\telse\n\t\tspte |= shadow_accessed_mask;\n\n\tmmu_spte_set(sptep, spte);\n\n\tmmu_page_add_parent_pte(vcpu, sp, sptep);\n\n\tif (sp->unsync_children || sp->unsync)\n\t\tmark_unsync(sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_DISABLED_MASK (1ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void link_shadow_page(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t     struct kvm_mmu_page *sp)\n{\n\tu64 spte;\n\n\tBUILD_BUG_ON(VMX_EPT_WRITABLE_MASK != PT_WRITABLE_MASK);\n\n\tspte = __pa(sp->spt) | shadow_present_mask | PT_WRITABLE_MASK |\n\t       shadow_user_mask | shadow_x_mask | shadow_me_mask;\n\n\tif (sp_ad_disabled(sp))\n\t\tspte |= SPTE_AD_DISABLED_MASK;\n\telse\n\t\tspte |= shadow_accessed_mask;\n\n\tmmu_spte_set(sptep, spte);\n\n\tmmu_page_add_parent_pte(vcpu, sp, sptep);\n\n\tif (sp->unsync_children || sp->unsync)\n\t\tmark_unsync(sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_get_page",
          "args": [
            "vcpu",
            "base_gfn",
            "it.addr",
            "it.level - 1",
            "true",
            "ACC_ALL"
          ],
          "line": 3366
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_get_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2476-2564",
          "snippet": "static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned int access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tint collisions = 0;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu->mmu_role.base;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.gpte_is_8_bytes = true;\n\trole.access = access;\n\tif (!vcpu->arch.mmu->direct_map\n\t    && vcpu->arch.mmu->root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (sp->gfn != gfn) {\n\t\t\tcollisions++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\tgoto out;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn, 1);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\nout:\n\tif (collisions > vcpu->kvm->stat.max_mmu_page_hash_collisions)\n\t\tvcpu->kvm->stat.max_mmu_page_hash_collisions = collisions;\n\treturn sp;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned int access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tint collisions = 0;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu->mmu_role.base;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.gpte_is_8_bytes = true;\n\trole.access = access;\n\tif (!vcpu->arch.mmu->direct_map\n\t    && vcpu->arch.mmu->root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (sp->gfn != gfn) {\n\t\t\tcollisions++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\tgoto out;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn, 1);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\nout:\n\tif (collisions > vcpu->kvm->stat.max_mmu_page_hash_collisions)\n\t\tvcpu->kvm->stat.max_mmu_page_hash_collisions = collisions;\n\treturn sp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*it.sptep"
          ],
          "line": 3365
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_large_spte",
          "args": [
            "vcpu",
            "it.sptep"
          ],
          "line": 3364
        },
        "resolved": true,
        "details": {
          "function_name": "drop_large_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1542-1550",
          "snippet": "static void drop_large_spte(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tif (__drop_large_spte(vcpu->kvm, sptep)) {\n\t\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, sp->gfn,\n\t\t\tKVM_PAGES_PER_HPAGE(sp->role.level));\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void drop_large_spte(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tif (__drop_large_spte(vcpu->kvm, sptep)) {\n\t\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, sp->gfn,\n\t\t\tKVM_PAGES_PER_HPAGE(sp->role.level));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "it.level"
          ],
          "line": 3360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disallowed_hugepage_adjust",
          "args": [
            "it",
            "gfn",
            "&pfn",
            "&level"
          ],
          "line": 3358
        },
        "resolved": true,
        "details": {
          "function_name": "disallowed_hugepage_adjust",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3314-3335",
          "snippet": "static void disallowed_hugepage_adjust(struct kvm_shadow_walk_iterator it,\n\t\t\t\t       gfn_t gfn, kvm_pfn_t *pfnp, int *levelp)\n{\n\tint level = *levelp;\n\tu64 spte = *it.sptep;\n\n\tif (it.level == level && level > PT_PAGE_TABLE_LEVEL &&\n\t    is_nx_huge_page_enabled() &&\n\t    is_shadow_present_pte(spte) &&\n\t    !is_large_pte(spte)) {\n\t\t/*\n\t\t * A small SPTE exists for this pfn, but FNAME(fetch)\n\t\t * and __direct_map would like to create a large PTE\n\t\t * instead: just force them to go down another level,\n\t\t * patching back for them into pfn the next 9 bits of\n\t\t * the address.\n\t\t */\n\t\tu64 page_mask = KVM_PAGES_PER_HPAGE(level) - KVM_PAGES_PER_HPAGE(level - 1);\n\t\t*pfnp |= gfn & page_mask;\n\t\t(*levelp)--;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void disallowed_hugepage_adjust(struct kvm_shadow_walk_iterator it,\n\t\t\t\t       gfn_t gfn, kvm_pfn_t *pfnp, int *levelp)\n{\n\tint level = *levelp;\n\tu64 spte = *it.sptep;\n\n\tif (it.level == level && level > PT_PAGE_TABLE_LEVEL &&\n\t    is_nx_huge_page_enabled() &&\n\t    is_shadow_present_pte(spte) &&\n\t    !is_large_pte(spte)) {\n\t\t/*\n\t\t * A small SPTE exists for this pfn, but FNAME(fetch)\n\t\t * and __direct_map would like to create a large PTE\n\t\t * instead: just force them to go down another level,\n\t\t * patching back for them into pfn the next 9 bits of\n\t\t * the address.\n\t\t */\n\t\tu64 page_mask = KVM_PAGES_PER_HPAGE(level) - KVM_PAGES_PER_HPAGE(level - 1);\n\t\t*pfnp |= gfn & page_mask;\n\t\t(*levelp)--;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_shadow_entry",
          "args": [
            "vcpu",
            "gpa",
            "it"
          ],
          "line": 3353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_spte_requested",
          "args": [
            "gpa",
            "level",
            "pfn"
          ],
          "line": 3352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_hugepage_adjust",
          "args": [
            "vcpu",
            "gfn",
            "max_level",
            "&pfn"
          ],
          "line": 3350
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_hugepage_adjust",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3268-3312",
          "snippet": "static int kvm_mmu_hugepage_adjust(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   int max_level, kvm_pfn_t *pfnp)\n{\n\tstruct kvm_memory_slot *slot;\n\tstruct kvm_lpage_info *linfo;\n\tkvm_pfn_t pfn = *pfnp;\n\tkvm_pfn_t mask;\n\tint level;\n\n\tif (unlikely(max_level == PT_PAGE_TABLE_LEVEL))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tif (is_error_noslot_pfn(pfn) || kvm_is_reserved_pfn(pfn))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, true);\n\tif (!slot)\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tmax_level = min(max_level, max_page_level);\n\tfor ( ; max_level > PT_PAGE_TABLE_LEVEL; max_level--) {\n\t\tlinfo = lpage_info_slot(gfn, slot, max_level);\n\t\tif (!linfo->disallow_lpage)\n\t\t\tbreak;\n\t}\n\n\tif (max_level == PT_PAGE_TABLE_LEVEL)\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tlevel = host_pfn_mapping_level(vcpu, gfn, pfn, slot);\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn level;\n\n\tlevel = min(level, max_level);\n\n\t/*\n\t * mmu_notifier_retry() was successful and mmu_lock is held, so\n\t * the pmd can't be split from under us.\n\t */\n\tmask = KVM_PAGES_PER_HPAGE(level) - 1;\n\tVM_BUG_ON((gfn & mask) != (pfn & mask));\n\t*pfnp = pfn & ~mask;\n\n\treturn level;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int max_page_level",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int max_page_level;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int kvm_mmu_hugepage_adjust(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   int max_level, kvm_pfn_t *pfnp)\n{\n\tstruct kvm_memory_slot *slot;\n\tstruct kvm_lpage_info *linfo;\n\tkvm_pfn_t pfn = *pfnp;\n\tkvm_pfn_t mask;\n\tint level;\n\n\tif (unlikely(max_level == PT_PAGE_TABLE_LEVEL))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tif (is_error_noslot_pfn(pfn) || kvm_is_reserved_pfn(pfn))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, true);\n\tif (!slot)\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tmax_level = min(max_level, max_page_level);\n\tfor ( ; max_level > PT_PAGE_TABLE_LEVEL; max_level--) {\n\t\tlinfo = lpage_info_slot(gfn, slot, max_level);\n\t\tif (!linfo->disallow_lpage)\n\t\t\tbreak;\n\t}\n\n\tif (max_level == PT_PAGE_TABLE_LEVEL)\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tlevel = host_pfn_mapping_level(vcpu, gfn, pfn, slot);\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn level;\n\n\tlevel = min(level, max_level);\n\n\t/*\n\t * mmu_notifier_retry() was successful and mmu_lock is held, so\n\t * the pmd can't be split from under us.\n\t */\n\tmask = KVM_PAGES_PER_HPAGE(level) - 1;\n\tVM_BUG_ON((gfn & mask) != (pfn & mask));\n\t*pfnp = pfn & ~mask;\n\n\treturn level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!VALID_PAGE(vcpu->arch.mmu->root_hpa)"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VALID_PAGE",
          "args": [
            "vcpu->arch.mmu->root_hpa"
          ],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int __direct_map(struct kvm_vcpu *vcpu, gpa_t gpa, int write,\n\t\t\tint map_writable, int max_level, kvm_pfn_t pfn,\n\t\t\tbool prefault, bool account_disallowed_nx_lpage)\n{\n\tstruct kvm_shadow_walk_iterator it;\n\tstruct kvm_mmu_page *sp;\n\tint level, ret;\n\tgfn_t gfn = gpa >> PAGE_SHIFT;\n\tgfn_t base_gfn = gfn;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tlevel = kvm_mmu_hugepage_adjust(vcpu, gfn, max_level, &pfn);\n\n\ttrace_kvm_mmu_spte_requested(gpa, level, pfn);\n\tfor_each_shadow_entry(vcpu, gpa, it) {\n\t\t/*\n\t\t * We cannot overwrite existing page tables with an NX\n\t\t * large page, as the leaf could be executable.\n\t\t */\n\t\tdisallowed_hugepage_adjust(it, gfn, &pfn, &level);\n\n\t\tbase_gfn = gfn & ~(KVM_PAGES_PER_HPAGE(it.level) - 1);\n\t\tif (it.level == level)\n\t\t\tbreak;\n\n\t\tdrop_large_spte(vcpu, it.sptep);\n\t\tif (!is_shadow_present_pte(*it.sptep)) {\n\t\t\tsp = kvm_mmu_get_page(vcpu, base_gfn, it.addr,\n\t\t\t\t\t      it.level - 1, true, ACC_ALL);\n\n\t\t\tlink_shadow_page(vcpu, it.sptep, sp);\n\t\t\tif (account_disallowed_nx_lpage)\n\t\t\t\taccount_huge_nx_page(vcpu->kvm, sp);\n\t\t}\n\t}\n\n\tret = mmu_set_spte(vcpu, it.sptep, ACC_ALL,\n\t\t\t   write, level, base_gfn, pfn, prefault,\n\t\t\t   map_writable);\n\tdirect_pte_prefetch(vcpu, it.sptep);\n\t++vcpu->stat.pf_fixed;\n\treturn ret;\n}"
  },
  {
    "function_name": "disallowed_hugepage_adjust",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3314-3335",
    "snippet": "static void disallowed_hugepage_adjust(struct kvm_shadow_walk_iterator it,\n\t\t\t\t       gfn_t gfn, kvm_pfn_t *pfnp, int *levelp)\n{\n\tint level = *levelp;\n\tu64 spte = *it.sptep;\n\n\tif (it.level == level && level > PT_PAGE_TABLE_LEVEL &&\n\t    is_nx_huge_page_enabled() &&\n\t    is_shadow_present_pte(spte) &&\n\t    !is_large_pte(spte)) {\n\t\t/*\n\t\t * A small SPTE exists for this pfn, but FNAME(fetch)\n\t\t * and __direct_map would like to create a large PTE\n\t\t * instead: just force them to go down another level,\n\t\t * patching back for them into pfn the next 9 bits of\n\t\t * the address.\n\t\t */\n\t\tu64 page_mask = KVM_PAGES_PER_HPAGE(level) - KVM_PAGES_PER_HPAGE(level - 1);\n\t\t*pfnp |= gfn & page_mask;\n\t\t(*levelp)--;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "level - 1"
          ],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "level"
          ],
          "line": 3331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "spte"
          ],
          "line": 3323
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "616-619",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "spte"
          ],
          "line": 3322
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_nx_huge_page_enabled",
          "args": [],
          "line": 3321
        },
        "resolved": true,
        "details": {
          "function_name": "is_nx_huge_page_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "377-380",
          "snippet": "static bool is_nx_huge_page_enabled(void)\n{\n\treturn READ_ONCE(nx_huge_pages);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool is_nx_huge_page_enabled(void)\n{\n\treturn READ_ONCE(nx_huge_pages);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void disallowed_hugepage_adjust(struct kvm_shadow_walk_iterator it,\n\t\t\t\t       gfn_t gfn, kvm_pfn_t *pfnp, int *levelp)\n{\n\tint level = *levelp;\n\tu64 spte = *it.sptep;\n\n\tif (it.level == level && level > PT_PAGE_TABLE_LEVEL &&\n\t    is_nx_huge_page_enabled() &&\n\t    is_shadow_present_pte(spte) &&\n\t    !is_large_pte(spte)) {\n\t\t/*\n\t\t * A small SPTE exists for this pfn, but FNAME(fetch)\n\t\t * and __direct_map would like to create a large PTE\n\t\t * instead: just force them to go down another level,\n\t\t * patching back for them into pfn the next 9 bits of\n\t\t * the address.\n\t\t */\n\t\tu64 page_mask = KVM_PAGES_PER_HPAGE(level) - KVM_PAGES_PER_HPAGE(level - 1);\n\t\t*pfnp |= gfn & page_mask;\n\t\t(*levelp)--;\n\t}\n}"
  },
  {
    "function_name": "kvm_mmu_hugepage_adjust",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3268-3312",
    "snippet": "static int kvm_mmu_hugepage_adjust(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   int max_level, kvm_pfn_t *pfnp)\n{\n\tstruct kvm_memory_slot *slot;\n\tstruct kvm_lpage_info *linfo;\n\tkvm_pfn_t pfn = *pfnp;\n\tkvm_pfn_t mask;\n\tint level;\n\n\tif (unlikely(max_level == PT_PAGE_TABLE_LEVEL))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tif (is_error_noslot_pfn(pfn) || kvm_is_reserved_pfn(pfn))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, true);\n\tif (!slot)\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tmax_level = min(max_level, max_page_level);\n\tfor ( ; max_level > PT_PAGE_TABLE_LEVEL; max_level--) {\n\t\tlinfo = lpage_info_slot(gfn, slot, max_level);\n\t\tif (!linfo->disallow_lpage)\n\t\t\tbreak;\n\t}\n\n\tif (max_level == PT_PAGE_TABLE_LEVEL)\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tlevel = host_pfn_mapping_level(vcpu, gfn, pfn, slot);\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn level;\n\n\tlevel = min(level, max_level);\n\n\t/*\n\t * mmu_notifier_retry() was successful and mmu_lock is held, so\n\t * the pmd can't be split from under us.\n\t */\n\tmask = KVM_PAGES_PER_HPAGE(level) - 1;\n\tVM_BUG_ON((gfn & mask) != (pfn & mask));\n\t*pfnp = pfn & ~mask;\n\n\treturn level;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int max_page_level",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VM_BUG_ON",
          "args": [
            "(gfn & mask) != (pfn & mask)"
          ],
          "line": 3308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "level"
          ],
          "line": 3307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "level",
            "max_level"
          ],
          "line": 3301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "host_pfn_mapping_level",
          "args": [
            "vcpu",
            "gfn",
            "pfn",
            "slot"
          ],
          "line": 3297
        },
        "resolved": true,
        "details": {
          "function_name": "host_pfn_mapping_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3237-3266",
          "snippet": "static int host_pfn_mapping_level(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t  kvm_pfn_t pfn, struct kvm_memory_slot *slot)\n{\n\tunsigned long hva;\n\tpte_t *pte;\n\tint level;\n\n\tBUILD_BUG_ON(PT_PAGE_TABLE_LEVEL != (int)PG_LEVEL_4K ||\n\t\t     PT_DIRECTORY_LEVEL != (int)PG_LEVEL_2M ||\n\t\t     PT_PDPE_LEVEL != (int)PG_LEVEL_1G);\n\n\tif (!PageCompound(pfn_to_page(pfn)) && !kvm_is_zone_device_pfn(pfn))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\t/*\n\t * Note, using the already-retrieved memslot and __gfn_to_hva_memslot()\n\t * is not solely for performance, it's also necessary to avoid the\n\t * \"writable\" check in __gfn_to_hva_many(), which will always fail on\n\t * read-only memslots due to gfn_to_hva() assuming writes.  Earlier\n\t * page fault steps have already verified the guest isn't writing a\n\t * read-only memslot.\n\t */\n\thva = __gfn_to_hva_memslot(slot, gfn);\n\n\tpte = lookup_address_in_mm(vcpu->kvm->mm, hva, &level);\n\tif (unlikely(!pte))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\treturn level;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int host_pfn_mapping_level(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t  kvm_pfn_t pfn, struct kvm_memory_slot *slot)\n{\n\tunsigned long hva;\n\tpte_t *pte;\n\tint level;\n\n\tBUILD_BUG_ON(PT_PAGE_TABLE_LEVEL != (int)PG_LEVEL_4K ||\n\t\t     PT_DIRECTORY_LEVEL != (int)PG_LEVEL_2M ||\n\t\t     PT_PDPE_LEVEL != (int)PG_LEVEL_1G);\n\n\tif (!PageCompound(pfn_to_page(pfn)) && !kvm_is_zone_device_pfn(pfn))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\t/*\n\t * Note, using the already-retrieved memslot and __gfn_to_hva_memslot()\n\t * is not solely for performance, it's also necessary to avoid the\n\t * \"writable\" check in __gfn_to_hva_many(), which will always fail on\n\t * read-only memslots due to gfn_to_hva() assuming writes.  Earlier\n\t * page fault steps have already verified the guest isn't writing a\n\t * read-only memslot.\n\t */\n\thva = __gfn_to_hva_memslot(slot, gfn);\n\n\tpte = lookup_address_in_mm(vcpu->kvm->mm, hva, &level);\n\tif (unlikely(!pte))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\treturn level;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lpage_info_slot",
          "args": [
            "gfn",
            "slot",
            "max_level"
          ],
          "line": 3289
        },
        "resolved": true,
        "details": {
          "function_name": "lpage_info_slot",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1183-1191",
          "snippet": "static struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max_level",
            "max_page_level"
          ],
          "line": 3287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_memslot_dirty_bitmap",
          "args": [
            "vcpu",
            "gfn",
            "true"
          ],
          "line": 3283
        },
        "resolved": true,
        "details": {
          "function_name": "gfn_to_memslot_dirty_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1270-1283",
          "snippet": "static struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn NULL;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn NULL;\n\n\treturn slot;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn NULL;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn NULL;\n\n\treturn slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_is_reserved_pfn",
          "args": [
            "pfn"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_noslot_pfn",
          "args": [
            "pfn"
          ],
          "line": 3280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "max_level == PT_PAGE_TABLE_LEVEL"
          ],
          "line": 3277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int max_page_level;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int kvm_mmu_hugepage_adjust(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   int max_level, kvm_pfn_t *pfnp)\n{\n\tstruct kvm_memory_slot *slot;\n\tstruct kvm_lpage_info *linfo;\n\tkvm_pfn_t pfn = *pfnp;\n\tkvm_pfn_t mask;\n\tint level;\n\n\tif (unlikely(max_level == PT_PAGE_TABLE_LEVEL))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tif (is_error_noslot_pfn(pfn) || kvm_is_reserved_pfn(pfn))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, true);\n\tif (!slot)\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tmax_level = min(max_level, max_page_level);\n\tfor ( ; max_level > PT_PAGE_TABLE_LEVEL; max_level--) {\n\t\tlinfo = lpage_info_slot(gfn, slot, max_level);\n\t\tif (!linfo->disallow_lpage)\n\t\t\tbreak;\n\t}\n\n\tif (max_level == PT_PAGE_TABLE_LEVEL)\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\tlevel = host_pfn_mapping_level(vcpu, gfn, pfn, slot);\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn level;\n\n\tlevel = min(level, max_level);\n\n\t/*\n\t * mmu_notifier_retry() was successful and mmu_lock is held, so\n\t * the pmd can't be split from under us.\n\t */\n\tmask = KVM_PAGES_PER_HPAGE(level) - 1;\n\tVM_BUG_ON((gfn & mask) != (pfn & mask));\n\t*pfnp = pfn & ~mask;\n\n\treturn level;\n}"
  },
  {
    "function_name": "host_pfn_mapping_level",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3237-3266",
    "snippet": "static int host_pfn_mapping_level(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t  kvm_pfn_t pfn, struct kvm_memory_slot *slot)\n{\n\tunsigned long hva;\n\tpte_t *pte;\n\tint level;\n\n\tBUILD_BUG_ON(PT_PAGE_TABLE_LEVEL != (int)PG_LEVEL_4K ||\n\t\t     PT_DIRECTORY_LEVEL != (int)PG_LEVEL_2M ||\n\t\t     PT_PDPE_LEVEL != (int)PG_LEVEL_1G);\n\n\tif (!PageCompound(pfn_to_page(pfn)) && !kvm_is_zone_device_pfn(pfn))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\t/*\n\t * Note, using the already-retrieved memslot and __gfn_to_hva_memslot()\n\t * is not solely for performance, it's also necessary to avoid the\n\t * \"writable\" check in __gfn_to_hva_many(), which will always fail on\n\t * read-only memslots due to gfn_to_hva() assuming writes.  Earlier\n\t * page fault steps have already verified the guest isn't writing a\n\t * read-only memslot.\n\t */\n\thva = __gfn_to_hva_memslot(slot, gfn);\n\n\tpte = lookup_address_in_mm(vcpu->kvm->mm, hva, &level);\n\tif (unlikely(!pte))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\treturn level;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!pte"
          ],
          "line": 3262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_address_in_mm",
          "args": [
            "vcpu->kvm->mm",
            "hva",
            "&level"
          ],
          "line": 3261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__gfn_to_hva_memslot",
          "args": [
            "slot",
            "gfn"
          ],
          "line": 3259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_zone_device_pfn",
          "args": [
            "pfn"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageCompound",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 3248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PT_PAGE_TABLE_LEVEL != (int)PG_LEVEL_4K ||\n\t\t     PT_DIRECTORY_LEVEL != (int)PG_LEVEL_2M ||\n\t\t     PT_PDPE_LEVEL != (int)PG_LEVEL_1G"
          ],
          "line": 3244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int host_pfn_mapping_level(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t  kvm_pfn_t pfn, struct kvm_memory_slot *slot)\n{\n\tunsigned long hva;\n\tpte_t *pte;\n\tint level;\n\n\tBUILD_BUG_ON(PT_PAGE_TABLE_LEVEL != (int)PG_LEVEL_4K ||\n\t\t     PT_DIRECTORY_LEVEL != (int)PG_LEVEL_2M ||\n\t\t     PT_PDPE_LEVEL != (int)PG_LEVEL_1G);\n\n\tif (!PageCompound(pfn_to_page(pfn)) && !kvm_is_zone_device_pfn(pfn))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\t/*\n\t * Note, using the already-retrieved memslot and __gfn_to_hva_memslot()\n\t * is not solely for performance, it's also necessary to avoid the\n\t * \"writable\" check in __gfn_to_hva_many(), which will always fail on\n\t * read-only memslots due to gfn_to_hva() assuming writes.  Earlier\n\t * page fault steps have already verified the guest isn't writing a\n\t * read-only memslot.\n\t */\n\thva = __gfn_to_hva_memslot(slot, gfn);\n\n\tpte = lookup_address_in_mm(vcpu->kvm->mm, hva, &level);\n\tif (unlikely(!pte))\n\t\treturn PT_PAGE_TABLE_LEVEL;\n\n\treturn level;\n}"
  },
  {
    "function_name": "direct_pte_prefetch",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3217-3235",
    "snippet": "static void direct_pte_prefetch(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(sptep));\n\n\t/*\n\t * Without accessed bits, there's no way to distinguish between\n\t * actually accessed translations and prefetched, so disable pte\n\t * prefetch if accessed bits aren't available.\n\t */\n\tif (sp_ad_disabled(sp))\n\t\treturn;\n\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\t__direct_pte_prefetch(vcpu, sp, sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__direct_pte_prefetch",
          "args": [
            "vcpu",
            "sp",
            "sptep"
          ],
          "line": 3234
        },
        "resolved": true,
        "details": {
          "function_name": "__direct_pte_prefetch",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3194-3215",
          "snippet": "static void __direct_pte_prefetch(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *sptep)\n{\n\tu64 *spte, *start = NULL;\n\tint i;\n\n\tWARN_ON(!sp->role.direct);\n\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (is_shadow_present_pte(*spte) || spte == sptep) {\n\t\t\tif (!start)\n\t\t\t\tcontinue;\n\t\t\tif (direct_pte_prefetch_many(vcpu, sp, start, spte) < 0)\n\t\t\t\tbreak;\n\t\t\tstart = NULL;\n\t\t} else if (!start)\n\t\t\tstart = spte;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_PREFETCH_NUM\t\t8"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __direct_pte_prefetch(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *sptep)\n{\n\tu64 *spte, *start = NULL;\n\tint i;\n\n\tWARN_ON(!sp->role.direct);\n\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (is_shadow_present_pte(*spte) || spte == sptep) {\n\t\t\tif (!start)\n\t\t\t\tcontinue;\n\t\t\tif (direct_pte_prefetch_many(vcpu, sp, start, spte) < 0)\n\t\t\t\tbreak;\n\t\t\tstart = NULL;\n\t\t} else if (!start)\n\t\t\tstart = spte;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sp_ad_disabled",
          "args": [
            "sp"
          ],
          "line": 3228
        },
        "resolved": true,
        "details": {
          "function_name": "sp_ad_disabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "349-352",
          "snippet": "static inline bool sp_ad_disabled(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.ad_disabled;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool sp_ad_disabled(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.ad_disabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 3221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void direct_pte_prefetch(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(sptep));\n\n\t/*\n\t * Without accessed bits, there's no way to distinguish between\n\t * actually accessed translations and prefetched, so disable pte\n\t * prefetch if accessed bits aren't available.\n\t */\n\tif (sp_ad_disabled(sp))\n\t\treturn;\n\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn;\n\n\t__direct_pte_prefetch(vcpu, sp, sptep);\n}"
  },
  {
    "function_name": "__direct_pte_prefetch",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3194-3215",
    "snippet": "static void __direct_pte_prefetch(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *sptep)\n{\n\tu64 *spte, *start = NULL;\n\tint i;\n\n\tWARN_ON(!sp->role.direct);\n\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (is_shadow_present_pte(*spte) || spte == sptep) {\n\t\t\tif (!start)\n\t\t\t\tcontinue;\n\t\t\tif (direct_pte_prefetch_many(vcpu, sp, start, spte) < 0)\n\t\t\t\tbreak;\n\t\t\tstart = NULL;\n\t\t} else if (!start)\n\t\t\tstart = spte;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_PREFETCH_NUM\t\t8"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "direct_pte_prefetch_many",
          "args": [
            "vcpu",
            "sp",
            "start",
            "spte"
          ],
          "line": 3209
        },
        "resolved": true,
        "details": {
          "function_name": "direct_pte_prefetch_many",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3166-3192",
          "snippet": "static int direct_pte_prefetch_many(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp,\n\t\t\t\t    u64 *start, u64 *end)\n{\n\tstruct page *pages[PTE_PREFETCH_NUM];\n\tstruct kvm_memory_slot *slot;\n\tunsigned int access = sp->role.access;\n\tint i, ret;\n\tgfn_t gfn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, start - sp->spt);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, access & ACC_WRITE_MASK);\n\tif (!slot)\n\t\treturn -1;\n\n\tret = gfn_to_page_many_atomic(slot, gfn, pages, end - start);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ret; i++, gfn++, start++) {\n\t\tmmu_set_spte(vcpu, start, access, 0, sp->role.level, gfn,\n\t\t\t     page_to_pfn(pages[i]), true, true);\n\t\tput_page(pages[i]);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
            "#define PTE_PREFETCH_NUM\t\t8"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int direct_pte_prefetch_many(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp,\n\t\t\t\t    u64 *start, u64 *end)\n{\n\tstruct page *pages[PTE_PREFETCH_NUM];\n\tstruct kvm_memory_slot *slot;\n\tunsigned int access = sp->role.access;\n\tint i, ret;\n\tgfn_t gfn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, start - sp->spt);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, access & ACC_WRITE_MASK);\n\tif (!slot)\n\t\treturn -1;\n\n\tret = gfn_to_page_many_atomic(slot, gfn, pages, end - start);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ret; i++, gfn++, start++) {\n\t\tmmu_set_spte(vcpu, start, access, 0, sp->role.level, gfn,\n\t\t\t     page_to_pfn(pages[i]), true, true);\n\t\tput_page(pages[i]);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*spte"
          ],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sp->role.direct"
          ],
          "line": 3200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __direct_pte_prefetch(struct kvm_vcpu *vcpu,\n\t\t\t\t  struct kvm_mmu_page *sp, u64 *sptep)\n{\n\tu64 *spte, *start = NULL;\n\tint i;\n\n\tWARN_ON(!sp->role.direct);\n\n\ti = (sptep - sp->spt) & ~(PTE_PREFETCH_NUM - 1);\n\tspte = sp->spt + i;\n\n\tfor (i = 0; i < PTE_PREFETCH_NUM; i++, spte++) {\n\t\tif (is_shadow_present_pte(*spte) || spte == sptep) {\n\t\t\tif (!start)\n\t\t\t\tcontinue;\n\t\t\tif (direct_pte_prefetch_many(vcpu, sp, start, spte) < 0)\n\t\t\t\tbreak;\n\t\t\tstart = NULL;\n\t\t} else if (!start)\n\t\t\tstart = spte;\n\t}\n}"
  },
  {
    "function_name": "direct_pte_prefetch_many",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3166-3192",
    "snippet": "static int direct_pte_prefetch_many(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp,\n\t\t\t\t    u64 *start, u64 *end)\n{\n\tstruct page *pages[PTE_PREFETCH_NUM];\n\tstruct kvm_memory_slot *slot;\n\tunsigned int access = sp->role.access;\n\tint i, ret;\n\tgfn_t gfn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, start - sp->spt);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, access & ACC_WRITE_MASK);\n\tif (!slot)\n\t\treturn -1;\n\n\tret = gfn_to_page_many_atomic(slot, gfn, pages, end - start);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ret; i++, gfn++, start++) {\n\t\tmmu_set_spte(vcpu, start, access, 0, sp->role.level, gfn,\n\t\t\t     page_to_pfn(pages[i]), true, true);\n\t\tput_page(pages[i]);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
      "#define PTE_PREFETCH_NUM\t\t8"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "pages[i]"
          ],
          "line": 3188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_set_spte",
          "args": [
            "vcpu",
            "start",
            "access",
            "0",
            "sp->role.level",
            "gfn",
            "page_to_pfn(pages[i])",
            "true",
            "true"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_set_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3087-3152",
          "snippet": "static int mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\tunsigned int pte_access, int write_fault, int level,\n\t\t\tgfn_t gfn, kvm_pfn_t pfn, bool speculative,\n\t\t\tbool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tint set_spte_ret;\n\tint ret = RET_PF_RETRY;\n\tbool flush = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tflush = true;\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tflush = true;\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tset_spte_ret = set_spte(vcpu, sptep, pte_access, level, gfn, pfn,\n\t\t\t\tspeculative, true, host_writable);\n\tif (set_spte_ret & SET_SPTE_WRITE_PROTECTED_PT) {\n\t\tif (write_fault)\n\t\t\tret = RET_PF_EMULATE;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (set_spte_ret & SET_SPTE_NEED_REMOTE_TLB_FLUSH || flush)\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn,\n\t\t\t\tKVM_PAGES_PER_HPAGE(level));\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\tret = RET_PF_EMULATE;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\ttrace_kvm_mmu_set_spte(level, gfn, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SET_SPTE_NEED_REMOTE_TLB_FLUSH\tBIT(1)",
            "#define SET_SPTE_WRITE_PROTECTED_PT\tBIT(0)",
            "#define RMAP_RECYCLE_THRESHOLD 1000",
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SET_SPTE_NEED_REMOTE_TLB_FLUSH\tBIT(1)\n#define SET_SPTE_WRITE_PROTECTED_PT\tBIT(0)\n#define RMAP_RECYCLE_THRESHOLD 1000\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\tunsigned int pte_access, int write_fault, int level,\n\t\t\tgfn_t gfn, kvm_pfn_t pfn, bool speculative,\n\t\t\tbool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tint set_spte_ret;\n\tint ret = RET_PF_RETRY;\n\tbool flush = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tflush = true;\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tflush = true;\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tset_spte_ret = set_spte(vcpu, sptep, pte_access, level, gfn, pfn,\n\t\t\t\tspeculative, true, host_writable);\n\tif (set_spte_ret & SET_SPTE_WRITE_PROTECTED_PT) {\n\t\tif (write_fault)\n\t\t\tret = RET_PF_EMULATE;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (set_spte_ret & SET_SPTE_NEED_REMOTE_TLB_FLUSH || flush)\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn,\n\t\t\t\tKVM_PAGES_PER_HPAGE(level));\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\tret = RET_PF_EMULATE;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\ttrace_kvm_mmu_set_spte(level, gfn, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "pages[i]"
          ],
          "line": 3187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_page_many_atomic",
          "args": [
            "slot",
            "gfn",
            "pages",
            "end - start"
          ],
          "line": 3181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_memslot_dirty_bitmap",
          "args": [
            "vcpu",
            "gfn",
            "access & ACC_WRITE_MASK"
          ],
          "line": 3177
        },
        "resolved": true,
        "details": {
          "function_name": "gfn_to_memslot_dirty_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1270-1283",
          "snippet": "static struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn NULL;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn NULL;\n\n\treturn slot;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn NULL;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn NULL;\n\n\treturn slot;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "sp",
            "start - sp->spt"
          ],
          "line": 3176
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1157-1163",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int direct_pte_prefetch_many(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp,\n\t\t\t\t    u64 *start, u64 *end)\n{\n\tstruct page *pages[PTE_PREFETCH_NUM];\n\tstruct kvm_memory_slot *slot;\n\tunsigned int access = sp->role.access;\n\tint i, ret;\n\tgfn_t gfn;\n\n\tgfn = kvm_mmu_page_get_gfn(sp, start - sp->spt);\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, access & ACC_WRITE_MASK);\n\tif (!slot)\n\t\treturn -1;\n\n\tret = gfn_to_page_many_atomic(slot, gfn, pages, end - start);\n\tif (ret <= 0)\n\t\treturn -1;\n\n\tfor (i = 0; i < ret; i++, gfn++, start++) {\n\t\tmmu_set_spte(vcpu, start, access, 0, sp->role.level, gfn,\n\t\t\t     page_to_pfn(pages[i]), true, true);\n\t\tput_page(pages[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "pte_prefetch_gfn_to_pfn",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3154-3164",
    "snippet": "static kvm_pfn_t pte_prefetch_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t     bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, no_dirty_log);\n\tif (!slot)\n\t\treturn KVM_PFN_ERR_FAULT;\n\n\treturn gfn_to_pfn_memslot_atomic(slot, gfn);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfn_to_pfn_memslot_atomic",
          "args": [
            "slot",
            "gfn"
          ],
          "line": 3163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_memslot_dirty_bitmap",
          "args": [
            "vcpu",
            "gfn",
            "no_dirty_log"
          ],
          "line": 3159
        },
        "resolved": true,
        "details": {
          "function_name": "gfn_to_memslot_dirty_bitmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1270-1283",
          "snippet": "static struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn NULL;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn NULL;\n\n\treturn slot;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn NULL;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn NULL;\n\n\treturn slot;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic kvm_pfn_t pte_prefetch_gfn_to_pfn(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t     bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = gfn_to_memslot_dirty_bitmap(vcpu, gfn, no_dirty_log);\n\tif (!slot)\n\t\treturn KVM_PFN_ERR_FAULT;\n\n\treturn gfn_to_pfn_memslot_atomic(slot, gfn);\n}"
  },
  {
    "function_name": "mmu_set_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "3087-3152",
    "snippet": "static int mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\tunsigned int pte_access, int write_fault, int level,\n\t\t\tgfn_t gfn, kvm_pfn_t pfn, bool speculative,\n\t\t\tbool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tint set_spte_ret;\n\tint ret = RET_PF_RETRY;\n\tbool flush = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tflush = true;\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tflush = true;\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tset_spte_ret = set_spte(vcpu, sptep, pte_access, level, gfn, pfn,\n\t\t\t\tspeculative, true, host_writable);\n\tif (set_spte_ret & SET_SPTE_WRITE_PROTECTED_PT) {\n\t\tif (write_fault)\n\t\t\tret = RET_PF_EMULATE;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (set_spte_ret & SET_SPTE_NEED_REMOTE_TLB_FLUSH || flush)\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn,\n\t\t\t\tKVM_PAGES_PER_HPAGE(level));\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\tret = RET_PF_EMULATE;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\ttrace_kvm_mmu_set_spte(level, gfn, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SET_SPTE_NEED_REMOTE_TLB_FLUSH\tBIT(1)",
      "#define SET_SPTE_WRITE_PROTECTED_PT\tBIT(0)",
      "#define RMAP_RECYCLE_THRESHOLD 1000",
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
      "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_recycle",
          "args": [
            "vcpu",
            "sptep",
            "gfn"
          ],
          "line": 3147
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_recycle",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2014-2026",
          "snippet": "static void rmap_recycle(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(spte));\n\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\n\tkvm_unmap_rmapp(vcpu->kvm, rmap_head, NULL, gfn, sp->role.level, 0);\n\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, sp->gfn,\n\t\t\tKVM_PAGES_PER_HPAGE(sp->role.level));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void rmap_recycle(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(spte));\n\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\n\tkvm_unmap_rmapp(vcpu->kvm, rmap_head, NULL, gfn, sp->role.level, 0);\n\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, sp->gfn,\n\t\t\tKVM_PAGES_PER_HPAGE(sp->role.level));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_add",
          "args": [
            "vcpu",
            "sptep",
            "gfn"
          ],
          "line": 3145
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_add",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1423-1432",
          "snippet": "static int rmap_add(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tkvm_mmu_page_set_gfn(sp, spte - sp->spt, gfn);\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\treturn pte_list_add(vcpu, spte, rmap_head);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int rmap_add(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tkvm_mmu_page_set_gfn(sp, spte - sp->spt, gfn);\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\treturn pte_list_add(vcpu, spte, rmap_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 3143
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "*sptep"
          ],
          "line": 3140
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "616-619",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_set_spte",
          "args": [
            "level",
            "gfn",
            "sptep"
          ],
          "line": 3139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: setting spte %llx\\n\"",
            "__func__",
            "*sptep"
          ],
          "line": 3138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_mmio_spte(*sptep)"
          ],
          "line": 3135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "*sptep"
          ],
          "line": 3135
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "344-347",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs_with_address",
          "args": [
            "vcpu->kvm",
            "gfn",
            "KVM_PAGES_PER_HPAGE(level)"
          ],
          "line": 3132
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_flush_remote_tlbs_with_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "323-332",
          "snippet": "static void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "level"
          ],
          "line": 3133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 3128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_spte",
          "args": [
            "vcpu",
            "sptep",
            "pte_access",
            "level",
            "gfn",
            "pfn",
            "speculative",
            "true",
            "host_writable"
          ],
          "line": 3123
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_set_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "3087-3152",
          "snippet": "static int mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\tunsigned int pte_access, int write_fault, int level,\n\t\t\tgfn_t gfn, kvm_pfn_t pfn, bool speculative,\n\t\t\tbool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tint set_spte_ret;\n\tint ret = RET_PF_RETRY;\n\tbool flush = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tflush = true;\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tflush = true;\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tset_spte_ret = set_spte(vcpu, sptep, pte_access, level, gfn, pfn,\n\t\t\t\tspeculative, true, host_writable);\n\tif (set_spte_ret & SET_SPTE_WRITE_PROTECTED_PT) {\n\t\tif (write_fault)\n\t\t\tret = RET_PF_EMULATE;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (set_spte_ret & SET_SPTE_NEED_REMOTE_TLB_FLUSH || flush)\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn,\n\t\t\t\tKVM_PAGES_PER_HPAGE(level));\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\tret = RET_PF_EMULATE;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\ttrace_kvm_mmu_set_spte(level, gfn, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "drop_spte",
          "args": [
            "vcpu->kvm",
            "sptep"
          ],
          "line": 3117
        },
        "resolved": true,
        "details": {
          "function_name": "drop_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1522-1526",
          "snippet": "static void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"hfn old %llx new %llx\\n\"",
            "spte_to_pfn(*sptep)",
            "pfn"
          ],
          "line": 3115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_to_pfn",
          "args": [
            "*sptep"
          ],
          "line": 3116
        },
        "resolved": true,
        "details": {
          "function_name": "spte_to_pfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "635-638",
          "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_parent_pte",
          "args": [
            "child",
            "sptep"
          ],
          "line": 3112
        },
        "resolved": true,
        "details": {
          "function_name": "drop_parent_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2097-2102",
          "snippet": "static void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "pte & PT64_BASE_ADDR_MASK"
          ],
          "line": 3111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: spte %llx write_fault %d gfn %llx\\n\"",
            "__func__",
            "*sptep",
            "write_fault",
            "gfn"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SET_SPTE_NEED_REMOTE_TLB_FLUSH\tBIT(1)\n#define SET_SPTE_WRITE_PROTECTED_PT\tBIT(0)\n#define RMAP_RECYCLE_THRESHOLD 1000\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int mmu_set_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\tunsigned int pte_access, int write_fault, int level,\n\t\t\tgfn_t gfn, kvm_pfn_t pfn, bool speculative,\n\t\t\tbool host_writable)\n{\n\tint was_rmapped = 0;\n\tint rmap_count;\n\tint set_spte_ret;\n\tint ret = RET_PF_RETRY;\n\tbool flush = false;\n\n\tpgprintk(\"%s: spte %llx write_fault %d gfn %llx\\n\", __func__,\n\t\t *sptep, write_fault, gfn);\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\t/*\n\t\t * If we overwrite a PTE page pointer with a 2MB PMD, unlink\n\t\t * the parent of the now unreachable PTE.\n\t\t */\n\t\tif (level > PT_PAGE_TABLE_LEVEL &&\n\t\t    !is_large_pte(*sptep)) {\n\t\t\tstruct kvm_mmu_page *child;\n\t\t\tu64 pte = *sptep;\n\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, sptep);\n\t\t\tflush = true;\n\t\t} else if (pfn != spte_to_pfn(*sptep)) {\n\t\t\tpgprintk(\"hfn old %llx new %llx\\n\",\n\t\t\t\t spte_to_pfn(*sptep), pfn);\n\t\t\tdrop_spte(vcpu->kvm, sptep);\n\t\t\tflush = true;\n\t\t} else\n\t\t\twas_rmapped = 1;\n\t}\n\n\tset_spte_ret = set_spte(vcpu, sptep, pte_access, level, gfn, pfn,\n\t\t\t\tspeculative, true, host_writable);\n\tif (set_spte_ret & SET_SPTE_WRITE_PROTECTED_PT) {\n\t\tif (write_fault)\n\t\t\tret = RET_PF_EMULATE;\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t}\n\n\tif (set_spte_ret & SET_SPTE_NEED_REMOTE_TLB_FLUSH || flush)\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn,\n\t\t\t\tKVM_PAGES_PER_HPAGE(level));\n\n\tif (unlikely(is_mmio_spte(*sptep)))\n\t\tret = RET_PF_EMULATE;\n\n\tpgprintk(\"%s: setting spte %llx\\n\", __func__, *sptep);\n\ttrace_kvm_mmu_set_spte(level, gfn, sptep);\n\tif (!was_rmapped && is_large_pte(*sptep))\n\t\t++vcpu->kvm->stat.lpages;\n\n\tif (is_shadow_present_pte(*sptep)) {\n\t\tif (!was_rmapped) {\n\t\t\trmap_count = rmap_add(vcpu, sptep, gfn);\n\t\t\tif (rmap_count > RMAP_RECYCLE_THRESHOLD)\n\t\t\t\trmap_recycle(vcpu, sptep, gfn);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "set_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2995-3085",
    "snippet": "static int set_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t    unsigned int pte_access, int level,\n\t\t    gfn_t gfn, kvm_pfn_t pfn, bool speculative,\n\t\t    bool can_unsync, bool host_writable)\n{\n\tu64 spte = 0;\n\tint ret = 0;\n\tstruct kvm_mmu_page *sp;\n\n\tif (set_mmio_spte(vcpu, sptep, gfn, pfn, pte_access))\n\t\treturn 0;\n\n\tsp = page_header(__pa(sptep));\n\tif (sp_ad_disabled(sp))\n\t\tspte |= SPTE_AD_DISABLED_MASK;\n\telse if (kvm_vcpu_ad_need_write_protect(vcpu))\n\t\tspte |= SPTE_AD_WRPROT_ONLY_MASK;\n\n\t/*\n\t * For the EPT case, shadow_present_mask is 0 if hardware\n\t * supports exec-only page table entries.  In that case,\n\t * ACC_USER_MASK and shadow_user_mask are used to represent\n\t * read access.  See FNAME(gpte_access) in paging_tmpl.h.\n\t */\n\tspte |= shadow_present_mask;\n\tif (!speculative)\n\t\tspte |= spte_shadow_accessed_mask(spte);\n\n\tif (level > PT_PAGE_TABLE_LEVEL && (pte_access & ACC_EXEC_MASK) &&\n\t    is_nx_huge_page_enabled()) {\n\t\tpte_access &= ~ACC_EXEC_MASK;\n\t}\n\n\tif (pte_access & ACC_EXEC_MASK)\n\t\tspte |= shadow_x_mask;\n\telse\n\t\tspte |= shadow_nx_mask;\n\n\tif (pte_access & ACC_USER_MASK)\n\t\tspte |= shadow_user_mask;\n\n\tif (level > PT_PAGE_TABLE_LEVEL)\n\t\tspte |= PT_PAGE_SIZE_MASK;\n\tif (tdp_enabled)\n\t\tspte |= kvm_x86_ops.get_mt_mask(vcpu, gfn,\n\t\t\tkvm_is_mmio_pfn(pfn));\n\n\tif (host_writable)\n\t\tspte |= SPTE_HOST_WRITEABLE;\n\telse\n\t\tpte_access &= ~ACC_WRITE_MASK;\n\n\tif (!kvm_is_mmio_pfn(pfn))\n\t\tspte |= shadow_me_mask;\n\n\tspte |= (u64)pfn << PAGE_SHIFT;\n\n\tif (pte_access & ACC_WRITE_MASK) {\n\t\tspte |= PT_WRITABLE_MASK | SPTE_MMU_WRITEABLE;\n\n\t\t/*\n\t\t * Optimization: for pte sync, if spte was writable the hash\n\t\t * lookup is unnecessary (and expensive). Write protection\n\t\t * is responsibility of mmu_get_page / kvm_sync_page.\n\t\t * Same reasoning can be applied to dirty page accounting.\n\t\t */\n\t\tif (!can_unsync && is_writable_pte(*sptep))\n\t\t\tgoto set_pte;\n\n\t\tif (mmu_need_write_protect(vcpu, gfn, can_unsync)) {\n\t\t\tpgprintk(\"%s: found shadow page for %llx, marking ro\\n\",\n\t\t\t\t __func__, gfn);\n\t\t\tret |= SET_SPTE_WRITE_PROTECTED_PT;\n\t\t\tpte_access &= ~ACC_WRITE_MASK;\n\t\t\tspte &= ~(PT_WRITABLE_MASK | SPTE_MMU_WRITEABLE);\n\t\t}\n\t}\n\n\tif (pte_access & ACC_WRITE_MASK) {\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t\tspte |= spte_shadow_dirty_mask(spte);\n\t}\n\n\tif (speculative)\n\t\tspte = mark_spte_for_access_track(spte);\n\nset_pte:\n\tif (mmu_spte_update(sptep, spte))\n\t\tret |= SET_SPTE_NEED_REMOTE_TLB_FLUSH;\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SET_SPTE_NEED_REMOTE_TLB_FLUSH\tBIT(1)",
      "#define SET_SPTE_WRITE_PROTECTED_PT\tBIT(0)",
      "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
      "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)",
      "#define ACC_USER_MASK    PT_USER_MASK",
      "#define ACC_WRITE_MASK   PT_WRITABLE_MASK",
      "#define ACC_EXEC_MASK    1",
      "#define SPTE_AD_WRPROT_ONLY_MASK (2ULL << 52)",
      "#define SPTE_AD_DISABLED_MASK (1ULL << 52)"
    ],
    "globals_used": [
      "bool tdp_enabled = false;",
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_update",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 3082
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "877-910",
          "snippet": "static bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tbool flush = false;\n\tu64 old_spte = mmu_spte_update_no_track(sptep, new_spte);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn false;\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_can_locklessly_be_made_writable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tflush = true;\n\n\t/*\n\t * Flush TLB when accessed/dirty states are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\n\tif (is_accessed_spte(old_spte) && !is_accessed_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\t}\n\n\tif (is_dirty_spte(old_spte) && !is_dirty_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t}\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tbool flush = false;\n\tu64 old_spte = mmu_spte_update_no_track(sptep, new_spte);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn false;\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_can_locklessly_be_made_writable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tflush = true;\n\n\t/*\n\t * Flush TLB when accessed/dirty states are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\n\tif (is_accessed_spte(old_spte) && !is_accessed_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\t}\n\n\tif (is_dirty_spte(old_spte) && !is_dirty_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t}\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_spte_for_access_track",
          "args": [
            "spte"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "mark_spte_for_access_track",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "964-990",
          "snippet": "static u64 mark_spte_for_access_track(u64 spte)\n{\n\tif (spte_ad_enabled(spte))\n\t\treturn spte & ~shadow_accessed_mask;\n\n\tif (is_access_track_spte(spte))\n\t\treturn spte;\n\n\t/*\n\t * Making an Access Tracking PTE will result in removal of write access\n\t * from the PTE. So, verify that we will be able to restore the write\n\t * access in the fast page fault path later on.\n\t */\n\tWARN_ONCE((spte & PT_WRITABLE_MASK) &&\n\t\t  !spte_can_locklessly_be_made_writable(spte),\n\t\t  \"kvm: Writable SPTE is not locklessly dirty-trackable\\n\");\n\n\tWARN_ONCE(spte & (shadow_acc_track_saved_bits_mask <<\n\t\t\t  shadow_acc_track_saved_bits_shift),\n\t\t  \"kvm: Access Tracking saved bit locations are not zero\\n\");\n\n\tspte |= (spte & shadow_acc_track_saved_bits_mask) <<\n\t\tshadow_acc_track_saved_bits_shift;\n\tspte &= ~shadow_acc_track_mask;\n\n\treturn spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;",
            "static const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;",
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;\nstatic const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 mark_spte_for_access_track(u64 spte)\n{\n\tif (spte_ad_enabled(spte))\n\t\treturn spte & ~shadow_accessed_mask;\n\n\tif (is_access_track_spte(spte))\n\t\treturn spte;\n\n\t/*\n\t * Making an Access Tracking PTE will result in removal of write access\n\t * from the PTE. So, verify that we will be able to restore the write\n\t * access in the fast page fault path later on.\n\t */\n\tWARN_ONCE((spte & PT_WRITABLE_MASK) &&\n\t\t  !spte_can_locklessly_be_made_writable(spte),\n\t\t  \"kvm: Writable SPTE is not locklessly dirty-trackable\\n\");\n\n\tWARN_ONCE(spte & (shadow_acc_track_saved_bits_mask <<\n\t\t\t  shadow_acc_track_saved_bits_shift),\n\t\t  \"kvm: Access Tracking saved bit locations are not zero\\n\");\n\n\tspte |= (spte & shadow_acc_track_saved_bits_mask) <<\n\t\tshadow_acc_track_saved_bits_shift;\n\tspte &= ~shadow_acc_track_mask;\n\n\treturn spte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_shadow_dirty_mask",
          "args": [
            "spte"
          ],
          "line": 3075
        },
        "resolved": true,
        "details": {
          "function_name": "spte_shadow_dirty_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "388-392",
          "snippet": "static inline u64 spte_shadow_dirty_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_dirty_mask : 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline u64 spte_shadow_dirty_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_dirty_mask : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_mark_page_dirty",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 3074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: found shadow page for %llx, marking ro\\n\"",
            "__func__",
            "gfn"
          ],
          "line": 3065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_need_write_protect",
          "args": [
            "vcpu",
            "gfn",
            "can_unsync"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_need_write_protect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2909-2968",
          "snippet": "static bool mmu_need_write_protect(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   bool can_unsync)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!can_unsync)\n\t\t\treturn true;\n\n\t\tif (sp->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tkvm_unsync_page(vcpu, sp);\n\t}\n\n\t/*\n\t * We need to ensure that the marking of unsync pages is visible\n\t * before the SPTE is updated to allow writes because\n\t * kvm_mmu_sync_roots() checks the unsync flags without holding\n\t * the MMU lock and so can race with this. If the SPTE was updated\n\t * before the page had been marked as unsync-ed, something like the\n\t * following could happen:\n\t *\n\t * CPU 1                    CPU 2\n\t * ---------------------------------------------------------------------\n\t * 1.2 Host updates SPTE\n\t *     to be writable\n\t *                      2.1 Guest writes a GPTE for GVA X.\n\t *                          (GPTE being in the guest page table shadowed\n\t *                           by the SP from CPU 1.)\n\t *                          This reads SPTE during the page table walk.\n\t *                          Since SPTE.W is read as 1, there is no\n\t *                          fault.\n\t *\n\t *                      2.2 Guest issues TLB flush.\n\t *                          That causes a VM Exit.\n\t *\n\t *                      2.3 kvm_mmu_sync_pages() reads sp->unsync.\n\t *                          Since it is false, so it just returns.\n\t *\n\t *                      2.4 Guest accesses GVA X.\n\t *                          Since the mapping in the SP was not updated,\n\t *                          so the old mapping for GVA X incorrectly\n\t *                          gets used.\n\t * 1.1 Host marks SP\n\t *     as unsync\n\t *     (sp->unsync = true)\n\t *\n\t * The write barrier below ensures that 1.1 happens before 1.2 and thus\n\t * the situation in 2.4 does not arise. The implicit barrier in 2.2\n\t * pairs with this write barrier.\n\t */\n\tsmp_wmb();\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool mmu_need_write_protect(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   bool can_unsync)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!can_unsync)\n\t\t\treturn true;\n\n\t\tif (sp->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tkvm_unsync_page(vcpu, sp);\n\t}\n\n\t/*\n\t * We need to ensure that the marking of unsync pages is visible\n\t * before the SPTE is updated to allow writes because\n\t * kvm_mmu_sync_roots() checks the unsync flags without holding\n\t * the MMU lock and so can race with this. If the SPTE was updated\n\t * before the page had been marked as unsync-ed, something like the\n\t * following could happen:\n\t *\n\t * CPU 1                    CPU 2\n\t * ---------------------------------------------------------------------\n\t * 1.2 Host updates SPTE\n\t *     to be writable\n\t *                      2.1 Guest writes a GPTE for GVA X.\n\t *                          (GPTE being in the guest page table shadowed\n\t *                           by the SP from CPU 1.)\n\t *                          This reads SPTE during the page table walk.\n\t *                          Since SPTE.W is read as 1, there is no\n\t *                          fault.\n\t *\n\t *                      2.2 Guest issues TLB flush.\n\t *                          That causes a VM Exit.\n\t *\n\t *                      2.3 kvm_mmu_sync_pages() reads sp->unsync.\n\t *                          Since it is false, so it just returns.\n\t *\n\t *                      2.4 Guest accesses GVA X.\n\t *                          Since the mapping in the SP was not updated,\n\t *                          so the old mapping for GVA X incorrectly\n\t *                          gets used.\n\t * 1.1 Host marks SP\n\t *     as unsync\n\t *     (sp->unsync = true)\n\t *\n\t * The write barrier below ensures that 1.1 happens before 1.2 and thus\n\t * the situation in 2.4 does not arise. The implicit barrier in 2.2\n\t * pairs with this write barrier.\n\t */\n\tsmp_wmb();\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "*sptep"
          ],
          "line": 3061
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "151-154",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_is_mmio_pfn",
          "args": [
            "pfn"
          ],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_is_mmio_pfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2970-2989",
          "snippet": "static bool kvm_is_mmio_pfn(kvm_pfn_t pfn)\n{\n\tif (pfn_valid(pfn))\n\t\treturn !is_zero_pfn(pfn) && PageReserved(pfn_to_page(pfn)) &&\n\t\t\t/*\n\t\t\t * Some reserved pages, such as those from NVDIMM\n\t\t\t * DAX devices, are not for MMIO, and can be mapped\n\t\t\t * with cached memory type for better performance.\n\t\t\t * However, the above check misconceives those pages\n\t\t\t * as MMIO, and results in KVM mapping them with UC\n\t\t\t * memory type, which would hurt the performance.\n\t\t\t * Therefore, we check the host memory type in addition\n\t\t\t * and only treat UC/UC-/WC pages as MMIO.\n\t\t\t */\n\t\t\t(!pat_enabled() || pat_pfn_immune_to_uc_mtrr(pfn));\n\n\treturn !e820__mapped_raw_any(pfn_to_hpa(pfn),\n\t\t\t\t     pfn_to_hpa(pfn + 1) - 1,\n\t\t\t\t     E820_TYPE_RAM);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_is_mmio_pfn(kvm_pfn_t pfn)\n{\n\tif (pfn_valid(pfn))\n\t\treturn !is_zero_pfn(pfn) && PageReserved(pfn_to_page(pfn)) &&\n\t\t\t/*\n\t\t\t * Some reserved pages, such as those from NVDIMM\n\t\t\t * DAX devices, are not for MMIO, and can be mapped\n\t\t\t * with cached memory type for better performance.\n\t\t\t * However, the above check misconceives those pages\n\t\t\t * as MMIO, and results in KVM mapping them with UC\n\t\t\t * memory type, which would hurt the performance.\n\t\t\t * Therefore, we check the host memory type in addition\n\t\t\t * and only treat UC/UC-/WC pages as MMIO.\n\t\t\t */\n\t\t\t(!pat_enabled() || pat_pfn_immune_to_uc_mtrr(pfn));\n\n\treturn !e820__mapped_raw_any(pfn_to_hpa(pfn),\n\t\t\t\t     pfn_to_hpa(pfn + 1) - 1,\n\t\t\t\t     E820_TYPE_RAM);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.get_mt_mask",
          "args": [
            "vcpu",
            "gfn",
            "kvm_is_mmio_pfn(pfn)"
          ],
          "line": 3039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_nx_huge_page_enabled",
          "args": [],
          "line": 3024
        },
        "resolved": true,
        "details": {
          "function_name": "is_nx_huge_page_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "377-380",
          "snippet": "static bool is_nx_huge_page_enabled(void)\n{\n\treturn READ_ONCE(nx_huge_pages);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool is_nx_huge_page_enabled(void)\n{\n\treturn READ_ONCE(nx_huge_pages);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_shadow_accessed_mask",
          "args": [
            "spte"
          ],
          "line": 3021
        },
        "resolved": true,
        "details": {
          "function_name": "spte_shadow_accessed_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "382-386",
          "snippet": "static inline u64 spte_shadow_accessed_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_accessed_mask : 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline u64 spte_shadow_accessed_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_accessed_mask : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_ad_need_write_protect",
          "args": [
            "vcpu"
          ],
          "line": 3010
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ad_need_write_protect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "354-363",
          "snippet": "static inline bool kvm_vcpu_ad_need_write_protect(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * When using the EPT page-modification log, the GPAs in the log\n\t * would come from L2 rather than L1.  Therefore, we need to rely\n\t * on write protection to record dirty pages.  This also bypasses\n\t * PML, since writes now result in a vmexit.\n\t */\n\treturn vcpu->arch.mmu == &vcpu->arch.guest_mmu;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic inline bool kvm_vcpu_ad_need_write_protect(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * When using the EPT page-modification log, the GPAs in the log\n\t * would come from L2 rather than L1.  Therefore, we need to rely\n\t * on write protection to record dirty pages.  This also bypasses\n\t * PML, since writes now result in a vmexit.\n\t */\n\treturn vcpu->arch.mmu == &vcpu->arch.guest_mmu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sp_ad_disabled",
          "args": [
            "sp"
          ],
          "line": 3008
        },
        "resolved": true,
        "details": {
          "function_name": "sp_ad_disabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "349-352",
          "snippet": "static inline bool sp_ad_disabled(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.ad_disabled;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool sp_ad_disabled(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.ad_disabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 3007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_mmio_spte",
          "args": [
            "vcpu",
            "sptep",
            "gfn",
            "pfn",
            "pte_access"
          ],
          "line": 3004
        },
        "resolved": true,
        "details": {
          "function_name": "set_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "489-498",
          "snippet": "static bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t  kvm_pfn_t pfn, unsigned int access)\n{\n\tif (unlikely(is_noslot_pfn(pfn))) {\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t  kvm_pfn_t pfn, unsigned int access)\n{\n\tif (unlikely(is_noslot_pfn(pfn))) {\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SET_SPTE_NEED_REMOTE_TLB_FLUSH\tBIT(1)\n#define SET_SPTE_WRITE_PROTECTED_PT\tBIT(0)\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n#define ACC_USER_MASK    PT_USER_MASK\n#define ACC_WRITE_MASK   PT_WRITABLE_MASK\n#define ACC_EXEC_MASK    1\n#define SPTE_AD_WRPROT_ONLY_MASK (2ULL << 52)\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n\nbool tdp_enabled = false;\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int set_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t    unsigned int pte_access, int level,\n\t\t    gfn_t gfn, kvm_pfn_t pfn, bool speculative,\n\t\t    bool can_unsync, bool host_writable)\n{\n\tu64 spte = 0;\n\tint ret = 0;\n\tstruct kvm_mmu_page *sp;\n\n\tif (set_mmio_spte(vcpu, sptep, gfn, pfn, pte_access))\n\t\treturn 0;\n\n\tsp = page_header(__pa(sptep));\n\tif (sp_ad_disabled(sp))\n\t\tspte |= SPTE_AD_DISABLED_MASK;\n\telse if (kvm_vcpu_ad_need_write_protect(vcpu))\n\t\tspte |= SPTE_AD_WRPROT_ONLY_MASK;\n\n\t/*\n\t * For the EPT case, shadow_present_mask is 0 if hardware\n\t * supports exec-only page table entries.  In that case,\n\t * ACC_USER_MASK and shadow_user_mask are used to represent\n\t * read access.  See FNAME(gpte_access) in paging_tmpl.h.\n\t */\n\tspte |= shadow_present_mask;\n\tif (!speculative)\n\t\tspte |= spte_shadow_accessed_mask(spte);\n\n\tif (level > PT_PAGE_TABLE_LEVEL && (pte_access & ACC_EXEC_MASK) &&\n\t    is_nx_huge_page_enabled()) {\n\t\tpte_access &= ~ACC_EXEC_MASK;\n\t}\n\n\tif (pte_access & ACC_EXEC_MASK)\n\t\tspte |= shadow_x_mask;\n\telse\n\t\tspte |= shadow_nx_mask;\n\n\tif (pte_access & ACC_USER_MASK)\n\t\tspte |= shadow_user_mask;\n\n\tif (level > PT_PAGE_TABLE_LEVEL)\n\t\tspte |= PT_PAGE_SIZE_MASK;\n\tif (tdp_enabled)\n\t\tspte |= kvm_x86_ops.get_mt_mask(vcpu, gfn,\n\t\t\tkvm_is_mmio_pfn(pfn));\n\n\tif (host_writable)\n\t\tspte |= SPTE_HOST_WRITEABLE;\n\telse\n\t\tpte_access &= ~ACC_WRITE_MASK;\n\n\tif (!kvm_is_mmio_pfn(pfn))\n\t\tspte |= shadow_me_mask;\n\n\tspte |= (u64)pfn << PAGE_SHIFT;\n\n\tif (pte_access & ACC_WRITE_MASK) {\n\t\tspte |= PT_WRITABLE_MASK | SPTE_MMU_WRITEABLE;\n\n\t\t/*\n\t\t * Optimization: for pte sync, if spte was writable the hash\n\t\t * lookup is unnecessary (and expensive). Write protection\n\t\t * is responsibility of mmu_get_page / kvm_sync_page.\n\t\t * Same reasoning can be applied to dirty page accounting.\n\t\t */\n\t\tif (!can_unsync && is_writable_pte(*sptep))\n\t\t\tgoto set_pte;\n\n\t\tif (mmu_need_write_protect(vcpu, gfn, can_unsync)) {\n\t\t\tpgprintk(\"%s: found shadow page for %llx, marking ro\\n\",\n\t\t\t\t __func__, gfn);\n\t\t\tret |= SET_SPTE_WRITE_PROTECTED_PT;\n\t\t\tpte_access &= ~ACC_WRITE_MASK;\n\t\t\tspte &= ~(PT_WRITABLE_MASK | SPTE_MMU_WRITEABLE);\n\t\t}\n\t}\n\n\tif (pte_access & ACC_WRITE_MASK) {\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t\tspte |= spte_shadow_dirty_mask(spte);\n\t}\n\n\tif (speculative)\n\t\tspte = mark_spte_for_access_track(spte);\n\nset_pte:\n\tif (mmu_spte_update(sptep, spte))\n\t\tret |= SET_SPTE_NEED_REMOTE_TLB_FLUSH;\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_is_mmio_pfn",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2970-2989",
    "snippet": "static bool kvm_is_mmio_pfn(kvm_pfn_t pfn)\n{\n\tif (pfn_valid(pfn))\n\t\treturn !is_zero_pfn(pfn) && PageReserved(pfn_to_page(pfn)) &&\n\t\t\t/*\n\t\t\t * Some reserved pages, such as those from NVDIMM\n\t\t\t * DAX devices, are not for MMIO, and can be mapped\n\t\t\t * with cached memory type for better performance.\n\t\t\t * However, the above check misconceives those pages\n\t\t\t * as MMIO, and results in KVM mapping them with UC\n\t\t\t * memory type, which would hurt the performance.\n\t\t\t * Therefore, we check the host memory type in addition\n\t\t\t * and only treat UC/UC-/WC pages as MMIO.\n\t\t\t */\n\t\t\t(!pat_enabled() || pat_pfn_immune_to_uc_mtrr(pfn));\n\n\treturn !e820__mapped_raw_any(pfn_to_hpa(pfn),\n\t\t\t\t     pfn_to_hpa(pfn + 1) - 1,\n\t\t\t\t     E820_TYPE_RAM);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "e820__mapped_raw_any",
          "args": [
            "pfn_to_hpa(pfn)",
            "pfn_to_hpa(pfn + 1) - 1",
            "E820_TYPE_RAM"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_hpa",
          "args": [
            "pfn + 1"
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_hpa",
          "args": [
            "pfn"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pat_pfn_immune_to_uc_mtrr",
          "args": [
            "pfn"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pat_enabled",
          "args": [],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PageReserved",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_zero_pfn",
          "args": [
            "pfn"
          ],
          "line": 2973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_valid",
          "args": [
            "pfn"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_is_mmio_pfn(kvm_pfn_t pfn)\n{\n\tif (pfn_valid(pfn))\n\t\treturn !is_zero_pfn(pfn) && PageReserved(pfn_to_page(pfn)) &&\n\t\t\t/*\n\t\t\t * Some reserved pages, such as those from NVDIMM\n\t\t\t * DAX devices, are not for MMIO, and can be mapped\n\t\t\t * with cached memory type for better performance.\n\t\t\t * However, the above check misconceives those pages\n\t\t\t * as MMIO, and results in KVM mapping them with UC\n\t\t\t * memory type, which would hurt the performance.\n\t\t\t * Therefore, we check the host memory type in addition\n\t\t\t * and only treat UC/UC-/WC pages as MMIO.\n\t\t\t */\n\t\t\t(!pat_enabled() || pat_pfn_immune_to_uc_mtrr(pfn));\n\n\treturn !e820__mapped_raw_any(pfn_to_hpa(pfn),\n\t\t\t\t     pfn_to_hpa(pfn + 1) - 1,\n\t\t\t\t     E820_TYPE_RAM);\n}"
  },
  {
    "function_name": "mmu_need_write_protect",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2909-2968",
    "snippet": "static bool mmu_need_write_protect(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   bool can_unsync)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!can_unsync)\n\t\t\treturn true;\n\n\t\tif (sp->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tkvm_unsync_page(vcpu, sp);\n\t}\n\n\t/*\n\t * We need to ensure that the marking of unsync pages is visible\n\t * before the SPTE is updated to allow writes because\n\t * kvm_mmu_sync_roots() checks the unsync flags without holding\n\t * the MMU lock and so can race with this. If the SPTE was updated\n\t * before the page had been marked as unsync-ed, something like the\n\t * following could happen:\n\t *\n\t * CPU 1                    CPU 2\n\t * ---------------------------------------------------------------------\n\t * 1.2 Host updates SPTE\n\t *     to be writable\n\t *                      2.1 Guest writes a GPTE for GVA X.\n\t *                          (GPTE being in the guest page table shadowed\n\t *                           by the SP from CPU 1.)\n\t *                          This reads SPTE during the page table walk.\n\t *                          Since SPTE.W is read as 1, there is no\n\t *                          fault.\n\t *\n\t *                      2.2 Guest issues TLB flush.\n\t *                          That causes a VM Exit.\n\t *\n\t *                      2.3 kvm_mmu_sync_pages() reads sp->unsync.\n\t *                          Since it is false, so it just returns.\n\t *\n\t *                      2.4 Guest accesses GVA X.\n\t *                          Since the mapping in the SP was not updated,\n\t *                          so the old mapping for GVA X incorrectly\n\t *                          gets used.\n\t * 1.1 Host marks SP\n\t *     as unsync\n\t *     (sp->unsync = true)\n\t *\n\t * The write barrier below ensures that 1.1 happens before 1.2 and thus\n\t * the situation in 2.4 does not arise. The implicit barrier in 2.2\n\t * pairs with this write barrier.\n\t */\n\tsmp_wmb();\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_unsync_page",
          "args": [
            "vcpu",
            "sp"
          ],
          "line": 2925
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unsync_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2900-2907",
          "snippet": "static void kvm_unsync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\ttrace_kvm_mmu_unsync_page(sp);\n\t++vcpu->kvm->stat.mmu_unsync;\n\tsp->unsync = 1;\n\n\tkvm_mmu_mark_parents_unsync(sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void kvm_unsync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\ttrace_kvm_mmu_unsync_page(sp);\n\t++vcpu->kvm->stat.mmu_unsync;\n\tsp->unsync = 1;\n\n\tkvm_mmu_mark_parents_unsync(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "sp->role.level != PT_PAGE_TABLE_LEVEL"
          ],
          "line": 2924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_gfn_indirect_valid_sp",
          "args": [
            "vcpu->kvm",
            "sp",
            "gfn"
          ],
          "line": 2917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_page_track_is_active",
          "args": [
            "vcpu",
            "gfn",
            "KVM_PAGE_TRACK_WRITE"
          ],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_track_is_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/page_track.c",
          "lines": "141-156",
          "snippet": "bool kvm_page_track_is_active(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t      enum kvm_page_track_mode mode)\n{\n\tstruct kvm_memory_slot *slot;\n\tint index;\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn false;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot)\n\t\treturn false;\n\n\tindex = gfn_to_index(gfn, slot->base_gfn, PT_PAGE_TABLE_LEVEL);\n\treturn !!READ_ONCE(slot->arch.gfn_track[mode][index]);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <linux/rculist.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <linux/rculist.h>\n#include <linux/kvm_host.h>\n\nbool kvm_page_track_is_active(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t      enum kvm_page_track_mode mode)\n{\n\tstruct kvm_memory_slot *slot;\n\tint index;\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn false;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot)\n\t\treturn false;\n\n\tindex = gfn_to_index(gfn, slot->base_gfn, PT_PAGE_TABLE_LEVEL);\n\treturn !!READ_ONCE(slot->arch.gfn_track[mode][index]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool mmu_need_write_protect(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t\t   bool can_unsync)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (kvm_page_track_is_active(vcpu, gfn, KVM_PAGE_TRACK_WRITE))\n\t\treturn true;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (!can_unsync)\n\t\t\treturn true;\n\n\t\tif (sp->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(sp->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tkvm_unsync_page(vcpu, sp);\n\t}\n\n\t/*\n\t * We need to ensure that the marking of unsync pages is visible\n\t * before the SPTE is updated to allow writes because\n\t * kvm_mmu_sync_roots() checks the unsync flags without holding\n\t * the MMU lock and so can race with this. If the SPTE was updated\n\t * before the page had been marked as unsync-ed, something like the\n\t * following could happen:\n\t *\n\t * CPU 1                    CPU 2\n\t * ---------------------------------------------------------------------\n\t * 1.2 Host updates SPTE\n\t *     to be writable\n\t *                      2.1 Guest writes a GPTE for GVA X.\n\t *                          (GPTE being in the guest page table shadowed\n\t *                           by the SP from CPU 1.)\n\t *                          This reads SPTE during the page table walk.\n\t *                          Since SPTE.W is read as 1, there is no\n\t *                          fault.\n\t *\n\t *                      2.2 Guest issues TLB flush.\n\t *                          That causes a VM Exit.\n\t *\n\t *                      2.3 kvm_mmu_sync_pages() reads sp->unsync.\n\t *                          Since it is false, so it just returns.\n\t *\n\t *                      2.4 Guest accesses GVA X.\n\t *                          Since the mapping in the SP was not updated,\n\t *                          so the old mapping for GVA X incorrectly\n\t *                          gets used.\n\t * 1.1 Host marks SP\n\t *     as unsync\n\t *     (sp->unsync = true)\n\t *\n\t * The write barrier below ensures that 1.1 happens before 1.2 and thus\n\t * the situation in 2.4 does not arise. The implicit barrier in 2.2\n\t * pairs with this write barrier.\n\t */\n\tsmp_wmb();\n\n\treturn false;\n}"
  },
  {
    "function_name": "kvm_unsync_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2900-2907",
    "snippet": "static void kvm_unsync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\ttrace_kvm_mmu_unsync_page(sp);\n\t++vcpu->kvm->stat.mmu_unsync;\n\tsp->unsync = 1;\n\n\tkvm_mmu_mark_parents_unsync(sp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_mark_parents_unsync",
          "args": [
            "sp"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_mark_parents_unsync",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2126-2134",
          "snippet": "static void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_unsync_page",
          "args": [
            "sp"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void kvm_unsync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp)\n{\n\ttrace_kvm_mmu_unsync_page(sp);\n\t++vcpu->kvm->stat.mmu_unsync;\n\tsp->unsync = 1;\n\n\tkvm_mmu_mark_parents_unsync(sp);\n}"
  },
  {
    "function_name": "kvm_mmu_unprotect_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2878-2897",
    "snippet": "int kvm_mmu_unprotect_page(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\tint r;\n\n\tpgprintk(\"%s: looking for gfn %llx\\n\", __func__, gfn);\n\tr = 0;\n\tspin_lock(&kvm->mmu_lock);\n\tfor_each_gfn_indirect_valid_sp(kvm, sp, gfn) {\n\t\tpgprintk(\"%s: gfn %llx role %x\\n\", __func__, gfn,\n\t\t\t sp->role.word);\n\t\tr = 1;\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, &invalid_list);\n\t}\n\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\tspin_unlock(&kvm->mmu_lock);\n\n\treturn r;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 2894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2795-2818",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "&invalid_list"
          ],
          "line": 2891
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2786-2793",
          "snippet": "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: gfn %llx role %x\\n\"",
            "__func__",
            "gfn",
            "sp->role.word"
          ],
          "line": 2888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_gfn_indirect_valid_sp",
          "args": [
            "kvm",
            "sp",
            "gfn"
          ],
          "line": 2887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pgprintk",
          "args": [
            "\"%s: looking for gfn %llx\\n\"",
            "__func__",
            "gfn"
          ],
          "line": 2884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nint kvm_mmu_unprotect_page(struct kvm *kvm, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tLIST_HEAD(invalid_list);\n\tint r;\n\n\tpgprintk(\"%s: looking for gfn %llx\\n\", __func__, gfn);\n\tr = 0;\n\tspin_lock(&kvm->mmu_lock);\n\tfor_each_gfn_indirect_valid_sp(kvm, sp, gfn) {\n\t\tpgprintk(\"%s: gfn %llx role %x\\n\", __func__, gfn,\n\t\t\t sp->role.word);\n\t\tr = 1;\n\t\tkvm_mmu_prepare_zap_page(kvm, sp, &invalid_list);\n\t}\n\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\tspin_unlock(&kvm->mmu_lock);\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_mmu_change_mmu_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2857-2876",
    "snippet": "void kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned long goal_nr_mmu_pages)\n{\n\tLIST_HEAD(invalid_list);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tif (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages) {\n\t\t/* Need to free some mmu pages to achieve the goal. */\n\t\twhile (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages)\n\t\t\tif (!prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\t\tbreak;\n\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\tgoal_nr_mmu_pages = kvm->arch.n_used_mmu_pages;\n\t}\n\n\tkvm->arch.n_max_mmu_pages = goal_nr_mmu_pages;\n\n\tspin_unlock(&kvm->mmu_lock);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 2869
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2795-2818",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_zap_oldest_mmu_page",
          "args": [
            "kvm",
            "&invalid_list"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_zap_oldest_mmu_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2820-2831",
          "snippet": "static bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\treturn kvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\treturn kvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&kvm->mmu_lock"
          ],
          "line": 2861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 2859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nvoid kvm_mmu_change_mmu_pages(struct kvm *kvm, unsigned long goal_nr_mmu_pages)\n{\n\tLIST_HEAD(invalid_list);\n\n\tspin_lock(&kvm->mmu_lock);\n\n\tif (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages) {\n\t\t/* Need to free some mmu pages to achieve the goal. */\n\t\twhile (kvm->arch.n_used_mmu_pages > goal_nr_mmu_pages)\n\t\t\tif (!prepare_zap_oldest_mmu_page(kvm, &invalid_list))\n\t\t\t\tbreak;\n\n\t\tkvm_mmu_commit_zap_page(kvm, &invalid_list);\n\t\tgoal_nr_mmu_pages = kvm->arch.n_used_mmu_pages;\n\t}\n\n\tkvm->arch.n_max_mmu_pages = goal_nr_mmu_pages;\n\n\tspin_unlock(&kvm->mmu_lock);\n}"
  },
  {
    "function_name": "make_mmu_pages_available",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2833-2851",
    "snippet": "static int make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn 0;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\n\tif (!kvm_mmu_available_pages(vcpu->kvm))\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_available_pages",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2848
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_available_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "67-74",
          "snippet": "static inline unsigned long kvm_mmu_available_pages(struct kvm *kvm)\n{\n\tif (kvm->arch.n_max_mmu_pages > kvm->arch.n_used_mmu_pages)\n\t\treturn kvm->arch.n_max_mmu_pages -\n\t\t\tkvm->arch.n_used_mmu_pages;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_mmu_available_pages(struct kvm *kvm)\n{\n\tif (kvm->arch.n_max_mmu_pages > kvm->arch.n_used_mmu_pages)\n\t\treturn kvm->arch.n_max_mmu_pages -\n\t\t\tkvm->arch.n_used_mmu_pages;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "vcpu->kvm",
            "&invalid_list"
          ],
          "line": 2846
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2795-2818",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_zap_oldest_mmu_page",
          "args": [
            "vcpu->kvm",
            "&invalid_list"
          ],
          "line": 2841
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_zap_oldest_mmu_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2820-2831",
          "snippet": "static bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\treturn kvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\treturn kvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES"
          ],
          "line": 2837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 2835
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int make_mmu_pages_available(struct kvm_vcpu *vcpu)\n{\n\tLIST_HEAD(invalid_list);\n\n\tif (likely(kvm_mmu_available_pages(vcpu->kvm) >= KVM_MIN_FREE_MMU_PAGES))\n\t\treturn 0;\n\n\twhile (kvm_mmu_available_pages(vcpu->kvm) < KVM_REFILL_PAGES) {\n\t\tif (!prepare_zap_oldest_mmu_page(vcpu->kvm, &invalid_list))\n\t\t\tbreak;\n\n\t\t++vcpu->kvm->stat.mmu_recycled;\n\t}\n\tkvm_mmu_commit_zap_page(vcpu->kvm, &invalid_list);\n\n\tif (!kvm_mmu_available_pages(vcpu->kvm))\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
  },
  {
    "function_name": "prepare_zap_oldest_mmu_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2820-2831",
    "snippet": "static bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\treturn kvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "invalid_list"
          ],
          "line": 2830
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2786-2793",
          "snippet": "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_last_entry",
          "args": [
            "&kvm->arch.active_mmu_pages",
            "structkvm_mmu_page",
            "link"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&kvm->arch.active_mmu_pages"
          ],
          "line": 2825
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool prepare_zap_oldest_mmu_page(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tif (list_empty(&kvm->arch.active_mmu_pages))\n\t\treturn false;\n\n\tsp = list_last_entry(&kvm->arch.active_mmu_pages,\n\t\t\t     struct kvm_mmu_page, link);\n\treturn kvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n}"
  },
  {
    "function_name": "kvm_mmu_commit_zap_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2795-2818",
    "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_free_page",
          "args": [
            "sp"
          ],
          "line": 2816
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2066-2075",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sp->role.invalid || sp->root_count"
          ],
          "line": 2815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "sp",
            "nsp",
            "invalid_list",
            "link"
          ],
          "line": 2814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 2812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "invalid_list"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
  },
  {
    "function_name": "kvm_mmu_prepare_zap_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2786-2793",
    "snippet": "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "invalid_list",
            "&nr_zapped"
          ],
          "line": 2791
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2741-2784",
          "snippet": "static bool __kvm_mmu_prepare_zap_page(struct kvm *kvm,\n\t\t\t\t       struct kvm_mmu_page *sp,\n\t\t\t\t       struct list_head *invalid_list,\n\t\t\t\t       int *nr_zapped)\n{\n\tbool list_unstable;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\t*nr_zapped = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\t/* Zapping children means active_mmu_pages has become unstable. */\n\tlist_unstable = *nr_zapped;\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\t(*nr_zapped)++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * Obsolete pages cannot be used on any vCPUs, see the comment\n\t\t * in kvm_mmu_zap_all_fast().  Note, is_obsolete_sp() also\n\t\t * treats invalid shadow pages as being obsolete.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tif (sp->lpage_disallowed)\n\t\tunaccount_huge_nx_page(kvm, sp);\n\n\tsp->role.invalid = 1;\n\treturn list_unstable;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool __kvm_mmu_prepare_zap_page(struct kvm *kvm,\n\t\t\t\t       struct kvm_mmu_page *sp,\n\t\t\t\t       struct list_head *invalid_list,\n\t\t\t\t       int *nr_zapped)\n{\n\tbool list_unstable;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\t*nr_zapped = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\t/* Zapping children means active_mmu_pages has become unstable. */\n\tlist_unstable = *nr_zapped;\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\t(*nr_zapped)++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * Obsolete pages cannot be used on any vCPUs, see the comment\n\t\t * in kvm_mmu_zap_all_fast().  Note, is_obsolete_sp() also\n\t\t * treats invalid shadow pages as being obsolete.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tif (sp->lpage_disallowed)\n\t\tunaccount_huge_nx_page(kvm, sp);\n\n\tsp->role.invalid = 1;\n\treturn list_unstable;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}"
  },
  {
    "function_name": "__kvm_mmu_prepare_zap_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2741-2784",
    "snippet": "static bool __kvm_mmu_prepare_zap_page(struct kvm *kvm,\n\t\t\t\t       struct kvm_mmu_page *sp,\n\t\t\t\t       struct list_head *invalid_list,\n\t\t\t\t       int *nr_zapped)\n{\n\tbool list_unstable;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\t*nr_zapped = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\t/* Zapping children means active_mmu_pages has become unstable. */\n\tlist_unstable = *nr_zapped;\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\t(*nr_zapped)++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * Obsolete pages cannot be used on any vCPUs, see the comment\n\t\t * in kvm_mmu_zap_all_fast().  Note, is_obsolete_sp() also\n\t\t * treats invalid shadow pages as being obsolete.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tif (sp->lpage_disallowed)\n\t\tunaccount_huge_nx_page(kvm, sp);\n\n\tsp->role.invalid = 1;\n\treturn list_unstable;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unaccount_huge_nx_page",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 2780
        },
        "resolved": true,
        "details": {
          "function_name": "unaccount_huge_nx_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1263-1268",
          "snippet": "static void unaccount_huge_nx_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\t--kvm->stat.nx_lpage_splits;\n\tsp->lpage_disallowed = false;\n\tlist_del(&sp->lpage_disallowed_link);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void unaccount_huge_nx_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\t--kvm->stat.nx_lpage_splits;\n\tsp->lpage_disallowed = false;\n\tlist_del(&sp->lpage_disallowed_link);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_reload_remote_mmus",
          "args": [
            "kvm"
          ],
          "line": 2776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_obsolete_sp",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "is_obsolete_sp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2326-2330",
          "snippet": "static bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn sp->role.invalid ||\n\t       unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn sp->role.invalid ||\n\t       unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&sp->link",
            "&kvm->arch.active_mmu_pages"
          ],
          "line": 2768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mod_used_mmu_pages",
          "args": [
            "kvm",
            "-1"
          ],
          "line": 2766
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mod_used_mmu_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2060-2064",
          "snippet": "static inline void kvm_mod_used_mmu_pages(struct kvm *kvm, unsigned long nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_counter kvm_total_used_mmu_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct percpu_counter kvm_total_used_mmu_pages;\n\nstatic inline void kvm_mod_used_mmu_pages(struct kvm *kvm, unsigned long nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&sp->link",
            "invalid_list"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_unlink_unsync_page",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unlink_unsync_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2252-2258",
          "snippet": "static void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unaccount_shadowed",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "unaccount_shadowed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1246-1261",
          "snippet": "static void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_unlink_parents",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 2752
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_unlink_parents",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2708-2715",
          "snippet": "static void kvm_mmu_unlink_parents(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\twhile ((sptep = rmap_get_first(&sp->parent_ptes, &iter)))\n\t\tdrop_parent_pte(sp, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_unlink_parents(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\twhile ((sptep = rmap_get_first(&sp->parent_ptes, &iter)))\n\t\tdrop_parent_pte(sp, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_unlink_children",
          "args": [
            "kvm",
            "sp"
          ],
          "line": 2751
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_unlink_children",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2699-2706",
          "snippet": "static void kvm_mmu_page_unlink_children(struct kvm *kvm,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i)\n\t\tmmu_page_zap_pte(kvm, sp, sp->spt + i);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_page_unlink_children(struct kvm *kvm,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i)\n\t\tmmu_page_zap_pte(kvm, sp, sp->spt + i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_zap_unsync_children",
          "args": [
            "kvm",
            "sp",
            "invalid_list"
          ],
          "line": 2750
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_zap_unsync_children",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2717-2739",
          "snippet": "static int mmu_zap_unsync_children(struct kvm *kvm,\n\t\t\t\t   struct kvm_mmu_page *parent,\n\t\t\t\t   struct list_head *invalid_list)\n{\n\tint i, zapped = 0;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\n\tif (parent->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 0;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tstruct kvm_mmu_page *sp;\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t\tzapped++;\n\t\t}\n\t}\n\n\treturn zapped;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int mmu_zap_unsync_children(struct kvm *kvm,\n\t\t\t\t   struct kvm_mmu_page *parent,\n\t\t\t\t   struct list_head *invalid_list)\n{\n\tint i, zapped = 0;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\n\tif (parent->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 0;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tstruct kvm_mmu_page *sp;\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t\tzapped++;\n\t\t}\n\t}\n\n\treturn zapped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_prepare_zap_page",
          "args": [
            "sp"
          ],
          "line": 2748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool __kvm_mmu_prepare_zap_page(struct kvm *kvm,\n\t\t\t\t       struct kvm_mmu_page *sp,\n\t\t\t\t       struct list_head *invalid_list,\n\t\t\t\t       int *nr_zapped)\n{\n\tbool list_unstable;\n\n\ttrace_kvm_mmu_prepare_zap_page(sp);\n\t++kvm->stat.mmu_shadow_zapped;\n\t*nr_zapped = mmu_zap_unsync_children(kvm, sp, invalid_list);\n\tkvm_mmu_page_unlink_children(kvm, sp);\n\tkvm_mmu_unlink_parents(kvm, sp);\n\n\t/* Zapping children means active_mmu_pages has become unstable. */\n\tlist_unstable = *nr_zapped;\n\n\tif (!sp->role.invalid && !sp->role.direct)\n\t\tunaccount_shadowed(kvm, sp);\n\n\tif (sp->unsync)\n\t\tkvm_unlink_unsync_page(kvm, sp);\n\tif (!sp->root_count) {\n\t\t/* Count self */\n\t\t(*nr_zapped)++;\n\t\tlist_move(&sp->link, invalid_list);\n\t\tkvm_mod_used_mmu_pages(kvm, -1);\n\t} else {\n\t\tlist_move(&sp->link, &kvm->arch.active_mmu_pages);\n\n\t\t/*\n\t\t * Obsolete pages cannot be used on any vCPUs, see the comment\n\t\t * in kvm_mmu_zap_all_fast().  Note, is_obsolete_sp() also\n\t\t * treats invalid shadow pages as being obsolete.\n\t\t */\n\t\tif (!is_obsolete_sp(kvm, sp))\n\t\t\tkvm_reload_remote_mmus(kvm);\n\t}\n\n\tif (sp->lpage_disallowed)\n\t\tunaccount_huge_nx_page(kvm, sp);\n\n\tsp->role.invalid = 1;\n\treturn list_unstable;\n}"
  },
  {
    "function_name": "mmu_zap_unsync_children",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2717-2739",
    "snippet": "static int mmu_zap_unsync_children(struct kvm *kvm,\n\t\t\t\t   struct kvm_mmu_page *parent,\n\t\t\t\t   struct list_head *invalid_list)\n{\n\tint i, zapped = 0;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\n\tif (parent->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 0;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tstruct kvm_mmu_page *sp;\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t\tzapped++;\n\t\t}\n\t}\n\n\treturn zapped;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_pages_clear_parents",
          "args": [
            "&parents"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pages_clear_parents",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2412-2427",
          "snippet": "static void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define INVALID_INDEX (-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "kvm",
            "sp",
            "invalid_list"
          ],
          "line": 2732
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2786-2793",
          "snippet": "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_sp",
          "args": [
            "pages",
            "sp",
            "parents",
            "i"
          ],
          "line": 2731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_unsync_walk",
          "args": [
            "parent",
            "&pages"
          ],
          "line": 2728
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_unsync_walk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2241-2250",
          "snippet": "static int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define INVALID_INDEX (-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic int mmu_zap_unsync_children(struct kvm *kvm,\n\t\t\t\t   struct kvm_mmu_page *parent,\n\t\t\t\t   struct list_head *invalid_list)\n{\n\tint i, zapped = 0;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\n\tif (parent->role.level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 0;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tstruct kvm_mmu_page *sp;\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tkvm_mmu_prepare_zap_page(kvm, sp, invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t\tzapped++;\n\t\t}\n\t}\n\n\treturn zapped;\n}"
  },
  {
    "function_name": "kvm_mmu_unlink_parents",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2708-2715",
    "snippet": "static void kvm_mmu_unlink_parents(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\twhile ((sptep = rmap_get_first(&sp->parent_ptes, &iter)))\n\t\tdrop_parent_pte(sp, sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_parent_pte",
          "args": [
            "sp",
            "sptep"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "drop_parent_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2097-2102",
          "snippet": "static void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_get_first",
          "args": [
            "&sp->parent_ptes",
            "&iter"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_get_first",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1463-1483",
          "snippet": "static u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_unlink_parents(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\twhile ((sptep = rmap_get_first(&sp->parent_ptes, &iter)))\n\t\tdrop_parent_pte(sp, sptep);\n}"
  },
  {
    "function_name": "kvm_mmu_page_unlink_children",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2699-2706",
    "snippet": "static void kvm_mmu_page_unlink_children(struct kvm *kvm,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i)\n\t\tmmu_page_zap_pte(kvm, sp, sp->spt + i);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_page_zap_pte",
          "args": [
            "kvm",
            "sp",
            "sp->spt + i"
          ],
          "line": 2705
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_page_zap_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2674-2697",
          "snippet": "static bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_page_unlink_children(struct kvm *kvm,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tunsigned i;\n\n\tfor (i = 0; i < PT64_ENT_PER_PAGE; ++i)\n\t\tmmu_page_zap_pte(kvm, sp, sp->spt + i);\n}"
  },
  {
    "function_name": "mmu_page_zap_pte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2674-2697",
    "snippet": "static bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
      "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_clear_no_track",
          "args": [
            "spte"
          ],
          "line": 2694
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_clear_no_track",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "954-957",
          "snippet": "static void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "pte"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "344-347",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_parent_pte",
          "args": [
            "child",
            "spte"
          ],
          "line": 2688
        },
        "resolved": true,
        "details": {
          "function_name": "drop_parent_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2097-2102",
          "snippet": "static void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "pte & PT64_BASE_ADDR_MASK"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "pte"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "616-619",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_spte",
          "args": [
            "kvm",
            "spte"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "drop_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1522-1526",
          "snippet": "static void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "pte",
            "sp->role.level"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "621-628",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "pte"
          ],
          "line": 2681
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t     u64 *spte)\n{\n\tu64 pte;\n\tstruct kvm_mmu_page *child;\n\n\tpte = *spte;\n\tif (is_shadow_present_pte(pte)) {\n\t\tif (is_last_spte(pte, sp->role.level)) {\n\t\t\tdrop_spte(kvm, spte);\n\t\t\tif (is_large_pte(pte))\n\t\t\t\t--kvm->stat.lpages;\n\t\t} else {\n\t\t\tchild = page_header(pte & PT64_BASE_ADDR_MASK);\n\t\t\tdrop_parent_pte(child, spte);\n\t\t}\n\t\treturn true;\n\t}\n\n\tif (is_mmio_spte(pte))\n\t\tmmu_spte_clear_no_track(spte);\n\n\treturn false;\n}"
  },
  {
    "function_name": "validate_direct_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2652-2672",
    "snippet": "static void validate_direct_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t\t   unsigned direct_access)\n{\n\tif (is_shadow_present_pte(*sptep) && !is_large_pte(*sptep)) {\n\t\tstruct kvm_mmu_page *child;\n\n\t\t/*\n\t\t * For the direct sp, if the guest pte's dirty bit\n\t\t * changed form clean to dirty, it will corrupt the\n\t\t * sp's access: allow writable in the read-only sp,\n\t\t * so we should update the spte at this point to get\n\t\t * a new sp with the correct access.\n\t\t */\n\t\tchild = page_header(*sptep & PT64_BASE_ADDR_MASK);\n\t\tif (child->role.access == direct_access)\n\t\t\treturn;\n\n\t\tdrop_parent_pte(child, sptep);\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, child->gfn, 1);\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
      "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs_with_address",
          "args": [
            "vcpu->kvm",
            "child->gfn",
            "1"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_flush_remote_tlbs_with_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "323-332",
          "snippet": "static void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_parent_pte",
          "args": [
            "child",
            "sptep"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "drop_parent_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2097-2102",
          "snippet": "static void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "*sptep & PT64_BASE_ADDR_MASK"
          ],
          "line": 2665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "*sptep"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "616-619",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void validate_direct_spte(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t\t   unsigned direct_access)\n{\n\tif (is_shadow_present_pte(*sptep) && !is_large_pte(*sptep)) {\n\t\tstruct kvm_mmu_page *child;\n\n\t\t/*\n\t\t * For the direct sp, if the guest pte's dirty bit\n\t\t * changed form clean to dirty, it will corrupt the\n\t\t * sp's access: allow writable in the read-only sp,\n\t\t * so we should update the spte at this point to get\n\t\t * a new sp with the correct access.\n\t\t */\n\t\tchild = page_header(*sptep & PT64_BASE_ADDR_MASK);\n\t\tif (child->role.access == direct_access)\n\t\t\treturn;\n\n\t\tdrop_parent_pte(child, sptep);\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, child->gfn, 1);\n\t}\n}"
  },
  {
    "function_name": "link_shadow_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2629-2650",
    "snippet": "static void link_shadow_page(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t     struct kvm_mmu_page *sp)\n{\n\tu64 spte;\n\n\tBUILD_BUG_ON(VMX_EPT_WRITABLE_MASK != PT_WRITABLE_MASK);\n\n\tspte = __pa(sp->spt) | shadow_present_mask | PT_WRITABLE_MASK |\n\t       shadow_user_mask | shadow_x_mask | shadow_me_mask;\n\n\tif (sp_ad_disabled(sp))\n\t\tspte |= SPTE_AD_DISABLED_MASK;\n\telse\n\t\tspte |= shadow_accessed_mask;\n\n\tmmu_spte_set(sptep, spte);\n\n\tmmu_page_add_parent_pte(vcpu, sp, sptep);\n\n\tif (sp->unsync_children || sp->unsync)\n\t\tmark_unsync(sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_AD_DISABLED_MASK (1ULL << 52)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_unsync",
          "args": [
            "sptep"
          ],
          "line": 2649
        },
        "resolved": true,
        "details": {
          "function_name": "mark_unsync",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2136-2148",
          "snippet": "static void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_page_add_parent_pte",
          "args": [
            "vcpu",
            "sp",
            "sptep"
          ],
          "line": 2646
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_page_add_parent_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2082-2089",
          "snippet": "static void mmu_page_add_parent_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp, u64 *parent_pte)\n{\n\tif (!parent_pte)\n\t\treturn;\n\n\tpte_list_add(vcpu, parent_pte, &sp->parent_ptes);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void mmu_page_add_parent_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp, u64 *parent_pte)\n{\n\tif (!parent_pte)\n\t\treturn;\n\n\tpte_list_add(vcpu, parent_pte, &sp->parent_ptes);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_set",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 2644
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "835-839",
          "snippet": "static void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sp_ad_disabled",
          "args": [
            "sp"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "sp_ad_disabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "349-352",
          "snippet": "static inline bool sp_ad_disabled(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.ad_disabled;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool sp_ad_disabled(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.ad_disabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sp->spt"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "VMX_EPT_WRITABLE_MASK != PT_WRITABLE_MASK"
          ],
          "line": 2634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void link_shadow_page(struct kvm_vcpu *vcpu, u64 *sptep,\n\t\t\t     struct kvm_mmu_page *sp)\n{\n\tu64 spte;\n\n\tBUILD_BUG_ON(VMX_EPT_WRITABLE_MASK != PT_WRITABLE_MASK);\n\n\tspte = __pa(sp->spt) | shadow_present_mask | PT_WRITABLE_MASK |\n\t       shadow_user_mask | shadow_x_mask | shadow_me_mask;\n\n\tif (sp_ad_disabled(sp))\n\t\tspte |= SPTE_AD_DISABLED_MASK;\n\telse\n\t\tspte |= shadow_accessed_mask;\n\n\tmmu_spte_set(sptep, spte);\n\n\tmmu_page_add_parent_pte(vcpu, sp, sptep);\n\n\tif (sp->unsync_children || sp->unsync)\n\t\tmark_unsync(sptep);\n}"
  },
  {
    "function_name": "shadow_walk_next",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2624-2627",
    "snippet": "static void shadow_walk_next(struct kvm_shadow_walk_iterator *iterator)\n{\n\t__shadow_walk_next(iterator, *iterator->sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__shadow_walk_next",
          "args": [
            "iterator",
            "*iterator->sptep"
          ],
          "line": 2626
        },
        "resolved": true,
        "details": {
          "function_name": "__shadow_walk_next",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2612-2622",
          "snippet": "static void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void shadow_walk_next(struct kvm_shadow_walk_iterator *iterator)\n{\n\t__shadow_walk_next(iterator, *iterator->sptep);\n}"
  },
  {
    "function_name": "__shadow_walk_next",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2612-2622",
    "snippet": "static void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
      "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_last_spte",
          "args": [
            "spte",
            "iterator->level"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "is_last_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "621-628",
          "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __shadow_walk_next(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t       u64 spte)\n{\n\tif (is_last_spte(spte, iterator->level)) {\n\t\titerator->level = 0;\n\t\treturn;\n\t}\n\n\titerator->shadow_addr = spte & PT64_BASE_ADDR_MASK;\n\t--iterator->level;\n}"
  },
  {
    "function_name": "shadow_walk_okay",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2602-2610",
    "snippet": "static bool shadow_walk_okay(struct kvm_shadow_walk_iterator *iterator)\n{\n\tif (iterator->level < PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\titerator->index = SHADOW_PT_INDEX(iterator->addr, iterator->level);\n\titerator->sptep\t= ((u64 *)__va(iterator->shadow_addr)) + iterator->index;\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__va",
          "args": [
            "iterator->shadow_addr"
          ],
          "line": 2608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHADOW_PT_INDEX",
          "args": [
            "iterator->addr",
            "iterator->level"
          ],
          "line": 2607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool shadow_walk_okay(struct kvm_shadow_walk_iterator *iterator)\n{\n\tif (iterator->level < PT_PAGE_TABLE_LEVEL)\n\t\treturn false;\n\n\titerator->index = SHADOW_PT_INDEX(iterator->addr, iterator->level);\n\titerator->sptep\t= ((u64 *)__va(iterator->shadow_addr)) + iterator->index;\n\treturn true;\n}"
  },
  {
    "function_name": "shadow_walk_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2595-2600",
    "snippet": "static void shadow_walk_init(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t     struct kvm_vcpu *vcpu, u64 addr)\n{\n\tshadow_walk_init_using_root(iterator, vcpu, vcpu->arch.mmu->root_hpa,\n\t\t\t\t    addr);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shadow_walk_init_using_root",
          "args": [
            "iterator",
            "vcpu",
            "vcpu->arch.mmu->root_hpa",
            "addr"
          ],
          "line": 2598
        },
        "resolved": true,
        "details": {
          "function_name": "shadow_walk_init_using_root",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2566-2593",
          "snippet": "static void shadow_walk_init_using_root(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t\t\tstruct kvm_vcpu *vcpu, hpa_t root,\n\t\t\t\t\tu64 addr)\n{\n\titerator->addr = addr;\n\titerator->shadow_addr = root;\n\titerator->level = vcpu->arch.mmu->shadow_root_level;\n\n\tif (iterator->level == PT64_ROOT_4LEVEL &&\n\t    vcpu->arch.mmu->root_level < PT64_ROOT_4LEVEL &&\n\t    !vcpu->arch.mmu->direct_map)\n\t\t--iterator->level;\n\n\tif (iterator->level == PT32E_ROOT_LEVEL) {\n\t\t/*\n\t\t * prev_root is currently only used for 64-bit hosts. So only\n\t\t * the active root_hpa is valid here.\n\t\t */\n\t\tBUG_ON(root != vcpu->arch.mmu->root_hpa);\n\n\t\titerator->shadow_addr\n\t\t\t= vcpu->arch.mmu->pae_root[(addr >> 30) & 3];\n\t\titerator->shadow_addr &= PT64_BASE_ADDR_MASK;\n\t\t--iterator->level;\n\t\tif (!iterator->shadow_addr)\n\t\t\titerator->level = 0;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void shadow_walk_init_using_root(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t\t\tstruct kvm_vcpu *vcpu, hpa_t root,\n\t\t\t\t\tu64 addr)\n{\n\titerator->addr = addr;\n\titerator->shadow_addr = root;\n\titerator->level = vcpu->arch.mmu->shadow_root_level;\n\n\tif (iterator->level == PT64_ROOT_4LEVEL &&\n\t    vcpu->arch.mmu->root_level < PT64_ROOT_4LEVEL &&\n\t    !vcpu->arch.mmu->direct_map)\n\t\t--iterator->level;\n\n\tif (iterator->level == PT32E_ROOT_LEVEL) {\n\t\t/*\n\t\t * prev_root is currently only used for 64-bit hosts. So only\n\t\t * the active root_hpa is valid here.\n\t\t */\n\t\tBUG_ON(root != vcpu->arch.mmu->root_hpa);\n\n\t\titerator->shadow_addr\n\t\t\t= vcpu->arch.mmu->pae_root[(addr >> 30) & 3];\n\t\titerator->shadow_addr &= PT64_BASE_ADDR_MASK;\n\t\t--iterator->level;\n\t\tif (!iterator->shadow_addr)\n\t\t\titerator->level = 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void shadow_walk_init(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t     struct kvm_vcpu *vcpu, u64 addr)\n{\n\tshadow_walk_init_using_root(iterator, vcpu, vcpu->arch.mmu->root_hpa,\n\t\t\t\t    addr);\n}"
  },
  {
    "function_name": "shadow_walk_init_using_root",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2566-2593",
    "snippet": "static void shadow_walk_init_using_root(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t\t\tstruct kvm_vcpu *vcpu, hpa_t root,\n\t\t\t\t\tu64 addr)\n{\n\titerator->addr = addr;\n\titerator->shadow_addr = root;\n\titerator->level = vcpu->arch.mmu->shadow_root_level;\n\n\tif (iterator->level == PT64_ROOT_4LEVEL &&\n\t    vcpu->arch.mmu->root_level < PT64_ROOT_4LEVEL &&\n\t    !vcpu->arch.mmu->direct_map)\n\t\t--iterator->level;\n\n\tif (iterator->level == PT32E_ROOT_LEVEL) {\n\t\t/*\n\t\t * prev_root is currently only used for 64-bit hosts. So only\n\t\t * the active root_hpa is valid here.\n\t\t */\n\t\tBUG_ON(root != vcpu->arch.mmu->root_hpa);\n\n\t\titerator->shadow_addr\n\t\t\t= vcpu->arch.mmu->pae_root[(addr >> 30) & 3];\n\t\titerator->shadow_addr &= PT64_BASE_ADDR_MASK;\n\t\t--iterator->level;\n\t\tif (!iterator->shadow_addr)\n\t\t\titerator->level = 0;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
      "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "root != vcpu->arch.mmu->root_hpa"
          ],
          "line": 2584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void shadow_walk_init_using_root(struct kvm_shadow_walk_iterator *iterator,\n\t\t\t\t\tstruct kvm_vcpu *vcpu, hpa_t root,\n\t\t\t\t\tu64 addr)\n{\n\titerator->addr = addr;\n\titerator->shadow_addr = root;\n\titerator->level = vcpu->arch.mmu->shadow_root_level;\n\n\tif (iterator->level == PT64_ROOT_4LEVEL &&\n\t    vcpu->arch.mmu->root_level < PT64_ROOT_4LEVEL &&\n\t    !vcpu->arch.mmu->direct_map)\n\t\t--iterator->level;\n\n\tif (iterator->level == PT32E_ROOT_LEVEL) {\n\t\t/*\n\t\t * prev_root is currently only used for 64-bit hosts. So only\n\t\t * the active root_hpa is valid here.\n\t\t */\n\t\tBUG_ON(root != vcpu->arch.mmu->root_hpa);\n\n\t\titerator->shadow_addr\n\t\t\t= vcpu->arch.mmu->pae_root[(addr >> 30) & 3];\n\t\titerator->shadow_addr &= PT64_BASE_ADDR_MASK;\n\t\t--iterator->level;\n\t\tif (!iterator->shadow_addr)\n\t\t\titerator->level = 0;\n\t}\n}"
  },
  {
    "function_name": "kvm_mmu_get_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2476-2564",
    "snippet": "static struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned int access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tint collisions = 0;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu->mmu_role.base;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.gpte_is_8_bytes = true;\n\trole.access = access;\n\tif (!vcpu->arch.mmu->direct_map\n\t    && vcpu->arch.mmu->root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (sp->gfn != gfn) {\n\t\t\tcollisions++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\tgoto out;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn, 1);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\nout:\n\tif (collisions > vcpu->kvm->stat.max_mmu_page_hash_collisions)\n\t\tvcpu->kvm->stat.max_mmu_page_hash_collisions = collisions;\n\treturn sp;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_flush_or_zap",
          "args": [
            "vcpu",
            "&invalid_list",
            "false",
            "flush"
          ],
          "line": 2559
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_flush_or_zap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2308-2317",
          "snippet": "static void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (kvm_mmu_remote_flush_or_zap(vcpu->kvm, invalid_list, remote_flush))\n\t\treturn;\n\n\tif (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (kvm_mmu_remote_flush_or_zap(vcpu->kvm, invalid_list, remote_flush))\n\t\treturn;\n\n\tif (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_get_page",
          "args": [
            "sp",
            "true"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "sp->spt"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_sync_pages",
          "args": [
            "vcpu",
            "gfn",
            "&invalid_list"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_sync_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2340-2355",
          "snippet": "static bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs_with_address",
          "args": [
            "vcpu->kvm",
            "gfn",
            "1"
          ],
          "line": 2551
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_flush_remote_tlbs_with_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "323-332",
          "snippet": "static void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_write_protect",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "slot_rmap_write_protect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5870-5874",
          "snippet": "static bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_shadowed",
          "args": [
            "vcpu->kvm",
            "sp"
          ],
          "line": 2548
        },
        "resolved": true,
        "details": {
          "function_name": "unaccount_shadowed",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1246-1261",
          "snippet": "static void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&sp->hash_link",
            "&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_page_table_hashfn",
          "args": [
            "gfn"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_page_table_hashfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2077-2080",
          "snippet": "static unsigned kvm_page_table_hashfn(gfn_t gfn)\n{\n\treturn hash_64(gfn, KVM_MMU_HASH_SHIFT);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned kvm_page_table_hashfn(gfn_t gfn)\n{\n\treturn hash_64(gfn, KVM_MMU_HASH_SHIFT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_alloc_page",
          "args": [
            "vcpu",
            "direct"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_alloc_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2104-2123",
          "snippet": "static struct kvm_mmu_page *kvm_mmu_alloc_page(struct kvm_vcpu *vcpu, int direct)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_header_cache);\n\tsp->spt = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tif (!direct)\n\t\tsp->gfns = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tset_page_private(virt_to_page(sp->spt), (unsigned long)sp);\n\n\t/*\n\t * active_mmu_pages must be a FIFO list, as kvm_zap_obsolete_pages()\n\t * depends on valid pages being added to the head of the list.  See\n\t * comments in kvm_zap_obsolete_pages().\n\t */\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tlist_add(&sp->link, &vcpu->kvm->arch.active_mmu_pages);\n\tkvm_mod_used_mmu_pages(vcpu->kvm, +1);\n\treturn sp;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_mmu_page *kvm_mmu_alloc_page(struct kvm_vcpu *vcpu, int direct)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_header_cache);\n\tsp->spt = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tif (!direct)\n\t\tsp->gfns = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tset_page_private(virt_to_page(sp->spt), (unsigned long)sp);\n\n\t/*\n\t * active_mmu_pages must be a FIFO list, as kvm_zap_obsolete_pages()\n\t * depends on valid pages being added to the head of the list.  See\n\t * comments in kvm_zap_obsolete_pages().\n\t */\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tlist_add(&sp->link, &vcpu->kvm->arch.active_mmu_pages);\n\tkvm_mod_used_mmu_pages(vcpu->kvm, +1);\n\treturn sp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_mmu_get_page",
          "args": [
            "sp",
            "false"
          ],
          "line": 2530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_sp_write_flooding_count",
          "args": [
            "sp"
          ],
          "line": 2529
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_sp_write_flooding_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2464-2467",
          "snippet": "static void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_MMU_SYNC",
            "vcpu"
          ],
          "line": 2527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 2523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!list_empty(&invalid_list)"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&invalid_list"
          ],
          "line": 2522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_sync_page",
          "args": [
            "vcpu",
            "sp",
            "&invalid_list"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_sync_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2282-2292",
          "snippet": "static bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif ((!is_ept_sp(sp) && sp->role.gpte_is_8_bytes != !!is_pae(vcpu)) ||\n\t    vcpu->arch.mmu->sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif ((!is_ept_sp(sp) && sp->role.gpte_is_8_bytes != !!is_pae(vcpu)) ||\n\t    vcpu->arch.mmu->sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_valid_sp",
          "args": [
            "vcpu->kvm",
            "sp",
            "gfn"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 2489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic struct kvm_mmu_page *kvm_mmu_get_page(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     gfn_t gfn,\n\t\t\t\t\t     gva_t gaddr,\n\t\t\t\t\t     unsigned level,\n\t\t\t\t\t     int direct,\n\t\t\t\t\t     unsigned int access)\n{\n\tunion kvm_mmu_page_role role;\n\tunsigned quadrant;\n\tstruct kvm_mmu_page *sp;\n\tbool need_sync = false;\n\tbool flush = false;\n\tint collisions = 0;\n\tLIST_HEAD(invalid_list);\n\n\trole = vcpu->arch.mmu->mmu_role.base;\n\trole.level = level;\n\trole.direct = direct;\n\tif (role.direct)\n\t\trole.gpte_is_8_bytes = true;\n\trole.access = access;\n\tif (!vcpu->arch.mmu->direct_map\n\t    && vcpu->arch.mmu->root_level <= PT32_ROOT_LEVEL) {\n\t\tquadrant = gaddr >> (PAGE_SHIFT + (PT64_PT_BITS * level));\n\t\tquadrant &= (1 << ((PT32_PT_BITS - PT64_PT_BITS) * level)) - 1;\n\t\trole.quadrant = quadrant;\n\t}\n\tfor_each_valid_sp(vcpu->kvm, sp, gfn) {\n\t\tif (sp->gfn != gfn) {\n\t\t\tcollisions++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!need_sync && sp->unsync)\n\t\t\tneed_sync = true;\n\n\t\tif (sp->role.word != role.word)\n\t\t\tcontinue;\n\n\t\tif (sp->unsync) {\n\t\t\t/* The page is good, but __kvm_sync_page might still end\n\t\t\t * up zapping it.  If so, break in order to rebuild it.\n\t\t\t */\n\t\t\tif (!__kvm_sync_page(vcpu, sp, &invalid_list))\n\t\t\t\tbreak;\n\n\t\t\tWARN_ON(!list_empty(&invalid_list));\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\n\t\tif (sp->unsync_children)\n\t\t\tkvm_make_request(KVM_REQ_MMU_SYNC, vcpu);\n\n\t\t__clear_sp_write_flooding_count(sp);\n\t\ttrace_kvm_mmu_get_page(sp, false);\n\t\tgoto out;\n\t}\n\n\t++vcpu->kvm->stat.mmu_cache_miss;\n\n\tsp = kvm_mmu_alloc_page(vcpu, direct);\n\n\tsp->gfn = gfn;\n\tsp->role = role;\n\thlist_add_head(&sp->hash_link,\n\t\t&vcpu->kvm->arch.mmu_page_hash[kvm_page_table_hashfn(gfn)]);\n\tif (!direct) {\n\t\t/*\n\t\t * we should do write protection before syncing pages\n\t\t * otherwise the content of the synced shadow page may\n\t\t * be inconsistent with guest page table.\n\t\t */\n\t\taccount_shadowed(vcpu->kvm, sp);\n\t\tif (level == PT_PAGE_TABLE_LEVEL &&\n\t\t      rmap_write_protect(vcpu, gfn))\n\t\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, gfn, 1);\n\n\t\tif (level > PT_PAGE_TABLE_LEVEL && need_sync)\n\t\t\tflush |= kvm_sync_pages(vcpu, gfn, &invalid_list);\n\t}\n\tclear_page(sp->spt);\n\ttrace_kvm_mmu_get_page(sp, true);\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\nout:\n\tif (collisions > vcpu->kvm->stat.max_mmu_page_hash_collisions)\n\t\tvcpu->kvm->stat.max_mmu_page_hash_collisions = collisions;\n\treturn sp;\n}"
  },
  {
    "function_name": "clear_sp_write_flooding_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2469-2474",
    "snippet": "static void clear_sp_write_flooding_count(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(spte));\n\n\t__clear_sp_write_flooding_count(sp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_sp_write_flooding_count",
          "args": [
            "sp"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_sp_write_flooding_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2464-2467",
          "snippet": "static void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(spte)"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "spte"
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void clear_sp_write_flooding_count(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(spte));\n\n\t__clear_sp_write_flooding_count(sp);\n}"
  },
  {
    "function_name": "__clear_sp_write_flooding_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2464-2467",
    "snippet": "static void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&sp->write_flooding_count",
            "0"
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void __clear_sp_write_flooding_count(struct kvm_mmu_page *sp)\n{\n\tatomic_set(&sp->write_flooding_count,  0);\n}"
  },
  {
    "function_name": "mmu_sync_children",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2429-2462",
    "snippet": "static void mmu_sync_children(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_mmu_page *parent)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\tLIST_HEAD(invalid_list);\n\tbool flush = false;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tbool protected = false;\n\n\t\tfor_each_sp(pages, sp, parents, i)\n\t\t\tprotected |= rmap_write_protect(vcpu, sp->gfn);\n\n\t\tif (protected) {\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t\tflush = false;\n\t\t}\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tflush |= kvm_sync_page(vcpu, sp, &invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t}\n\t\tif (need_resched() || spin_needbreak(&vcpu->kvm->mmu_lock)) {\n\t\t\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\t\t\tcond_resched_lock(&vcpu->kvm->mmu_lock);\n\t\t\tflush = false;\n\t\t}\n\t}\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_flush_or_zap",
          "args": [
            "vcpu",
            "&invalid_list",
            "false",
            "flush"
          ],
          "line": 2461
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_flush_or_zap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2308-2317",
          "snippet": "static void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (kvm_mmu_remote_flush_or_zap(vcpu->kvm, invalid_list, remote_flush))\n\t\treturn;\n\n\tif (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (kvm_mmu_remote_flush_or_zap(vcpu->kvm, invalid_list, remote_flush))\n\t\treturn;\n\n\tif (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched_lock",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_needbreak",
          "args": [
            "&vcpu->kvm->mmu_lock"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "need_resched",
          "args": [],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_pages_clear_parents",
          "args": [
            "&parents"
          ],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pages_clear_parents",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2412-2427",
          "snippet": "static void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define INVALID_INDEX (-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_sync_page",
          "args": [
            "vcpu",
            "sp",
            "&invalid_list"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_sync_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2340-2355",
          "snippet": "static bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_sp",
          "args": [
            "pages",
            "sp",
            "parents",
            "i"
          ],
          "line": 2450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "vcpu->kvm"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_write_protect",
          "args": [
            "vcpu",
            "sp->gfn"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "slot_rmap_write_protect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5870-5874",
          "snippet": "static bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool slot_rmap_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_rmap_head *rmap_head)\n{\n\treturn __rmap_write_protect(kvm, rmap_head, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_sp",
          "args": [
            "pages",
            "sp",
            "parents",
            "i"
          ],
          "line": 2442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_unsync_walk",
          "args": [
            "parent",
            "&pages"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_unsync_walk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2241-2250",
          "snippet": "static int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define INVALID_INDEX (-1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "invalid_list"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void mmu_sync_children(struct kvm_vcpu *vcpu,\n\t\t\t      struct kvm_mmu_page *parent)\n{\n\tint i;\n\tstruct kvm_mmu_page *sp;\n\tstruct mmu_page_path parents;\n\tstruct kvm_mmu_pages pages;\n\tLIST_HEAD(invalid_list);\n\tbool flush = false;\n\n\twhile (mmu_unsync_walk(parent, &pages)) {\n\t\tbool protected = false;\n\n\t\tfor_each_sp(pages, sp, parents, i)\n\t\t\tprotected |= rmap_write_protect(vcpu, sp->gfn);\n\n\t\tif (protected) {\n\t\t\tkvm_flush_remote_tlbs(vcpu->kvm);\n\t\t\tflush = false;\n\t\t}\n\n\t\tfor_each_sp(pages, sp, parents, i) {\n\t\t\tflush |= kvm_sync_page(vcpu, sp, &invalid_list);\n\t\t\tmmu_pages_clear_parents(&parents);\n\t\t}\n\t\tif (need_resched() || spin_needbreak(&vcpu->kvm->mmu_lock)) {\n\t\t\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n\t\t\tcond_resched_lock(&vcpu->kvm->mmu_lock);\n\t\t\tflush = false;\n\t\t}\n\t}\n\n\tkvm_mmu_flush_or_zap(vcpu, &invalid_list, false, flush);\n}"
  },
  {
    "function_name": "mmu_pages_clear_parents",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2412-2427",
    "snippet": "static void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define INVALID_INDEX (-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_unsync_child_bit",
          "args": [
            "sp",
            "idx"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "clear_unsync_child_bit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2193-2198",
          "snippet": "static inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "idx == INVALID_INDEX"
          ],
          "line": 2423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic void mmu_pages_clear_parents(struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int level = 0;\n\n\tdo {\n\t\tunsigned int idx = parents->idx[level];\n\t\tsp = parents->parent[level];\n\t\tif (!sp)\n\t\t\treturn;\n\n\t\tWARN_ON(idx == INVALID_INDEX);\n\t\tclear_unsync_child_bit(sp, idx);\n\t\tlevel++;\n\t} while (!sp->unsync_children);\n}"
  },
  {
    "function_name": "mmu_pages_first",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2388-2410",
    "snippet": "static int mmu_pages_first(struct kvm_mmu_pages *pvec,\n\t\t\t   struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tint level;\n\n\tif (pvec->nr == 0)\n\t\treturn 0;\n\n\tWARN_ON(pvec->page[0].idx != INVALID_INDEX);\n\n\tsp = pvec->page[0].sp;\n\tlevel = sp->role.level;\n\tWARN_ON(level == PT_PAGE_TABLE_LEVEL);\n\n\tparents->parent[level-2] = sp;\n\n\t/* Also set up a sentinel.  Further entries in pvec are all\n\t * children of sp, so this element is never overwritten.\n\t */\n\tparents->parent[level-1] = NULL;\n\treturn mmu_pages_next(pvec, parents, 0);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define INVALID_INDEX (-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_pages_next",
          "args": [
            "pvec",
            "parents",
            "0"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pages_next",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2367-2386",
          "snippet": "static int mmu_pages_next(struct kvm_mmu_pages *pvec,\n\t\t\t  struct mmu_page_path *parents,\n\t\t\t  int i)\n{\n\tint n;\n\n\tfor (n = i+1; n < pvec->nr; n++) {\n\t\tstruct kvm_mmu_page *sp = pvec->page[n].sp;\n\t\tunsigned idx = pvec->page[n].idx;\n\t\tint level = sp->role.level;\n\n\t\tparents->idx[level-1] = idx;\n\t\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\t\tbreak;\n\n\t\tparents->parent[level-2] = sp;\n\t}\n\n\treturn n;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_pages_next(struct kvm_mmu_pages *pvec,\n\t\t\t  struct mmu_page_path *parents,\n\t\t\t  int i)\n{\n\tint n;\n\n\tfor (n = i+1; n < pvec->nr; n++) {\n\t\tstruct kvm_mmu_page *sp = pvec->page[n].sp;\n\t\tunsigned idx = pvec->page[n].idx;\n\t\tint level = sp->role.level;\n\n\t\tparents->idx[level-1] = idx;\n\t\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\t\tbreak;\n\n\t\tparents->parent[level-2] = sp;\n\t}\n\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "level == PT_PAGE_TABLE_LEVEL"
          ],
          "line": 2401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pvec->page[0].idx != INVALID_INDEX"
          ],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic int mmu_pages_first(struct kvm_mmu_pages *pvec,\n\t\t\t   struct mmu_page_path *parents)\n{\n\tstruct kvm_mmu_page *sp;\n\tint level;\n\n\tif (pvec->nr == 0)\n\t\treturn 0;\n\n\tWARN_ON(pvec->page[0].idx != INVALID_INDEX);\n\n\tsp = pvec->page[0].sp;\n\tlevel = sp->role.level;\n\tWARN_ON(level == PT_PAGE_TABLE_LEVEL);\n\n\tparents->parent[level-2] = sp;\n\n\t/* Also set up a sentinel.  Further entries in pvec are all\n\t * children of sp, so this element is never overwritten.\n\t */\n\tparents->parent[level-1] = NULL;\n\treturn mmu_pages_next(pvec, parents, 0);\n}"
  },
  {
    "function_name": "mmu_pages_next",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2367-2386",
    "snippet": "static int mmu_pages_next(struct kvm_mmu_pages *pvec,\n\t\t\t  struct mmu_page_path *parents,\n\t\t\t  int i)\n{\n\tint n;\n\n\tfor (n = i+1; n < pvec->nr; n++) {\n\t\tstruct kvm_mmu_page *sp = pvec->page[n].sp;\n\t\tunsigned idx = pvec->page[n].idx;\n\t\tint level = sp->role.level;\n\n\t\tparents->idx[level-1] = idx;\n\t\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\t\tbreak;\n\n\t\tparents->parent[level-2] = sp;\n\t}\n\n\treturn n;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_pages_next(struct kvm_mmu_pages *pvec,\n\t\t\t  struct mmu_page_path *parents,\n\t\t\t  int i)\n{\n\tint n;\n\n\tfor (n = i+1; n < pvec->nr; n++) {\n\t\tstruct kvm_mmu_page *sp = pvec->page[n].sp;\n\t\tunsigned idx = pvec->page[n].idx;\n\t\tint level = sp->role.level;\n\n\t\tparents->idx[level-1] = idx;\n\t\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\t\tbreak;\n\n\t\tparents->parent[level-2] = sp;\n\t}\n\n\treturn n;\n}"
  },
  {
    "function_name": "kvm_sync_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2340-2355",
    "snippet": "static bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_sync_page",
          "args": [
            "vcpu",
            "s",
            "invalid_list"
          ],
          "line": 2351
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_sync_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2340-2355",
          "snippet": "static bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "s->role.level != PT_PAGE_TABLE_LEVEL"
          ],
          "line": 2350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_gfn_indirect_valid_sp",
          "args": [
            "vcpu->kvm",
            "s",
            "gfn"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_sync_pages(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t   struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *s;\n\tbool ret = false;\n\n\tfor_each_gfn_indirect_valid_sp(vcpu->kvm, s, gfn) {\n\t\tif (!s->unsync)\n\t\t\tcontinue;\n\n\t\tWARN_ON(s->role.level != PT_PAGE_TABLE_LEVEL);\n\t\tret |= kvm_sync_page(vcpu, s, invalid_list);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_sync_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2332-2337",
    "snippet": "static bool kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t struct list_head *invalid_list)\n{\n\tkvm_unlink_unsync_page(vcpu->kvm, sp);\n\treturn __kvm_sync_page(vcpu, sp, invalid_list);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__kvm_sync_page",
          "args": [
            "vcpu",
            "sp",
            "invalid_list"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "__kvm_sync_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2282-2292",
          "snippet": "static bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif ((!is_ept_sp(sp) && sp->role.gpte_is_8_bytes != !!is_pae(vcpu)) ||\n\t    vcpu->arch.mmu->sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif ((!is_ept_sp(sp) && sp->role.gpte_is_8_bytes != !!is_pae(vcpu)) ||\n\t    vcpu->arch.mmu->sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_unlink_unsync_page",
          "args": [
            "vcpu->kvm",
            "sp"
          ],
          "line": 2335
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unlink_unsync_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2252-2258",
          "snippet": "static void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t struct list_head *invalid_list)\n{\n\tkvm_unlink_unsync_page(vcpu->kvm, sp);\n\treturn __kvm_sync_page(vcpu, sp, invalid_list);\n}"
  },
  {
    "function_name": "is_obsolete_sp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2326-2330",
    "snippet": "static bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn sp->role.invalid ||\n\t       unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sp->mmu_valid_gen != kvm->arch.mmu_valid_gen"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool is_obsolete_sp(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\treturn sp->role.invalid ||\n\t       unlikely(sp->mmu_valid_gen != kvm->arch.mmu_valid_gen);\n}"
  },
  {
    "function_name": "mmu_audit_disable",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2323-2323",
    "snippet": "static void mmu_audit_disable(void) { }",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_audit_disable(void) { }"
  },
  {
    "function_name": "kvm_mmu_audit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2322-2322",
    "snippet": "static void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void kvm_mmu_audit(struct kvm_vcpu *vcpu, int point) { }"
  },
  {
    "function_name": "kvm_mmu_flush_or_zap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2308-2317",
    "snippet": "static void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (kvm_mmu_remote_flush_or_zap(vcpu->kvm, invalid_list, remote_flush))\n\t\treturn;\n\n\tif (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TLB_FLUSH",
            "vcpu"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_remote_flush_or_zap",
          "args": [
            "vcpu->kvm",
            "invalid_list",
            "remote_flush"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_remote_flush_or_zap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2294-2306",
          "snippet": "static bool kvm_mmu_remote_flush_or_zap(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list,\n\t\t\t\t\tbool remote_flush)\n{\n\tif (!remote_flush && list_empty(invalid_list))\n\t\treturn false;\n\n\tif (!list_empty(invalid_list))\n\t\tkvm_mmu_commit_zap_page(kvm, invalid_list);\n\telse\n\t\tkvm_flush_remote_tlbs(kvm);\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_mmu_remote_flush_or_zap(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list,\n\t\t\t\t\tbool remote_flush)\n{\n\tif (!remote_flush && list_empty(invalid_list))\n\t\treturn false;\n\n\tif (!list_empty(invalid_list))\n\t\tkvm_mmu_commit_zap_page(kvm, invalid_list);\n\telse\n\t\tkvm_flush_remote_tlbs(kvm);\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_flush_or_zap(struct kvm_vcpu *vcpu,\n\t\t\t\t struct list_head *invalid_list,\n\t\t\t\t bool remote_flush, bool local_flush)\n{\n\tif (kvm_mmu_remote_flush_or_zap(vcpu->kvm, invalid_list, remote_flush))\n\t\treturn;\n\n\tif (local_flush)\n\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n}"
  },
  {
    "function_name": "kvm_mmu_remote_flush_or_zap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2294-2306",
    "snippet": "static bool kvm_mmu_remote_flush_or_zap(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list,\n\t\t\t\t\tbool remote_flush)\n{\n\tif (!remote_flush && list_empty(invalid_list))\n\t\treturn false;\n\n\tif (!list_empty(invalid_list))\n\t\tkvm_mmu_commit_zap_page(kvm, invalid_list);\n\telse\n\t\tkvm_flush_remote_tlbs(kvm);\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_commit_zap_page",
          "args": [
            "kvm",
            "invalid_list"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_commit_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2795-2818",
          "snippet": "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list)\n{\n\tstruct kvm_mmu_page *sp, *nsp;\n\n\tif (list_empty(invalid_list))\n\t\treturn;\n\n\t/*\n\t * We need to make sure everyone sees our modifications to\n\t * the page tables and see changes to vcpu->mode here. The barrier\n\t * in the kvm_flush_remote_tlbs() achieves this. This pairs\n\t * with vcpu_enter_guest and walk_shadow_page_lockless_begin/end.\n\t *\n\t * In addition, kvm_flush_remote_tlbs waits for all vcpus to exit\n\t * guest mode and/or lockless shadow page table walks.\n\t */\n\tkvm_flush_remote_tlbs(kvm);\n\n\tlist_for_each_entry_safe(sp, nsp, invalid_list, link) {\n\t\tWARN_ON(!sp->role.invalid || sp->root_count);\n\t\tkvm_mmu_free_page(sp);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "invalid_list"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "invalid_list"
          ],
          "line": 2298
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_mmu_remote_flush_or_zap(struct kvm *kvm,\n\t\t\t\t\tstruct list_head *invalid_list,\n\t\t\t\t\tbool remote_flush)\n{\n\tif (!remote_flush && list_empty(invalid_list))\n\t\treturn false;\n\n\tif (!list_empty(invalid_list))\n\t\tkvm_mmu_commit_zap_page(kvm, invalid_list);\n\telse\n\t\tkvm_flush_remote_tlbs(kvm);\n\treturn true;\n}"
  },
  {
    "function_name": "__kvm_sync_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2282-2292",
    "snippet": "static bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif ((!is_ept_sp(sp) && sp->role.gpte_is_8_bytes != !!is_pae(vcpu)) ||\n\t    vcpu->arch.mmu->sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
      "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_prepare_zap_page",
          "args": [
            "vcpu->kvm",
            "sp",
            "invalid_list"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_prepare_zap_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2786-2793",
          "snippet": "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);",
            "static void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list)\n{\n\tint nr_zapped;\n\n\t__kvm_mmu_prepare_zap_page(kvm, sp, invalid_list, &nr_zapped);\n\treturn nr_zapped;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu->arch.mmu->sync_page",
          "args": [
            "vcpu",
            "sp"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_pae",
          "args": [
            "vcpu"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "is_pae_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "143-146",
          "snippet": "static inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_pae_paging(struct kvm_vcpu *vcpu)\n{\n\treturn !is_long_mode(vcpu) && is_pae(vcpu) && is_paging(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_ept_sp",
          "args": [
            "sp"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "is_ept_sp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2276-2279",
          "snippet": "static inline bool is_ept_sp(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.cr0_wp && sp->role.smap_andnot_wp;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool is_ept_sp(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.cr0_wp && sp->role.smap_andnot_wp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic bool kvm_mmu_prepare_zap_page(struct kvm *kvm, struct kvm_mmu_page *sp,\n\t\t\t\t     struct list_head *invalid_list);\nstatic void kvm_mmu_commit_zap_page(struct kvm *kvm,\n\t\t\t\t    struct list_head *invalid_list);\n\nstatic bool __kvm_sync_page(struct kvm_vcpu *vcpu, struct kvm_mmu_page *sp,\n\t\t\t    struct list_head *invalid_list)\n{\n\tif ((!is_ept_sp(sp) && sp->role.gpte_is_8_bytes != !!is_pae(vcpu)) ||\n\t    vcpu->arch.mmu->sync_page(vcpu, sp) == 0) {\n\t\tkvm_mmu_prepare_zap_page(vcpu->kvm, sp, invalid_list);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "is_ept_sp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2276-2279",
    "snippet": "static inline bool is_ept_sp(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.cr0_wp && sp->role.smap_andnot_wp;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool is_ept_sp(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.cr0_wp && sp->role.smap_andnot_wp;\n}"
  },
  {
    "function_name": "kvm_unlink_unsync_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2252-2258",
    "snippet": "static void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_mmu_sync_page",
          "args": [
            "sp"
          ],
          "line": 2255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!sp->unsync"
          ],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_unlink_unsync_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tWARN_ON(!sp->unsync);\n\ttrace_kvm_mmu_sync_page(sp);\n\tsp->unsync = 0;\n\t--kvm->stat.mmu_unsync;\n}"
  },
  {
    "function_name": "mmu_unsync_walk",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2241-2250",
    "snippet": "static int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define INVALID_INDEX (-1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mmu_unsync_walk",
          "args": [
            "sp",
            "pvec"
          ],
          "line": 2249
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_unsync_walk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2200-2237",
          "snippet": "static int __mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tint i, ret, nr_unsync_leaf = 0;\n\n\tfor_each_set_bit(i, sp->unsync_child_bitmap, 512) {\n\t\tstruct kvm_mmu_page *child;\n\t\tu64 ent = sp->spt[i];\n\n\t\tif (!is_shadow_present_pte(ent) || is_large_pte(ent)) {\n\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchild = page_header(ent & PT64_BASE_ADDR_MASK);\n\n\t\tif (child->unsync_children) {\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tret = __mmu_unsync_walk(child, pvec);\n\t\t\tif (!ret) {\n\t\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\t\tcontinue;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tnr_unsync_leaf += ret;\n\t\t\t} else\n\t\t\t\treturn ret;\n\t\t} else if (child->unsync) {\n\t\t\tnr_unsync_leaf++;\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\tclear_unsync_child_bit(sp, i);\n\t}\n\n\treturn nr_unsync_leaf;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic int __mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tint i, ret, nr_unsync_leaf = 0;\n\n\tfor_each_set_bit(i, sp->unsync_child_bitmap, 512) {\n\t\tstruct kvm_mmu_page *child;\n\t\tu64 ent = sp->spt[i];\n\n\t\tif (!is_shadow_present_pte(ent) || is_large_pte(ent)) {\n\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchild = page_header(ent & PT64_BASE_ADDR_MASK);\n\n\t\tif (child->unsync_children) {\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tret = __mmu_unsync_walk(child, pvec);\n\t\t\tif (!ret) {\n\t\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\t\tcontinue;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tnr_unsync_leaf += ret;\n\t\t\t} else\n\t\t\t\treturn ret;\n\t\t} else if (child->unsync) {\n\t\t\tnr_unsync_leaf++;\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\tclear_unsync_child_bit(sp, i);\n\t}\n\n\treturn nr_unsync_leaf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_pages_add",
          "args": [
            "pvec",
            "sp",
            "INVALID_INDEX"
          ],
          "line": 2248
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pages_add",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2177-2191",
          "snippet": "static int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define KVM_PAGE_ARRAY_NR 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define KVM_PAGE_ARRAY_NR 16\n\nstatic int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define INVALID_INDEX (-1)\n\nstatic int mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tpvec->nr = 0;\n\tif (!sp->unsync_children)\n\t\treturn 0;\n\n\tmmu_pages_add(pvec, sp, INVALID_INDEX);\n\treturn __mmu_unsync_walk(sp, pvec);\n}"
  },
  {
    "function_name": "__mmu_unsync_walk",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2200-2237",
    "snippet": "static int __mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tint i, ret, nr_unsync_leaf = 0;\n\n\tfor_each_set_bit(i, sp->unsync_child_bitmap, 512) {\n\t\tstruct kvm_mmu_page *child;\n\t\tu64 ent = sp->spt[i];\n\n\t\tif (!is_shadow_present_pte(ent) || is_large_pte(ent)) {\n\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchild = page_header(ent & PT64_BASE_ADDR_MASK);\n\n\t\tif (child->unsync_children) {\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tret = __mmu_unsync_walk(child, pvec);\n\t\t\tif (!ret) {\n\t\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\t\tcontinue;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tnr_unsync_leaf += ret;\n\t\t\t} else\n\t\t\t\treturn ret;\n\t\t} else if (child->unsync) {\n\t\t\tnr_unsync_leaf++;\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\tclear_unsync_child_bit(sp, i);\n\t}\n\n\treturn nr_unsync_leaf;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
      "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_unsync_child_bit",
          "args": [
            "sp",
            "i"
          ],
          "line": 2233
        },
        "resolved": true,
        "details": {
          "function_name": "clear_unsync_child_bit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2193-2198",
          "snippet": "static inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_pages_add",
          "args": [
            "pvec",
            "child",
            "i"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_pages_add",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2177-2191",
          "snippet": "static int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define KVM_PAGE_ARRAY_NR 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define KVM_PAGE_ARRAY_NR 16\n\nstatic int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mmu_unsync_walk",
          "args": [
            "child",
            "pvec"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "__mmu_unsync_walk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2200-2237",
          "snippet": "static int __mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tint i, ret, nr_unsync_leaf = 0;\n\n\tfor_each_set_bit(i, sp->unsync_child_bitmap, 512) {\n\t\tstruct kvm_mmu_page *child;\n\t\tu64 ent = sp->spt[i];\n\n\t\tif (!is_shadow_present_pte(ent) || is_large_pte(ent)) {\n\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchild = page_header(ent & PT64_BASE_ADDR_MASK);\n\n\t\tif (child->unsync_children) {\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tret = __mmu_unsync_walk(child, pvec);\n\t\t\tif (!ret) {\n\t\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\t\tcontinue;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tnr_unsync_leaf += ret;\n\t\t\t} else\n\t\t\t\treturn ret;\n\t\t} else if (child->unsync) {\n\t\t\tnr_unsync_leaf++;\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\tclear_unsync_child_bit(sp, i);\n\t}\n\n\treturn nr_unsync_leaf;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "ent & PT64_BASE_ADDR_MASK"
          ],
          "line": 2214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "ent"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "616-619",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "ent"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "i",
            "sp->unsync_child_bitmap",
            "512"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic int __mmu_unsync_walk(struct kvm_mmu_page *sp,\n\t\t\t   struct kvm_mmu_pages *pvec)\n{\n\tint i, ret, nr_unsync_leaf = 0;\n\n\tfor_each_set_bit(i, sp->unsync_child_bitmap, 512) {\n\t\tstruct kvm_mmu_page *child;\n\t\tu64 ent = sp->spt[i];\n\n\t\tif (!is_shadow_present_pte(ent) || is_large_pte(ent)) {\n\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tchild = page_header(ent & PT64_BASE_ADDR_MASK);\n\n\t\tif (child->unsync_children) {\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\n\t\t\tret = __mmu_unsync_walk(child, pvec);\n\t\t\tif (!ret) {\n\t\t\t\tclear_unsync_child_bit(sp, i);\n\t\t\t\tcontinue;\n\t\t\t} else if (ret > 0) {\n\t\t\t\tnr_unsync_leaf += ret;\n\t\t\t} else\n\t\t\t\treturn ret;\n\t\t} else if (child->unsync) {\n\t\t\tnr_unsync_leaf++;\n\t\t\tif (mmu_pages_add(pvec, child, i))\n\t\t\t\treturn -ENOSPC;\n\t\t} else\n\t\t\tclear_unsync_child_bit(sp, i);\n\t}\n\n\treturn nr_unsync_leaf;\n}"
  },
  {
    "function_name": "clear_unsync_child_bit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2193-2198",
    "snippet": "static inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "idx",
            "sp->unsync_child_bitmap"
          ],
          "line": 2197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(int)sp->unsync_children < 0"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline void clear_unsync_child_bit(struct kvm_mmu_page *sp, int idx)\n{\n\t--sp->unsync_children;\n\tWARN_ON((int)sp->unsync_children < 0);\n\t__clear_bit(idx, sp->unsync_child_bitmap);\n}"
  },
  {
    "function_name": "mmu_pages_add",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2177-2191",
    "snippet": "static int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define KVM_PAGE_ARRAY_NR 16"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define KVM_PAGE_ARRAY_NR 16\n\nstatic int mmu_pages_add(struct kvm_mmu_pages *pvec, struct kvm_mmu_page *sp,\n\t\t\t int idx)\n{\n\tint i;\n\n\tif (sp->unsync)\n\t\tfor (i=0; i < pvec->nr; i++)\n\t\t\tif (pvec->page[i].sp == sp)\n\t\t\t\treturn 0;\n\n\tpvec->page[pvec->nr].sp = sp;\n\tpvec->page[pvec->nr].idx = idx;\n\tpvec->nr++;\n\treturn (pvec->nr == KVM_PAGE_ARRAY_NR);\n}"
  },
  {
    "function_name": "nonpaging_update_pte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2160-2165",
    "snippet": "static void nonpaging_update_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t const void *pte)\n{\n\tWARN_ON(1);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void nonpaging_update_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t struct kvm_mmu_page *sp, u64 *spte,\n\t\t\t\t const void *pte)\n{\n\tWARN_ON(1);\n}"
  },
  {
    "function_name": "nonpaging_invlpg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2156-2158",
    "snippet": "static void nonpaging_invlpg(struct kvm_vcpu *vcpu, gva_t gva, hpa_t root)\n{\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void nonpaging_invlpg(struct kvm_vcpu *vcpu, gva_t gva, hpa_t root)\n{\n}"
  },
  {
    "function_name": "nonpaging_sync_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2150-2154",
    "snippet": "static int nonpaging_sync_page(struct kvm_vcpu *vcpu,\n\t\t\t       struct kvm_mmu_page *sp)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int nonpaging_sync_page(struct kvm_vcpu *vcpu,\n\t\t\t       struct kvm_mmu_page *sp)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "mark_unsync",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2136-2148",
    "snippet": "static void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_mark_parents_unsync",
          "args": [
            "sp"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_mark_parents_unsync",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2126-2134",
          "snippet": "static void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__test_and_set_bit",
          "args": [
            "index",
            "sp->unsync_child_bitmap"
          ],
          "line": 2143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(spte)"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "spte"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}"
  },
  {
    "function_name": "kvm_mmu_mark_parents_unsync",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2126-2134",
    "snippet": "static void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_unsync",
          "args": [
            "sptep"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "mark_unsync",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2136-2148",
          "snippet": "static void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void mark_unsync(u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tunsigned int index;\n\n\tsp = page_header(__pa(spte));\n\tindex = spte - sp->spt;\n\tif (__test_and_set_bit(index, sp->unsync_child_bitmap))\n\t\treturn;\n\tif (sp->unsync_children++)\n\t\treturn;\n\tkvm_mmu_mark_parents_unsync(sp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "&sp->parent_ptes",
            "&iter",
            "sptep"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_mark_parents_unsync(struct kvm_mmu_page *sp)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(&sp->parent_ptes, &iter, sptep) {\n\t\tmark_unsync(sptep);\n\t}\n}"
  },
  {
    "function_name": "kvm_mmu_alloc_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2104-2123",
    "snippet": "static struct kvm_mmu_page *kvm_mmu_alloc_page(struct kvm_vcpu *vcpu, int direct)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_header_cache);\n\tsp->spt = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tif (!direct)\n\t\tsp->gfns = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tset_page_private(virt_to_page(sp->spt), (unsigned long)sp);\n\n\t/*\n\t * active_mmu_pages must be a FIFO list, as kvm_zap_obsolete_pages()\n\t * depends on valid pages being added to the head of the list.  See\n\t * comments in kvm_zap_obsolete_pages().\n\t */\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tlist_add(&sp->link, &vcpu->kvm->arch.active_mmu_pages);\n\tkvm_mod_used_mmu_pages(vcpu->kvm, +1);\n\treturn sp;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *mmu_page_header_cache;",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mod_used_mmu_pages",
          "args": [
            "vcpu->kvm",
            "+1"
          ],
          "line": 2121
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mod_used_mmu_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2060-2064",
          "snippet": "static inline void kvm_mod_used_mmu_pages(struct kvm *kvm, unsigned long nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct percpu_counter kvm_total_used_mmu_pages;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct percpu_counter kvm_total_used_mmu_pages;\n\nstatic inline void kvm_mod_used_mmu_pages(struct kvm *kvm, unsigned long nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&sp->link",
            "&vcpu->kvm->arch.active_mmu_pages"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "svm_ir_list_add",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4206-4248",
          "snippet": "static int svm_ir_list_add(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\n\t/**\n\t * In some cases, the existing irte is updaed and re-set,\n\t * so we need to check here if it's already been * added\n\t * to the ir_list.\n\t */\n\tif (pi->ir_data && (pi->prev_ga_tag != 0)) {\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tu32 vcpu_id = AVIC_GATAG_TO_VCPUID(pi->prev_ga_tag);\n\t\tstruct kvm_vcpu *prev_vcpu = kvm_get_vcpu_by_id(kvm, vcpu_id);\n\t\tstruct vcpu_svm *prev_svm;\n\n\t\tif (!prev_vcpu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprev_svm = to_svm(prev_vcpu);\n\t\tsvm_ir_list_del(prev_svm, pi);\n\t}\n\n\t/**\n\t * Allocating new amd_iommu_pi_data, which will get\n\t * add to the per-vcpu ir_list.\n\t */\n\tir = kzalloc(sizeof(struct amd_svm_iommu_ir), GFP_KERNEL_ACCOUNT);\n\tif (!ir) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tir->data = pi->ir_data;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_add(&ir->node, &svm->ir_list);\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_ir_list_add(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\n\t/**\n\t * In some cases, the existing irte is updaed and re-set,\n\t * so we need to check here if it's already been * added\n\t * to the ir_list.\n\t */\n\tif (pi->ir_data && (pi->prev_ga_tag != 0)) {\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tu32 vcpu_id = AVIC_GATAG_TO_VCPUID(pi->prev_ga_tag);\n\t\tstruct kvm_vcpu *prev_vcpu = kvm_get_vcpu_by_id(kvm, vcpu_id);\n\t\tstruct vcpu_svm *prev_svm;\n\n\t\tif (!prev_vcpu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprev_svm = to_svm(prev_vcpu);\n\t\tsvm_ir_list_del(prev_svm, pi);\n\t}\n\n\t/**\n\t * Allocating new amd_iommu_pi_data, which will get\n\t * add to the per-vcpu ir_list.\n\t */\n\tir = kzalloc(sizeof(struct amd_svm_iommu_ir), GFP_KERNEL_ACCOUNT);\n\tif (!ir) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tir->data = pi->ir_data;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_add(&ir->node, &svm->ir_list);\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_page_private",
          "args": [
            "virt_to_page(sp->spt)",
            "(unsigned long)sp"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "sp->spt"
          ],
          "line": 2112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_memory_cache_alloc",
          "args": [
            "&vcpu->arch.mmu_page_cache"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_memory_cache_alloc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1138-1145",
          "snippet": "static void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_mmu_page *kvm_mmu_alloc_page(struct kvm_vcpu *vcpu, int direct)\n{\n\tstruct kvm_mmu_page *sp;\n\n\tsp = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_header_cache);\n\tsp->spt = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tif (!direct)\n\t\tsp->gfns = mmu_memory_cache_alloc(&vcpu->arch.mmu_page_cache);\n\tset_page_private(virt_to_page(sp->spt), (unsigned long)sp);\n\n\t/*\n\t * active_mmu_pages must be a FIFO list, as kvm_zap_obsolete_pages()\n\t * depends on valid pages being added to the head of the list.  See\n\t * comments in kvm_zap_obsolete_pages().\n\t */\n\tsp->mmu_valid_gen = vcpu->kvm->arch.mmu_valid_gen;\n\tlist_add(&sp->link, &vcpu->kvm->arch.active_mmu_pages);\n\tkvm_mod_used_mmu_pages(vcpu->kvm, +1);\n\treturn sp;\n}"
  },
  {
    "function_name": "drop_parent_pte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2097-2102",
    "snippet": "static void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_clear_no_track",
          "args": [
            "parent_pte"
          ],
          "line": 2101
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_clear_no_track",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "954-957",
          "snippet": "static void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_page_remove_parent_pte",
          "args": [
            "sp",
            "parent_pte"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_page_remove_parent_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2091-2095",
          "snippet": "static void mmu_page_remove_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t\t       u64 *parent_pte)\n{\n\t__pte_list_remove(parent_pte, &sp->parent_ptes);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_page_remove_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t\t       u64 *parent_pte)\n{\n\t__pte_list_remove(parent_pte, &sp->parent_ptes);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t    u64 *parent_pte)\n{\n\tmmu_page_remove_parent_pte(sp, parent_pte);\n\tmmu_spte_clear_no_track(parent_pte);\n}"
  },
  {
    "function_name": "mmu_page_remove_parent_pte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2091-2095",
    "snippet": "static void mmu_page_remove_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t\t       u64 *parent_pte)\n{\n\t__pte_list_remove(parent_pte, &sp->parent_ptes);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pte_list_remove",
          "args": [
            "parent_pte",
            "&sp->parent_ptes"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "__pte_list_remove",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1353-1387",
          "snippet": "static void __pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tpr_err(\"%s: %p 0->BUG\\n\", __func__, spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"%s:  %p 1->0\\n\", __func__, spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tpr_err(\"%s:  %p 1->BUG\\n\", __func__, spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"%s:  %p many->many\\n\", __func__, spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"%s: %p many->many\\n\", __func__, spte);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_LIST_EXT 3"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tpr_err(\"%s: %p 0->BUG\\n\", __func__, spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"%s:  %p 1->0\\n\", __func__, spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tpr_err(\"%s:  %p 1->BUG\\n\", __func__, spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"%s:  %p many->many\\n\", __func__, spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"%s: %p many->many\\n\", __func__, spte);\n\t\tBUG();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_page_remove_parent_pte(struct kvm_mmu_page *sp,\n\t\t\t\t       u64 *parent_pte)\n{\n\t__pte_list_remove(parent_pte, &sp->parent_ptes);\n}"
  },
  {
    "function_name": "mmu_page_add_parent_pte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2082-2089",
    "snippet": "static void mmu_page_add_parent_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp, u64 *parent_pte)\n{\n\tif (!parent_pte)\n\t\treturn;\n\n\tpte_list_add(vcpu, parent_pte, &sp->parent_ptes);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_list_add",
          "args": [
            "vcpu",
            "parent_pte",
            "&sp->parent_ptes"
          ],
          "line": 2088
        },
        "resolved": true,
        "details": {
          "function_name": "pte_list_add",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1296-1328",
          "snippet": "static int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_LIST_EXT 3"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void mmu_page_add_parent_pte(struct kvm_vcpu *vcpu,\n\t\t\t\t    struct kvm_mmu_page *sp, u64 *parent_pte)\n{\n\tif (!parent_pte)\n\t\treturn;\n\n\tpte_list_add(vcpu, parent_pte, &sp->parent_ptes);\n}"
  },
  {
    "function_name": "kvm_page_table_hashfn",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2077-2080",
    "snippet": "static unsigned kvm_page_table_hashfn(gfn_t gfn)\n{\n\treturn hash_64(gfn, KVM_MMU_HASH_SHIFT);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hash_64",
          "args": [
            "gfn",
            "KVM_MMU_HASH_SHIFT"
          ],
          "line": 2079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic unsigned kvm_page_table_hashfn(gfn_t gfn)\n{\n\treturn hash_64(gfn, KVM_MMU_HASH_SHIFT);\n}"
  },
  {
    "function_name": "kvm_mmu_free_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2066-2075",
    "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *mmu_page_header_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "mmu_page_header_cache",
            "sp"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)sp->gfns"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2066-2075",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sp->link"
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_del",
          "args": [
            "&sp->hash_link"
          ],
          "line": 2069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "!is_empty_shadow_page(sp->spt)"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_empty_shadow_page",
          "args": [
            "sp->spt"
          ],
          "line": 2068
        },
        "resolved": true,
        "details": {
          "function_name": "is_empty_shadow_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2039-2051",
          "snippet": "static int is_empty_shadow_page(u64 *spt)\n{\n\tu64 *pos;\n\tu64 *end;\n\n\tfor (pos = spt, end = pos + PAGE_SIZE / sizeof(u64); pos != end; pos++)\n\t\tif (is_shadow_present_pte(*pos)) {\n\t\t\tprintk(KERN_ERR \"%s: %p %llx\\n\", __func__,\n\t\t\t       pos, *pos);\n\t\t\treturn 0;\n\t\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_empty_shadow_page(u64 *spt)\n{\n\tu64 *pos;\n\tu64 *end;\n\n\tfor (pos = spt, end = pos + PAGE_SIZE / sizeof(u64); pos != end; pos++)\n\t\tif (is_shadow_present_pte(*pos)) {\n\t\t\tprintk(KERN_ERR \"%s: %p %llx\\n\", __func__,\n\t\t\t       pos, *pos);\n\t\t\treturn 0;\n\t\t}\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
  },
  {
    "function_name": "kvm_mod_used_mmu_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2060-2064",
    "snippet": "static inline void kvm_mod_used_mmu_pages(struct kvm *kvm, unsigned long nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct percpu_counter kvm_total_used_mmu_pages;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "percpu_counter_add",
          "args": [
            "&kvm_total_used_mmu_pages",
            "nr"
          ],
          "line": 2063
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct percpu_counter kvm_total_used_mmu_pages;\n\nstatic inline void kvm_mod_used_mmu_pages(struct kvm *kvm, unsigned long nr)\n{\n\tkvm->arch.n_used_mmu_pages += nr;\n\tpercpu_counter_add(&kvm_total_used_mmu_pages, nr);\n}"
  },
  {
    "function_name": "is_empty_shadow_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2039-2051",
    "snippet": "static int is_empty_shadow_page(u64 *spt)\n{\n\tu64 *pos;\n\tu64 *end;\n\n\tfor (pos = spt, end = pos + PAGE_SIZE / sizeof(u64); pos != end; pos++)\n\t\tif (is_shadow_present_pte(*pos)) {\n\t\t\tprintk(KERN_ERR \"%s: %p %llx\\n\", __func__,\n\t\t\t       pos, *pos);\n\t\t\treturn 0;\n\t\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: %p %llx\\n\"",
            "__func__",
            "pos",
            "*pos"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*pos"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_empty_shadow_page(u64 *spt)\n{\n\tu64 *pos;\n\tu64 *end;\n\n\tfor (pos = spt, end = pos + PAGE_SIZE / sizeof(u64); pos != end; pos++)\n\t\tif (is_shadow_present_pte(*pos)) {\n\t\t\tprintk(KERN_ERR \"%s: %p %llx\\n\", __func__,\n\t\t\t       pos, *pos);\n\t\t\treturn 0;\n\t\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "kvm_test_age_hva",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2033-2036",
    "snippet": "int kvm_test_age_hva(struct kvm *kvm, unsigned long hva)\n{\n\treturn kvm_handle_hva(kvm, hva, 0, kvm_test_age_rmapp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_hva",
          "args": [
            "kvm",
            "hva",
            "0",
            "kvm_test_age_rmapp"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_hva",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1963-1972",
          "snippet": "static int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nint kvm_test_age_hva(struct kvm *kvm, unsigned long hva)\n{\n\treturn kvm_handle_hva(kvm, hva, 0, kvm_test_age_rmapp);\n}"
  },
  {
    "function_name": "kvm_age_hva",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2028-2031",
    "snippet": "int kvm_age_hva(struct kvm *kvm, unsigned long start, unsigned long end)\n{\n\treturn kvm_handle_hva_range(kvm, start, end, 0, kvm_age_rmapp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_hva_range",
          "args": [
            "kvm",
            "start",
            "end",
            "0",
            "kvm_age_rmapp"
          ],
          "line": 2030
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_hva_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1916-1961",
          "snippet": "static int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nint kvm_age_hva(struct kvm *kvm, unsigned long start, unsigned long end)\n{\n\treturn kvm_handle_hva_range(kvm, start, end, 0, kvm_age_rmapp);\n}"
  },
  {
    "function_name": "rmap_recycle",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "2014-2026",
    "snippet": "static void rmap_recycle(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(spte));\n\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\n\tkvm_unmap_rmapp(vcpu->kvm, rmap_head, NULL, gfn, sp->role.level, 0);\n\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, sp->gfn,\n\t\t\tKVM_PAGES_PER_HPAGE(sp->role.level));\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs_with_address",
          "args": [
            "vcpu->kvm",
            "sp->gfn",
            "KVM_PAGES_PER_HPAGE(sp->role.level)"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_flush_remote_tlbs_with_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "323-332",
          "snippet": "static void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "sp->role.level"
          ],
          "line": 2025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_unmap_rmapp",
          "args": [
            "vcpu->kvm",
            "rmap_head",
            "NULL",
            "gfn",
            "sp->role.level",
            "0"
          ],
          "line": 2023
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_unmap_rmapp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1795-1800",
          "snippet": "static int kvm_unmap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t   struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t   unsigned long data)\n{\n\treturn kvm_zap_rmapp(kvm, rmap_head);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_unmap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t   struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t   unsigned long data)\n{\n\treturn kvm_zap_rmapp(kvm, rmap_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfn_to_rmap",
          "args": [
            "vcpu->kvm",
            "gfn",
            "sp"
          ],
          "line": 2021
        },
        "resolved": true,
        "details": {
          "function_name": "gfn_to_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1404-1413",
          "snippet": "static struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(spte)"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "spte"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void rmap_recycle(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tstruct kvm_mmu_page *sp;\n\n\tsp = page_header(__pa(spte));\n\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\n\tkvm_unmap_rmapp(vcpu->kvm, rmap_head, NULL, gfn, sp->role.level, 0);\n\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, sp->gfn,\n\t\t\tKVM_PAGES_PER_HPAGE(sp->role.level));\n}"
  },
  {
    "function_name": "kvm_test_age_rmapp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1999-2010",
    "snippet": "static int kvm_test_age_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t      struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t      int level, unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tif (is_accessed_spte(*sptep))\n\t\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_accessed_spte",
          "args": [
            "*sptep"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "is_accessed_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "814-820",
          "snippet": "static bool is_accessed_spte(u64 spte)\n{\n\tu64 accessed_mask = spte_shadow_accessed_mask(spte);\n\n\treturn accessed_mask ? spte & accessed_mask\n\t\t\t     : !is_access_track_spte(spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_accessed_spte(u64 spte)\n{\n\tu64 accessed_mask = spte_shadow_accessed_mask(spte);\n\n\treturn accessed_mask ? spte & accessed_mask\n\t\t\t     : !is_access_track_spte(spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_test_age_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t      struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t      int level, unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tif (is_accessed_spte(*sptep))\n\t\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_age_rmapp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1984-1997",
    "snippet": "static int kvm_age_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator uninitialized_var(iter);\n\tint young = 0;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tyoung |= mmu_spte_age(sptep);\n\n\ttrace_kvm_age_page(gfn, level, slot, young);\n\treturn young;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_age_page",
          "args": [
            "gfn",
            "level",
            "slot",
            "young"
          ],
          "line": 1995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mmu_spte_age",
          "args": [
            "sptep"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_age",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1011-1034",
          "snippet": "static bool mmu_spte_age(u64 *sptep)\n{\n\tu64 spte = mmu_spte_get_lockless(sptep);\n\n\tif (!is_accessed_spte(spte))\n\t\treturn false;\n\n\tif (spte_ad_enabled(spte)) {\n\t\tclear_bit((ffs(shadow_accessed_mask) - 1),\n\t\t\t  (unsigned long *)sptep);\n\t} else {\n\t\t/*\n\t\t * Capture the dirty status of the page, so that it doesn't get\n\t\t * lost when the SPTE is marked for access tracking.\n\t\t */\n\t\tif (is_writable_pte(spte))\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(spte));\n\n\t\tspte = mark_spte_for_access_track(spte);\n\t\tmmu_spte_update_no_track(sptep, spte);\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_spte_age(u64 *sptep)\n{\n\tu64 spte = mmu_spte_get_lockless(sptep);\n\n\tif (!is_accessed_spte(spte))\n\t\treturn false;\n\n\tif (spte_ad_enabled(spte)) {\n\t\tclear_bit((ffs(shadow_accessed_mask) - 1),\n\t\t\t  (unsigned long *)sptep);\n\t} else {\n\t\t/*\n\t\t * Capture the dirty status of the page, so that it doesn't get\n\t\t * lost when the SPTE is marked for access tracking.\n\t\t */\n\t\tif (is_writable_pte(spte))\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(spte));\n\n\t\tspte = mark_spte_for_access_track(spte);\n\t\tmmu_spte_update_no_track(sptep, spte);\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_age_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator uninitialized_var(iter);\n\tint young = 0;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tyoung |= mmu_spte_age(sptep);\n\n\ttrace_kvm_age_page(gfn, level, slot, young);\n\treturn young;\n}"
  },
  {
    "function_name": "kvm_set_spte_hva",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1979-1982",
    "snippet": "int kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte)\n{\n\treturn kvm_handle_hva(kvm, hva, (unsigned long)&pte, kvm_set_pte_rmapp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_hva",
          "args": [
            "kvm",
            "hva",
            "(unsigned long)&pte",
            "kvm_set_pte_rmapp"
          ],
          "line": 1981
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_hva",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1963-1972",
          "snippet": "static int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nint kvm_set_spte_hva(struct kvm *kvm, unsigned long hva, pte_t pte)\n{\n\treturn kvm_handle_hva(kvm, hva, (unsigned long)&pte, kvm_set_pte_rmapp);\n}"
  },
  {
    "function_name": "kvm_unmap_hva_range",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1974-1977",
    "snippet": "int kvm_unmap_hva_range(struct kvm *kvm, unsigned long start, unsigned long end)\n{\n\treturn kvm_handle_hva_range(kvm, start, end, 0, kvm_unmap_rmapp);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_hva_range",
          "args": [
            "kvm",
            "start",
            "end",
            "0",
            "kvm_unmap_rmapp"
          ],
          "line": 1976
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_hva_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1916-1961",
          "snippet": "static int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nint kvm_unmap_hva_range(struct kvm *kvm, unsigned long start, unsigned long end)\n{\n\treturn kvm_handle_hva_range(kvm, start, end, 0, kvm_unmap_rmapp);\n}"
  },
  {
    "function_name": "kvm_handle_hva",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1963-1972",
    "snippet": "static int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_hva_range",
          "args": [
            "kvm",
            "hva",
            "hva + 1",
            "data",
            "handler"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_hva_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1916-1961",
          "snippet": "static int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva(struct kvm *kvm, unsigned long hva,\n\t\t\t  unsigned long data,\n\t\t\t  int (*handler)(struct kvm *kvm,\n\t\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t struct kvm_memory_slot *slot,\n\t\t\t\t\t gfn_t gfn, int level,\n\t\t\t\t\t unsigned long data))\n{\n\treturn kvm_handle_hva_range(kvm, hva, hva + 1, data, handler);\n}"
  },
  {
    "function_name": "kvm_handle_hva_range",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1916-1961",
    "snippet": "static int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "handler",
          "args": [
            "kvm",
            "iterator.rmap",
            "memslot",
            "iterator.gfn",
            "iterator.level",
            "data"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_slot_rmap_range",
          "args": [
            "memslot",
            "PT_PAGE_TABLE_LEVEL",
            "PT_MAX_HUGEPAGE_LEVEL",
            "gfn_start",
            "gfn_end - 1",
            "&iterator"
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hva_to_gfn_memslot",
          "args": [
            "hva_end + PAGE_SIZE - 1",
            "memslot"
          ],
          "line": 1949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hva_to_gfn_memslot",
          "args": [
            "hva_start",
            "memslot"
          ],
          "line": 1948
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "end",
            "memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT)"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "start",
            "memslot->userspace_addr"
          ],
          "line": 1939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_memslot",
          "args": [
            "memslot",
            "slots"
          ],
          "line": 1935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kvm_memslots",
          "args": [
            "kvm",
            "i"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_handle_hva_range(struct kvm *kvm,\n\t\t\t\tunsigned long start,\n\t\t\t\tunsigned long end,\n\t\t\t\tunsigned long data,\n\t\t\t\tint (*handler)(struct kvm *kvm,\n\t\t\t\t\t       struct kvm_rmap_head *rmap_head,\n\t\t\t\t\t       struct kvm_memory_slot *slot,\n\t\t\t\t\t       gfn_t gfn,\n\t\t\t\t\t       int level,\n\t\t\t\t\t       unsigned long data))\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *memslot;\n\tstruct slot_rmap_walk_iterator iterator;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tslots = __kvm_memslots(kvm, i);\n\t\tkvm_for_each_memslot(memslot, slots) {\n\t\t\tunsigned long hva_start, hva_end;\n\t\t\tgfn_t gfn_start, gfn_end;\n\n\t\t\thva_start = max(start, memslot->userspace_addr);\n\t\t\thva_end = min(end, memslot->userspace_addr +\n\t\t\t\t      (memslot->npages << PAGE_SHIFT));\n\t\t\tif (hva_start >= hva_end)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * {gfn(page) | page intersects with [hva_start, hva_end)} =\n\t\t\t * {gfn_start, gfn_start+1, ..., gfn_end-1}.\n\t\t\t */\n\t\t\tgfn_start = hva_to_gfn_memslot(hva_start, memslot);\n\t\t\tgfn_end = hva_to_gfn_memslot(hva_end + PAGE_SIZE - 1, memslot);\n\n\t\t\tfor_each_slot_rmap_range(memslot, PT_PAGE_TABLE_LEVEL,\n\t\t\t\t\t\t PT_MAX_HUGEPAGE_LEVEL,\n\t\t\t\t\t\t gfn_start, gfn_end - 1,\n\t\t\t\t\t\t &iterator)\n\t\t\t\tret |= handler(kvm, iterator.rmap, memslot,\n\t\t\t\t\t       iterator.gfn, iterator.level, data);\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "slot_rmap_walk_next",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1894-1907",
    "snippet": "static void slot_rmap_walk_next(struct slot_rmap_walk_iterator *iterator)\n{\n\tif (++iterator->rmap <= iterator->end_rmap) {\n\t\titerator->gfn += (1UL << KVM_HPAGE_GFN_SHIFT(iterator->level));\n\t\treturn;\n\t}\n\n\tif (++iterator->level > iterator->end_level) {\n\t\titerator->rmap = NULL;\n\t\treturn;\n\t}\n\n\trmap_walk_init_level(iterator, iterator->level);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_walk_init_level",
          "args": [
            "iterator",
            "iterator->level"
          ],
          "line": 1906
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_init_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1865-1873",
          "snippet": "static void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_HPAGE_GFN_SHIFT",
          "args": [
            "iterator->level"
          ],
          "line": 1897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void slot_rmap_walk_next(struct slot_rmap_walk_iterator *iterator)\n{\n\tif (++iterator->rmap <= iterator->end_rmap) {\n\t\titerator->gfn += (1UL << KVM_HPAGE_GFN_SHIFT(iterator->level));\n\t\treturn;\n\t}\n\n\tif (++iterator->level > iterator->end_level) {\n\t\titerator->rmap = NULL;\n\t\treturn;\n\t}\n\n\trmap_walk_init_level(iterator, iterator->level);\n}"
  },
  {
    "function_name": "slot_rmap_walk_okay",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1889-1892",
    "snippet": "static bool slot_rmap_walk_okay(struct slot_rmap_walk_iterator *iterator)\n{\n\treturn !!iterator->rmap;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool slot_rmap_walk_okay(struct slot_rmap_walk_iterator *iterator)\n{\n\treturn !!iterator->rmap;\n}"
  },
  {
    "function_name": "slot_rmap_walk_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1875-1887",
    "snippet": "static void\nslot_rmap_walk_init(struct slot_rmap_walk_iterator *iterator,\n\t\t    struct kvm_memory_slot *slot, int start_level,\n\t\t    int end_level, gfn_t start_gfn, gfn_t end_gfn)\n{\n\titerator->slot = slot;\n\titerator->start_level = start_level;\n\titerator->end_level = end_level;\n\titerator->start_gfn = start_gfn;\n\titerator->end_gfn = end_gfn;\n\n\trmap_walk_init_level(iterator, iterator->start_level);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_walk_init_level",
          "args": [
            "iterator",
            "iterator->start_level"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_walk_init_level",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1865-1873",
          "snippet": "static void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\nslot_rmap_walk_init(struct slot_rmap_walk_iterator *iterator,\n\t\t    struct kvm_memory_slot *slot, int start_level,\n\t\t    int end_level, gfn_t start_gfn, gfn_t end_gfn)\n{\n\titerator->slot = slot;\n\titerator->start_level = start_level;\n\titerator->end_level = end_level;\n\titerator->start_gfn = start_gfn;\n\titerator->end_gfn = end_gfn;\n\n\trmap_walk_init_level(iterator, iterator->start_level);\n}"
  },
  {
    "function_name": "rmap_walk_init_level",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1865-1873",
    "snippet": "static void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "iterator->end_gfn",
            "level",
            "iterator->slot"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1395-1402",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void\nrmap_walk_init_level(struct slot_rmap_walk_iterator *iterator, int level)\n{\n\titerator->level = level;\n\titerator->gfn = iterator->start_gfn;\n\titerator->rmap = __gfn_to_rmap(iterator->gfn, level, iterator->slot);\n\titerator->end_rmap = __gfn_to_rmap(iterator->end_gfn, level,\n\t\t\t\t\t   iterator->slot);\n}"
  },
  {
    "function_name": "kvm_set_pte_rmapp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1802-1846",
    "snippet": "static int kvm_set_pte_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t     struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t     unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tint need_flush = 0;\n\tu64 new_spte;\n\tpte_t *ptep = (pte_t *)data;\n\tkvm_pfn_t new_pfn;\n\n\tWARN_ON(pte_huge(*ptep));\n\tnew_pfn = pte_pfn(*ptep);\n\nrestart:\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\trmap_printk(\"kvm_set_pte_rmapp: spte %p %llx gfn %llx (%d)\\n\",\n\t\t\t    sptep, *sptep, gfn, level);\n\n\t\tneed_flush = 1;\n\n\t\tif (pte_write(*ptep)) {\n\t\t\tpte_list_remove(rmap_head, sptep);\n\t\t\tgoto restart;\n\t\t} else {\n\t\t\tnew_spte = *sptep & ~PT64_BASE_ADDR_MASK;\n\t\t\tnew_spte |= (u64)new_pfn << PAGE_SHIFT;\n\n\t\t\tnew_spte &= ~PT_WRITABLE_MASK;\n\t\t\tnew_spte &= ~SPTE_HOST_WRITEABLE;\n\n\t\t\tnew_spte = mark_spte_for_access_track(new_spte);\n\n\t\t\tmmu_spte_clear_track_bits(sptep);\n\t\t\tmmu_spte_set(sptep, new_spte);\n\t\t}\n\t}\n\n\tif (need_flush && kvm_available_flush_tlb_with_range()) {\n\t\tkvm_flush_remote_tlbs_with_address(kvm, gfn, 1);\n\t\treturn 0;\n\t}\n\n\treturn need_flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)",
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
      "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs_with_address",
          "args": [
            "kvm",
            "gfn",
            "1"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_flush_remote_tlbs_with_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "323-332",
          "snippet": "static void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_available_flush_tlb_with_range",
          "args": [],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_available_flush_tlb_with_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "306-309",
          "snippet": "static inline bool kvm_available_flush_tlb_with_range(void)\n{\n\treturn kvm_x86_ops.tlb_remote_flush_with_range;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool kvm_available_flush_tlb_with_range(void)\n{\n\treturn kvm_x86_ops.tlb_remote_flush_with_range;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_set",
          "args": [
            "sptep",
            "new_spte"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "835-839",
          "snippet": "static void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_clear_track_bits",
          "args": [
            "sptep"
          ],
          "line": 1835
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_clear_track_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "918-947",
          "snippet": "static int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (is_accessed_spte(old_spte))\n\t\tkvm_set_pfn_accessed(pfn);\n\n\tif (is_dirty_spte(old_spte))\n\t\tkvm_set_pfn_dirty(pfn);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (is_accessed_spte(old_spte))\n\t\tkvm_set_pfn_accessed(pfn);\n\n\tif (is_dirty_spte(old_spte))\n\t\tkvm_set_pfn_dirty(pfn);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_spte_for_access_track",
          "args": [
            "new_spte"
          ],
          "line": 1833
        },
        "resolved": true,
        "details": {
          "function_name": "mark_spte_for_access_track",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "964-990",
          "snippet": "static u64 mark_spte_for_access_track(u64 spte)\n{\n\tif (spte_ad_enabled(spte))\n\t\treturn spte & ~shadow_accessed_mask;\n\n\tif (is_access_track_spte(spte))\n\t\treturn spte;\n\n\t/*\n\t * Making an Access Tracking PTE will result in removal of write access\n\t * from the PTE. So, verify that we will be able to restore the write\n\t * access in the fast page fault path later on.\n\t */\n\tWARN_ONCE((spte & PT_WRITABLE_MASK) &&\n\t\t  !spte_can_locklessly_be_made_writable(spte),\n\t\t  \"kvm: Writable SPTE is not locklessly dirty-trackable\\n\");\n\n\tWARN_ONCE(spte & (shadow_acc_track_saved_bits_mask <<\n\t\t\t  shadow_acc_track_saved_bits_shift),\n\t\t  \"kvm: Access Tracking saved bit locations are not zero\\n\");\n\n\tspte |= (spte & shadow_acc_track_saved_bits_mask) <<\n\t\tshadow_acc_track_saved_bits_shift;\n\tspte &= ~shadow_acc_track_mask;\n\n\treturn spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;",
            "static const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;",
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;\nstatic const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 mark_spte_for_access_track(u64 spte)\n{\n\tif (spte_ad_enabled(spte))\n\t\treturn spte & ~shadow_accessed_mask;\n\n\tif (is_access_track_spte(spte))\n\t\treturn spte;\n\n\t/*\n\t * Making an Access Tracking PTE will result in removal of write access\n\t * from the PTE. So, verify that we will be able to restore the write\n\t * access in the fast page fault path later on.\n\t */\n\tWARN_ONCE((spte & PT_WRITABLE_MASK) &&\n\t\t  !spte_can_locklessly_be_made_writable(spte),\n\t\t  \"kvm: Writable SPTE is not locklessly dirty-trackable\\n\");\n\n\tWARN_ONCE(spte & (shadow_acc_track_saved_bits_mask <<\n\t\t\t  shadow_acc_track_saved_bits_shift),\n\t\t  \"kvm: Access Tracking saved bit locations are not zero\\n\");\n\n\tspte |= (spte & shadow_acc_track_saved_bits_mask) <<\n\t\tshadow_acc_track_saved_bits_shift;\n\tspte &= ~shadow_acc_track_mask;\n\n\treturn spte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_list_remove",
          "args": [
            "rmap_head",
            "sptep"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "pte_list_remove",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1389-1393",
          "snippet": "static void pte_list_remove(struct kvm_rmap_head *rmap_head, u64 *sptep)\n{\n\tmmu_spte_clear_track_bits(sptep);\n\t__pte_list_remove(sptep, rmap_head);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void pte_list_remove(struct kvm_rmap_head *rmap_head, u64 *sptep)\n{\n\tmmu_spte_clear_track_bits(sptep);\n\t__pte_list_remove(sptep, rmap_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pte_write",
          "args": [
            "*ptep"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"kvm_set_pte_rmapp: spte %p %llx gfn %llx (%d)\\n\"",
            "sptep",
            "*sptep",
            "gfn",
            "level"
          ],
          "line": 1818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 1817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_pfn",
          "args": [
            "*ptep"
          ],
          "line": 1814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "pte_huge(*ptep)"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_huge",
          "args": [
            "*ptep"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic int kvm_set_pte_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t     struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t     unsigned long data)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tint need_flush = 0;\n\tu64 new_spte;\n\tpte_t *ptep = (pte_t *)data;\n\tkvm_pfn_t new_pfn;\n\n\tWARN_ON(pte_huge(*ptep));\n\tnew_pfn = pte_pfn(*ptep);\n\nrestart:\n\tfor_each_rmap_spte(rmap_head, &iter, sptep) {\n\t\trmap_printk(\"kvm_set_pte_rmapp: spte %p %llx gfn %llx (%d)\\n\",\n\t\t\t    sptep, *sptep, gfn, level);\n\n\t\tneed_flush = 1;\n\n\t\tif (pte_write(*ptep)) {\n\t\t\tpte_list_remove(rmap_head, sptep);\n\t\t\tgoto restart;\n\t\t} else {\n\t\t\tnew_spte = *sptep & ~PT64_BASE_ADDR_MASK;\n\t\t\tnew_spte |= (u64)new_pfn << PAGE_SHIFT;\n\n\t\t\tnew_spte &= ~PT_WRITABLE_MASK;\n\t\t\tnew_spte &= ~SPTE_HOST_WRITEABLE;\n\n\t\t\tnew_spte = mark_spte_for_access_track(new_spte);\n\n\t\t\tmmu_spte_clear_track_bits(sptep);\n\t\t\tmmu_spte_set(sptep, new_spte);\n\t\t}\n\t}\n\n\tif (need_flush && kvm_available_flush_tlb_with_range()) {\n\t\tkvm_flush_remote_tlbs_with_address(kvm, gfn, 1);\n\t\treturn 0;\n\t}\n\n\treturn need_flush;\n}"
  },
  {
    "function_name": "kvm_unmap_rmapp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1795-1800",
    "snippet": "static int kvm_unmap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t   struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t   unsigned long data)\n{\n\treturn kvm_zap_rmapp(kvm, rmap_head);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_zap_rmapp",
          "args": [
            "kvm",
            "rmap_head"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_zap_rmapp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1779-1793",
          "snippet": "static bool kvm_zap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\twhile ((sptep = rmap_get_first(rmap_head, &iter))) {\n\t\trmap_printk(\"%s: spte %p %llx.\\n\", __func__, sptep, *sptep);\n\n\t\tpte_list_remove(rmap_head, sptep);\n\t\tflush = true;\n\t}\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool kvm_zap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\twhile ((sptep = rmap_get_first(rmap_head, &iter))) {\n\t\trmap_printk(\"%s: spte %p %llx.\\n\", __func__, sptep, *sptep);\n\n\t\tpte_list_remove(rmap_head, sptep);\n\t\tflush = true;\n\t}\n\n\treturn flush;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int kvm_unmap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head,\n\t\t\t   struct kvm_memory_slot *slot, gfn_t gfn, int level,\n\t\t\t   unsigned long data)\n{\n\treturn kvm_zap_rmapp(kvm, rmap_head);\n}"
  },
  {
    "function_name": "kvm_zap_rmapp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1779-1793",
    "snippet": "static bool kvm_zap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\twhile ((sptep = rmap_get_first(rmap_head, &iter))) {\n\t\trmap_printk(\"%s: spte %p %llx.\\n\", __func__, sptep, *sptep);\n\n\t\tpte_list_remove(rmap_head, sptep);\n\t\tflush = true;\n\t}\n\n\treturn flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_list_remove",
          "args": [
            "rmap_head",
            "sptep"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "pte_list_remove",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1389-1393",
          "snippet": "static void pte_list_remove(struct kvm_rmap_head *rmap_head, u64 *sptep)\n{\n\tmmu_spte_clear_track_bits(sptep);\n\t__pte_list_remove(sptep, rmap_head);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void pte_list_remove(struct kvm_rmap_head *rmap_head, u64 *sptep)\n{\n\tmmu_spte_clear_track_bits(sptep);\n\t__pte_list_remove(sptep, rmap_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"%s: spte %p %llx.\\n\"",
            "__func__",
            "sptep",
            "*sptep"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_get_first",
          "args": [
            "rmap_head",
            "&iter"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_get_first",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1463-1483",
          "snippet": "static u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool kvm_zap_rmapp(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\twhile ((sptep = rmap_get_first(rmap_head, &iter))) {\n\t\trmap_printk(\"%s: spte %p %llx.\\n\", __func__, sptep, *sptep);\n\n\t\tpte_list_remove(rmap_head, sptep);\n\t\tflush = true;\n\t}\n\n\treturn flush;\n}"
  },
  {
    "function_name": "rmap_write_protect",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1771-1777",
    "snippet": "static bool rmap_write_protect(struct kvm_vcpu *vcpu, u64 gfn)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\treturn kvm_mmu_slot_gfn_write_protect(vcpu->kvm, slot, gfn);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_slot_gfn_write_protect",
          "args": [
            "vcpu->kvm",
            "slot",
            "gfn"
          ],
          "line": 1776
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_slot_gfn_write_protect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1756-1769",
          "snippet": "bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_memory_slot *slot, u64 gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tint i;\n\tbool write_protected = false;\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\trmap_head = __gfn_to_rmap(gfn, i, slot);\n\t\twrite_protected |= __rmap_write_protect(kvm, rmap_head, true);\n\t}\n\n\treturn write_protected;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_memory_slot *slot, u64 gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tint i;\n\tbool write_protected = false;\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\trmap_head = __gfn_to_rmap(gfn, i, slot);\n\t\twrite_protected |= __rmap_write_protect(kvm, rmap_head, true);\n\t}\n\n\treturn write_protected;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_memslot",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool rmap_write_protect(struct kvm_vcpu *vcpu, u64 gfn)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\treturn kvm_mmu_slot_gfn_write_protect(vcpu->kvm, slot, gfn);\n}"
  },
  {
    "function_name": "kvm_mmu_slot_gfn_write_protect",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1756-1769",
    "snippet": "bool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_memory_slot *slot, u64 gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tint i;\n\tbool write_protected = false;\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\trmap_head = __gfn_to_rmap(gfn, i, slot);\n\t\twrite_protected |= __rmap_write_protect(kvm, rmap_head, true);\n\t}\n\n\treturn write_protected;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rmap_write_protect",
          "args": [
            "kvm",
            "rmap_head",
            "true"
          ],
          "line": 1765
        },
        "resolved": true,
        "details": {
          "function_name": "__rmap_write_protect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1582-1594",
          "snippet": "static bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(sptep, pt_protect);\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(sptep, pt_protect);\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "gfn",
            "i",
            "slot"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1395-1402",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool kvm_mmu_slot_gfn_write_protect(struct kvm *kvm,\n\t\t\t\t    struct kvm_memory_slot *slot, u64 gfn)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\tint i;\n\tbool write_protected = false;\n\n\tfor (i = PT_PAGE_TABLE_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\trmap_head = __gfn_to_rmap(gfn, i, slot);\n\t\twrite_protected |= __rmap_write_protect(kvm, rmap_head, true);\n\t}\n\n\treturn write_protected;\n}"
  },
  {
    "function_name": "kvm_arch_write_log_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1748-1754",
    "snippet": "int kvm_arch_write_log_dirty(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_x86_ops.write_log_dirty)\n\t\treturn kvm_x86_ops.write_log_dirty(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_x86_ops.write_log_dirty",
          "args": [
            "vcpu"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_arch_write_log_dirty(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_x86_ops.write_log_dirty)\n\t\treturn kvm_x86_ops.write_log_dirty(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_arch_mmu_enable_log_dirty_pt_masked",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1730-1739",
    "snippet": "void kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *slot,\n\t\t\t\tgfn_t gfn_offset, unsigned long mask)\n{\n\tif (kvm_x86_ops.enable_log_dirty_pt_masked)\n\t\tkvm_x86_ops.enable_log_dirty_pt_masked(kvm, slot, gfn_offset,\n\t\t\t\tmask);\n\telse\n\t\tkvm_mmu_write_protect_pt_masked(kvm, slot, gfn_offset, mask);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_write_protect_pt_masked",
          "args": [
            "kvm",
            "slot",
            "gfn_offset",
            "mask"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_write_protect_pt_masked",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1677-1691",
          "snippet": "static void kvm_mmu_write_protect_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_write_protect(kvm, rmap_head, false);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_write_protect_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_write_protect(kvm, rmap_head, false);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.enable_log_dirty_pt_masked",
          "args": [
            "kvm",
            "slot",
            "gfn_offset",
            "mask"
          ],
          "line": 1735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_arch_mmu_enable_log_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\tstruct kvm_memory_slot *slot,\n\t\t\t\tgfn_t gfn_offset, unsigned long mask)\n{\n\tif (kvm_x86_ops.enable_log_dirty_pt_masked)\n\t\tkvm_x86_ops.enable_log_dirty_pt_masked(kvm, slot, gfn_offset,\n\t\t\t\tmask);\n\telse\n\t\tkvm_mmu_write_protect_pt_masked(kvm, slot, gfn_offset, mask);\n}"
  },
  {
    "function_name": "kvm_mmu_clear_dirty_pt_masked",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1703-1717",
    "snippet": "void kvm_mmu_clear_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_clear_dirty(kvm, rmap_head);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rmap_clear_dirty",
          "args": [
            "kvm",
            "rmap_head"
          ],
          "line": 1712
        },
        "resolved": true,
        "details": {
          "function_name": "__rmap_clear_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1623-1636",
          "snippet": "static bool __rmap_clear_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tif (spte_ad_need_write_protect(*sptep))\n\t\t\tflush |= spte_wrprot_for_clear_dirty(sptep);\n\t\telse\n\t\t\tflush |= spte_clear_dirty(sptep);\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_clear_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tif (spte_ad_need_write_protect(*sptep))\n\t\t\tflush |= spte_wrprot_for_clear_dirty(sptep);\n\t\telse\n\t\t\tflush |= spte_clear_dirty(sptep);\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "slot->base_gfn + gfn_offset + __ffs(mask)",
            "PT_PAGE_TABLE_LEVEL",
            "slot"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1395-1402",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "mask"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_clear_dirty_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_clear_dirty(kvm, rmap_head);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}"
  },
  {
    "function_name": "kvm_mmu_write_protect_pt_masked",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1677-1691",
    "snippet": "static void kvm_mmu_write_protect_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_write_protect(kvm, rmap_head, false);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rmap_write_protect",
          "args": [
            "kvm",
            "rmap_head",
            "false"
          ],
          "line": 1686
        },
        "resolved": true,
        "details": {
          "function_name": "__rmap_write_protect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1582-1594",
          "snippet": "static bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(sptep, pt_protect);\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(sptep, pt_protect);\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "slot->base_gfn + gfn_offset + __ffs(mask)",
            "PT_PAGE_TABLE_LEVEL",
            "slot"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1395-1402",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "mask"
          ],
          "line": 1684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_write_protect_pt_masked(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot,\n\t\t\t\t     gfn_t gfn_offset, unsigned long mask)\n{\n\tstruct kvm_rmap_head *rmap_head;\n\n\twhile (mask) {\n\t\trmap_head = __gfn_to_rmap(slot->base_gfn + gfn_offset + __ffs(mask),\n\t\t\t\t\t  PT_PAGE_TABLE_LEVEL, slot);\n\t\t__rmap_write_protect(kvm, rmap_head, false);\n\n\t\t/* clear the first set bit */\n\t\tmask &= mask - 1;\n\t}\n}"
  },
  {
    "function_name": "__rmap_set_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1654-1665",
    "snippet": "static bool __rmap_set_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tif (spte_ad_enabled(*sptep))\n\t\t\tflush |= spte_set_dirty(sptep);\n\n\treturn flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spte_set_dirty",
          "args": [
            "sptep"
          ],
          "line": 1662
        },
        "resolved": true,
        "details": {
          "function_name": "spte_set_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1638-1652",
          "snippet": "static bool spte_set_dirty(u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_set_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\t/*\n\t * Similar to the !kvm_x86_ops.slot_disable_log_dirty case,\n\t * do not bother adding back write access to pages marked\n\t * SPTE_AD_WRPROT_ONLY_MASK.\n\t */\n\tspte |= shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_WRPROT_ONLY_MASK (2ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_WRPROT_ONLY_MASK (2ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_set_dirty(u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_set_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\t/*\n\t * Similar to the !kvm_x86_ops.slot_disable_log_dirty case,\n\t * do not bother adding back write access to pages marked\n\t * SPTE_AD_WRPROT_ONLY_MASK.\n\t */\n\tspte |= shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_ad_enabled",
          "args": [
            "*sptep"
          ],
          "line": 1661
        },
        "resolved": true,
        "details": {
          "function_name": "spte_ad_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "365-369",
          "snippet": "static inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_DISABLED_MASK (1ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_set_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tif (spte_ad_enabled(*sptep))\n\t\t\tflush |= spte_set_dirty(sptep);\n\n\treturn flush;\n}"
  },
  {
    "function_name": "spte_set_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1638-1652",
    "snippet": "static bool spte_set_dirty(u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_set_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\t/*\n\t * Similar to the !kvm_x86_ops.slot_disable_log_dirty case,\n\t * do not bother adding back write access to pages marked\n\t * SPTE_AD_WRPROT_ONLY_MASK.\n\t */\n\tspte |= shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_AD_WRPROT_ONLY_MASK (2ULL << 52)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_update",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 1651
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "877-910",
          "snippet": "static bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tbool flush = false;\n\tu64 old_spte = mmu_spte_update_no_track(sptep, new_spte);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn false;\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_can_locklessly_be_made_writable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tflush = true;\n\n\t/*\n\t * Flush TLB when accessed/dirty states are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\n\tif (is_accessed_spte(old_spte) && !is_accessed_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\t}\n\n\tif (is_dirty_spte(old_spte) && !is_dirty_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t}\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tbool flush = false;\n\tu64 old_spte = mmu_spte_update_no_track(sptep, new_spte);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn false;\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_can_locklessly_be_made_writable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tflush = true;\n\n\t/*\n\t * Flush TLB when accessed/dirty states are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\n\tif (is_accessed_spte(old_spte) && !is_accessed_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\t}\n\n\tif (is_dirty_spte(old_spte) && !is_dirty_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t}\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"rmap_set_dirty: spte %p %llx\\n\"",
            "sptep",
            "*sptep"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_WRPROT_ONLY_MASK (2ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_set_dirty(u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_set_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\t/*\n\t * Similar to the !kvm_x86_ops.slot_disable_log_dirty case,\n\t * do not bother adding back write access to pages marked\n\t * SPTE_AD_WRPROT_ONLY_MASK.\n\t */\n\tspte |= shadow_dirty_mask;\n\n\treturn mmu_spte_update(sptep, spte);\n}"
  },
  {
    "function_name": "__rmap_clear_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1623-1636",
    "snippet": "static bool __rmap_clear_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tif (spte_ad_need_write_protect(*sptep))\n\t\t\tflush |= spte_wrprot_for_clear_dirty(sptep);\n\t\telse\n\t\t\tflush |= spte_clear_dirty(sptep);\n\n\treturn flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spte_clear_dirty",
          "args": [
            "sptep"
          ],
          "line": 1633
        },
        "resolved": true,
        "details": {
          "function_name": "spte_clear_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1596-1605",
          "snippet": "static bool spte_clear_dirty(u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_clear_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tMMU_WARN_ON(!spte_ad_enabled(spte));\n\tspte &= ~shadow_dirty_mask;\n\treturn mmu_spte_update(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_clear_dirty(u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_clear_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tMMU_WARN_ON(!spte_ad_enabled(spte));\n\tspte &= ~shadow_dirty_mask;\n\treturn mmu_spte_update(sptep, spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_wrprot_for_clear_dirty",
          "args": [
            "sptep"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "spte_wrprot_for_clear_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1607-1615",
          "snippet": "static bool spte_wrprot_for_clear_dirty(u64 *sptep)\n{\n\tbool was_writable = test_and_clear_bit(PT_WRITABLE_SHIFT,\n\t\t\t\t\t       (unsigned long *)sptep);\n\tif (was_writable && !spte_ad_enabled(*sptep))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(*sptep));\n\n\treturn was_writable;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool spte_wrprot_for_clear_dirty(u64 *sptep)\n{\n\tbool was_writable = test_and_clear_bit(PT_WRITABLE_SHIFT,\n\t\t\t\t\t       (unsigned long *)sptep);\n\tif (was_writable && !spte_ad_enabled(*sptep))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(*sptep));\n\n\treturn was_writable;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_ad_need_write_protect",
          "args": [
            "*sptep"
          ],
          "line": 1630
        },
        "resolved": true,
        "details": {
          "function_name": "spte_ad_need_write_protect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "371-375",
          "snippet": "static inline bool spte_ad_need_write_protect(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_ENABLED_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_ENABLED_MASK (0ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_ENABLED_MASK (0ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_need_write_protect(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_ENABLED_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_clear_dirty(struct kvm *kvm, struct kvm_rmap_head *rmap_head)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tif (spte_ad_need_write_protect(*sptep))\n\t\t\tflush |= spte_wrprot_for_clear_dirty(sptep);\n\t\telse\n\t\t\tflush |= spte_clear_dirty(sptep);\n\n\treturn flush;\n}"
  },
  {
    "function_name": "spte_wrprot_for_clear_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1607-1615",
    "snippet": "static bool spte_wrprot_for_clear_dirty(u64 *sptep)\n{\n\tbool was_writable = test_and_clear_bit(PT_WRITABLE_SHIFT,\n\t\t\t\t\t       (unsigned long *)sptep);\n\tif (was_writable && !spte_ad_enabled(*sptep))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(*sptep));\n\n\treturn was_writable;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_pfn_dirty",
          "args": [
            "spte_to_pfn(*sptep)"
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_to_pfn",
          "args": [
            "*sptep"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "spte_to_pfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "635-638",
          "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_ad_enabled",
          "args": [
            "*sptep"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "spte_ad_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "365-369",
          "snippet": "static inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_DISABLED_MASK (1ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "PT_WRITABLE_SHIFT",
            "(unsigned long *)sptep"
          ],
          "line": 1609
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool spte_wrprot_for_clear_dirty(u64 *sptep)\n{\n\tbool was_writable = test_and_clear_bit(PT_WRITABLE_SHIFT,\n\t\t\t\t\t       (unsigned long *)sptep);\n\tif (was_writable && !spte_ad_enabled(*sptep))\n\t\tkvm_set_pfn_dirty(spte_to_pfn(*sptep));\n\n\treturn was_writable;\n}"
  },
  {
    "function_name": "spte_clear_dirty",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1596-1605",
    "snippet": "static bool spte_clear_dirty(u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_clear_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tMMU_WARN_ON(!spte_ad_enabled(spte));\n\tspte &= ~shadow_dirty_mask;\n\treturn mmu_spte_update(sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_update",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "877-910",
          "snippet": "static bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tbool flush = false;\n\tu64 old_spte = mmu_spte_update_no_track(sptep, new_spte);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn false;\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_can_locklessly_be_made_writable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tflush = true;\n\n\t/*\n\t * Flush TLB when accessed/dirty states are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\n\tif (is_accessed_spte(old_spte) && !is_accessed_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\t}\n\n\tif (is_dirty_spte(old_spte) && !is_dirty_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t}\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tbool flush = false;\n\tu64 old_spte = mmu_spte_update_no_track(sptep, new_spte);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn false;\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_can_locklessly_be_made_writable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tflush = true;\n\n\t/*\n\t * Flush TLB when accessed/dirty states are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\n\tif (is_accessed_spte(old_spte) && !is_accessed_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\t}\n\n\tif (is_dirty_spte(old_spte) && !is_dirty_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t}\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "!spte_ad_enabled(spte)"
          ],
          "line": 1602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_ad_enabled",
          "args": [
            "spte"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "spte_ad_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "365-369",
          "snippet": "static inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_DISABLED_MASK (1ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"rmap_clear_dirty: spte %p %llx\\n\"",
            "sptep",
            "*sptep"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_clear_dirty(u64 *sptep)\n{\n\tu64 spte = *sptep;\n\n\trmap_printk(\"rmap_clear_dirty: spte %p %llx\\n\", sptep, *sptep);\n\n\tMMU_WARN_ON(!spte_ad_enabled(spte));\n\tspte &= ~shadow_dirty_mask;\n\treturn mmu_spte_update(sptep, spte);\n}"
  },
  {
    "function_name": "__rmap_write_protect",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1582-1594",
    "snippet": "static bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(sptep, pt_protect);\n\n\treturn flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spte_write_protect",
          "args": [
            "sptep",
            "pt_protect"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "spte_write_protect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1565-1580",
          "snippet": "static bool spte_write_protect(u64 *sptep, bool pt_protect)\n{\n\tu64 spte = *sptep;\n\n\tif (!is_writable_pte(spte) &&\n\t      !(pt_protect && spte_can_locklessly_be_made_writable(spte)))\n\t\treturn false;\n\n\trmap_printk(\"rmap_write_protect: spte %p %llx\\n\", sptep, *sptep);\n\n\tif (pt_protect)\n\t\tspte &= ~SPTE_MMU_WRITEABLE;\n\tspte = spte & ~PT_WRITABLE_MASK;\n\n\treturn mmu_spte_update(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_write_protect(u64 *sptep, bool pt_protect)\n{\n\tu64 spte = *sptep;\n\n\tif (!is_writable_pte(spte) &&\n\t      !(pt_protect && spte_can_locklessly_be_made_writable(spte)))\n\t\treturn false;\n\n\trmap_printk(\"rmap_write_protect: spte %p %llx\\n\", sptep, *sptep);\n\n\tif (pt_protect)\n\t\tspte &= ~SPTE_MMU_WRITEABLE;\n\tspte = spte & ~PT_WRITABLE_MASK;\n\n\treturn mmu_spte_update(sptep, spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_rmap_spte",
          "args": [
            "rmap_head",
            "&iter",
            "sptep"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __rmap_write_protect(struct kvm *kvm,\n\t\t\t\t struct kvm_rmap_head *rmap_head,\n\t\t\t\t bool pt_protect)\n{\n\tu64 *sptep;\n\tstruct rmap_iterator iter;\n\tbool flush = false;\n\n\tfor_each_rmap_spte(rmap_head, &iter, sptep)\n\t\tflush |= spte_write_protect(sptep, pt_protect);\n\n\treturn flush;\n}"
  },
  {
    "function_name": "spte_write_protect",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1565-1580",
    "snippet": "static bool spte_write_protect(u64 *sptep, bool pt_protect)\n{\n\tu64 spte = *sptep;\n\n\tif (!is_writable_pte(spte) &&\n\t      !(pt_protect && spte_can_locklessly_be_made_writable(spte)))\n\t\treturn false;\n\n\trmap_printk(\"rmap_write_protect: spte %p %llx\\n\", sptep, *sptep);\n\n\tif (pt_protect)\n\t\tspte &= ~SPTE_MMU_WRITEABLE;\n\tspte = spte & ~PT_WRITABLE_MASK;\n\n\treturn mmu_spte_update(sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_update",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "877-910",
          "snippet": "static bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tbool flush = false;\n\tu64 old_spte = mmu_spte_update_no_track(sptep, new_spte);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn false;\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_can_locklessly_be_made_writable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tflush = true;\n\n\t/*\n\t * Flush TLB when accessed/dirty states are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\n\tif (is_accessed_spte(old_spte) && !is_accessed_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\t}\n\n\tif (is_dirty_spte(old_spte) && !is_dirty_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t}\n\n\treturn flush;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tbool flush = false;\n\tu64 old_spte = mmu_spte_update_no_track(sptep, new_spte);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn false;\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_can_locklessly_be_made_writable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tflush = true;\n\n\t/*\n\t * Flush TLB when accessed/dirty states are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\n\tif (is_accessed_spte(old_spte) && !is_accessed_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\t}\n\n\tif (is_dirty_spte(old_spte) && !is_dirty_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t}\n\n\treturn flush;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"rmap_write_protect: spte %p %llx\\n\"",
            "sptep",
            "*sptep"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_can_locklessly_be_made_writable",
          "args": [
            "spte"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "spte_can_locklessly_be_made_writable",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "784-788",
          "snippet": "static bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
            "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "spte"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "151-154",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_write_protect(u64 *sptep, bool pt_protect)\n{\n\tu64 spte = *sptep;\n\n\tif (!is_writable_pte(spte) &&\n\t      !(pt_protect && spte_can_locklessly_be_made_writable(spte)))\n\t\treturn false;\n\n\trmap_printk(\"rmap_write_protect: spte %p %llx\\n\", sptep, *sptep);\n\n\tif (pt_protect)\n\t\tspte &= ~SPTE_MMU_WRITEABLE;\n\tspte = spte & ~PT_WRITABLE_MASK;\n\n\treturn mmu_spte_update(sptep, spte);\n}"
  },
  {
    "function_name": "drop_large_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1542-1550",
    "snippet": "static void drop_large_spte(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tif (__drop_large_spte(vcpu->kvm, sptep)) {\n\t\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, sp->gfn,\n\t\t\tKVM_PAGES_PER_HPAGE(sp->role.level));\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs_with_address",
          "args": [
            "vcpu->kvm",
            "sp->gfn",
            "KVM_PAGES_PER_HPAGE(sp->role.level)"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_flush_remote_tlbs_with_address",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "323-332",
          "snippet": "static void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KVM_PAGES_PER_HPAGE",
          "args": [
            "sp->role.level"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__drop_large_spte",
          "args": [
            "vcpu->kvm",
            "sptep"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "__drop_large_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1529-1540",
          "snippet": "static bool __drop_large_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (is_large_pte(*sptep)) {\n\t\tWARN_ON(page_header(__pa(sptep))->role.level ==\n\t\t\tPT_PAGE_TABLE_LEVEL);\n\t\tdrop_spte(kvm, sptep);\n\t\t--kvm->stat.lpages;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __drop_large_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (is_large_pte(*sptep)) {\n\t\tWARN_ON(page_header(__pa(sptep))->role.level ==\n\t\t\tPT_PAGE_TABLE_LEVEL);\n\t\tdrop_spte(kvm, sptep);\n\t\t--kvm->stat.lpages;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void drop_large_spte(struct kvm_vcpu *vcpu, u64 *sptep)\n{\n\tif (__drop_large_spte(vcpu->kvm, sptep)) {\n\t\tstruct kvm_mmu_page *sp = page_header(__pa(sptep));\n\n\t\tkvm_flush_remote_tlbs_with_address(vcpu->kvm, sp->gfn,\n\t\t\tKVM_PAGES_PER_HPAGE(sp->role.level));\n\t}\n}"
  },
  {
    "function_name": "__drop_large_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1529-1540",
    "snippet": "static bool __drop_large_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (is_large_pte(*sptep)) {\n\t\tWARN_ON(page_header(__pa(sptep))->role.level ==\n\t\t\tPT_PAGE_TABLE_LEVEL);\n\t\tdrop_spte(kvm, sptep);\n\t\t--kvm->stat.lpages;\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "drop_spte",
          "args": [
            "kvm",
            "sptep"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "drop_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1522-1526",
          "snippet": "static void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "page_header(__pa(sptep))->role.level ==\n\t\t\tPT_PAGE_TABLE_LEVEL"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "*sptep"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "616-619",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool __drop_large_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (is_large_pte(*sptep)) {\n\t\tWARN_ON(page_header(__pa(sptep))->role.level ==\n\t\t\tPT_PAGE_TABLE_LEVEL);\n\t\tdrop_spte(kvm, sptep);\n\t\t--kvm->stat.lpages;\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "drop_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1522-1526",
    "snippet": "static void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rmap_remove",
          "args": [
            "kvm",
            "sptep"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "rmap_remove",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1434-1444",
          "snippet": "static void rmap_remove(struct kvm *kvm, u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tgfn = kvm_mmu_page_get_gfn(sp, spte - sp->spt);\n\trmap_head = gfn_to_rmap(kvm, gfn, sp);\n\t__pte_list_remove(spte, rmap_head);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void rmap_remove(struct kvm *kvm, u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tgfn = kvm_mmu_page_get_gfn(sp, spte - sp->spt);\n\trmap_head = gfn_to_rmap(kvm, gfn, sp);\n\t__pte_list_remove(spte, rmap_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_clear_track_bits",
          "args": [
            "sptep"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_clear_track_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "918-947",
          "snippet": "static int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (is_accessed_spte(old_spte))\n\t\tkvm_set_pfn_accessed(pfn);\n\n\tif (is_dirty_spte(old_spte))\n\t\tkvm_set_pfn_dirty(pfn);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (is_accessed_spte(old_spte))\n\t\tkvm_set_pfn_accessed(pfn);\n\n\tif (is_dirty_spte(old_spte))\n\t\tkvm_set_pfn_dirty(pfn);\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void drop_spte(struct kvm *kvm, u64 *sptep)\n{\n\tif (mmu_spte_clear_track_bits(sptep))\n\t\trmap_remove(kvm, sptep);\n}"
  },
  {
    "function_name": "rmap_get_next",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1490-1516",
    "snippet": "static u64 *rmap_get_next(struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (iter->desc) {\n\t\tif (iter->pos < PTE_LIST_EXT - 1) {\n\t\t\t++iter->pos;\n\t\t\tsptep = iter->desc->sptes[iter->pos];\n\t\t\tif (sptep)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\titer->desc = iter->desc->more;\n\n\t\tif (iter->desc) {\n\t\t\titer->pos = 0;\n\t\t\t/* desc->sptes[0] cannot be NULL */\n\t\t\tsptep = iter->desc->sptes[iter->pos];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn NULL;\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_LIST_EXT 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!is_shadow_present_pte(*sptep)"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic u64 *rmap_get_next(struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (iter->desc) {\n\t\tif (iter->pos < PTE_LIST_EXT - 1) {\n\t\t\t++iter->pos;\n\t\t\tsptep = iter->desc->sptes[iter->pos];\n\t\t\tif (sptep)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\titer->desc = iter->desc->more;\n\n\t\tif (iter->desc) {\n\t\t\titer->pos = 0;\n\t\t\t/* desc->sptes[0] cannot be NULL */\n\t\t\tsptep = iter->desc->sptes[iter->pos];\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\treturn NULL;\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}"
  },
  {
    "function_name": "rmap_get_first",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1463-1483",
    "snippet": "static u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!is_shadow_present_pte(*sptep)"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 *rmap_get_first(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct rmap_iterator *iter)\n{\n\tu64 *sptep;\n\n\tif (!rmap_head->val)\n\t\treturn NULL;\n\n\tif (!(rmap_head->val & 1)) {\n\t\titer->desc = NULL;\n\t\tsptep = (u64 *)rmap_head->val;\n\t\tgoto out;\n\t}\n\n\titer->desc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\titer->pos = 0;\n\tsptep = iter->desc->sptes[iter->pos];\nout:\n\tBUG_ON(!is_shadow_present_pte(*sptep));\n\treturn sptep;\n}"
  },
  {
    "function_name": "rmap_remove",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1434-1444",
    "snippet": "static void rmap_remove(struct kvm *kvm, u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tgfn = kvm_mmu_page_get_gfn(sp, spte - sp->spt);\n\trmap_head = gfn_to_rmap(kvm, gfn, sp);\n\t__pte_list_remove(spte, rmap_head);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pte_list_remove",
          "args": [
            "spte",
            "rmap_head"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "__pte_list_remove",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1353-1387",
          "snippet": "static void __pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tpr_err(\"%s: %p 0->BUG\\n\", __func__, spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"%s:  %p 1->0\\n\", __func__, spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tpr_err(\"%s:  %p 1->BUG\\n\", __func__, spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"%s:  %p many->many\\n\", __func__, spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"%s: %p many->many\\n\", __func__, spte);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_LIST_EXT 3"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tpr_err(\"%s: %p 0->BUG\\n\", __func__, spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"%s:  %p 1->0\\n\", __func__, spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tpr_err(\"%s:  %p 1->BUG\\n\", __func__, spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"%s:  %p many->many\\n\", __func__, spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"%s: %p many->many\\n\", __func__, spte);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfn_to_rmap",
          "args": [
            "kvm",
            "gfn",
            "sp"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "gfn_to_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1404-1413",
          "snippet": "static struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "sp",
            "spte - sp->spt"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1157-1163",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(spte)"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "spte"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void rmap_remove(struct kvm *kvm, u64 *spte)\n{\n\tstruct kvm_mmu_page *sp;\n\tgfn_t gfn;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tgfn = kvm_mmu_page_get_gfn(sp, spte - sp->spt);\n\trmap_head = gfn_to_rmap(kvm, gfn, sp);\n\t__pte_list_remove(spte, rmap_head);\n}"
  },
  {
    "function_name": "rmap_add",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1423-1432",
    "snippet": "static int rmap_add(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tkvm_mmu_page_set_gfn(sp, spte - sp->spt, gfn);\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\treturn pte_list_add(vcpu, spte, rmap_head);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pte_list_add",
          "args": [
            "vcpu",
            "spte",
            "rmap_head"
          ],
          "line": 1431
        },
        "resolved": true,
        "details": {
          "function_name": "pte_list_add",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1296-1328",
          "snippet": "static int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_LIST_EXT 3"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfn_to_rmap",
          "args": [
            "vcpu->kvm",
            "gfn",
            "sp"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "gfn_to_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1404-1413",
          "snippet": "static struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_set_gfn",
          "args": [
            "sp",
            "spte - sp->spt",
            "gfn"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_set_gfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1165-1177",
          "snippet": "static void kvm_mmu_page_set_gfn(struct kvm_mmu_page *sp, int index, gfn_t gfn)\n{\n\tif (!sp->role.direct) {\n\t\tsp->gfns[index] = gfn;\n\t\treturn;\n\t}\n\n\tif (WARN_ON(gfn != kvm_mmu_page_get_gfn(sp, index)))\n\t\tpr_err_ratelimited(\"gfn mismatch under direct page %llx \"\n\t\t\t\t   \"(expected %llx, got %llx)\\n\",\n\t\t\t\t   sp->gfn,\n\t\t\t\t   kvm_mmu_page_get_gfn(sp, index), gfn);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_page_set_gfn(struct kvm_mmu_page *sp, int index, gfn_t gfn)\n{\n\tif (!sp->role.direct) {\n\t\tsp->gfns[index] = gfn;\n\t\treturn;\n\t}\n\n\tif (WARN_ON(gfn != kvm_mmu_page_get_gfn(sp, index)))\n\t\tpr_err_ratelimited(\"gfn mismatch under direct page %llx \"\n\t\t\t\t   \"(expected %llx, got %llx)\\n\",\n\t\t\t\t   sp->gfn,\n\t\t\t\t   kvm_mmu_page_get_gfn(sp, index), gfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(spte)"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "spte"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int rmap_add(struct kvm_vcpu *vcpu, u64 *spte, gfn_t gfn)\n{\n\tstruct kvm_mmu_page *sp;\n\tstruct kvm_rmap_head *rmap_head;\n\n\tsp = page_header(__pa(spte));\n\tkvm_mmu_page_set_gfn(sp, spte - sp->spt, gfn);\n\trmap_head = gfn_to_rmap(vcpu->kvm, gfn, sp);\n\treturn pte_list_add(vcpu, spte, rmap_head);\n}"
  },
  {
    "function_name": "rmap_can_add",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1415-1421",
    "snippet": "static bool rmap_can_add(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_memory_cache *cache;\n\n\tcache = &vcpu->arch.mmu_pte_list_desc_cache;\n\treturn mmu_memory_cache_free_objects(cache);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_memory_cache_free_objects",
          "args": [
            "cache"
          ],
          "line": 1420
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_memory_cache_free_objects",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1078-1081",
          "snippet": "static int mmu_memory_cache_free_objects(struct kvm_mmu_memory_cache *cache)\n{\n\treturn cache->nobjs;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_memory_cache_free_objects(struct kvm_mmu_memory_cache *cache)\n{\n\treturn cache->nobjs;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool rmap_can_add(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_mmu_memory_cache *cache;\n\n\tcache = &vcpu->arch.mmu_pte_list_desc_cache;\n\treturn mmu_memory_cache_free_objects(cache);\n}"
  },
  {
    "function_name": "gfn_to_rmap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1404-1413",
    "snippet": "static struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__gfn_to_rmap",
          "args": [
            "gfn",
            "sp->role.level",
            "slot"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "__gfn_to_rmap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1395-1402",
          "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_memslot",
          "args": [
            "slots",
            "gfn"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots_for_spte_role",
          "args": [
            "kvm",
            "sp->role"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *gfn_to_rmap(struct kvm *kvm, gfn_t gfn,\n\t\t\t\t\t struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\treturn __gfn_to_rmap(gfn, sp->role.level, slot);\n}"
  },
  {
    "function_name": "__gfn_to_rmap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1395-1402",
    "snippet": "static struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfn_to_index",
          "args": [
            "gfn",
            "slot->base_gfn",
            "level"
          ],
          "line": 1400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_rmap_head *__gfn_to_rmap(gfn_t gfn, int level,\n\t\t\t\t\t   struct kvm_memory_slot *slot)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.rmap[level - PT_PAGE_TABLE_LEVEL][idx];\n}"
  },
  {
    "function_name": "pte_list_remove",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1389-1393",
    "snippet": "static void pte_list_remove(struct kvm_rmap_head *rmap_head, u64 *sptep)\n{\n\tmmu_spte_clear_track_bits(sptep);\n\t__pte_list_remove(sptep, rmap_head);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pte_list_remove",
          "args": [
            "sptep",
            "rmap_head"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "__pte_list_remove",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1353-1387",
          "snippet": "static void __pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tpr_err(\"%s: %p 0->BUG\\n\", __func__, spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"%s:  %p 1->0\\n\", __func__, spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tpr_err(\"%s:  %p 1->BUG\\n\", __func__, spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"%s:  %p many->many\\n\", __func__, spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"%s: %p many->many\\n\", __func__, spte);\n\t\tBUG();\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_LIST_EXT 3"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tpr_err(\"%s: %p 0->BUG\\n\", __func__, spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"%s:  %p 1->0\\n\", __func__, spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tpr_err(\"%s:  %p 1->BUG\\n\", __func__, spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"%s:  %p many->many\\n\", __func__, spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"%s: %p many->many\\n\", __func__, spte);\n\t\tBUG();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_clear_track_bits",
          "args": [
            "sptep"
          ],
          "line": 1391
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_clear_track_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "918-947",
          "snippet": "static int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (is_accessed_spte(old_spte))\n\t\tkvm_set_pfn_accessed(pfn);\n\n\tif (is_dirty_spte(old_spte))\n\t\tkvm_set_pfn_dirty(pfn);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (is_accessed_spte(old_spte))\n\t\tkvm_set_pfn_accessed(pfn);\n\n\tif (is_dirty_spte(old_spte))\n\t\tkvm_set_pfn_dirty(pfn);\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void pte_list_remove(struct kvm_rmap_head *rmap_head, u64 *sptep)\n{\n\tmmu_spte_clear_track_bits(sptep);\n\t__pte_list_remove(sptep, rmap_head);\n}"
  },
  {
    "function_name": "__pte_list_remove",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1353-1387",
    "snippet": "static void __pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tpr_err(\"%s: %p 0->BUG\\n\", __func__, spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"%s:  %p 1->0\\n\", __func__, spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tpr_err(\"%s:  %p 1->BUG\\n\", __func__, spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"%s:  %p many->many\\n\", __func__, spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"%s: %p many->many\\n\", __func__, spte);\n\t\tBUG();\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_LIST_EXT 3"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: %p many->many\\n\"",
            "__func__",
            "spte"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pte_list_desc_remove_entry",
          "args": [
            "rmap_head",
            "desc",
            "i",
            "prev_desc"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "pte_list_desc_remove_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1330-1351",
          "snippet": "static void\npte_list_desc_remove_entry(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct pte_list_desc *desc, int i,\n\t\t\t   struct pte_list_desc *prev_desc)\n{\n\tint j;\n\n\tfor (j = PTE_LIST_EXT - 1; !desc->sptes[j] && j > i; --j)\n\t\t;\n\tdesc->sptes[i] = desc->sptes[j];\n\tdesc->sptes[j] = NULL;\n\tif (j != 0)\n\t\treturn;\n\tif (!prev_desc && !desc->more)\n\t\trmap_head->val = 0;\n\telse\n\t\tif (prev_desc)\n\t\t\tprev_desc->more = desc->more;\n\t\telse\n\t\t\trmap_head->val = (unsigned long)desc->more | 1;\n\tmmu_free_pte_list_desc(desc);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PTE_LIST_EXT 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void\npte_list_desc_remove_entry(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct pte_list_desc *desc, int i,\n\t\t\t   struct pte_list_desc *prev_desc)\n{\n\tint j;\n\n\tfor (j = PTE_LIST_EXT - 1; !desc->sptes[j] && j > i; --j)\n\t\t;\n\tdesc->sptes[i] = desc->sptes[j];\n\tdesc->sptes[j] = NULL;\n\tif (j != 0)\n\t\treturn;\n\tif (!prev_desc && !desc->more)\n\t\trmap_head->val = 0;\n\telse\n\t\tif (prev_desc)\n\t\t\tprev_desc->more = desc->more;\n\t\telse\n\t\t\trmap_head->val = (unsigned long)desc->more | 1;\n\tmmu_free_pte_list_desc(desc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"%s:  %p many->many\\n\"",
            "__func__",
            "spte"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s:  %p 1->BUG\\n\"",
            "__func__",
            "spte"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"%s:  %p 1->0\\n\"",
            "__func__",
            "spte"
          ],
          "line": 1363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: %p 0->BUG\\n\"",
            "__func__",
            "spte"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __pte_list_remove(u64 *spte, struct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tstruct pte_list_desc *prev_desc;\n\tint i;\n\n\tif (!rmap_head->val) {\n\t\tpr_err(\"%s: %p 0->BUG\\n\", __func__, spte);\n\t\tBUG();\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"%s:  %p 1->0\\n\", __func__, spte);\n\t\tif ((u64 *)rmap_head->val != spte) {\n\t\t\tpr_err(\"%s:  %p 1->BUG\\n\", __func__, spte);\n\t\t\tBUG();\n\t\t}\n\t\trmap_head->val = 0;\n\t} else {\n\t\trmap_printk(\"%s:  %p many->many\\n\", __func__, spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\tprev_desc = NULL;\n\t\twhile (desc) {\n\t\t\tfor (i = 0; i < PTE_LIST_EXT && desc->sptes[i]; ++i) {\n\t\t\t\tif (desc->sptes[i] == spte) {\n\t\t\t\t\tpte_list_desc_remove_entry(rmap_head,\n\t\t\t\t\t\t\tdesc, i, prev_desc);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tprev_desc = desc;\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tpr_err(\"%s: %p many->many\\n\", __func__, spte);\n\t\tBUG();\n\t}\n}"
  },
  {
    "function_name": "pte_list_desc_remove_entry",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1330-1351",
    "snippet": "static void\npte_list_desc_remove_entry(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct pte_list_desc *desc, int i,\n\t\t\t   struct pte_list_desc *prev_desc)\n{\n\tint j;\n\n\tfor (j = PTE_LIST_EXT - 1; !desc->sptes[j] && j > i; --j)\n\t\t;\n\tdesc->sptes[i] = desc->sptes[j];\n\tdesc->sptes[j] = NULL;\n\tif (j != 0)\n\t\treturn;\n\tif (!prev_desc && !desc->more)\n\t\trmap_head->val = 0;\n\telse\n\t\tif (prev_desc)\n\t\t\tprev_desc->more = desc->more;\n\t\telse\n\t\t\trmap_head->val = (unsigned long)desc->more | 1;\n\tmmu_free_pte_list_desc(desc);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_LIST_EXT 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_free_pte_list_desc",
          "args": [
            "desc"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_free_pte_list_desc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1152-1155",
          "snippet": "static void mmu_free_pte_list_desc(struct pte_list_desc *pte_list_desc)\n{\n\tkmem_cache_free(pte_list_desc_cache, pte_list_desc);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *pte_list_desc_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\n\nstatic void mmu_free_pte_list_desc(struct pte_list_desc *pte_list_desc)\n{\n\tkmem_cache_free(pte_list_desc_cache, pte_list_desc);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void\npte_list_desc_remove_entry(struct kvm_rmap_head *rmap_head,\n\t\t\t   struct pte_list_desc *desc, int i,\n\t\t\t   struct pte_list_desc *prev_desc)\n{\n\tint j;\n\n\tfor (j = PTE_LIST_EXT - 1; !desc->sptes[j] && j > i; --j)\n\t\t;\n\tdesc->sptes[i] = desc->sptes[j];\n\tdesc->sptes[j] = NULL;\n\tif (j != 0)\n\t\treturn;\n\tif (!prev_desc && !desc->more)\n\t\trmap_head->val = 0;\n\telse\n\t\tif (prev_desc)\n\t\t\tprev_desc->more = desc->more;\n\t\telse\n\t\t\trmap_head->val = (unsigned long)desc->more | 1;\n\tmmu_free_pte_list_desc(desc);\n}"
  },
  {
    "function_name": "pte_list_add",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1296-1328",
    "snippet": "static int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_LIST_EXT 3"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_alloc_pte_list_desc",
          "args": [
            "vcpu"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_alloc_pte_list_desc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1147-1150",
          "snippet": "static struct pte_list_desc *mmu_alloc_pte_list_desc(struct kvm_vcpu *vcpu)\n{\n\treturn mmu_memory_cache_alloc(&vcpu->arch.mmu_pte_list_desc_cache);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic struct pte_list_desc *mmu_alloc_pte_list_desc(struct kvm_vcpu *vcpu)\n{\n\treturn mmu_memory_cache_alloc(&vcpu->arch.mmu_pte_list_desc_cache);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"pte_list_add: %p %llx many->many\\n\"",
            "spte",
            "*spte"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"pte_list_add: %p %llx 1->many\\n\"",
            "spte",
            "*spte"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rmap_printk",
          "args": [
            "\"pte_list_add: %p %llx 0->1\\n\"",
            "spte",
            "*spte"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_LIST_EXT 3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic int pte_list_add(struct kvm_vcpu *vcpu, u64 *spte,\n\t\t\tstruct kvm_rmap_head *rmap_head)\n{\n\tstruct pte_list_desc *desc;\n\tint i, count = 0;\n\n\tif (!rmap_head->val) {\n\t\trmap_printk(\"pte_list_add: %p %llx 0->1\\n\", spte, *spte);\n\t\trmap_head->val = (unsigned long)spte;\n\t} else if (!(rmap_head->val & 1)) {\n\t\trmap_printk(\"pte_list_add: %p %llx 1->many\\n\", spte, *spte);\n\t\tdesc = mmu_alloc_pte_list_desc(vcpu);\n\t\tdesc->sptes[0] = (u64 *)rmap_head->val;\n\t\tdesc->sptes[1] = spte;\n\t\trmap_head->val = (unsigned long)desc | 1;\n\t\t++count;\n\t} else {\n\t\trmap_printk(\"pte_list_add: %p %llx many->many\\n\", spte, *spte);\n\t\tdesc = (struct pte_list_desc *)(rmap_head->val & ~1ul);\n\t\twhile (desc->sptes[PTE_LIST_EXT-1] && desc->more) {\n\t\t\tdesc = desc->more;\n\t\t\tcount += PTE_LIST_EXT;\n\t\t}\n\t\tif (desc->sptes[PTE_LIST_EXT-1]) {\n\t\t\tdesc->more = mmu_alloc_pte_list_desc(vcpu);\n\t\t\tdesc = desc->more;\n\t\t}\n\t\tfor (i = 0; desc->sptes[i]; ++i)\n\t\t\t++count;\n\t\tdesc->sptes[i] = spte;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "gfn_to_memslot_dirty_bitmap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1270-1283",
    "snippet": "static struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn NULL;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn NULL;\n\n\treturn slot;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_memslot",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic struct kvm_memory_slot *\ngfn_to_memslot_dirty_bitmap(struct kvm_vcpu *vcpu, gfn_t gfn,\n\t\t\t    bool no_dirty_log)\n{\n\tstruct kvm_memory_slot *slot;\n\n\tslot = kvm_vcpu_gfn_to_memslot(vcpu, gfn);\n\tif (!slot || slot->flags & KVM_MEMSLOT_INVALID)\n\t\treturn NULL;\n\tif (no_dirty_log && slot->dirty_bitmap)\n\t\treturn NULL;\n\n\treturn slot;\n}"
  },
  {
    "function_name": "unaccount_huge_nx_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1263-1268",
    "snippet": "static void unaccount_huge_nx_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\t--kvm->stat.nx_lpage_splits;\n\tsp->lpage_disallowed = false;\n\tlist_del(&sp->lpage_disallowed_link);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&sp->lpage_disallowed_link"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void unaccount_huge_nx_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\t--kvm->stat.nx_lpage_splits;\n\tsp->lpage_disallowed = false;\n\tlist_del(&sp->lpage_disallowed_link);\n}"
  },
  {
    "function_name": "unaccount_shadowed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1246-1261",
    "snippet": "static void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_gfn_allow_lpage",
          "args": [
            "slot",
            "gfn"
          ],
          "line": 1260
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gfn_allow_lpage",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1211-1214",
          "snippet": "void kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_slot_page_track_remove_page",
          "args": [
            "kvm",
            "slot",
            "gfn",
            "KVM_PAGE_TRACK_WRITE"
          ],
          "line": 1257
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_slot_page_track_remove_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/page_track.c",
          "lines": "121-135",
          "snippet": "void kvm_slot_page_track_remove_page(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t     enum kvm_page_track_mode mode)\n{\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn;\n\n\tupdate_gfn_track(slot, gfn, mode, -1);\n\n\t/*\n\t * allow large page mapping for the tracked page\n\t * after the tracker is gone.\n\t */\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <linux/rculist.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <linux/rculist.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_slot_page_track_remove_page(struct kvm *kvm,\n\t\t\t\t     struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t     enum kvm_page_track_mode mode)\n{\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn;\n\n\tupdate_gfn_track(slot, gfn, mode, -1);\n\n\t/*\n\t * allow large page mapping for the tracked page\n\t * after the tracker is gone.\n\t */\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_memslot",
          "args": [
            "slots",
            "gfn"
          ],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots_for_spte_role",
          "args": [
            "kvm",
            "sp->role"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void unaccount_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages--;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_remove_page(kvm, slot, gfn,\n\t\t\t\t\t\t       KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_allow_lpage(slot, gfn);\n}"
  },
  {
    "function_name": "account_huge_nx_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1235-1244",
    "snippet": "static void account_huge_nx_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tif (sp->lpage_disallowed)\n\t\treturn;\n\n\t++kvm->stat.nx_lpage_splits;\n\tlist_add_tail(&sp->lpage_disallowed_link,\n\t\t      &kvm->arch.lpage_disallowed_mmu_pages);\n\tsp->lpage_disallowed = true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&sp->lpage_disallowed_link",
            "&kvm->arch.lpage_disallowed_mmu_pages"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void account_huge_nx_page(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tif (sp->lpage_disallowed)\n\t\treturn;\n\n\t++kvm->stat.nx_lpage_splits;\n\tlist_add_tail(&sp->lpage_disallowed_link,\n\t\t      &kvm->arch.lpage_disallowed_mmu_pages);\n\tsp->lpage_disallowed = true;\n}"
  },
  {
    "function_name": "account_shadowed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1216-1233",
    "snippet": "static void account_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages++;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\n\t/* the non-leaf shadow pages are keeping readonly. */\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_add_page(kvm, slot, gfn,\n\t\t\t\t\t\t    KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_disallow_lpage(slot, gfn);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_gfn_disallow_lpage",
          "args": [
            "slot",
            "gfn"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_gfn_disallow_lpage",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1206-1209",
          "snippet": "void kvm_mmu_gfn_disallow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, 1);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_gfn_disallow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_slot_page_track_add_page",
          "args": [
            "kvm",
            "slot",
            "gfn",
            "KVM_PAGE_TRACK_WRITE"
          ],
          "line": 1229
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_slot_page_track_add_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/page_track.c",
          "lines": "86-105",
          "snippet": "void kvm_slot_page_track_add_page(struct kvm *kvm,\n\t\t\t\t  struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t  enum kvm_page_track_mode mode)\n{\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn;\n\n\tupdate_gfn_track(slot, gfn, mode, 1);\n\n\t/*\n\t * new track stops large page mapping for the\n\t * tracked page.\n\t */\n\tkvm_mmu_gfn_disallow_lpage(slot, gfn);\n\n\tif (mode == KVM_PAGE_TRACK_WRITE)\n\t\tif (kvm_mmu_slot_gfn_write_protect(kvm, slot, gfn))\n\t\t\tkvm_flush_remote_tlbs(kvm);\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <linux/rculist.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include <asm/kvm_page_track.h>\n#include <linux/rculist.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_slot_page_track_add_page(struct kvm *kvm,\n\t\t\t\t  struct kvm_memory_slot *slot, gfn_t gfn,\n\t\t\t\t  enum kvm_page_track_mode mode)\n{\n\n\tif (WARN_ON(!page_track_mode_is_valid(mode)))\n\t\treturn;\n\n\tupdate_gfn_track(slot, gfn, mode, 1);\n\n\t/*\n\t * new track stops large page mapping for the\n\t * tracked page.\n\t */\n\tkvm_mmu_gfn_disallow_lpage(slot, gfn);\n\n\tif (mode == KVM_PAGE_TRACK_WRITE)\n\t\tif (kvm_mmu_slot_gfn_write_protect(kvm, slot, gfn))\n\t\t\tkvm_flush_remote_tlbs(kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__gfn_to_memslot",
          "args": [
            "slots",
            "gfn"
          ],
          "line": 1225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_memslots_for_spte_role",
          "args": [
            "kvm",
            "sp->role"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void account_shadowed(struct kvm *kvm, struct kvm_mmu_page *sp)\n{\n\tstruct kvm_memslots *slots;\n\tstruct kvm_memory_slot *slot;\n\tgfn_t gfn;\n\n\tkvm->arch.indirect_shadow_pages++;\n\tgfn = sp->gfn;\n\tslots = kvm_memslots_for_spte_role(kvm, sp->role);\n\tslot = __gfn_to_memslot(slots, gfn);\n\n\t/* the non-leaf shadow pages are keeping readonly. */\n\tif (sp->role.level > PT_PAGE_TABLE_LEVEL)\n\t\treturn kvm_slot_page_track_add_page(kvm, slot, gfn,\n\t\t\t\t\t\t    KVM_PAGE_TRACK_WRITE);\n\n\tkvm_mmu_gfn_disallow_lpage(slot, gfn);\n}"
  },
  {
    "function_name": "kvm_mmu_gfn_allow_lpage",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1211-1214",
    "snippet": "void kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_gfn_disallow_lpage_count",
          "args": [
            "slot",
            "gfn",
            "-1"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "update_gfn_disallow_lpage_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1193-1204",
          "snippet": "static void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_gfn_allow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, -1);\n}"
  },
  {
    "function_name": "kvm_mmu_gfn_disallow_lpage",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1206-1209",
    "snippet": "void kvm_mmu_gfn_disallow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, 1);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_gfn_disallow_lpage_count",
          "args": [
            "slot",
            "gfn",
            "1"
          ],
          "line": 1208
        },
        "resolved": true,
        "details": {
          "function_name": "update_gfn_disallow_lpage_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1193-1204",
          "snippet": "static void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nvoid kvm_mmu_gfn_disallow_lpage(struct kvm_memory_slot *slot, gfn_t gfn)\n{\n\tupdate_gfn_disallow_lpage_count(slot, gfn, 1);\n}"
  },
  {
    "function_name": "update_gfn_disallow_lpage_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1193-1204",
    "snippet": "static void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "linfo->disallow_lpage < 0"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lpage_info_slot",
          "args": [
            "gfn",
            "slot",
            "i"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "lpage_info_slot",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1183-1191",
          "snippet": "static struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void update_gfn_disallow_lpage_count(struct kvm_memory_slot *slot,\n\t\t\t\t\t    gfn_t gfn, int count)\n{\n\tstruct kvm_lpage_info *linfo;\n\tint i;\n\n\tfor (i = PT_DIRECTORY_LEVEL; i <= PT_MAX_HUGEPAGE_LEVEL; ++i) {\n\t\tlinfo = lpage_info_slot(gfn, slot, i);\n\t\tlinfo->disallow_lpage += count;\n\t\tWARN_ON(linfo->disallow_lpage < 0);\n\t}\n}"
  },
  {
    "function_name": "lpage_info_slot",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1183-1191",
    "snippet": "static struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gfn_to_index",
          "args": [
            "gfn",
            "slot->base_gfn",
            "level"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kvm_lpage_info *lpage_info_slot(gfn_t gfn,\n\t\t\t\t\t      struct kvm_memory_slot *slot,\n\t\t\t\t\t      int level)\n{\n\tunsigned long idx;\n\n\tidx = gfn_to_index(gfn, slot->base_gfn, level);\n\treturn &slot->arch.lpage_info[level - 2][idx];\n}"
  },
  {
    "function_name": "kvm_mmu_page_set_gfn",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1165-1177",
    "snippet": "static void kvm_mmu_page_set_gfn(struct kvm_mmu_page *sp, int index, gfn_t gfn)\n{\n\tif (!sp->role.direct) {\n\t\tsp->gfns[index] = gfn;\n\t\treturn;\n\t}\n\n\tif (WARN_ON(gfn != kvm_mmu_page_get_gfn(sp, index)))\n\t\tpr_err_ratelimited(\"gfn mismatch under direct page %llx \"\n\t\t\t\t   \"(expected %llx, got %llx)\\n\",\n\t\t\t\t   sp->gfn,\n\t\t\t\t   kvm_mmu_page_get_gfn(sp, index), gfn);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err_ratelimited",
          "args": [
            "\"gfn mismatch under direct page %llx \"\n\t\t\t\t   \"(expected %llx, got %llx)\\n\"",
            "sp->gfn",
            "kvm_mmu_page_get_gfn(sp, index)",
            "gfn"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_mmu_page_get_gfn",
          "args": [
            "sp",
            "index"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_get_gfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1157-1163",
          "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_LEVEL_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "gfn != kvm_mmu_page_get_gfn(sp, index)"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_mmu_page_set_gfn(struct kvm_mmu_page *sp, int index, gfn_t gfn)\n{\n\tif (!sp->role.direct) {\n\t\tsp->gfns[index] = gfn;\n\t\treturn;\n\t}\n\n\tif (WARN_ON(gfn != kvm_mmu_page_get_gfn(sp, index)))\n\t\tpr_err_ratelimited(\"gfn mismatch under direct page %llx \"\n\t\t\t\t   \"(expected %llx, got %llx)\\n\",\n\t\t\t\t   sp->gfn,\n\t\t\t\t   kvm_mmu_page_get_gfn(sp, index), gfn);\n}"
  },
  {
    "function_name": "kvm_mmu_page_get_gfn",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1157-1163",
    "snippet": "static gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_LEVEL_BITS 9"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_LEVEL_BITS 9\n\nstatic gfn_t kvm_mmu_page_get_gfn(struct kvm_mmu_page *sp, int index)\n{\n\tif (!sp->role.direct)\n\t\treturn sp->gfns[index];\n\n\treturn sp->gfn + (index << ((sp->role.level - 1) * PT64_LEVEL_BITS));\n}"
  },
  {
    "function_name": "mmu_free_pte_list_desc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1152-1155",
    "snippet": "static void mmu_free_pte_list_desc(struct pte_list_desc *pte_list_desc)\n{\n\tkmem_cache_free(pte_list_desc_cache, pte_list_desc);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pte_list_desc_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "pte_list_desc_cache",
            "pte_list_desc"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\n\nstatic void mmu_free_pte_list_desc(struct pte_list_desc *pte_list_desc)\n{\n\tkmem_cache_free(pte_list_desc_cache, pte_list_desc);\n}"
  },
  {
    "function_name": "mmu_alloc_pte_list_desc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1147-1150",
    "snippet": "static struct pte_list_desc *mmu_alloc_pte_list_desc(struct kvm_vcpu *vcpu)\n{\n\treturn mmu_memory_cache_alloc(&vcpu->arch.mmu_pte_list_desc_cache);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_memory_cache_alloc",
          "args": [
            "&vcpu->arch.mmu_pte_list_desc_cache"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_memory_cache_alloc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1138-1145",
          "snippet": "static void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic struct pte_list_desc *mmu_alloc_pte_list_desc(struct kvm_vcpu *vcpu)\n{\n\treturn mmu_memory_cache_alloc(&vcpu->arch.mmu_pte_list_desc_cache);\n}"
  },
  {
    "function_name": "mmu_memory_cache_alloc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1138-1145",
    "snippet": "static void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!mc->nobjs"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void *mmu_memory_cache_alloc(struct kvm_mmu_memory_cache *mc)\n{\n\tvoid *p;\n\n\tBUG_ON(!mc->nobjs);\n\tp = mc->objects[--mc->nobjs];\n\treturn p;\n}"
  },
  {
    "function_name": "mmu_free_memory_caches",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1129-1136",
    "snippet": "static void mmu_free_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\tpte_list_desc_cache);\n\tmmu_free_memory_cache_page(&vcpu->arch.mmu_page_cache);\n\tmmu_free_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\tmmu_page_header_cache);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pte_list_desc_cache;",
      "static struct kmem_cache *mmu_page_header_cache;",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_free_memory_cache",
          "args": [
            "&vcpu->arch.mmu_page_header_cache",
            "mmu_page_header_cache"
          ],
          "line": 1134
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_free_memory_cache",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1083-1088",
          "snippet": "static void mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc,\n\t\t\t\t  struct kmem_cache *cache)\n{\n\twhile (mc->nobjs)\n\t\tkmem_cache_free(cache, mc->objects[--mc->nobjs]);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc,\n\t\t\t\t  struct kmem_cache *cache)\n{\n\twhile (mc->nobjs)\n\t\tkmem_cache_free(cache, mc->objects[--mc->nobjs]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_free_memory_cache_page",
          "args": [
            "&vcpu->arch.mmu_page_cache"
          ],
          "line": 1133
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_free_memory_cache_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1106-1110",
          "snippet": "static void mmu_free_memory_cache_page(struct kvm_mmu_memory_cache *mc)\n{\n\twhile (mc->nobjs)\n\t\tfree_page((unsigned long)mc->objects[--mc->nobjs]);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_memory_cache_page(struct kvm_mmu_memory_cache *mc)\n{\n\twhile (mc->nobjs)\n\t\tfree_page((unsigned long)mc->objects[--mc->nobjs]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void mmu_free_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tmmu_free_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\tpte_list_desc_cache);\n\tmmu_free_memory_cache_page(&vcpu->arch.mmu_page_cache);\n\tmmu_free_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\tmmu_page_header_cache);\n}"
  },
  {
    "function_name": "mmu_topup_memory_caches",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1112-1127",
    "snippet": "static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PTE_PREFETCH_NUM\t\t8"
    ],
    "globals_used": [
      "static struct kmem_cache *pte_list_desc_cache;",
      "static struct kmem_cache *mmu_page_header_cache;",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_topup_memory_cache",
          "args": [
            "&vcpu->arch.mmu_page_header_cache",
            "mmu_page_header_cache",
            "4"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_topup_memory_cache",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1062-1076",
          "snippet": "static int mmu_topup_memory_cache(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t  struct kmem_cache *base_cache, int min)\n{\n\tvoid *obj;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tobj = kmem_cache_zalloc(base_cache, GFP_KERNEL_ACCOUNT);\n\t\tif (!obj)\n\t\t\treturn cache->nobjs >= min ? 0 : -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = obj;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_topup_memory_cache(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t  struct kmem_cache *base_cache, int min)\n{\n\tvoid *obj;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tobj = kmem_cache_zalloc(base_cache, GFP_KERNEL_ACCOUNT);\n\t\tif (!obj)\n\t\t\treturn cache->nobjs >= min ? 0 : -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = obj;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_topup_memory_cache_page",
          "args": [
            "&vcpu->arch.mmu_page_cache",
            "8"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_topup_memory_cache_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "1090-1104",
          "snippet": "static int mmu_topup_memory_cache_page(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t       int min)\n{\n\tvoid *page;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tpage = (void *)__get_free_page(GFP_KERNEL_ACCOUNT);\n\t\tif (!page)\n\t\t\treturn cache->nobjs >= min ? 0 : -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = page;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_topup_memory_cache_page(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t       int min)\n{\n\tvoid *page;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tpage = (void *)__get_free_page(GFP_KERNEL_ACCOUNT);\n\t\tif (!page)\n\t\t\treturn cache->nobjs >= min ? 0 : -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = page;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PTE_PREFETCH_NUM\t\t8\n\nstatic struct kmem_cache *pte_list_desc_cache;\nstatic struct kmem_cache *mmu_page_header_cache;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_pte_list_desc_cache,\n\t\t\t\t   pte_list_desc_cache, 8 + PTE_PREFETCH_NUM);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache_page(&vcpu->arch.mmu_page_cache, 8);\n\tif (r)\n\t\tgoto out;\n\tr = mmu_topup_memory_cache(&vcpu->arch.mmu_page_header_cache,\n\t\t\t\t   mmu_page_header_cache, 4);\nout:\n\treturn r;\n}"
  },
  {
    "function_name": "mmu_free_memory_cache_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1106-1110",
    "snippet": "static void mmu_free_memory_cache_page(struct kvm_mmu_memory_cache *mc)\n{\n\twhile (mc->nobjs)\n\t\tfree_page((unsigned long)mc->objects[--mc->nobjs]);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_page",
          "args": [
            "(unsigned long)mc->objects[--mc->nobjs]"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_free_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "2066-2075",
          "snippet": "static void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *mmu_page_header_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic struct kmem_cache *mmu_page_header_cache;\n\nstatic void kvm_mmu_free_page(struct kvm_mmu_page *sp)\n{\n\tMMU_WARN_ON(!is_empty_shadow_page(sp->spt));\n\thlist_del(&sp->hash_link);\n\tlist_del(&sp->link);\n\tfree_page((unsigned long)sp->spt);\n\tif (!sp->role.direct)\n\t\tfree_page((unsigned long)sp->gfns);\n\tkmem_cache_free(mmu_page_header_cache, sp);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_memory_cache_page(struct kvm_mmu_memory_cache *mc)\n{\n\twhile (mc->nobjs)\n\t\tfree_page((unsigned long)mc->objects[--mc->nobjs]);\n}"
  },
  {
    "function_name": "mmu_topup_memory_cache_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1090-1104",
    "snippet": "static int mmu_topup_memory_cache_page(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t       int min)\n{\n\tvoid *page;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tpage = (void *)__get_free_page(GFP_KERNEL_ACCOUNT);\n\t\tif (!page)\n\t\t\treturn cache->nobjs >= min ? 0 : -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = page;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_free_page",
          "args": [
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cache->objects"
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_topup_memory_cache_page(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t       int min)\n{\n\tvoid *page;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tpage = (void *)__get_free_page(GFP_KERNEL_ACCOUNT);\n\t\tif (!page)\n\t\t\treturn cache->nobjs >= min ? 0 : -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = page;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "mmu_free_memory_cache",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1083-1088",
    "snippet": "static void mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc,\n\t\t\t\t  struct kmem_cache *cache)\n{\n\twhile (mc->nobjs)\n\t\tkmem_cache_free(cache, mc->objects[--mc->nobjs]);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "cache",
            "mc->objects[--mc->nobjs]"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_free_memory_cache(struct kvm_mmu_memory_cache *mc,\n\t\t\t\t  struct kmem_cache *cache)\n{\n\twhile (mc->nobjs)\n\t\tkmem_cache_free(cache, mc->objects[--mc->nobjs]);\n}"
  },
  {
    "function_name": "mmu_memory_cache_free_objects",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1078-1081",
    "snippet": "static int mmu_memory_cache_free_objects(struct kvm_mmu_memory_cache *cache)\n{\n\treturn cache->nobjs;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_memory_cache_free_objects(struct kvm_mmu_memory_cache *cache)\n{\n\treturn cache->nobjs;\n}"
  },
  {
    "function_name": "mmu_topup_memory_cache",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1062-1076",
    "snippet": "static int mmu_topup_memory_cache(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t  struct kmem_cache *base_cache, int min)\n{\n\tvoid *obj;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tobj = kmem_cache_zalloc(base_cache, GFP_KERNEL_ACCOUNT);\n\t\tif (!obj)\n\t\t\treturn cache->nobjs >= min ? 0 : -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = obj;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "base_cache",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cache->objects"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_topup_memory_cache(struct kvm_mmu_memory_cache *cache,\n\t\t\t\t  struct kmem_cache *base_cache, int min)\n{\n\tvoid *obj;\n\n\tif (cache->nobjs >= min)\n\t\treturn 0;\n\twhile (cache->nobjs < ARRAY_SIZE(cache->objects)) {\n\t\tobj = kmem_cache_zalloc(base_cache, GFP_KERNEL_ACCOUNT);\n\t\tif (!obj)\n\t\t\treturn cache->nobjs >= min ? 0 : -ENOMEM;\n\t\tcache->objects[cache->nobjs++] = obj;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "walk_shadow_page_lockless_end",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1051-1060",
    "snippet": "static void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_mmu_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 1059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_store_release",
          "args": [
            "&vcpu->mode",
            "OUTSIDE_GUEST_MODE"
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void walk_shadow_page_lockless_end(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Make sure the write to vcpu->mode is not reordered in front of\n\t * reads to sptes.  If it does, kvm_mmu_commit_zap_page() can see us\n\t * OUTSIDE_GUEST_MODE and proceed to free the shadow page table.\n\t */\n\tsmp_store_release(&vcpu->mode, OUTSIDE_GUEST_MODE);\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "walk_shadow_page_lockless_begin",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1036-1049",
    "snippet": "static void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_store_mb",
          "args": [
            "vcpu->mode",
            "READING_SHADOW_PAGE_TABLES"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void walk_shadow_page_lockless_begin(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Prevent page table teardown by making any free-er wait during\n\t * kvm_flush_remote_tlbs() IPI to all active vcpus.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * Make sure a following spte read is not reordered ahead of the write\n\t * to vcpu->mode.\n\t */\n\tsmp_store_mb(vcpu->mode, READING_SHADOW_PAGE_TABLES);\n}"
  },
  {
    "function_name": "mmu_spte_age",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "1011-1034",
    "snippet": "static bool mmu_spte_age(u64 *sptep)\n{\n\tu64 spte = mmu_spte_get_lockless(sptep);\n\n\tif (!is_accessed_spte(spte))\n\t\treturn false;\n\n\tif (spte_ad_enabled(spte)) {\n\t\tclear_bit((ffs(shadow_accessed_mask) - 1),\n\t\t\t  (unsigned long *)sptep);\n\t} else {\n\t\t/*\n\t\t * Capture the dirty status of the page, so that it doesn't get\n\t\t * lost when the SPTE is marked for access tracking.\n\t\t */\n\t\tif (is_writable_pte(spte))\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(spte));\n\n\t\tspte = mark_spte_for_access_track(spte);\n\t\tmmu_spte_update_no_track(sptep, spte);\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_update_no_track",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_update_no_track",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "845-864",
          "snippet": "static u64 mmu_spte_update_no_track(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn old_spte;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\tWARN_ON(spte_to_pfn(old_spte) != spte_to_pfn(new_spte));\n\n\treturn old_spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 mmu_spte_update_no_track(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn old_spte;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\tWARN_ON(spte_to_pfn(old_spte) != spte_to_pfn(new_spte));\n\n\treturn old_spte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_spte_for_access_track",
          "args": [
            "spte"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "mark_spte_for_access_track",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "964-990",
          "snippet": "static u64 mark_spte_for_access_track(u64 spte)\n{\n\tif (spte_ad_enabled(spte))\n\t\treturn spte & ~shadow_accessed_mask;\n\n\tif (is_access_track_spte(spte))\n\t\treturn spte;\n\n\t/*\n\t * Making an Access Tracking PTE will result in removal of write access\n\t * from the PTE. So, verify that we will be able to restore the write\n\t * access in the fast page fault path later on.\n\t */\n\tWARN_ONCE((spte & PT_WRITABLE_MASK) &&\n\t\t  !spte_can_locklessly_be_made_writable(spte),\n\t\t  \"kvm: Writable SPTE is not locklessly dirty-trackable\\n\");\n\n\tWARN_ONCE(spte & (shadow_acc_track_saved_bits_mask <<\n\t\t\t  shadow_acc_track_saved_bits_shift),\n\t\t  \"kvm: Access Tracking saved bit locations are not zero\\n\");\n\n\tspte |= (spte & shadow_acc_track_saved_bits_mask) <<\n\t\tshadow_acc_track_saved_bits_shift;\n\tspte &= ~shadow_acc_track_mask;\n\n\treturn spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;",
            "static const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;",
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;\nstatic const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 mark_spte_for_access_track(u64 spte)\n{\n\tif (spte_ad_enabled(spte))\n\t\treturn spte & ~shadow_accessed_mask;\n\n\tif (is_access_track_spte(spte))\n\t\treturn spte;\n\n\t/*\n\t * Making an Access Tracking PTE will result in removal of write access\n\t * from the PTE. So, verify that we will be able to restore the write\n\t * access in the fast page fault path later on.\n\t */\n\tWARN_ONCE((spte & PT_WRITABLE_MASK) &&\n\t\t  !spte_can_locklessly_be_made_writable(spte),\n\t\t  \"kvm: Writable SPTE is not locklessly dirty-trackable\\n\");\n\n\tWARN_ONCE(spte & (shadow_acc_track_saved_bits_mask <<\n\t\t\t  shadow_acc_track_saved_bits_shift),\n\t\t  \"kvm: Access Tracking saved bit locations are not zero\\n\");\n\n\tspte |= (spte & shadow_acc_track_saved_bits_mask) <<\n\t\tshadow_acc_track_saved_bits_shift;\n\tspte &= ~shadow_acc_track_mask;\n\n\treturn spte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_pfn_dirty",
          "args": [
            "spte_to_pfn(spte)"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_to_pfn",
          "args": [
            "spte"
          ],
          "line": 1027
        },
        "resolved": true,
        "details": {
          "function_name": "spte_to_pfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "635-638",
          "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "spte"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "151-154",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "(ffs(shadow_accessed_mask) - 1)",
            "(unsigned long *)sptep"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "214-222",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "shadow_accessed_mask"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "vmx_read_l1_tsc_offset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.c",
          "lines": "1716-1725",
          "snippet": "static u64 vmx_read_l1_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING))\n\t\treturn vcpu->arch.tsc_offset - vmcs12->tsc_offset;\n\n\treturn vcpu->arch.tsc_offset;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"vmcs.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"ops.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"irq.h\"",
            "#include \"evmcs.h\"",
            "#include \"cpuid.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/virtext.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/mwait.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/mmu_context.h>",
            "#include <asm/mce.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/kexec.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/io.h>",
            "#include <asm/fpu/internal.h>",
            "#include <asm/desc.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/cpu.h>",
            "#include <asm/asm.h>",
            "#include <asm/apic.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/tboot.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/smt.h>",
            "#include <linux/sched.h>",
            "#include <linux/mm.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kernel.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/highmem.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool guest_state_valid(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"vmcs.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"ops.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"kvm_cache_regs.h\"\n#include \"irq.h\"\n#include \"evmcs.h\"\n#include \"cpuid.h\"\n#include \"capabilities.h\"\n#include <asm/vmx.h>\n#include <asm/virtext.h>\n#include <asm/spec-ctrl.h>\n#include <asm/mwait.h>\n#include <asm/mshyperv.h>\n#include <asm/mmu_context.h>\n#include <asm/mce.h>\n#include <asm/perf_event.h>\n#include <asm/kexec.h>\n#include <asm/irq_remapping.h>\n#include <asm/io.h>\n#include <asm/fpu/internal.h>\n#include <asm/desc.h>\n#include <asm/debugreg.h>\n#include <asm/cpu_device_id.h>\n#include <asm/cpu.h>\n#include <asm/asm.h>\n#include <asm/apic.h>\n#include <linux/trace_events.h>\n#include <linux/tboot.h>\n#include <linux/slab.h>\n#include <linux/sched/smt.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/mod_devicetable.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/kvm_host.h>\n#include <linux/kernel.h>\n#include <linux/hrtimer.h>\n#include <linux/highmem.h>\n#include <linux/frame.h>\n\nstatic bool guest_state_valid(struct kvm_vcpu *vcpu);\n\nstatic u64 vmx_read_l1_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (is_guest_mode(vcpu) &&\n\t    (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING))\n\t\treturn vcpu->arch.tsc_offset - vmcs12->tsc_offset;\n\n\treturn vcpu->arch.tsc_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_ad_enabled",
          "args": [
            "spte"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "spte_ad_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "365-369",
          "snippet": "static inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_DISABLED_MASK (1ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_accessed_spte",
          "args": [
            "spte"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "is_accessed_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "814-820",
          "snippet": "static bool is_accessed_spte(u64 spte)\n{\n\tu64 accessed_mask = spte_shadow_accessed_mask(spte);\n\n\treturn accessed_mask ? spte & accessed_mask\n\t\t\t     : !is_access_track_spte(spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_accessed_spte(u64 spte)\n{\n\tu64 accessed_mask = spte_shadow_accessed_mask(spte);\n\n\treturn accessed_mask ? spte & accessed_mask\n\t\t\t     : !is_access_track_spte(spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_get_lockless",
          "args": [
            "sptep"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_get_lockless",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "959-962",
          "snippet": "static u64 mmu_spte_get_lockless(u64 *sptep)\n{\n\treturn __get_spte_lockless(sptep);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 mmu_spte_get_lockless(u64 *sptep)\n{\n\treturn __get_spte_lockless(sptep);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_spte_age(u64 *sptep)\n{\n\tu64 spte = mmu_spte_get_lockless(sptep);\n\n\tif (!is_accessed_spte(spte))\n\t\treturn false;\n\n\tif (spte_ad_enabled(spte)) {\n\t\tclear_bit((ffs(shadow_accessed_mask) - 1),\n\t\t\t  (unsigned long *)sptep);\n\t} else {\n\t\t/*\n\t\t * Capture the dirty status of the page, so that it doesn't get\n\t\t * lost when the SPTE is marked for access tracking.\n\t\t */\n\t\tif (is_writable_pte(spte))\n\t\t\tkvm_set_pfn_dirty(spte_to_pfn(spte));\n\n\t\tspte = mark_spte_for_access_track(spte);\n\t\tmmu_spte_update_no_track(sptep, spte);\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "restore_acc_track_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "993-1008",
    "snippet": "static u64 restore_acc_track_spte(u64 spte)\n{\n\tu64 new_spte = spte;\n\tu64 saved_bits = (spte >> shadow_acc_track_saved_bits_shift)\n\t\t\t & shadow_acc_track_saved_bits_mask;\n\n\tWARN_ON_ONCE(spte_ad_enabled(spte));\n\tWARN_ON_ONCE(!is_access_track_spte(spte));\n\n\tnew_spte &= ~shadow_acc_track_mask;\n\tnew_spte &= ~(shadow_acc_track_saved_bits_mask <<\n\t\t      shadow_acc_track_saved_bits_shift);\n\tnew_spte |= saved_bits;\n\n\treturn new_spte;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;",
      "static const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;",
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!is_access_track_spte(spte)"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_access_track_spte",
          "args": [
            "spte"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "is_access_track_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "394-397",
          "snippet": "static inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "spte_ad_enabled(spte)"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_ad_enabled",
          "args": [
            "spte"
          ],
          "line": 999
        },
        "resolved": true,
        "details": {
          "function_name": "spte_ad_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "365-369",
          "snippet": "static inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_DISABLED_MASK (1ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;\nstatic const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 restore_acc_track_spte(u64 spte)\n{\n\tu64 new_spte = spte;\n\tu64 saved_bits = (spte >> shadow_acc_track_saved_bits_shift)\n\t\t\t & shadow_acc_track_saved_bits_mask;\n\n\tWARN_ON_ONCE(spte_ad_enabled(spte));\n\tWARN_ON_ONCE(!is_access_track_spte(spte));\n\n\tnew_spte &= ~shadow_acc_track_mask;\n\tnew_spte &= ~(shadow_acc_track_saved_bits_mask <<\n\t\t      shadow_acc_track_saved_bits_shift);\n\tnew_spte |= saved_bits;\n\n\treturn new_spte;\n}"
  },
  {
    "function_name": "mark_spte_for_access_track",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "964-990",
    "snippet": "static u64 mark_spte_for_access_track(u64 spte)\n{\n\tif (spte_ad_enabled(spte))\n\t\treturn spte & ~shadow_accessed_mask;\n\n\tif (is_access_track_spte(spte))\n\t\treturn spte;\n\n\t/*\n\t * Making an Access Tracking PTE will result in removal of write access\n\t * from the PTE. So, verify that we will be able to restore the write\n\t * access in the fast page fault path later on.\n\t */\n\tWARN_ONCE((spte & PT_WRITABLE_MASK) &&\n\t\t  !spte_can_locklessly_be_made_writable(spte),\n\t\t  \"kvm: Writable SPTE is not locklessly dirty-trackable\\n\");\n\n\tWARN_ONCE(spte & (shadow_acc_track_saved_bits_mask <<\n\t\t\t  shadow_acc_track_saved_bits_shift),\n\t\t  \"kvm: Access Tracking saved bit locations are not zero\\n\");\n\n\tspte |= (spte & shadow_acc_track_saved_bits_mask) <<\n\t\tshadow_acc_track_saved_bits_shift;\n\tspte &= ~shadow_acc_track_mask;\n\n\treturn spte;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;",
      "static const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;",
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "spte & (shadow_acc_track_saved_bits_mask <<\n\t\t\t  shadow_acc_track_saved_bits_shift)",
            "\"kvm: Access Tracking saved bit locations are not zero\\n\""
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "(spte & PT_WRITABLE_MASK) &&\n\t\t  !spte_can_locklessly_be_made_writable(spte)",
            "\"kvm: Writable SPTE is not locklessly dirty-trackable\\n\""
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_can_locklessly_be_made_writable",
          "args": [
            "spte"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "spte_can_locklessly_be_made_writable",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "784-788",
          "snippet": "static bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
            "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_access_track_spte",
          "args": [
            "spte"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "is_access_track_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "394-397",
          "snippet": "static inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_ad_enabled",
          "args": [
            "spte"
          ],
          "line": 966
        },
        "resolved": true,
        "details": {
          "function_name": "spte_ad_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "365-369",
          "snippet": "static inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_DISABLED_MASK (1ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic const u64 shadow_acc_track_saved_bits_mask = PT64_EPT_READABLE_MASK |\n\t\t\t\t\t\t    PT64_EPT_EXECUTABLE_MASK;\nstatic const u64 shadow_acc_track_saved_bits_shift = PT64_SECOND_AVAIL_BITS_SHIFT;\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 mark_spte_for_access_track(u64 spte)\n{\n\tif (spte_ad_enabled(spte))\n\t\treturn spte & ~shadow_accessed_mask;\n\n\tif (is_access_track_spte(spte))\n\t\treturn spte;\n\n\t/*\n\t * Making an Access Tracking PTE will result in removal of write access\n\t * from the PTE. So, verify that we will be able to restore the write\n\t * access in the fast page fault path later on.\n\t */\n\tWARN_ONCE((spte & PT_WRITABLE_MASK) &&\n\t\t  !spte_can_locklessly_be_made_writable(spte),\n\t\t  \"kvm: Writable SPTE is not locklessly dirty-trackable\\n\");\n\n\tWARN_ONCE(spte & (shadow_acc_track_saved_bits_mask <<\n\t\t\t  shadow_acc_track_saved_bits_shift),\n\t\t  \"kvm: Access Tracking saved bit locations are not zero\\n\");\n\n\tspte |= (spte & shadow_acc_track_saved_bits_mask) <<\n\t\tshadow_acc_track_saved_bits_shift;\n\tspte &= ~shadow_acc_track_mask;\n\n\treturn spte;\n}"
  },
  {
    "function_name": "mmu_spte_get_lockless",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "959-962",
    "snippet": "static u64 mmu_spte_get_lockless(u64 *sptep)\n{\n\treturn __get_spte_lockless(sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_spte_lockless",
          "args": [
            "sptep"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "__get_spte_lockless",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "760-781",
          "snippet": "static u64 __get_spte_lockless(u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\tunion split_spte spte, *orig = (union split_spte *)sptep;\n\tint count;\n\nretry:\n\tcount = sp->clear_spte_count;\n\tsmp_rmb();\n\n\tspte.spte_low = orig->spte_low;\n\tsmp_rmb();\n\n\tspte.spte_high = orig->spte_high;\n\tsmp_rmb();\n\n\tif (unlikely(spte.spte_low != orig->spte_low ||\n\t      count != sp->clear_spte_count))\n\t\tgoto retry;\n\n\treturn spte.spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __get_spte_lockless(u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\tunion split_spte spte, *orig = (union split_spte *)sptep;\n\tint count;\n\nretry:\n\tcount = sp->clear_spte_count;\n\tsmp_rmb();\n\n\tspte.spte_low = orig->spte_low;\n\tsmp_rmb();\n\n\tspte.spte_high = orig->spte_high;\n\tsmp_rmb();\n\n\tif (unlikely(spte.spte_low != orig->spte_low ||\n\t      count != sp->clear_spte_count))\n\t\tgoto retry;\n\n\treturn spte.spte;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 mmu_spte_get_lockless(u64 *sptep)\n{\n\treturn __get_spte_lockless(sptep);\n}"
  },
  {
    "function_name": "mmu_spte_clear_no_track",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "954-957",
    "snippet": "static void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__update_clear_spte_fast",
          "args": [
            "sptep",
            "0ull"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "__update_clear_spte_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "707-724",
          "snippet": "static void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_clear_no_track(u64 *sptep)\n{\n\t__update_clear_spte_fast(sptep, 0ull);\n}"
  },
  {
    "function_name": "mmu_spte_clear_track_bits",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "918-947",
    "snippet": "static int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (is_accessed_spte(old_spte))\n\t\tkvm_set_pfn_accessed(pfn);\n\n\tif (is_dirty_spte(old_spte))\n\t\tkvm_set_pfn_dirty(pfn);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_pfn_dirty",
          "args": [
            "pfn"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_dirty_spte",
          "args": [
            "old_spte"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "is_dirty_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "822-827",
          "snippet": "static bool is_dirty_spte(u64 spte)\n{\n\tu64 dirty_mask = spte_shadow_dirty_mask(spte);\n\n\treturn dirty_mask ? spte & dirty_mask : spte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_dirty_spte(u64 spte)\n{\n\tu64 dirty_mask = spte_shadow_dirty_mask(spte);\n\n\treturn dirty_mask ? spte & dirty_mask : spte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_pfn_accessed",
          "args": [
            "pfn"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_accessed_spte",
          "args": [
            "old_spte"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "is_accessed_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "814-820",
          "snippet": "static bool is_accessed_spte(u64 spte)\n{\n\tu64 accessed_mask = spte_shadow_accessed_mask(spte);\n\n\treturn accessed_mask ? spte & accessed_mask\n\t\t\t     : !is_access_track_spte(spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_accessed_spte(u64 spte)\n{\n\tu64 accessed_mask = spte_shadow_accessed_mask(spte);\n\n\treturn accessed_mask ? spte & accessed_mask\n\t\t\t     : !is_access_track_spte(spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn))"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_count",
          "args": [
            "pfn_to_page(pfn)"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "pfn"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_reserved_pfn",
          "args": [
            "pfn"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_to_pfn",
          "args": [
            "old_spte"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "spte_to_pfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "635-638",
          "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "old_spte"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_clear_spte_slow",
          "args": [
            "sptep",
            "0ull"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "__update_clear_spte_slow",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "726-740",
          "snippet": "static u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_clear_spte_fast",
          "args": [
            "sptep",
            "0ull"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "__update_clear_spte_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "707-724",
          "snippet": "static void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_has_volatile_bits",
          "args": [
            "old_spte"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "spte_has_volatile_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "790-812",
          "snippet": "static bool spte_has_volatile_bits(u64 spte)\n{\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_can_locklessly_be_made_writable(spte) ||\n\t    is_access_track_spte(spte))\n\t\treturn true;\n\n\tif (spte_ad_enabled(spte)) {\n\t\tif ((spte & shadow_accessed_mask) == 0 ||\n\t    \t    (is_writable_pte(spte) && (spte & shadow_dirty_mask) == 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_has_volatile_bits(u64 spte)\n{\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_can_locklessly_be_made_writable(spte) ||\n\t    is_access_track_spte(spte))\n\t\treturn true;\n\n\tif (spte_ad_enabled(spte)) {\n\t\tif ((spte & shadow_accessed_mask) == 0 ||\n\t    \t    (is_writable_pte(spte) && (spte & shadow_dirty_mask) == 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int mmu_spte_clear_track_bits(u64 *sptep)\n{\n\tkvm_pfn_t pfn;\n\tu64 old_spte = *sptep;\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, 0ull);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, 0ull);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn 0;\n\n\tpfn = spte_to_pfn(old_spte);\n\n\t/*\n\t * KVM does not hold the refcount of the page used by\n\t * kvm mmu, before reclaiming the page, we should\n\t * unmap it from mmu first.\n\t */\n\tWARN_ON(!kvm_is_reserved_pfn(pfn) && !page_count(pfn_to_page(pfn)));\n\n\tif (is_accessed_spte(old_spte))\n\t\tkvm_set_pfn_accessed(pfn);\n\n\tif (is_dirty_spte(old_spte))\n\t\tkvm_set_pfn_dirty(pfn);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "mmu_spte_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "877-910",
    "snippet": "static bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tbool flush = false;\n\tu64 old_spte = mmu_spte_update_no_track(sptep, new_spte);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn false;\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_can_locklessly_be_made_writable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tflush = true;\n\n\t/*\n\t * Flush TLB when accessed/dirty states are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\n\tif (is_accessed_spte(old_spte) && !is_accessed_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\t}\n\n\tif (is_dirty_spte(old_spte) && !is_dirty_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t}\n\n\treturn flush;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_pfn_dirty",
          "args": [
            "spte_to_pfn(old_spte)"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_to_pfn",
          "args": [
            "old_spte"
          ],
          "line": 906
        },
        "resolved": true,
        "details": {
          "function_name": "spte_to_pfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "635-638",
          "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dirty_spte",
          "args": [
            "new_spte"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "is_dirty_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "822-827",
          "snippet": "static bool is_dirty_spte(u64 spte)\n{\n\tu64 dirty_mask = spte_shadow_dirty_mask(spte);\n\n\treturn dirty_mask ? spte & dirty_mask : spte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_dirty_spte(u64 spte)\n{\n\tu64 dirty_mask = spte_shadow_dirty_mask(spte);\n\n\treturn dirty_mask ? spte & dirty_mask : spte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_pfn_accessed",
          "args": [
            "spte_to_pfn(old_spte)"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_accessed_spte",
          "args": [
            "new_spte"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "is_accessed_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "814-820",
          "snippet": "static bool is_accessed_spte(u64 spte)\n{\n\tu64 accessed_mask = spte_shadow_accessed_mask(spte);\n\n\treturn accessed_mask ? spte & accessed_mask\n\t\t\t     : !is_access_track_spte(spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_accessed_spte(u64 spte)\n{\n\tu64 accessed_mask = spte_shadow_accessed_mask(spte);\n\n\treturn accessed_mask ? spte & accessed_mask\n\t\t\t     : !is_access_track_spte(spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "new_spte"
          ],
          "line": 891
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "151-154",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_can_locklessly_be_made_writable",
          "args": [
            "old_spte"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "spte_can_locklessly_be_made_writable",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "784-788",
          "snippet": "static bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
            "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "old_spte"
          ],
          "line": 882
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_update_no_track",
          "args": [
            "sptep",
            "new_spte"
          ],
          "line": 880
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_update_no_track",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "845-864",
          "snippet": "static u64 mmu_spte_update_no_track(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn old_spte;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\tWARN_ON(spte_to_pfn(old_spte) != spte_to_pfn(new_spte));\n\n\treturn old_spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 mmu_spte_update_no_track(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn old_spte;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\tWARN_ON(spte_to_pfn(old_spte) != spte_to_pfn(new_spte));\n\n\treturn old_spte;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool mmu_spte_update(u64 *sptep, u64 new_spte)\n{\n\tbool flush = false;\n\tu64 old_spte = mmu_spte_update_no_track(sptep, new_spte);\n\n\tif (!is_shadow_present_pte(old_spte))\n\t\treturn false;\n\n\t/*\n\t * For the spte updated out of mmu-lock is safe, since\n\t * we always atomically update it, see the comments in\n\t * spte_has_volatile_bits().\n\t */\n\tif (spte_can_locklessly_be_made_writable(old_spte) &&\n\t      !is_writable_pte(new_spte))\n\t\tflush = true;\n\n\t/*\n\t * Flush TLB when accessed/dirty states are changed in the page tables,\n\t * to guarantee consistency between TLB and page tables.\n\t */\n\n\tif (is_accessed_spte(old_spte) && !is_accessed_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_accessed(spte_to_pfn(old_spte));\n\t}\n\n\tif (is_dirty_spte(old_spte) && !is_dirty_spte(new_spte)) {\n\t\tflush = true;\n\t\tkvm_set_pfn_dirty(spte_to_pfn(old_spte));\n\t}\n\n\treturn flush;\n}"
  },
  {
    "function_name": "mmu_spte_update_no_track",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "845-864",
    "snippet": "static u64 mmu_spte_update_no_track(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn old_spte;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\tWARN_ON(spte_to_pfn(old_spte) != spte_to_pfn(new_spte));\n\n\treturn old_spte;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "spte_to_pfn(old_spte) != spte_to_pfn(new_spte)"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spte_to_pfn",
          "args": [
            "new_spte"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "spte_to_pfn",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "635-638",
          "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
            "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_clear_spte_slow",
          "args": [
            "sptep",
            "new_spte"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "__update_clear_spte_slow",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "726-740",
          "snippet": "static u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__update_clear_spte_fast",
          "args": [
            "sptep",
            "new_spte"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "__update_clear_spte_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "707-724",
          "snippet": "static void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_has_volatile_bits",
          "args": [
            "old_spte"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "spte_has_volatile_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "790-812",
          "snippet": "static bool spte_has_volatile_bits(u64 spte)\n{\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_can_locklessly_be_made_writable(spte) ||\n\t    is_access_track_spte(spte))\n\t\treturn true;\n\n\tif (spte_ad_enabled(spte)) {\n\t\tif ((spte & shadow_accessed_mask) == 0 ||\n\t    \t    (is_writable_pte(spte) && (spte & shadow_dirty_mask) == 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_has_volatile_bits(u64 spte)\n{\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_can_locklessly_be_made_writable(spte) ||\n\t    is_access_track_spte(spte))\n\t\treturn true;\n\n\tif (spte_ad_enabled(spte)) {\n\t\tif ((spte & shadow_accessed_mask) == 0 ||\n\t    \t    (is_writable_pte(spte) && (spte & shadow_dirty_mask) == 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mmu_spte_set",
          "args": [
            "sptep",
            "new_spte"
          ],
          "line": 852
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "835-839",
          "snippet": "static void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "old_spte"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!is_shadow_present_pte(new_spte)"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 mmu_spte_update_no_track(u64 *sptep, u64 new_spte)\n{\n\tu64 old_spte = *sptep;\n\n\tWARN_ON(!is_shadow_present_pte(new_spte));\n\n\tif (!is_shadow_present_pte(old_spte)) {\n\t\tmmu_spte_set(sptep, new_spte);\n\t\treturn old_spte;\n\t}\n\n\tif (!spte_has_volatile_bits(old_spte))\n\t\t__update_clear_spte_fast(sptep, new_spte);\n\telse\n\t\told_spte = __update_clear_spte_slow(sptep, new_spte);\n\n\tWARN_ON(spte_to_pfn(old_spte) != spte_to_pfn(new_spte));\n\n\treturn old_spte;\n}"
  },
  {
    "function_name": "mmu_spte_set",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "835-839",
    "snippet": "static void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_spte",
          "args": [
            "sptep",
            "new_spte"
          ],
          "line": 838
        },
        "resolved": true,
        "details": {
          "function_name": "__set_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "688-705",
          "snippet": "static void __set_spte(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_high = sspte.spte_high;\n\n\t/*\n\t * If we map the spte from nonpresent to present, We should store\n\t * the high bits firstly, then set present bit, so cpu can not\n\t * fetch this spte while we are setting the spte.\n\t */\n\tsmp_wmb();\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __set_spte(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_high = sspte.spte_high;\n\n\t/*\n\t * If we map the spte from nonpresent to present, We should store\n\t * the high bits firstly, then set present bit, so cpu can not\n\t * fetch this spte while we are setting the spte.\n\t */\n\tsmp_wmb();\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "is_shadow_present_pte(*sptep)"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "*sptep"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}"
  },
  {
    "function_name": "is_dirty_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "822-827",
    "snippet": "static bool is_dirty_spte(u64 spte)\n{\n\tu64 dirty_mask = spte_shadow_dirty_mask(spte);\n\n\treturn dirty_mask ? spte & dirty_mask : spte & PT_WRITABLE_MASK;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spte_shadow_dirty_mask",
          "args": [
            "spte"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "spte_shadow_dirty_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "388-392",
          "snippet": "static inline u64 spte_shadow_dirty_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_dirty_mask : 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline u64 spte_shadow_dirty_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_dirty_mask : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_dirty_spte(u64 spte)\n{\n\tu64 dirty_mask = spte_shadow_dirty_mask(spte);\n\n\treturn dirty_mask ? spte & dirty_mask : spte & PT_WRITABLE_MASK;\n}"
  },
  {
    "function_name": "is_accessed_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "814-820",
    "snippet": "static bool is_accessed_spte(u64 spte)\n{\n\tu64 accessed_mask = spte_shadow_accessed_mask(spte);\n\n\treturn accessed_mask ? spte & accessed_mask\n\t\t\t     : !is_access_track_spte(spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_access_track_spte",
          "args": [
            "spte"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "is_access_track_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "394-397",
          "snippet": "static inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_shadow_accessed_mask",
          "args": [
            "spte"
          ],
          "line": 816
        },
        "resolved": true,
        "details": {
          "function_name": "spte_shadow_accessed_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "382-386",
          "snippet": "static inline u64 spte_shadow_accessed_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_accessed_mask : 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline u64 spte_shadow_accessed_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_accessed_mask : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_accessed_spte(u64 spte)\n{\n\tu64 accessed_mask = spte_shadow_accessed_mask(spte);\n\n\treturn accessed_mask ? spte & accessed_mask\n\t\t\t     : !is_access_track_spte(spte);\n}"
  },
  {
    "function_name": "spte_has_volatile_bits",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "790-812",
    "snippet": "static bool spte_has_volatile_bits(u64 spte)\n{\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_can_locklessly_be_made_writable(spte) ||\n\t    is_access_track_spte(spte))\n\t\treturn true;\n\n\tif (spte_ad_enabled(spte)) {\n\t\tif ((spte & shadow_accessed_mask) == 0 ||\n\t    \t    (is_writable_pte(spte) && (spte & shadow_dirty_mask) == 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_writable_pte",
          "args": [
            "spte"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "is_writable_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "151-154",
          "snippet": "static inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\n#define PT_WRITABLE_MASK (1ULL << PT_WRITABLE_SHIFT)\n\nstatic inline int is_writable_pte(unsigned long pte)\n{\n\treturn pte & PT_WRITABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_ad_enabled",
          "args": [
            "spte"
          ],
          "line": 805
        },
        "resolved": true,
        "details": {
          "function_name": "spte_ad_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "365-369",
          "snippet": "static inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_DISABLED_MASK (1ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_access_track_spte",
          "args": [
            "spte"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "is_access_track_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "394-397",
          "snippet": "static inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spte_can_locklessly_be_made_writable",
          "args": [
            "spte"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "spte_can_locklessly_be_made_writable",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "784-788",
          "snippet": "static bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
            "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "spte"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_has_volatile_bits(u64 spte)\n{\n\tif (!is_shadow_present_pte(spte))\n\t\treturn false;\n\n\t/*\n\t * Always atomically update spte if it can be updated\n\t * out of mmu-lock, it can ensure dirty bit is not lost,\n\t * also, it can help us to get a stable is_writable_pte()\n\t * to ensure tlb flush is not missed.\n\t */\n\tif (spte_can_locklessly_be_made_writable(spte) ||\n\t    is_access_track_spte(spte))\n\t\treturn true;\n\n\tif (spte_ad_enabled(spte)) {\n\t\tif ((spte & shadow_accessed_mask) == 0 ||\n\t    \t    (is_writable_pte(spte) && (spte & shadow_dirty_mask) == 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "spte_can_locklessly_be_made_writable",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "784-788",
    "snippet": "static bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))",
      "#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMU_WRITEABLE\t(1ULL << (PT_FIRST_AVAIL_BITS_SHIFT + 1))\n#define SPTE_HOST_WRITEABLE\t(1ULL << PT_FIRST_AVAIL_BITS_SHIFT)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool spte_can_locklessly_be_made_writable(u64 spte)\n{\n\treturn (spte & (SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE)) ==\n\t\t(SPTE_HOST_WRITEABLE | SPTE_MMU_WRITEABLE);\n}"
  },
  {
    "function_name": "__get_spte_lockless",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "760-781",
    "snippet": "static u64 __get_spte_lockless(u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\tunion split_spte spte, *orig = (union split_spte *)sptep;\n\tint count;\n\nretry:\n\tcount = sp->clear_spte_count;\n\tsmp_rmb();\n\n\tspte.spte_low = orig->spte_low;\n\tsmp_rmb();\n\n\tspte.spte_high = orig->spte_high;\n\tsmp_rmb();\n\n\tif (unlikely(spte.spte_low != orig->spte_low ||\n\t      count != sp->clear_spte_count))\n\t\tgoto retry;\n\n\treturn spte.spte;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "spte.spte_low != orig->spte_low ||\n\t      count != sp->clear_spte_count"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __get_spte_lockless(u64 *sptep)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\tunion split_spte spte, *orig = (union split_spte *)sptep;\n\tint count;\n\nretry:\n\tcount = sp->clear_spte_count;\n\tsmp_rmb();\n\n\tspte.spte_low = orig->spte_low;\n\tsmp_rmb();\n\n\tspte.spte_high = orig->spte_high;\n\tsmp_rmb();\n\n\tif (unlikely(spte.spte_low != orig->spte_low ||\n\t      count != sp->clear_spte_count))\n\t\tgoto retry;\n\n\treturn spte.spte;\n}"
  },
  {
    "function_name": "__update_clear_spte_slow",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "726-740",
    "snippet": "static u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_spte_clear",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "count_spte_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "676-686",
          "snippet": "static void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "&ssptep->spte_low",
            "sspte.spte_low"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte, orig;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\t/* xchg acts as a barrier before the setting of the high bits */\n\torig.spte_low = xchg(&ssptep->spte_low, sspte.spte_low);\n\torig.spte_high = ssptep->spte_high;\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n\n\treturn orig.spte;\n}"
  },
  {
    "function_name": "__update_clear_spte_fast",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "707-724",
    "snippet": "static void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "count_spte_clear",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "count_spte_clear",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "676-686",
          "snippet": "static void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ssptep->spte_low",
            "sspte.spte_low"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n\n\t/*\n\t * If we map the spte from present to nonpresent, we should clear\n\t * present bit firstly to avoid vcpu fetch the old high bits.\n\t */\n\tsmp_wmb();\n\n\tssptep->spte_high = sspte.spte_high;\n\tcount_spte_clear(sptep, spte);\n}"
  },
  {
    "function_name": "__set_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "688-705",
    "snippet": "static void __set_spte(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_high = sspte.spte_high;\n\n\t/*\n\t * If we map the spte from nonpresent to present, We should store\n\t * the high bits firstly, then set present bit, so cpu can not\n\t * fetch this spte while we are setting the spte.\n\t */\n\tsmp_wmb();\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "ssptep->spte_low",
            "sspte.spte_low"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __set_spte(u64 *sptep, u64 spte)\n{\n\tunion split_spte *ssptep, sspte;\n\n\tssptep = (union split_spte *)sptep;\n\tsspte = (union split_spte)spte;\n\n\tssptep->spte_high = sspte.spte_high;\n\n\t/*\n\t * If we map the spte from nonpresent to present, We should store\n\t * the high bits firstly, then set present bit, so cpu can not\n\t * fetch this spte while we are setting the spte.\n\t */\n\tsmp_wmb();\n\n\tWRITE_ONCE(ssptep->spte_low, sspte.spte_low);\n}"
  },
  {
    "function_name": "count_spte_clear",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "676-686",
    "snippet": "static void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_shadow_present_pte",
          "args": [
            "spte"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "is_shadow_present_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "611-614",
          "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_header",
          "args": [
            "__pa(sptep)"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "sptep"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void count_spte_clear(u64 *sptep, u64 spte)\n{\n\tstruct kvm_mmu_page *sp =  page_header(__pa(sptep));\n\n\tif (is_shadow_present_pte(spte))\n\t\treturn;\n\n\t/* Ensure the spte is completely set before we increase the count */\n\tsmp_wmb();\n\tsp->clear_spte_count++;\n}"
  },
  {
    "function_name": "__get_spte_lockless",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "663-666",
    "snippet": "static u64 __get_spte_lockless(u64 *sptep)\n{\n\treturn READ_ONCE(*sptep);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*sptep"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u64 __get_spte_lockless(u64 *sptep)\n{\n\treturn READ_ONCE(*sptep);\n}"
  },
  {
    "function_name": "__update_clear_spte_slow",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "658-661",
    "snippet": "static u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\treturn xchg(sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xchg",
          "args": [
            "sptep",
            "spte"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 __update_clear_spte_slow(u64 *sptep, u64 spte)\n{\n\treturn xchg(sptep, spte);\n}"
  },
  {
    "function_name": "__update_clear_spte_fast",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "653-656",
    "snippet": "static void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tWRITE_ONCE(*sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*sptep",
            "spte"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __update_clear_spte_fast(u64 *sptep, u64 spte)\n{\n\tWRITE_ONCE(*sptep, spte);\n}"
  },
  {
    "function_name": "__set_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "648-651",
    "snippet": "static void __set_spte(u64 *sptep, u64 spte)\n{\n\tWRITE_ONCE(*sptep, spte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*sptep",
            "spte"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic void __set_spte(u64 *sptep, u64 spte)\n{\n\tWRITE_ONCE(*sptep, spte);\n}"
  },
  {
    "function_name": "pse36_gfn_delta",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "640-645",
    "snippet": "static gfn_t pse36_gfn_delta(u32 gpte)\n{\n\tint shift = 32 - PT32_DIR_PSE36_SHIFT - PAGE_SHIFT;\n\n\treturn (gpte & PT32_DIR_PSE36_MASK) << shift;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic gfn_t pse36_gfn_delta(u32 gpte)\n{\n\tint shift = 32 - PT32_DIR_PSE36_SHIFT - PAGE_SHIFT;\n\n\treturn (gpte & PT32_DIR_PSE36_MASK) << shift;\n}"
  },
  {
    "function_name": "spte_to_pfn",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "635-638",
    "snippet": "static kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))",
      "#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))\n#define PT64_BASE_ADDR_MASK (physical_mask & ~(u64)(PAGE_SIZE-1))\n\nstatic kvm_pfn_t spte_to_pfn(u64 pte)\n{\n\treturn (pte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT;\n}"
  },
  {
    "function_name": "is_executable_pte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "630-633",
    "snippet": "static bool is_executable_pte(u64 spte)\n{\n\treturn (spte & (shadow_x_mask | shadow_nx_mask)) == shadow_x_mask;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_executable_pte(u64 spte)\n{\n\treturn (spte & (shadow_x_mask | shadow_nx_mask)) == shadow_x_mask;\n}"
  },
  {
    "function_name": "is_last_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "621-628",
    "snippet": "static int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_large_pte",
          "args": [
            "pte"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "is_large_pte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "616-619",
          "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_last_spte(u64 pte, int level)\n{\n\tif (level == PT_PAGE_TABLE_LEVEL)\n\t\treturn 1;\n\tif (is_large_pte(pte))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "is_large_pte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "616-619",
    "snippet": "static int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_large_pte(u64 pte)\n{\n\treturn pte & PT_PAGE_SIZE_MASK;\n}"
  },
  {
    "function_name": "is_shadow_present_pte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "611-614",
    "snippet": "static int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "pte"
          ],
          "line": 613
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "344-347",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_shadow_present_pte(u64 pte)\n{\n\treturn (pte != 0) && !is_mmio_spte(pte);\n}"
  },
  {
    "function_name": "is_nx",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "606-609",
    "snippet": "static int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic int is_nx(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.efer & EFER_NX;\n}"
  },
  {
    "function_name": "is_cpuid_PSE36",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "601-604",
    "snippet": "static int is_cpuid_PSE36(void)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic int is_cpuid_PSE36(void)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "kvm_mmu_reset_all_pte_masks",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "560-599",
    "snippet": "static void kvm_mmu_reset_all_pte_masks(void)\n{\n\tu8 low_phys_bits;\n\n\tshadow_user_mask = 0;\n\tshadow_accessed_mask = 0;\n\tshadow_dirty_mask = 0;\n\tshadow_nx_mask = 0;\n\tshadow_x_mask = 0;\n\tshadow_mmio_mask = 0;\n\tshadow_present_mask = 0;\n\tshadow_acc_track_mask = 0;\n\n\tshadow_phys_bits = kvm_get_shadow_phys_bits();\n\n\t/*\n\t * If the CPU has 46 or less physical address bits, then set an\n\t * appropriate mask to guard against L1TF attacks. Otherwise, it is\n\t * assumed that the CPU is not vulnerable to L1TF.\n\t *\n\t * Some Intel CPUs address the L1 cache using more PA bits than are\n\t * reported by CPUID. Use the PA width of the L1 cache when possible\n\t * to achieve more effective mitigation, e.g. if system RAM overlaps\n\t * the most significant bits of legal physical address space.\n\t */\n\tshadow_nonpresent_or_rsvd_mask = 0;\n\tlow_phys_bits = boot_cpu_data.x86_cache_bits;\n\tif (boot_cpu_data.x86_cache_bits <\n\t    52 - shadow_nonpresent_or_rsvd_mask_len) {\n\t\tshadow_nonpresent_or_rsvd_mask =\n\t\t\trsvd_bits(boot_cpu_data.x86_cache_bits -\n\t\t\t\t  shadow_nonpresent_or_rsvd_mask_len,\n\t\t\t\t  boot_cpu_data.x86_cache_bits - 1);\n\t\tlow_phys_bits -= shadow_nonpresent_or_rsvd_mask_len;\n\t} else\n\t\tWARN_ON_ONCE(boot_cpu_has_bug(X86_BUG_L1TF));\n\n\tshadow_nonpresent_or_rsvd_lower_gfn_mask =\n\t\tGENMASK_ULL(low_phys_bits - 1, PAGE_SHIFT);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const u64 shadow_nonpresent_or_rsvd_mask_len = 5;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "GENMASK_ULL",
          "args": [
            "low_phys_bits - 1",
            "PAGE_SHIFT"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "boot_cpu_has_bug(X86_BUG_L1TF)"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has_bug",
          "args": [
            "X86_BUG_L1TF"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rsvd_bits",
          "args": [
            "boot_cpu_data.x86_cache_bits -\n\t\t\t\t  shadow_nonpresent_or_rsvd_mask_len",
            "boot_cpu_data.x86_cache_bits - 1"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "rsvd_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "46-52",
          "snippet": "static inline u64 rsvd_bits(int s, int e)\n{\n\tif (e < s)\n\t\treturn 0;\n\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 rsvd_bits(int s, int e)\n{\n\tif (e < s)\n\t\treturn 0;\n\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_shadow_phys_bits",
          "args": [],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_shadow_phys_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "541-558",
          "snippet": "static u8 kvm_get_shadow_phys_bits(void)\n{\n\t/*\n\t * boot_cpu_data.x86_phys_bits is reduced when MKTME or SME are detected\n\t * in CPU detection code, but the processor treats those reduced bits as\n\t * 'keyID' thus they are not reserved bits. Therefore KVM needs to look at\n\t * the physical address bits reported by CPUID.\n\t */\n\tif (likely(boot_cpu_data.extended_cpuid_level >= 0x80000008))\n\t\treturn cpuid_eax(0x80000008) & 0xff;\n\n\t/*\n\t * Quite weird to have VMX or SVM but not MAXPHYADDR; probably a VM with\n\t * custom CPUID.  Proceed with whatever the kernel found since these features\n\t * aren't virtualizable (SME/SEV also require CPUIDs higher than 0x80000008).\n\t */\n\treturn boot_cpu_data.x86_phys_bits;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u8 kvm_get_shadow_phys_bits(void)\n{\n\t/*\n\t * boot_cpu_data.x86_phys_bits is reduced when MKTME or SME are detected\n\t * in CPU detection code, but the processor treats those reduced bits as\n\t * 'keyID' thus they are not reserved bits. Therefore KVM needs to look at\n\t * the physical address bits reported by CPUID.\n\t */\n\tif (likely(boot_cpu_data.extended_cpuid_level >= 0x80000008))\n\t\treturn cpuid_eax(0x80000008) & 0xff;\n\n\t/*\n\t * Quite weird to have VMX or SVM but not MAXPHYADDR; probably a VM with\n\t * custom CPUID.  Proceed with whatever the kernel found since these features\n\t * aren't virtualizable (SME/SEV also require CPUIDs higher than 0x80000008).\n\t */\n\treturn boot_cpu_data.x86_phys_bits;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic const u64 shadow_nonpresent_or_rsvd_mask_len = 5;\n\nstatic void kvm_mmu_reset_all_pte_masks(void)\n{\n\tu8 low_phys_bits;\n\n\tshadow_user_mask = 0;\n\tshadow_accessed_mask = 0;\n\tshadow_dirty_mask = 0;\n\tshadow_nx_mask = 0;\n\tshadow_x_mask = 0;\n\tshadow_mmio_mask = 0;\n\tshadow_present_mask = 0;\n\tshadow_acc_track_mask = 0;\n\n\tshadow_phys_bits = kvm_get_shadow_phys_bits();\n\n\t/*\n\t * If the CPU has 46 or less physical address bits, then set an\n\t * appropriate mask to guard against L1TF attacks. Otherwise, it is\n\t * assumed that the CPU is not vulnerable to L1TF.\n\t *\n\t * Some Intel CPUs address the L1 cache using more PA bits than are\n\t * reported by CPUID. Use the PA width of the L1 cache when possible\n\t * to achieve more effective mitigation, e.g. if system RAM overlaps\n\t * the most significant bits of legal physical address space.\n\t */\n\tshadow_nonpresent_or_rsvd_mask = 0;\n\tlow_phys_bits = boot_cpu_data.x86_cache_bits;\n\tif (boot_cpu_data.x86_cache_bits <\n\t    52 - shadow_nonpresent_or_rsvd_mask_len) {\n\t\tshadow_nonpresent_or_rsvd_mask =\n\t\t\trsvd_bits(boot_cpu_data.x86_cache_bits -\n\t\t\t\t  shadow_nonpresent_or_rsvd_mask_len,\n\t\t\t\t  boot_cpu_data.x86_cache_bits - 1);\n\t\tlow_phys_bits -= shadow_nonpresent_or_rsvd_mask_len;\n\t} else\n\t\tWARN_ON_ONCE(boot_cpu_has_bug(X86_BUG_L1TF));\n\n\tshadow_nonpresent_or_rsvd_lower_gfn_mask =\n\t\tGENMASK_ULL(low_phys_bits - 1, PAGE_SHIFT);\n}"
  },
  {
    "function_name": "kvm_get_shadow_phys_bits",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "541-558",
    "snippet": "static u8 kvm_get_shadow_phys_bits(void)\n{\n\t/*\n\t * boot_cpu_data.x86_phys_bits is reduced when MKTME or SME are detected\n\t * in CPU detection code, but the processor treats those reduced bits as\n\t * 'keyID' thus they are not reserved bits. Therefore KVM needs to look at\n\t * the physical address bits reported by CPUID.\n\t */\n\tif (likely(boot_cpu_data.extended_cpuid_level >= 0x80000008))\n\t\treturn cpuid_eax(0x80000008) & 0xff;\n\n\t/*\n\t * Quite weird to have VMX or SVM but not MAXPHYADDR; probably a VM with\n\t * custom CPUID.  Proceed with whatever the kernel found since these features\n\t * aren't virtualizable (SME/SEV also require CPUIDs higher than 0x80000008).\n\t */\n\treturn boot_cpu_data.x86_phys_bits;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpuid_eax",
          "args": [
            "0x80000008"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "boot_cpu_data.extended_cpuid_level >= 0x80000008"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic u8 kvm_get_shadow_phys_bits(void)\n{\n\t/*\n\t * boot_cpu_data.x86_phys_bits is reduced when MKTME or SME are detected\n\t * in CPU detection code, but the processor treats those reduced bits as\n\t * 'keyID' thus they are not reserved bits. Therefore KVM needs to look at\n\t * the physical address bits reported by CPUID.\n\t */\n\tif (likely(boot_cpu_data.extended_cpuid_level >= 0x80000008))\n\t\treturn cpuid_eax(0x80000008) & 0xff;\n\n\t/*\n\t * Quite weird to have VMX or SVM but not MAXPHYADDR; probably a VM with\n\t * custom CPUID.  Proceed with whatever the kernel found since these features\n\t * aren't virtualizable (SME/SEV also require CPUIDs higher than 0x80000008).\n\t */\n\treturn boot_cpu_data.x86_phys_bits;\n}"
  },
  {
    "function_name": "kvm_mmu_set_mask_ptes",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "522-538",
    "snippet": "void kvm_mmu_set_mask_ptes(u64 user_mask, u64 accessed_mask,\n\t\tu64 dirty_mask, u64 nx_mask, u64 x_mask, u64 p_mask,\n\t\tu64 acc_track_mask, u64 me_mask)\n{\n\tBUG_ON(!dirty_mask != !accessed_mask);\n\tBUG_ON(!accessed_mask && !acc_track_mask);\n\tBUG_ON(acc_track_mask & SPTE_SPECIAL_MASK);\n\n\tshadow_user_mask = user_mask;\n\tshadow_accessed_mask = accessed_mask;\n\tshadow_dirty_mask = dirty_mask;\n\tshadow_nx_mask = nx_mask;\n\tshadow_x_mask = x_mask;\n\tshadow_present_mask = p_mask;\n\tshadow_acc_track_mask = acc_track_mask;\n\tshadow_me_mask = me_mask;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_SPECIAL_MASK (3ULL << 52)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "acc_track_mask & SPTE_SPECIAL_MASK"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!accessed_mask && !acc_track_mask"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dirty_mask != !accessed_mask"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nvoid kvm_mmu_set_mask_ptes(u64 user_mask, u64 accessed_mask,\n\t\tu64 dirty_mask, u64 nx_mask, u64 x_mask, u64 p_mask,\n\t\tu64 acc_track_mask, u64 me_mask)\n{\n\tBUG_ON(!dirty_mask != !accessed_mask);\n\tBUG_ON(!accessed_mask && !acc_track_mask);\n\tBUG_ON(acc_track_mask & SPTE_SPECIAL_MASK);\n\n\tshadow_user_mask = user_mask;\n\tshadow_accessed_mask = accessed_mask;\n\tshadow_dirty_mask = dirty_mask;\n\tshadow_nx_mask = nx_mask;\n\tshadow_x_mask = x_mask;\n\tshadow_present_mask = p_mask;\n\tshadow_acc_track_mask = acc_track_mask;\n\tshadow_me_mask = me_mask;\n}"
  },
  {
    "function_name": "check_mmio_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "500-513",
    "snippet": "static bool check_mmio_spte(struct kvm_vcpu *vcpu, u64 spte)\n{\n\tu64 kvm_gen, spte_gen, gen;\n\n\tgen = kvm_vcpu_memslots(vcpu)->generation;\n\tif (unlikely(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS))\n\t\treturn false;\n\n\tkvm_gen = gen & MMIO_SPTE_GEN_MASK;\n\tspte_gen = get_mmio_spte_generation(spte);\n\n\ttrace_check_mmio_spte(spte, kvm_gen, spte_gen);\n\treturn likely(kvm_gen == spte_gen);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "kvm_gen == spte_gen"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_check_mmio_spte",
          "args": [
            "spte",
            "kvm_gen",
            "spte_gen"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mmio_spte_generation",
          "args": [
            "spte"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "get_mmio_spte_generation",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "437-444",
          "snippet": "static u64 get_mmio_spte_generation(u64 spte)\n{\n\tu64 gen;\n\n\tgen = (spte & MMIO_SPTE_GEN_LOW_MASK) >> MMIO_SPTE_GEN_LOW_START;\n\tgen |= (spte & MMIO_SPTE_GEN_HIGH_MASK) >> MMIO_SPTE_GEN_HIGH_START;\n\treturn gen;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_SPTE_GEN_HIGH_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_HIGH_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_HIGH_START)",
            "#define MMIO_SPTE_GEN_HIGH_START\tPT64_SECOND_AVAIL_BITS_SHIFT",
            "#define MMIO_SPTE_GEN_LOW_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_LOW_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_LOW_START)",
            "#define MMIO_SPTE_GEN_LOW_START\t\t3"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_SPTE_GEN_HIGH_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_HIGH_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_HIGH_START)\n#define MMIO_SPTE_GEN_HIGH_START\tPT64_SECOND_AVAIL_BITS_SHIFT\n#define MMIO_SPTE_GEN_LOW_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_LOW_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_LOW_START)\n#define MMIO_SPTE_GEN_LOW_START\t\t3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 get_mmio_spte_generation(u64 spte)\n{\n\tu64 gen;\n\n\tgen = (spte & MMIO_SPTE_GEN_LOW_MASK) >> MMIO_SPTE_GEN_LOW_START;\n\tgen |= (spte & MMIO_SPTE_GEN_HIGH_MASK) >> MMIO_SPTE_GEN_HIGH_START;\n\treturn gen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_memslots",
          "args": [
            "vcpu"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool check_mmio_spte(struct kvm_vcpu *vcpu, u64 spte)\n{\n\tu64 kvm_gen, spte_gen, gen;\n\n\tgen = kvm_vcpu_memslots(vcpu)->generation;\n\tif (unlikely(gen & KVM_MEMSLOT_GEN_UPDATE_IN_PROGRESS))\n\t\treturn false;\n\n\tkvm_gen = gen & MMIO_SPTE_GEN_MASK;\n\tspte_gen = get_mmio_spte_generation(spte);\n\n\ttrace_check_mmio_spte(spte, kvm_gen, spte_gen);\n\treturn likely(kvm_gen == spte_gen);\n}"
  },
  {
    "function_name": "set_mmio_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "489-498",
    "snippet": "static bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t  kvm_pfn_t pfn, unsigned int access)\n{\n\tif (unlikely(is_noslot_pfn(pfn))) {\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_mmio_spte",
          "args": [
            "vcpu",
            "sptep",
            "gfn",
            "access"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "mark_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "462-472",
          "snippet": "static void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned int access)\n{\n\tu64 mask = make_mmio_spte(vcpu, gfn, access);\n\tunsigned int gen = get_mmio_spte_generation(mask);\n\n\taccess = mask & ACC_ALL;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
          ],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned int access)\n{\n\tu64 mask = make_mmio_spte(vcpu, gfn, access);\n\tunsigned int gen = get_mmio_spte_generation(mask);\n\n\taccess = mask & ACC_ALL;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_noslot_pfn(pfn)"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_noslot_pfn",
          "args": [
            "pfn"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic bool set_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,\n\t\t\t  kvm_pfn_t pfn, unsigned int access)\n{\n\tif (unlikely(is_noslot_pfn(pfn))) {\n\t\tmark_mmio_spte(vcpu, sptep, gfn, access);\n\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "get_mmio_spte_access",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "484-487",
    "snippet": "static unsigned get_mmio_spte_access(u64 spte)\n{\n\treturn spte & shadow_mmio_access_mask;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic unsigned get_mmio_spte_access(u64 spte)\n{\n\treturn spte & shadow_mmio_access_mask;\n}"
  },
  {
    "function_name": "get_mmio_spte_gfn",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "474-482",
    "snippet": "static gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 gpa = spte & shadow_nonpresent_or_rsvd_lower_gfn_mask;\n\n\tgpa |= (spte >> shadow_nonpresent_or_rsvd_mask_len)\n\t       & shadow_nonpresent_or_rsvd_mask;\n\n\treturn gpa >> PAGE_SHIFT;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const u64 shadow_nonpresent_or_rsvd_mask_len = 5;",
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic const u64 shadow_nonpresent_or_rsvd_mask_len = 5;\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic gfn_t get_mmio_spte_gfn(u64 spte)\n{\n\tu64 gpa = spte & shadow_nonpresent_or_rsvd_lower_gfn_mask;\n\n\tgpa |= (spte >> shadow_nonpresent_or_rsvd_mask_len)\n\t       & shadow_nonpresent_or_rsvd_mask;\n\n\treturn gpa >> PAGE_SHIFT;\n}"
  },
  {
    "function_name": "mark_mmio_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "462-472",
    "snippet": "static void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned int access)\n{\n\tu64 mask = make_mmio_spte(vcpu, gfn, access);\n\tunsigned int gen = get_mmio_spte_generation(mask);\n\n\taccess = mask & ACC_ALL;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)"
    ],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mmu_spte_set",
          "args": [
            "sptep",
            "mask"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "mmu_spte_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "835-839",
          "snippet": "static void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 new_spte)\n{\n\tWARN_ON(is_shadow_present_pte(*sptep));\n\t__set_spte(sptep, new_spte);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_mark_mmio_spte",
          "args": [
            "sptep",
            "gfn",
            "access",
            "gen"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_mmio_spte_generation",
          "args": [
            "mask"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "get_mmio_spte_generation",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "437-444",
          "snippet": "static u64 get_mmio_spte_generation(u64 spte)\n{\n\tu64 gen;\n\n\tgen = (spte & MMIO_SPTE_GEN_LOW_MASK) >> MMIO_SPTE_GEN_LOW_START;\n\tgen |= (spte & MMIO_SPTE_GEN_HIGH_MASK) >> MMIO_SPTE_GEN_HIGH_START;\n\treturn gen;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_SPTE_GEN_HIGH_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_HIGH_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_HIGH_START)",
            "#define MMIO_SPTE_GEN_HIGH_START\tPT64_SECOND_AVAIL_BITS_SHIFT",
            "#define MMIO_SPTE_GEN_LOW_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_LOW_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_LOW_START)",
            "#define MMIO_SPTE_GEN_LOW_START\t\t3"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_SPTE_GEN_HIGH_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_HIGH_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_HIGH_START)\n#define MMIO_SPTE_GEN_HIGH_START\tPT64_SECOND_AVAIL_BITS_SHIFT\n#define MMIO_SPTE_GEN_LOW_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_LOW_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_LOW_START)\n#define MMIO_SPTE_GEN_LOW_START\t\t3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 get_mmio_spte_generation(u64 spte)\n{\n\tu64 gen;\n\n\tgen = (spte & MMIO_SPTE_GEN_LOW_MASK) >> MMIO_SPTE_GEN_LOW_START;\n\tgen |= (spte & MMIO_SPTE_GEN_HIGH_MASK) >> MMIO_SPTE_GEN_HIGH_START;\n\treturn gen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_mmio_spte",
          "args": [
            "vcpu",
            "gfn",
            "access"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "make_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "446-460",
          "snippet": "static u64 make_mmio_spte(struct kvm_vcpu *vcpu, u64 gfn, unsigned int access)\n{\n\n\tu64 gen = kvm_vcpu_memslots(vcpu)->generation & MMIO_SPTE_GEN_MASK;\n\tu64 mask = generation_mmio_spte_mask(gen);\n\tu64 gpa = gfn << PAGE_SHIFT;\n\n\taccess &= shadow_mmio_access_mask;\n\tmask |= shadow_mmio_value | access;\n\tmask |= gpa | shadow_nonpresent_or_rsvd_mask;\n\tmask |= (gpa & shadow_nonpresent_or_rsvd_mask)\n\t\t<< shadow_nonpresent_or_rsvd_mask_len;\n\n\treturn mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)"
          ],
          "globals_used": [
            "static const u64 shadow_nonpresent_or_rsvd_mask_len = 5;",
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)\n\nstatic const u64 shadow_nonpresent_or_rsvd_mask_len = 5;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic u64 make_mmio_spte(struct kvm_vcpu *vcpu, u64 gfn, unsigned int access)\n{\n\n\tu64 gen = kvm_vcpu_memslots(vcpu)->generation & MMIO_SPTE_GEN_MASK;\n\tu64 mask = generation_mmio_spte_mask(gen);\n\tu64 gpa = gfn << PAGE_SHIFT;\n\n\taccess &= shadow_mmio_access_mask;\n\tmask |= shadow_mmio_value | access;\n\tmask |= gpa | shadow_nonpresent_or_rsvd_mask;\n\tmask |= (gpa & shadow_nonpresent_or_rsvd_mask)\n\t\t<< shadow_nonpresent_or_rsvd_mask_len;\n\n\treturn mask;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define ACC_ALL          (ACC_EXEC_MASK | ACC_WRITE_MASK | ACC_USER_MASK)\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic void mark_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, u64 gfn,\n\t\t\t   unsigned int access)\n{\n\tu64 mask = make_mmio_spte(vcpu, gfn, access);\n\tunsigned int gen = get_mmio_spte_generation(mask);\n\n\taccess = mask & ACC_ALL;\n\n\ttrace_mark_mmio_spte(sptep, gfn, access, gen);\n\tmmu_spte_set(sptep, mask);\n}"
  },
  {
    "function_name": "make_mmio_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "446-460",
    "snippet": "static u64 make_mmio_spte(struct kvm_vcpu *vcpu, u64 gfn, unsigned int access)\n{\n\n\tu64 gen = kvm_vcpu_memslots(vcpu)->generation & MMIO_SPTE_GEN_MASK;\n\tu64 mask = generation_mmio_spte_mask(gen);\n\tu64 gpa = gfn << PAGE_SHIFT;\n\n\taccess &= shadow_mmio_access_mask;\n\tmask |= shadow_mmio_value | access;\n\tmask |= gpa | shadow_nonpresent_or_rsvd_mask;\n\tmask |= (gpa & shadow_nonpresent_or_rsvd_mask)\n\t\t<< shadow_nonpresent_or_rsvd_mask_len;\n\n\treturn mask;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)"
    ],
    "globals_used": [
      "static const u64 shadow_nonpresent_or_rsvd_mask_len = 5;",
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "generation_mmio_spte_mask",
          "args": [
            "gen"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "generation_mmio_spte_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "425-435",
          "snippet": "static u64 generation_mmio_spte_mask(u64 gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_SPTE_GEN_MASK);\n\tBUILD_BUG_ON((MMIO_SPTE_GEN_HIGH_MASK | MMIO_SPTE_GEN_LOW_MASK) & SPTE_SPECIAL_MASK);\n\n\tmask = (gen << MMIO_SPTE_GEN_LOW_START) & MMIO_SPTE_GEN_LOW_MASK;\n\tmask |= (gen << MMIO_SPTE_GEN_HIGH_START) & MMIO_SPTE_GEN_HIGH_MASK;\n\treturn mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define MMIO_SPTE_GEN_HIGH_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_HIGH_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_HIGH_START)",
            "#define MMIO_SPTE_GEN_HIGH_START\tPT64_SECOND_AVAIL_BITS_SHIFT",
            "#define MMIO_SPTE_GEN_LOW_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_LOW_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_LOW_START)",
            "#define MMIO_SPTE_GEN_LOW_START\t\t3",
            "#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_SPTE_GEN_HIGH_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_HIGH_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_HIGH_START)\n#define MMIO_SPTE_GEN_HIGH_START\tPT64_SECOND_AVAIL_BITS_SHIFT\n#define MMIO_SPTE_GEN_LOW_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_LOW_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_LOW_START)\n#define MMIO_SPTE_GEN_LOW_START\t\t3\n#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic u64 generation_mmio_spte_mask(u64 gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_SPTE_GEN_MASK);\n\tBUILD_BUG_ON((MMIO_SPTE_GEN_HIGH_MASK | MMIO_SPTE_GEN_LOW_MASK) & SPTE_SPECIAL_MASK);\n\n\tmask = (gen << MMIO_SPTE_GEN_LOW_START) & MMIO_SPTE_GEN_LOW_MASK;\n\tmask |= (gen << MMIO_SPTE_GEN_HIGH_START) & MMIO_SPTE_GEN_HIGH_MASK;\n\treturn mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_memslots",
          "args": [
            "vcpu"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)\n\nstatic const u64 shadow_nonpresent_or_rsvd_mask_len = 5;\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic u64 make_mmio_spte(struct kvm_vcpu *vcpu, u64 gfn, unsigned int access)\n{\n\n\tu64 gen = kvm_vcpu_memslots(vcpu)->generation & MMIO_SPTE_GEN_MASK;\n\tu64 mask = generation_mmio_spte_mask(gen);\n\tu64 gpa = gfn << PAGE_SHIFT;\n\n\taccess &= shadow_mmio_access_mask;\n\tmask |= shadow_mmio_value | access;\n\tmask |= gpa | shadow_nonpresent_or_rsvd_mask;\n\tmask |= (gpa & shadow_nonpresent_or_rsvd_mask)\n\t\t<< shadow_nonpresent_or_rsvd_mask_len;\n\n\treturn mask;\n}"
  },
  {
    "function_name": "get_mmio_spte_generation",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "437-444",
    "snippet": "static u64 get_mmio_spte_generation(u64 spte)\n{\n\tu64 gen;\n\n\tgen = (spte & MMIO_SPTE_GEN_LOW_MASK) >> MMIO_SPTE_GEN_LOW_START;\n\tgen |= (spte & MMIO_SPTE_GEN_HIGH_MASK) >> MMIO_SPTE_GEN_HIGH_START;\n\treturn gen;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define MMIO_SPTE_GEN_HIGH_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_HIGH_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_HIGH_START)",
      "#define MMIO_SPTE_GEN_HIGH_START\tPT64_SECOND_AVAIL_BITS_SHIFT",
      "#define MMIO_SPTE_GEN_LOW_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_LOW_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_LOW_START)",
      "#define MMIO_SPTE_GEN_LOW_START\t\t3"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_SPTE_GEN_HIGH_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_HIGH_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_HIGH_START)\n#define MMIO_SPTE_GEN_HIGH_START\tPT64_SECOND_AVAIL_BITS_SHIFT\n#define MMIO_SPTE_GEN_LOW_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_LOW_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_LOW_START)\n#define MMIO_SPTE_GEN_LOW_START\t\t3\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic u64 get_mmio_spte_generation(u64 spte)\n{\n\tu64 gen;\n\n\tgen = (spte & MMIO_SPTE_GEN_LOW_MASK) >> MMIO_SPTE_GEN_LOW_START;\n\tgen |= (spte & MMIO_SPTE_GEN_HIGH_MASK) >> MMIO_SPTE_GEN_HIGH_START;\n\treturn gen;\n}"
  },
  {
    "function_name": "generation_mmio_spte_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "425-435",
    "snippet": "static u64 generation_mmio_spte_mask(u64 gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_SPTE_GEN_MASK);\n\tBUILD_BUG_ON((MMIO_SPTE_GEN_HIGH_MASK | MMIO_SPTE_GEN_LOW_MASK) & SPTE_SPECIAL_MASK);\n\n\tmask = (gen << MMIO_SPTE_GEN_LOW_START) & MMIO_SPTE_GEN_LOW_MASK;\n\tmask |= (gen << MMIO_SPTE_GEN_HIGH_START) & MMIO_SPTE_GEN_HIGH_MASK;\n\treturn mask;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define MMIO_SPTE_GEN_HIGH_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_HIGH_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_HIGH_START)",
      "#define MMIO_SPTE_GEN_HIGH_START\tPT64_SECOND_AVAIL_BITS_SHIFT",
      "#define MMIO_SPTE_GEN_LOW_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_LOW_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_LOW_START)",
      "#define MMIO_SPTE_GEN_LOW_START\t\t3",
      "#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)",
      "#define SPTE_SPECIAL_MASK (3ULL << 52)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "(MMIO_SPTE_GEN_HIGH_MASK | MMIO_SPTE_GEN_LOW_MASK) & SPTE_SPECIAL_MASK"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "gen & ~MMIO_SPTE_GEN_MASK"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define MMIO_SPTE_GEN_HIGH_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_HIGH_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_HIGH_START)\n#define MMIO_SPTE_GEN_HIGH_START\tPT64_SECOND_AVAIL_BITS_SHIFT\n#define MMIO_SPTE_GEN_LOW_MASK\t\tGENMASK_ULL(MMIO_SPTE_GEN_LOW_END, \\\n\t\t\t\t\t\t    MMIO_SPTE_GEN_LOW_START)\n#define MMIO_SPTE_GEN_LOW_START\t\t3\n#define MMIO_SPTE_GEN_MASK\t\tGENMASK_ULL(17, 0)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic u64 generation_mmio_spte_mask(u64 gen)\n{\n\tu64 mask;\n\n\tWARN_ON(gen & ~MMIO_SPTE_GEN_MASK);\n\tBUILD_BUG_ON((MMIO_SPTE_GEN_HIGH_MASK | MMIO_SPTE_GEN_LOW_MASK) & SPTE_SPECIAL_MASK);\n\n\tmask = (gen << MMIO_SPTE_GEN_LOW_START) & MMIO_SPTE_GEN_LOW_MASK;\n\tmask |= (gen << MMIO_SPTE_GEN_HIGH_START) & MMIO_SPTE_GEN_HIGH_MASK;\n\treturn mask;\n}"
  },
  {
    "function_name": "is_access_track_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "394-397",
    "snippet": "static inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spte_ad_enabled",
          "args": [
            "spte"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "spte_ad_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "365-369",
          "snippet": "static inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_DISABLED_MASK (1ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool is_access_track_spte(u64 spte)\n{\n\treturn !spte_ad_enabled(spte) && (spte & shadow_acc_track_mask) == 0;\n}"
  },
  {
    "function_name": "spte_shadow_dirty_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "388-392",
    "snippet": "static inline u64 spte_shadow_dirty_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_dirty_mask : 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spte_ad_enabled",
          "args": [
            "spte"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "spte_ad_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "365-369",
          "snippet": "static inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_DISABLED_MASK (1ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "is_mmio_spte(spte)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "spte"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "344-347",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline u64 spte_shadow_dirty_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_dirty_mask : 0;\n}"
  },
  {
    "function_name": "spte_shadow_accessed_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "382-386",
    "snippet": "static inline u64 spte_shadow_accessed_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_accessed_mask : 0;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spte_ad_enabled",
          "args": [
            "spte"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "spte_ad_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "365-369",
          "snippet": "static inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_AD_DISABLED_MASK (1ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "is_mmio_spte(spte)"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "spte"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "344-347",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline u64 spte_shadow_accessed_mask(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn spte_ad_enabled(spte) ? shadow_accessed_mask : 0;\n}"
  },
  {
    "function_name": "is_nx_huge_page_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "377-380",
    "snippet": "static bool is_nx_huge_page_enabled(void)\n{\n\treturn READ_ONCE(nx_huge_pages);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "nx_huge_pages"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic bool is_nx_huge_page_enabled(void)\n{\n\treturn READ_ONCE(nx_huge_pages);\n}"
  },
  {
    "function_name": "spte_ad_need_write_protect",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "371-375",
    "snippet": "static inline bool spte_ad_need_write_protect(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_ENABLED_MASK;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_AD_ENABLED_MASK (0ULL << 52)",
      "#define SPTE_SPECIAL_MASK (3ULL << 52)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "is_mmio_spte(spte)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "spte"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "344-347",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_ENABLED_MASK (0ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_need_write_protect(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_ENABLED_MASK;\n}"
  },
  {
    "function_name": "spte_ad_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "365-369",
    "snippet": "static inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_AD_DISABLED_MASK (1ULL << 52)",
      "#define SPTE_SPECIAL_MASK (3ULL << 52)"
    ],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "MMU_WARN_ON",
          "args": [
            "is_mmio_spte(spte)"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_mmio_spte",
          "args": [
            "spte"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "is_mmio_spte",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "344-347",
          "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void mmu_spte_set(u64 *sptep, u64 spte);",
            "static bool is_executable_pte(u64 spte);",
            "static void mark_unsync(u64 *spte);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_AD_DISABLED_MASK (1ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic inline bool spte_ad_enabled(u64 spte)\n{\n\tMMU_WARN_ON(is_mmio_spte(spte));\n\treturn (spte & SPTE_SPECIAL_MASK) != SPTE_AD_DISABLED_MASK;\n}"
  },
  {
    "function_name": "kvm_vcpu_ad_need_write_protect",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "354-363",
    "snippet": "static inline bool kvm_vcpu_ad_need_write_protect(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * When using the EPT page-modification log, the GPAs in the log\n\t * would come from L2 rather than L1.  Therefore, we need to rely\n\t * on write protection to record dirty pages.  This also bypasses\n\t * PML, since writes now result in a vmexit.\n\t */\n\treturn vcpu->arch.mmu == &vcpu->arch.guest_mmu;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nstatic inline bool kvm_vcpu_ad_need_write_protect(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * When using the EPT page-modification log, the GPAs in the log\n\t * would come from L2 rather than L1.  Therefore, we need to rely\n\t * on write protection to record dirty pages.  This also bypasses\n\t * PML, since writes now result in a vmexit.\n\t */\n\treturn vcpu->arch.mmu == &vcpu->arch.guest_mmu;\n}"
  },
  {
    "function_name": "sp_ad_disabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "349-352",
    "snippet": "static inline bool sp_ad_disabled(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.ad_disabled;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool sp_ad_disabled(struct kvm_mmu_page *sp)\n{\n\treturn sp->role.ad_disabled;\n}"
  },
  {
    "function_name": "is_mmio_spte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "344-347",
    "snippet": "static bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void mmu_spte_set(u64 *sptep, u64 spte);",
      "static bool is_executable_pte(u64 spte);",
      "static void mark_unsync(u64 *spte);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void mmu_spte_set(u64 *sptep, u64 spte);\nstatic bool is_executable_pte(u64 spte);\nstatic void mark_unsync(u64 *spte);\n\nstatic bool is_mmio_spte(u64 spte)\n{\n\treturn (spte & shadow_mmio_mask) == shadow_mmio_value;\n}"
  },
  {
    "function_name": "kvm_mmu_set_mmio_spte_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "334-341",
    "snippet": "void kvm_mmu_set_mmio_spte_mask(u64 mmio_mask, u64 mmio_value, u64 access_mask)\n{\n\tBUG_ON((u64)(unsigned)access_mask != access_mask);\n\tBUG_ON((mmio_mask & mmio_value) != mmio_value);\n\tshadow_mmio_value = mmio_value | SPTE_MMIO_MASK;\n\tshadow_mmio_mask = mmio_mask | SPTE_SPECIAL_MASK;\n\tshadow_mmio_access_mask = access_mask;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [
      "#define SPTE_MMIO_MASK (3ULL << 52)",
      "#define SPTE_SPECIAL_MASK (3ULL << 52)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(mmio_mask & mmio_value) != mmio_value"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(u64)(unsigned)access_mask != access_mask"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMIO_MASK (3ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nvoid kvm_mmu_set_mmio_spte_mask(u64 mmio_mask, u64 mmio_value, u64 access_mask)\n{\n\tBUG_ON((u64)(unsigned)access_mask != access_mask);\n\tBUG_ON((mmio_mask & mmio_value) != mmio_value);\n\tshadow_mmio_value = mmio_value | SPTE_MMIO_MASK;\n\tshadow_mmio_mask = mmio_mask | SPTE_SPECIAL_MASK;\n\tshadow_mmio_access_mask = access_mask;\n}"
  },
  {
    "function_name": "kvm_flush_remote_tlbs_with_address",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "323-332",
    "snippet": "static void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs_with_range",
          "args": [
            "kvm",
            "&range"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_flush_remote_tlbs_with_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "311-321",
          "snippet": "static void kvm_flush_remote_tlbs_with_range(struct kvm *kvm,\n\t\tstruct kvm_tlb_range *range)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (range && kvm_x86_ops.tlb_remote_flush_with_range)\n\t\tret = kvm_x86_ops.tlb_remote_flush_with_range(kvm, range);\n\n\tif (ret)\n\t\tkvm_flush_remote_tlbs(kvm);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_range(struct kvm *kvm,\n\t\tstruct kvm_tlb_range *range)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (range && kvm_x86_ops.tlb_remote_flush_with_range)\n\t\tret = kvm_x86_ops.tlb_remote_flush_with_range(kvm, range);\n\n\tif (ret)\n\t\tkvm_flush_remote_tlbs(kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_address(struct kvm *kvm,\n\t\tu64 start_gfn, u64 pages)\n{\n\tstruct kvm_tlb_range range;\n\n\trange.start_gfn = start_gfn;\n\trange.pages = pages;\n\n\tkvm_flush_remote_tlbs_with_range(kvm, &range);\n}"
  },
  {
    "function_name": "kvm_flush_remote_tlbs_with_range",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "311-321",
    "snippet": "static void kvm_flush_remote_tlbs_with_range(struct kvm *kvm,\n\t\tstruct kvm_tlb_range *range)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (range && kvm_x86_ops.tlb_remote_flush_with_range)\n\t\tret = kvm_x86_ops.tlb_remote_flush_with_range(kvm, range);\n\n\tif (ret)\n\t\tkvm_flush_remote_tlbs(kvm);\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_flush_remote_tlbs",
          "args": [
            "kvm"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.tlb_remote_flush_with_range",
          "args": [
            "kvm",
            "range"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic void kvm_flush_remote_tlbs_with_range(struct kvm *kvm,\n\t\tstruct kvm_tlb_range *range)\n{\n\tint ret = -ENOTSUPP;\n\n\tif (range && kvm_x86_ops.tlb_remote_flush_with_range)\n\t\tret = kvm_x86_ops.tlb_remote_flush_with_range(kvm, range);\n\n\tif (ret)\n\t\tkvm_flush_remote_tlbs(kvm);\n}"
  },
  {
    "function_name": "kvm_available_flush_tlb_with_range",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
    "lines": "306-309",
    "snippet": "static inline bool kvm_available_flush_tlb_with_range(void)\n{\n\treturn kvm_x86_ops.tlb_remote_flush_with_range;\n}",
    "includes": [
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"paging_tmpl.h\"",
      "#include \"mmu_audit.c\"",
      "#include \"mmutrace.h\"",
      "#include <trace/events/kvm.h>",
      "#include \"trace.h\"",
      "#include <asm/kvm_page_track.h>",
      "#include <asm/vmx.h>",
      "#include <asm/io.h>",
      "#include <asm/e820/api.h>",
      "#include <asm/cmpxchg.h>",
      "#include <asm/memtype.h>",
      "#include <asm/page.h>",
      "#include <linux/kthread.h>",
      "#include <linux/kern_levels.h>",
      "#include <linux/hash.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/srcu.h>",
      "#include <linux/compiler.h>",
      "#include <linux/hugetlb.h>",
      "#include <linux/swap.h>",
      "#include <linux/export.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/kvm_host.h>",
      "#include \"cpuid.h\"",
      "#include \"kvm_emulate.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"x86.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic inline bool kvm_available_flush_tlb_with_range(void)\n{\n\treturn kvm_x86_ops.tlb_remote_flush_with_range;\n}"
  }
]