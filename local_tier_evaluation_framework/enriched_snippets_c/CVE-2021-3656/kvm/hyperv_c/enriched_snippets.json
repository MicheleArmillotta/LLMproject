[
  {
    "function_name": "kvm_vcpu_ioctl_get_hv_cpuid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1788-1916",
    "snippet": "int kvm_vcpu_ioctl_get_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 *cpuid,\n\t\t\t\tstruct kvm_cpuid_entry2 __user *entries)\n{\n\tuint16_t evmcs_ver = 0;\n\tstruct kvm_cpuid_entry2 cpuid_entries[] = {\n\t\t{ .function = HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS },\n\t\t{ .function = HYPERV_CPUID_INTERFACE },\n\t\t{ .function = HYPERV_CPUID_VERSION },\n\t\t{ .function = HYPERV_CPUID_FEATURES },\n\t\t{ .function = HYPERV_CPUID_ENLIGHTMENT_INFO },\n\t\t{ .function = HYPERV_CPUID_IMPLEMENT_LIMITS },\n\t\t{ .function = HYPERV_CPUID_NESTED_FEATURES },\n\t};\n\tint i, nent = ARRAY_SIZE(cpuid_entries);\n\n\tif (kvm_x86_ops.nested_get_evmcs_version)\n\t\tevmcs_ver = kvm_x86_ops.nested_get_evmcs_version(vcpu);\n\n\t/* Skip NESTED_FEATURES if eVMCS is not supported */\n\tif (!evmcs_ver)\n\t\t--nent;\n\n\tif (cpuid->nent < nent)\n\t\treturn -E2BIG;\n\n\tif (cpuid->nent > nent)\n\t\tcpuid->nent = nent;\n\n\tfor (i = 0; i < nent; i++) {\n\t\tstruct kvm_cpuid_entry2 *ent = &cpuid_entries[i];\n\t\tu32 signature[3];\n\n\t\tswitch (ent->function) {\n\t\tcase HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS:\n\t\t\tmemcpy(signature, \"Linux KVM Hv\", 12);\n\n\t\t\tent->eax = HYPERV_CPUID_NESTED_FEATURES;\n\t\t\tent->ebx = signature[0];\n\t\t\tent->ecx = signature[1];\n\t\t\tent->edx = signature[2];\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_INTERFACE:\n\t\t\tmemcpy(signature, \"Hv#1\\0\\0\\0\\0\\0\\0\\0\\0\", 12);\n\t\t\tent->eax = signature[0];\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_VERSION:\n\t\t\t/*\n\t\t\t * We implement some Hyper-V 2016 functions so let's use\n\t\t\t * this version.\n\t\t\t */\n\t\t\tent->eax = 0x00003839;\n\t\t\tent->ebx = 0x000A0000;\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_FEATURES:\n\t\t\tent->eax |= HV_X64_MSR_VP_RUNTIME_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_TIME_REF_COUNT_AVAILABLE;\n\t\t\tent->eax |= HV_X64_MSR_SYNIC_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_SYNTIMER_AVAILABLE;\n\t\t\tent->eax |= HV_X64_MSR_APIC_ACCESS_AVAILABLE;\n\t\t\tent->eax |= HV_X64_MSR_HYPERCALL_AVAILABLE;\n\t\t\tent->eax |= HV_X64_MSR_VP_INDEX_AVAILABLE;\n\t\t\tent->eax |= HV_X64_MSR_RESET_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_REFERENCE_TSC_AVAILABLE;\n\t\t\tent->eax |= HV_X64_ACCESS_FREQUENCY_MSRS;\n\t\t\tent->eax |= HV_X64_ACCESS_REENLIGHTENMENT;\n\n\t\t\tent->ebx |= HV_X64_POST_MESSAGES;\n\t\t\tent->ebx |= HV_X64_SIGNAL_EVENTS;\n\n\t\t\tent->edx |= HV_FEATURE_FREQUENCY_MSRS_AVAILABLE;\n\t\t\tent->edx |= HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE;\n\n\t\t\t/*\n\t\t\t * Direct Synthetic timers only make sense with in-kernel\n\t\t\t * LAPIC\n\t\t\t */\n\t\t\tif (lapic_in_kernel(vcpu))\n\t\t\t\tent->edx |= HV_STIMER_DIRECT_MODE_AVAILABLE;\n\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_ENLIGHTMENT_INFO:\n\t\t\tent->eax |= HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_APIC_ACCESS_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_RELAXED_TIMING_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_CLUSTER_IPI_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED;\n\t\t\tif (evmcs_ver)\n\t\t\t\tent->eax |= HV_X64_ENLIGHTENED_VMCS_RECOMMENDED;\n\t\t\tif (!cpu_smt_possible())\n\t\t\t\tent->eax |= HV_X64_NO_NONARCH_CORESHARING;\n\t\t\t/*\n\t\t\t * Default number of spinlock retry attempts, matches\n\t\t\t * HyperV 2016.\n\t\t\t */\n\t\t\tent->ebx = 0x00000FFF;\n\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_IMPLEMENT_LIMITS:\n\t\t\t/* Maximum number of virtual processors */\n\t\t\tent->eax = KVM_MAX_VCPUS;\n\t\t\t/*\n\t\t\t * Maximum number of logical processors, matches\n\t\t\t * HyperV 2016.\n\t\t\t */\n\t\t\tent->ebx = 64;\n\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_NESTED_FEATURES:\n\t\t\tent->eax = evmcs_ver;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (copy_to_user(entries, cpuid_entries,\n\t\t\t nent * sizeof(struct kvm_cpuid_entry2)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "entries",
            "cpuid_entries",
            "nent * sizeof(struct kvm_cpuid_entry2)"
          ],
          "line": 1911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_smt_possible",
          "args": [],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "signature",
            "\"Hv#1\\0\\0\\0\\0\\0\\0\\0\\0\"",
            "12"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "signature",
            "\"Linux KVM Hv\"",
            "12"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.nested_get_evmcs_version",
          "args": [
            "vcpu"
          ],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "nested_get_evmcs_version",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/evmcs.c",
          "lines": "335-348",
          "snippet": "uint16_t nested_get_evmcs_version(struct kvm_vcpu *vcpu)\n{\n       struct vcpu_vmx *vmx = to_vmx(vcpu);\n       /*\n        * vmcs_version represents the range of supported Enlightened VMCS\n        * versions: lower 8 bits is the minimal version, higher 8 bits is the\n        * maximum supported version. KVM supports versions from 1 to\n        * KVM_EVMCS_VERSION.\n        */\n       if (vmx->nested.enlightened_vmcs_enabled)\n               return (KVM_EVMCS_VERSION << 8) | 1;\n\n       return 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"vmx.h\"",
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include \"../hyperv.h\"",
            "#include <linux/smp.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"vmx.h\"\n#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include \"../hyperv.h\"\n#include <linux/smp.h>\n#include <linux/errno.h>\n\nuint16_t nested_get_evmcs_version(struct kvm_vcpu *vcpu)\n{\n       struct vcpu_vmx *vmx = to_vmx(vcpu);\n       /*\n        * vmcs_version represents the range of supported Enlightened VMCS\n        * versions: lower 8 bits is the minimal version, higher 8 bits is the\n        * maximum supported version. KVM supports versions from 1 to\n        * KVM_EVMCS_VERSION.\n        */\n       if (vmx->nested.enlightened_vmcs_enabled)\n               return (KVM_EVMCS_VERSION << 8) | 1;\n\n       return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cpuid_entries"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_vcpu_ioctl_get_hv_cpuid(struct kvm_vcpu *vcpu, struct kvm_cpuid2 *cpuid,\n\t\t\t\tstruct kvm_cpuid_entry2 __user *entries)\n{\n\tuint16_t evmcs_ver = 0;\n\tstruct kvm_cpuid_entry2 cpuid_entries[] = {\n\t\t{ .function = HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS },\n\t\t{ .function = HYPERV_CPUID_INTERFACE },\n\t\t{ .function = HYPERV_CPUID_VERSION },\n\t\t{ .function = HYPERV_CPUID_FEATURES },\n\t\t{ .function = HYPERV_CPUID_ENLIGHTMENT_INFO },\n\t\t{ .function = HYPERV_CPUID_IMPLEMENT_LIMITS },\n\t\t{ .function = HYPERV_CPUID_NESTED_FEATURES },\n\t};\n\tint i, nent = ARRAY_SIZE(cpuid_entries);\n\n\tif (kvm_x86_ops.nested_get_evmcs_version)\n\t\tevmcs_ver = kvm_x86_ops.nested_get_evmcs_version(vcpu);\n\n\t/* Skip NESTED_FEATURES if eVMCS is not supported */\n\tif (!evmcs_ver)\n\t\t--nent;\n\n\tif (cpuid->nent < nent)\n\t\treturn -E2BIG;\n\n\tif (cpuid->nent > nent)\n\t\tcpuid->nent = nent;\n\n\tfor (i = 0; i < nent; i++) {\n\t\tstruct kvm_cpuid_entry2 *ent = &cpuid_entries[i];\n\t\tu32 signature[3];\n\n\t\tswitch (ent->function) {\n\t\tcase HYPERV_CPUID_VENDOR_AND_MAX_FUNCTIONS:\n\t\t\tmemcpy(signature, \"Linux KVM Hv\", 12);\n\n\t\t\tent->eax = HYPERV_CPUID_NESTED_FEATURES;\n\t\t\tent->ebx = signature[0];\n\t\t\tent->ecx = signature[1];\n\t\t\tent->edx = signature[2];\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_INTERFACE:\n\t\t\tmemcpy(signature, \"Hv#1\\0\\0\\0\\0\\0\\0\\0\\0\", 12);\n\t\t\tent->eax = signature[0];\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_VERSION:\n\t\t\t/*\n\t\t\t * We implement some Hyper-V 2016 functions so let's use\n\t\t\t * this version.\n\t\t\t */\n\t\t\tent->eax = 0x00003839;\n\t\t\tent->ebx = 0x000A0000;\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_FEATURES:\n\t\t\tent->eax |= HV_X64_MSR_VP_RUNTIME_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_TIME_REF_COUNT_AVAILABLE;\n\t\t\tent->eax |= HV_X64_MSR_SYNIC_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_SYNTIMER_AVAILABLE;\n\t\t\tent->eax |= HV_X64_MSR_APIC_ACCESS_AVAILABLE;\n\t\t\tent->eax |= HV_X64_MSR_HYPERCALL_AVAILABLE;\n\t\t\tent->eax |= HV_X64_MSR_VP_INDEX_AVAILABLE;\n\t\t\tent->eax |= HV_X64_MSR_RESET_AVAILABLE;\n\t\t\tent->eax |= HV_MSR_REFERENCE_TSC_AVAILABLE;\n\t\t\tent->eax |= HV_X64_ACCESS_FREQUENCY_MSRS;\n\t\t\tent->eax |= HV_X64_ACCESS_REENLIGHTENMENT;\n\n\t\t\tent->ebx |= HV_X64_POST_MESSAGES;\n\t\t\tent->ebx |= HV_X64_SIGNAL_EVENTS;\n\n\t\t\tent->edx |= HV_FEATURE_FREQUENCY_MSRS_AVAILABLE;\n\t\t\tent->edx |= HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE;\n\n\t\t\t/*\n\t\t\t * Direct Synthetic timers only make sense with in-kernel\n\t\t\t * LAPIC\n\t\t\t */\n\t\t\tif (lapic_in_kernel(vcpu))\n\t\t\t\tent->edx |= HV_STIMER_DIRECT_MODE_AVAILABLE;\n\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_ENLIGHTMENT_INFO:\n\t\t\tent->eax |= HV_X64_REMOTE_TLB_FLUSH_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_APIC_ACCESS_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_RELAXED_TIMING_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_CLUSTER_IPI_RECOMMENDED;\n\t\t\tent->eax |= HV_X64_EX_PROCESSOR_MASKS_RECOMMENDED;\n\t\t\tif (evmcs_ver)\n\t\t\t\tent->eax |= HV_X64_ENLIGHTENED_VMCS_RECOMMENDED;\n\t\t\tif (!cpu_smt_possible())\n\t\t\t\tent->eax |= HV_X64_NO_NONARCH_CORESHARING;\n\t\t\t/*\n\t\t\t * Default number of spinlock retry attempts, matches\n\t\t\t * HyperV 2016.\n\t\t\t */\n\t\t\tent->ebx = 0x00000FFF;\n\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_IMPLEMENT_LIMITS:\n\t\t\t/* Maximum number of virtual processors */\n\t\t\tent->eax = KVM_MAX_VCPUS;\n\t\t\t/*\n\t\t\t * Maximum number of logical processors, matches\n\t\t\t * HyperV 2016.\n\t\t\t */\n\t\t\tent->ebx = 64;\n\n\t\t\tbreak;\n\n\t\tcase HYPERV_CPUID_NESTED_FEATURES:\n\t\t\tent->eax = evmcs_ver;\n\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (copy_to_user(entries, cpuid_entries,\n\t\t\t nent * sizeof(struct kvm_cpuid_entry2)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_vm_ioctl_hv_eventfd",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1777-1786",
    "snippet": "int kvm_vm_ioctl_hv_eventfd(struct kvm *kvm, struct kvm_hyperv_eventfd *args)\n{\n\tif ((args->flags & ~KVM_HYPERV_EVENTFD_DEASSIGN) ||\n\t    (args->conn_id & ~KVM_HYPERV_CONN_ID_MASK))\n\t\treturn -EINVAL;\n\n\tif (args->flags == KVM_HYPERV_EVENTFD_DEASSIGN)\n\t\treturn kvm_hv_eventfd_deassign(kvm, args->conn_id);\n\treturn kvm_hv_eventfd_assign(kvm, args->conn_id, args->fd);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_eventfd_assign",
          "args": [
            "kvm",
            "args->conn_id",
            "args->fd"
          ],
          "line": 1785
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_eventfd_assign",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1736-1758",
          "snippet": "static int kvm_hv_eventfd_assign(struct kvm *kvm, u32 conn_id, int fd)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct eventfd_ctx *eventfd;\n\tint ret;\n\n\teventfd = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(eventfd))\n\t\treturn PTR_ERR(eventfd);\n\n\tmutex_lock(&hv->hv_lock);\n\tret = idr_alloc(&hv->conn_to_evt, eventfd, conn_id, conn_id + 1,\n\t\t\tGFP_KERNEL_ACCOUNT);\n\tmutex_unlock(&hv->hv_lock);\n\n\tif (ret >= 0)\n\t\treturn 0;\n\n\tif (ret == -ENOSPC)\n\t\tret = -EEXIST;\n\teventfd_ctx_put(eventfd);\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_eventfd_assign(struct kvm *kvm, u32 conn_id, int fd)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct eventfd_ctx *eventfd;\n\tint ret;\n\n\teventfd = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(eventfd))\n\t\treturn PTR_ERR(eventfd);\n\n\tmutex_lock(&hv->hv_lock);\n\tret = idr_alloc(&hv->conn_to_evt, eventfd, conn_id, conn_id + 1,\n\t\t\tGFP_KERNEL_ACCOUNT);\n\tmutex_unlock(&hv->hv_lock);\n\n\tif (ret >= 0)\n\t\treturn 0;\n\n\tif (ret == -ENOSPC)\n\t\tret = -EEXIST;\n\teventfd_ctx_put(eventfd);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_eventfd_deassign",
          "args": [
            "kvm",
            "args->conn_id"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_eventfd_deassign",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1760-1775",
          "snippet": "static int kvm_hv_eventfd_deassign(struct kvm *kvm, u32 conn_id)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct eventfd_ctx *eventfd;\n\n\tmutex_lock(&hv->hv_lock);\n\teventfd = idr_remove(&hv->conn_to_evt, conn_id);\n\tmutex_unlock(&hv->hv_lock);\n\n\tif (!eventfd)\n\t\treturn -ENOENT;\n\n\tsynchronize_srcu(&kvm->srcu);\n\teventfd_ctx_put(eventfd);\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_eventfd_deassign(struct kvm *kvm, u32 conn_id)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct eventfd_ctx *eventfd;\n\n\tmutex_lock(&hv->hv_lock);\n\teventfd = idr_remove(&hv->conn_to_evt, conn_id);\n\tmutex_unlock(&hv->hv_lock);\n\n\tif (!eventfd)\n\t\treturn -ENOENT;\n\n\tsynchronize_srcu(&kvm->srcu);\n\teventfd_ctx_put(eventfd);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_vm_ioctl_hv_eventfd(struct kvm *kvm, struct kvm_hyperv_eventfd *args)\n{\n\tif ((args->flags & ~KVM_HYPERV_EVENTFD_DEASSIGN) ||\n\t    (args->conn_id & ~KVM_HYPERV_CONN_ID_MASK))\n\t\treturn -EINVAL;\n\n\tif (args->flags == KVM_HYPERV_EVENTFD_DEASSIGN)\n\t\treturn kvm_hv_eventfd_deassign(kvm, args->conn_id);\n\treturn kvm_hv_eventfd_assign(kvm, args->conn_id, args->fd);\n}"
  },
  {
    "function_name": "kvm_hv_eventfd_deassign",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1760-1775",
    "snippet": "static int kvm_hv_eventfd_deassign(struct kvm *kvm, u32 conn_id)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct eventfd_ctx *eventfd;\n\n\tmutex_lock(&hv->hv_lock);\n\teventfd = idr_remove(&hv->conn_to_evt, conn_id);\n\tmutex_unlock(&hv->hv_lock);\n\n\tif (!eventfd)\n\t\treturn -ENOENT;\n\n\tsynchronize_srcu(&kvm->srcu);\n\teventfd_ctx_put(eventfd);\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventfd_ctx_put",
          "args": [
            "eventfd"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "&kvm->srcu"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hv->hv_lock"
          ],
          "line": 1767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&hv->conn_to_evt",
            "conn_id"
          ],
          "line": 1766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hv->hv_lock"
          ],
          "line": 1765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_eventfd_deassign(struct kvm *kvm, u32 conn_id)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct eventfd_ctx *eventfd;\n\n\tmutex_lock(&hv->hv_lock);\n\teventfd = idr_remove(&hv->conn_to_evt, conn_id);\n\tmutex_unlock(&hv->hv_lock);\n\n\tif (!eventfd)\n\t\treturn -ENOENT;\n\n\tsynchronize_srcu(&kvm->srcu);\n\teventfd_ctx_put(eventfd);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_eventfd_assign",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1736-1758",
    "snippet": "static int kvm_hv_eventfd_assign(struct kvm *kvm, u32 conn_id, int fd)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct eventfd_ctx *eventfd;\n\tint ret;\n\n\teventfd = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(eventfd))\n\t\treturn PTR_ERR(eventfd);\n\n\tmutex_lock(&hv->hv_lock);\n\tret = idr_alloc(&hv->conn_to_evt, eventfd, conn_id, conn_id + 1,\n\t\t\tGFP_KERNEL_ACCOUNT);\n\tmutex_unlock(&hv->hv_lock);\n\n\tif (ret >= 0)\n\t\treturn 0;\n\n\tif (ret == -ENOSPC)\n\t\tret = -EEXIST;\n\teventfd_ctx_put(eventfd);\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventfd_ctx_put",
          "args": [
            "eventfd"
          ],
          "line": 1756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&hv->hv_lock"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_alloc",
          "args": [
            "&hv->conn_to_evt",
            "eventfd",
            "conn_id",
            "conn_id + 1",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&hv->hv_lock"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "eventfd"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "eventfd"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_fdget",
          "args": [
            "fd"
          ],
          "line": 1742
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_eventfd_assign(struct kvm *kvm, u32 conn_id, int fd)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct eventfd_ctx *eventfd;\n\tint ret;\n\n\teventfd = eventfd_ctx_fdget(fd);\n\tif (IS_ERR(eventfd))\n\t\treturn PTR_ERR(eventfd);\n\n\tmutex_lock(&hv->hv_lock);\n\tret = idr_alloc(&hv->conn_to_evt, eventfd, conn_id, conn_id + 1,\n\t\t\tGFP_KERNEL_ACCOUNT);\n\tmutex_unlock(&hv->hv_lock);\n\n\tif (ret >= 0)\n\t\treturn 0;\n\n\tif (ret == -ENOSPC)\n\t\tret = -EEXIST;\n\teventfd_ctx_put(eventfd);\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_hv_destroy_vm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1726-1734",
    "snippet": "void kvm_hv_destroy_vm(struct kvm *kvm)\n{\n\tstruct eventfd_ctx *eventfd;\n\tint i;\n\n\tidr_for_each_entry(&kvm->arch.hyperv.conn_to_evt, eventfd, i)\n\t\teventfd_ctx_put(eventfd);\n\tidr_destroy(&kvm->arch.hyperv.conn_to_evt);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_destroy",
          "args": [
            "&kvm->arch.hyperv.conn_to_evt"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_ctx_put",
          "args": [
            "eventfd"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_for_each_entry",
          "args": [
            "&kvm->arch.hyperv.conn_to_evt",
            "eventfd",
            "i"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_destroy_vm(struct kvm *kvm)\n{\n\tstruct eventfd_ctx *eventfd;\n\tint i;\n\n\tidr_for_each_entry(&kvm->arch.hyperv.conn_to_evt, eventfd, i)\n\t\teventfd_ctx_put(eventfd);\n\tidr_destroy(&kvm->arch.hyperv.conn_to_evt);\n}"
  },
  {
    "function_name": "kvm_hv_init_vm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1720-1724",
    "snippet": "void kvm_hv_init_vm(struct kvm *kvm)\n{\n\tmutex_init(&kvm->arch.hyperv.hv_lock);\n\tidr_init(&kvm->arch.hyperv.conn_to_evt);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&kvm->arch.hyperv.conn_to_evt"
          ],
          "line": 1723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&kvm->arch.hyperv.hv_lock"
          ],
          "line": 1722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_init_vm(struct kvm *kvm)\n{\n\tmutex_init(&kvm->arch.hyperv.hv_lock);\n\tidr_init(&kvm->arch.hyperv.conn_to_evt);\n}"
  },
  {
    "function_name": "kvm_hv_hypercall",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1600-1718",
    "snippet": "int kvm_hv_hypercall(struct kvm_vcpu *vcpu)\n{\n\tu64 param, ingpa, outgpa, ret = HV_STATUS_SUCCESS;\n\tuint16_t code, rep_idx, rep_cnt;\n\tbool fast, rep;\n\n\t/*\n\t * hypercall generates UD from non zero cpl and real mode\n\t * per HYPER-V spec\n\t */\n\tif (kvm_x86_ops.get_cpl(vcpu) != 0 || !is_protmode(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (is_64_bit_mode(vcpu)) {\n\t\tparam = kvm_rcx_read(vcpu);\n\t\tingpa = kvm_rdx_read(vcpu);\n\t\toutgpa = kvm_r8_read(vcpu);\n\t} else\n#endif\n\t{\n\t\tparam = ((u64)kvm_rdx_read(vcpu) << 32) |\n\t\t\t(kvm_rax_read(vcpu) & 0xffffffff);\n\t\tingpa = ((u64)kvm_rbx_read(vcpu) << 32) |\n\t\t\t(kvm_rcx_read(vcpu) & 0xffffffff);\n\t\toutgpa = ((u64)kvm_rdi_read(vcpu) << 32) |\n\t\t\t(kvm_rsi_read(vcpu) & 0xffffffff);\n\t}\n\n\tcode = param & 0xffff;\n\tfast = !!(param & HV_HYPERCALL_FAST_BIT);\n\trep_cnt = (param >> HV_HYPERCALL_REP_COMP_OFFSET) & 0xfff;\n\trep_idx = (param >> HV_HYPERCALL_REP_START_OFFSET) & 0xfff;\n\trep = !!(rep_cnt || rep_idx);\n\n\ttrace_kvm_hv_hypercall(code, fast, rep_cnt, rep_idx, ingpa, outgpa);\n\n\tswitch (code) {\n\tcase HVCALL_NOTIFY_LONG_SPIN_WAIT:\n\t\tif (unlikely(rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tkvm_vcpu_on_spin(vcpu, true);\n\t\tbreak;\n\tcase HVCALL_SIGNAL_EVENT:\n\t\tif (unlikely(rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hvcall_signal_event(vcpu, fast, ingpa);\n\t\tif (ret != HV_STATUS_INVALID_PORT_ID)\n\t\t\tbreak;\n\t\t/* fall through - maybe userspace knows this conn_id. */\n\tcase HVCALL_POST_MESSAGE:\n\t\t/* don't bother userspace if it has no way to handle it */\n\t\tif (unlikely(rep || !vcpu_to_synic(vcpu)->active)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\tvcpu->run->hyperv.type = KVM_EXIT_HYPERV_HCALL;\n\t\tvcpu->run->hyperv.u.hcall.input = param;\n\t\tvcpu->run->hyperv.u.hcall.params[0] = ingpa;\n\t\tvcpu->run->hyperv.u.hcall.params[1] = outgpa;\n\t\tvcpu->arch.complete_userspace_io =\n\t\t\t\tkvm_hv_hypercall_complete_userspace;\n\t\treturn 0;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST:\n\t\tif (unlikely(fast || !rep_cnt || rep_idx)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, false);\n\t\tbreak;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE:\n\t\tif (unlikely(fast || rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, false);\n\t\tbreak;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX:\n\t\tif (unlikely(fast || !rep_cnt || rep_idx)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, true);\n\t\tbreak;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX:\n\t\tif (unlikely(fast || rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, true);\n\t\tbreak;\n\tcase HVCALL_SEND_IPI:\n\t\tif (unlikely(rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_send_ipi(vcpu, ingpa, outgpa, false, fast);\n\t\tbreak;\n\tcase HVCALL_SEND_IPI_EX:\n\t\tif (unlikely(fast || rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_send_ipi(vcpu, ingpa, outgpa, true, false);\n\t\tbreak;\n\tdefault:\n\t\tret = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tbreak;\n\t}\n\n\treturn kvm_hv_hypercall_complete(vcpu, ret);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_hypercall_complete",
          "args": [
            "vcpu",
            "ret"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_hypercall_complete",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1549-1554",
          "snippet": "static int kvm_hv_hypercall_complete(struct kvm_vcpu *vcpu, u64 result)\n{\n\tkvm_hv_hypercall_set_result(vcpu, result);\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_hypercall_complete(struct kvm_vcpu *vcpu, u64 result)\n{\n\tkvm_hv_hypercall_set_result(vcpu, result);\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_send_ipi",
          "args": [
            "vcpu",
            "ingpa",
            "outgpa",
            "true",
            "false"
          ],
          "line": 1710
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_send_ipi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1457-1529",
          "snippet": "static u64 kvm_hv_send_ipi(struct kvm_vcpu *current_vcpu, u64 ingpa, u64 outgpa,\n\t\t\t   bool ex, bool fast)\n{\n\tstruct kvm *kvm = current_vcpu->kvm;\n\tstruct hv_send_ipi_ex send_ipi_ex;\n\tstruct hv_send_ipi send_ipi;\n\tu64 vp_bitmap[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];\n\tDECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);\n\tunsigned long *vcpu_mask;\n\tunsigned long valid_bank_mask;\n\tu64 sparse_banks[64];\n\tint sparse_banks_len;\n\tu32 vector;\n\tbool all_cpus;\n\n\tif (!ex) {\n\t\tif (!fast) {\n\t\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &send_ipi,\n\t\t\t\t\t\t    sizeof(send_ipi))))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tsparse_banks[0] = send_ipi.cpu_mask;\n\t\t\tvector = send_ipi.vector;\n\t\t} else {\n\t\t\t/* 'reserved' part of hv_send_ipi should be 0 */\n\t\t\tif (unlikely(ingpa >> 32 != 0))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tsparse_banks[0] = outgpa;\n\t\t\tvector = (u32)ingpa;\n\t\t}\n\t\tall_cpus = false;\n\t\tvalid_bank_mask = BIT_ULL(0);\n\n\t\ttrace_kvm_hv_send_ipi(vector, sparse_banks[0]);\n\t} else {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &send_ipi_ex,\n\t\t\t\t\t    sizeof(send_ipi_ex))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_send_ipi_ex(send_ipi_ex.vector,\n\t\t\t\t\t send_ipi_ex.vp_set.format,\n\t\t\t\t\t send_ipi_ex.vp_set.valid_bank_mask);\n\n\t\tvector = send_ipi_ex.vector;\n\t\tvalid_bank_mask = send_ipi_ex.vp_set.valid_bank_mask;\n\t\tsparse_banks_len = bitmap_weight(&valid_bank_mask, 64) *\n\t\t\tsizeof(sparse_banks[0]);\n\n\t\tall_cpus = send_ipi_ex.vp_set.format == HV_GENERIC_SET_ALL;\n\n\t\tif (!sparse_banks_len)\n\t\t\tgoto ret_success;\n\n\t\tif (!all_cpus &&\n\t\t    kvm_read_guest(kvm,\n\t\t\t\t   ingpa + offsetof(struct hv_send_ipi_ex,\n\t\t\t\t\t\t    vp_set.bank_contents),\n\t\t\t\t   sparse_banks,\n\t\t\t\t   sparse_banks_len))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t}\n\n\tif ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))\n\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\tvcpu_mask = all_cpus ? NULL :\n\t\tsparse_set_to_vcpu_mask(kvm, sparse_banks, valid_bank_mask,\n\t\t\t\t\tvp_bitmap, vcpu_bitmap);\n\n\tkvm_send_ipi_to_many(kvm, vector, vcpu_mask);\n\nret_success:\n\treturn HV_STATUS_SUCCESS;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [
            "#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\n#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)\n\nstatic u64 kvm_hv_send_ipi(struct kvm_vcpu *current_vcpu, u64 ingpa, u64 outgpa,\n\t\t\t   bool ex, bool fast)\n{\n\tstruct kvm *kvm = current_vcpu->kvm;\n\tstruct hv_send_ipi_ex send_ipi_ex;\n\tstruct hv_send_ipi send_ipi;\n\tu64 vp_bitmap[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];\n\tDECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);\n\tunsigned long *vcpu_mask;\n\tunsigned long valid_bank_mask;\n\tu64 sparse_banks[64];\n\tint sparse_banks_len;\n\tu32 vector;\n\tbool all_cpus;\n\n\tif (!ex) {\n\t\tif (!fast) {\n\t\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &send_ipi,\n\t\t\t\t\t\t    sizeof(send_ipi))))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tsparse_banks[0] = send_ipi.cpu_mask;\n\t\t\tvector = send_ipi.vector;\n\t\t} else {\n\t\t\t/* 'reserved' part of hv_send_ipi should be 0 */\n\t\t\tif (unlikely(ingpa >> 32 != 0))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tsparse_banks[0] = outgpa;\n\t\t\tvector = (u32)ingpa;\n\t\t}\n\t\tall_cpus = false;\n\t\tvalid_bank_mask = BIT_ULL(0);\n\n\t\ttrace_kvm_hv_send_ipi(vector, sparse_banks[0]);\n\t} else {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &send_ipi_ex,\n\t\t\t\t\t    sizeof(send_ipi_ex))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_send_ipi_ex(send_ipi_ex.vector,\n\t\t\t\t\t send_ipi_ex.vp_set.format,\n\t\t\t\t\t send_ipi_ex.vp_set.valid_bank_mask);\n\n\t\tvector = send_ipi_ex.vector;\n\t\tvalid_bank_mask = send_ipi_ex.vp_set.valid_bank_mask;\n\t\tsparse_banks_len = bitmap_weight(&valid_bank_mask, 64) *\n\t\t\tsizeof(sparse_banks[0]);\n\n\t\tall_cpus = send_ipi_ex.vp_set.format == HV_GENERIC_SET_ALL;\n\n\t\tif (!sparse_banks_len)\n\t\t\tgoto ret_success;\n\n\t\tif (!all_cpus &&\n\t\t    kvm_read_guest(kvm,\n\t\t\t\t   ingpa + offsetof(struct hv_send_ipi_ex,\n\t\t\t\t\t\t    vp_set.bank_contents),\n\t\t\t\t   sparse_banks,\n\t\t\t\t   sparse_banks_len))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t}\n\n\tif ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))\n\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\tvcpu_mask = all_cpus ? NULL :\n\t\tsparse_set_to_vcpu_mask(kvm, sparse_banks, valid_bank_mask,\n\t\t\t\t\tvp_bitmap, vcpu_bitmap);\n\n\tkvm_send_ipi_to_many(kvm, vector, vcpu_mask);\n\nret_success:\n\treturn HV_STATUS_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fast || rep"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rep"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_flush_tlb",
          "args": [
            "vcpu",
            "ingpa",
            "rep_cnt",
            "true"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_flush_tlb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1354-1436",
          "snippet": "static u64 kvm_hv_flush_tlb(struct kvm_vcpu *current_vcpu, u64 ingpa,\n\t\t\t    u16 rep_cnt, bool ex)\n{\n\tstruct kvm *kvm = current_vcpu->kvm;\n\tstruct kvm_vcpu_hv *hv_vcpu = &current_vcpu->arch.hyperv;\n\tstruct hv_tlb_flush_ex flush_ex;\n\tstruct hv_tlb_flush flush;\n\tu64 vp_bitmap[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];\n\tDECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);\n\tunsigned long *vcpu_mask;\n\tu64 valid_bank_mask;\n\tu64 sparse_banks[64];\n\tint sparse_banks_len;\n\tbool all_cpus;\n\n\tif (!ex) {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &flush, sizeof(flush))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_flush_tlb(flush.processor_mask,\n\t\t\t\t       flush.address_space, flush.flags);\n\n\t\tvalid_bank_mask = BIT_ULL(0);\n\t\tsparse_banks[0] = flush.processor_mask;\n\n\t\t/*\n\t\t * Work around possible WS2012 bug: it sends hypercalls\n\t\t * with processor_mask = 0x0 and HV_FLUSH_ALL_PROCESSORS clear,\n\t\t * while also expecting us to flush something and crashing if\n\t\t * we don't. Let's treat processor_mask == 0 same as\n\t\t * HV_FLUSH_ALL_PROCESSORS.\n\t\t */\n\t\tall_cpus = (flush.flags & HV_FLUSH_ALL_PROCESSORS) ||\n\t\t\tflush.processor_mask == 0;\n\t} else {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &flush_ex,\n\t\t\t\t\t    sizeof(flush_ex))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_flush_tlb_ex(flush_ex.hv_vp_set.valid_bank_mask,\n\t\t\t\t\t  flush_ex.hv_vp_set.format,\n\t\t\t\t\t  flush_ex.address_space,\n\t\t\t\t\t  flush_ex.flags);\n\n\t\tvalid_bank_mask = flush_ex.hv_vp_set.valid_bank_mask;\n\t\tall_cpus = flush_ex.hv_vp_set.format !=\n\t\t\tHV_GENERIC_SET_SPARSE_4K;\n\n\t\tsparse_banks_len =\n\t\t\tbitmap_weight((unsigned long *)&valid_bank_mask, 64) *\n\t\t\tsizeof(sparse_banks[0]);\n\n\t\tif (!sparse_banks_len && !all_cpus)\n\t\t\tgoto ret_success;\n\n\t\tif (!all_cpus &&\n\t\t    kvm_read_guest(kvm,\n\t\t\t\t   ingpa + offsetof(struct hv_tlb_flush_ex,\n\t\t\t\t\t\t    hv_vp_set.bank_contents),\n\t\t\t\t   sparse_banks,\n\t\t\t\t   sparse_banks_len))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t}\n\n\tcpumask_clear(&hv_vcpu->tlb_flush);\n\n\tvcpu_mask = all_cpus ? NULL :\n\t\tsparse_set_to_vcpu_mask(kvm, sparse_banks, valid_bank_mask,\n\t\t\t\t\tvp_bitmap, vcpu_bitmap);\n\n\t/*\n\t * vcpu->arch.cr3 may not be up-to-date for running vCPUs so we can't\n\t * analyze it here, flush TLB regardless of the specified address space.\n\t */\n\tkvm_make_vcpus_request_mask(kvm,\n\t\t\t\t    KVM_REQ_TLB_FLUSH | KVM_REQUEST_NO_WAKEUP,\n\t\t\t\t    vcpu_mask, &hv_vcpu->tlb_flush);\n\nret_success:\n\t/* We always do full TLB flush, set rep_done = rep_cnt. */\n\treturn (u64)HV_STATUS_SUCCESS |\n\t\t((u64)rep_cnt << HV_HYPERCALL_REP_COMP_OFFSET);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [
            "#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\n#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)\n\nstatic u64 kvm_hv_flush_tlb(struct kvm_vcpu *current_vcpu, u64 ingpa,\n\t\t\t    u16 rep_cnt, bool ex)\n{\n\tstruct kvm *kvm = current_vcpu->kvm;\n\tstruct kvm_vcpu_hv *hv_vcpu = &current_vcpu->arch.hyperv;\n\tstruct hv_tlb_flush_ex flush_ex;\n\tstruct hv_tlb_flush flush;\n\tu64 vp_bitmap[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];\n\tDECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);\n\tunsigned long *vcpu_mask;\n\tu64 valid_bank_mask;\n\tu64 sparse_banks[64];\n\tint sparse_banks_len;\n\tbool all_cpus;\n\n\tif (!ex) {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &flush, sizeof(flush))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_flush_tlb(flush.processor_mask,\n\t\t\t\t       flush.address_space, flush.flags);\n\n\t\tvalid_bank_mask = BIT_ULL(0);\n\t\tsparse_banks[0] = flush.processor_mask;\n\n\t\t/*\n\t\t * Work around possible WS2012 bug: it sends hypercalls\n\t\t * with processor_mask = 0x0 and HV_FLUSH_ALL_PROCESSORS clear,\n\t\t * while also expecting us to flush something and crashing if\n\t\t * we don't. Let's treat processor_mask == 0 same as\n\t\t * HV_FLUSH_ALL_PROCESSORS.\n\t\t */\n\t\tall_cpus = (flush.flags & HV_FLUSH_ALL_PROCESSORS) ||\n\t\t\tflush.processor_mask == 0;\n\t} else {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &flush_ex,\n\t\t\t\t\t    sizeof(flush_ex))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_flush_tlb_ex(flush_ex.hv_vp_set.valid_bank_mask,\n\t\t\t\t\t  flush_ex.hv_vp_set.format,\n\t\t\t\t\t  flush_ex.address_space,\n\t\t\t\t\t  flush_ex.flags);\n\n\t\tvalid_bank_mask = flush_ex.hv_vp_set.valid_bank_mask;\n\t\tall_cpus = flush_ex.hv_vp_set.format !=\n\t\t\tHV_GENERIC_SET_SPARSE_4K;\n\n\t\tsparse_banks_len =\n\t\t\tbitmap_weight((unsigned long *)&valid_bank_mask, 64) *\n\t\t\tsizeof(sparse_banks[0]);\n\n\t\tif (!sparse_banks_len && !all_cpus)\n\t\t\tgoto ret_success;\n\n\t\tif (!all_cpus &&\n\t\t    kvm_read_guest(kvm,\n\t\t\t\t   ingpa + offsetof(struct hv_tlb_flush_ex,\n\t\t\t\t\t\t    hv_vp_set.bank_contents),\n\t\t\t\t   sparse_banks,\n\t\t\t\t   sparse_banks_len))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t}\n\n\tcpumask_clear(&hv_vcpu->tlb_flush);\n\n\tvcpu_mask = all_cpus ? NULL :\n\t\tsparse_set_to_vcpu_mask(kvm, sparse_banks, valid_bank_mask,\n\t\t\t\t\tvp_bitmap, vcpu_bitmap);\n\n\t/*\n\t * vcpu->arch.cr3 may not be up-to-date for running vCPUs so we can't\n\t * analyze it here, flush TLB regardless of the specified address space.\n\t */\n\tkvm_make_vcpus_request_mask(kvm,\n\t\t\t\t    KVM_REQ_TLB_FLUSH | KVM_REQUEST_NO_WAKEUP,\n\t\t\t\t    vcpu_mask, &hv_vcpu->tlb_flush);\n\nret_success:\n\t/* We always do full TLB flush, set rep_done = rep_cnt. */\n\treturn (u64)HV_STATUS_SUCCESS |\n\t\t((u64)rep_cnt << HV_HYPERCALL_REP_COMP_OFFSET);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fast || rep"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fast || !rep_cnt || rep_idx"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fast || rep"
          ],
          "line": 1678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fast || !rep_cnt || rep_idx"
          ],
          "line": 1671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rep || !vcpu_to_synic(vcpu)->active"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "39-42",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hvcall_signal_event",
          "args": [
            "vcpu",
            "fast",
            "ingpa"
          ],
          "line": 1652
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hvcall_signal_event",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1561-1598",
          "snippet": "static u16 kvm_hvcall_signal_event(struct kvm_vcpu *vcpu, bool fast, u64 param)\n{\n\tstruct eventfd_ctx *eventfd;\n\n\tif (unlikely(!fast)) {\n\t\tint ret;\n\t\tgpa_t gpa = param;\n\n\t\tif ((gpa & (__alignof__(param) - 1)) ||\n\t\t    offset_in_page(gpa) + sizeof(param) > PAGE_SIZE)\n\t\t\treturn HV_STATUS_INVALID_ALIGNMENT;\n\n\t\tret = kvm_vcpu_read_guest(vcpu, gpa, &param, sizeof(param));\n\t\tif (ret < 0)\n\t\t\treturn HV_STATUS_INVALID_ALIGNMENT;\n\t}\n\n\t/*\n\t * Per spec, bits 32-47 contain the extra \"flag number\".  However, we\n\t * have no use for it, and in all known usecases it is zero, so just\n\t * report lookup failure if it isn't.\n\t */\n\tif (param & 0xffff00000000ULL)\n\t\treturn HV_STATUS_INVALID_PORT_ID;\n\t/* remaining bits are reserved-zero */\n\tif (param & ~KVM_HYPERV_CONN_ID_MASK)\n\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t/* the eventfd is protected by vcpu->kvm->srcu, but conn_to_evt isn't */\n\trcu_read_lock();\n\teventfd = idr_find(&vcpu->kvm->arch.hyperv.conn_to_evt, param);\n\trcu_read_unlock();\n\tif (!eventfd)\n\t\treturn HV_STATUS_INVALID_PORT_ID;\n\n\teventfd_signal(eventfd, 1);\n\treturn HV_STATUS_SUCCESS;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u16 kvm_hvcall_signal_event(struct kvm_vcpu *vcpu, bool fast, u64 param)\n{\n\tstruct eventfd_ctx *eventfd;\n\n\tif (unlikely(!fast)) {\n\t\tint ret;\n\t\tgpa_t gpa = param;\n\n\t\tif ((gpa & (__alignof__(param) - 1)) ||\n\t\t    offset_in_page(gpa) + sizeof(param) > PAGE_SIZE)\n\t\t\treturn HV_STATUS_INVALID_ALIGNMENT;\n\n\t\tret = kvm_vcpu_read_guest(vcpu, gpa, &param, sizeof(param));\n\t\tif (ret < 0)\n\t\t\treturn HV_STATUS_INVALID_ALIGNMENT;\n\t}\n\n\t/*\n\t * Per spec, bits 32-47 contain the extra \"flag number\".  However, we\n\t * have no use for it, and in all known usecases it is zero, so just\n\t * report lookup failure if it isn't.\n\t */\n\tif (param & 0xffff00000000ULL)\n\t\treturn HV_STATUS_INVALID_PORT_ID;\n\t/* remaining bits are reserved-zero */\n\tif (param & ~KVM_HYPERV_CONN_ID_MASK)\n\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t/* the eventfd is protected by vcpu->kvm->srcu, but conn_to_evt isn't */\n\trcu_read_lock();\n\teventfd = idr_find(&vcpu->kvm->arch.hyperv.conn_to_evt, param);\n\trcu_read_unlock();\n\tif (!eventfd)\n\t\treturn HV_STATUS_INVALID_PORT_ID;\n\n\teventfd_signal(eventfd, 1);\n\treturn HV_STATUS_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rep"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_on_spin",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "rep"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_hypercall",
          "args": [
            "code",
            "fast",
            "rep_cnt",
            "rep_idx",
            "ingpa",
            "outgpa"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rsi_read",
          "args": [
            "vcpu"
          ],
          "line": 1628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rdi_read",
          "args": [
            "vcpu"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rcx_read",
          "args": [
            "vcpu"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rbx_read",
          "args": [
            "vcpu"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rax_read",
          "args": [
            "vcpu"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rdx_read",
          "args": [
            "vcpu"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_r8_read",
          "args": [
            "vcpu"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rdx_read",
          "args": [
            "vcpu"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rcx_read",
          "args": [
            "vcpu"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_64_bit_mode",
          "args": [
            "vcpu"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "is_64_bit_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "94-102",
          "snippet": "static inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "vcpu",
            "UD_VECTOR"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_protmode",
          "args": [
            "vcpu"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "is_protmode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "80-83",
          "snippet": "static inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_protmode(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, X86_CR0_PE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_hypercall(struct kvm_vcpu *vcpu)\n{\n\tu64 param, ingpa, outgpa, ret = HV_STATUS_SUCCESS;\n\tuint16_t code, rep_idx, rep_cnt;\n\tbool fast, rep;\n\n\t/*\n\t * hypercall generates UD from non zero cpl and real mode\n\t * per HYPER-V spec\n\t */\n\tif (kvm_x86_ops.get_cpl(vcpu) != 0 || !is_protmode(vcpu)) {\n\t\tkvm_queue_exception(vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n#ifdef CONFIG_X86_64\n\tif (is_64_bit_mode(vcpu)) {\n\t\tparam = kvm_rcx_read(vcpu);\n\t\tingpa = kvm_rdx_read(vcpu);\n\t\toutgpa = kvm_r8_read(vcpu);\n\t} else\n#endif\n\t{\n\t\tparam = ((u64)kvm_rdx_read(vcpu) << 32) |\n\t\t\t(kvm_rax_read(vcpu) & 0xffffffff);\n\t\tingpa = ((u64)kvm_rbx_read(vcpu) << 32) |\n\t\t\t(kvm_rcx_read(vcpu) & 0xffffffff);\n\t\toutgpa = ((u64)kvm_rdi_read(vcpu) << 32) |\n\t\t\t(kvm_rsi_read(vcpu) & 0xffffffff);\n\t}\n\n\tcode = param & 0xffff;\n\tfast = !!(param & HV_HYPERCALL_FAST_BIT);\n\trep_cnt = (param >> HV_HYPERCALL_REP_COMP_OFFSET) & 0xfff;\n\trep_idx = (param >> HV_HYPERCALL_REP_START_OFFSET) & 0xfff;\n\trep = !!(rep_cnt || rep_idx);\n\n\ttrace_kvm_hv_hypercall(code, fast, rep_cnt, rep_idx, ingpa, outgpa);\n\n\tswitch (code) {\n\tcase HVCALL_NOTIFY_LONG_SPIN_WAIT:\n\t\tif (unlikely(rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tkvm_vcpu_on_spin(vcpu, true);\n\t\tbreak;\n\tcase HVCALL_SIGNAL_EVENT:\n\t\tif (unlikely(rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hvcall_signal_event(vcpu, fast, ingpa);\n\t\tif (ret != HV_STATUS_INVALID_PORT_ID)\n\t\t\tbreak;\n\t\t/* fall through - maybe userspace knows this conn_id. */\n\tcase HVCALL_POST_MESSAGE:\n\t\t/* don't bother userspace if it has no way to handle it */\n\t\tif (unlikely(rep || !vcpu_to_synic(vcpu)->active)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tvcpu->run->exit_reason = KVM_EXIT_HYPERV;\n\t\tvcpu->run->hyperv.type = KVM_EXIT_HYPERV_HCALL;\n\t\tvcpu->run->hyperv.u.hcall.input = param;\n\t\tvcpu->run->hyperv.u.hcall.params[0] = ingpa;\n\t\tvcpu->run->hyperv.u.hcall.params[1] = outgpa;\n\t\tvcpu->arch.complete_userspace_io =\n\t\t\t\tkvm_hv_hypercall_complete_userspace;\n\t\treturn 0;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST:\n\t\tif (unlikely(fast || !rep_cnt || rep_idx)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, false);\n\t\tbreak;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE:\n\t\tif (unlikely(fast || rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, false);\n\t\tbreak;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_LIST_EX:\n\t\tif (unlikely(fast || !rep_cnt || rep_idx)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, true);\n\t\tbreak;\n\tcase HVCALL_FLUSH_VIRTUAL_ADDRESS_SPACE_EX:\n\t\tif (unlikely(fast || rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_flush_tlb(vcpu, ingpa, rep_cnt, true);\n\t\tbreak;\n\tcase HVCALL_SEND_IPI:\n\t\tif (unlikely(rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_send_ipi(vcpu, ingpa, outgpa, false, fast);\n\t\tbreak;\n\tcase HVCALL_SEND_IPI_EX:\n\t\tif (unlikely(fast || rep)) {\n\t\t\tret = HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tbreak;\n\t\t}\n\t\tret = kvm_hv_send_ipi(vcpu, ingpa, outgpa, true, false);\n\t\tbreak;\n\tdefault:\n\t\tret = HV_STATUS_INVALID_HYPERCALL_CODE;\n\t\tbreak;\n\t}\n\n\treturn kvm_hv_hypercall_complete(vcpu, ret);\n}"
  },
  {
    "function_name": "kvm_hvcall_signal_event",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1561-1598",
    "snippet": "static u16 kvm_hvcall_signal_event(struct kvm_vcpu *vcpu, bool fast, u64 param)\n{\n\tstruct eventfd_ctx *eventfd;\n\n\tif (unlikely(!fast)) {\n\t\tint ret;\n\t\tgpa_t gpa = param;\n\n\t\tif ((gpa & (__alignof__(param) - 1)) ||\n\t\t    offset_in_page(gpa) + sizeof(param) > PAGE_SIZE)\n\t\t\treturn HV_STATUS_INVALID_ALIGNMENT;\n\n\t\tret = kvm_vcpu_read_guest(vcpu, gpa, &param, sizeof(param));\n\t\tif (ret < 0)\n\t\t\treturn HV_STATUS_INVALID_ALIGNMENT;\n\t}\n\n\t/*\n\t * Per spec, bits 32-47 contain the extra \"flag number\".  However, we\n\t * have no use for it, and in all known usecases it is zero, so just\n\t * report lookup failure if it isn't.\n\t */\n\tif (param & 0xffff00000000ULL)\n\t\treturn HV_STATUS_INVALID_PORT_ID;\n\t/* remaining bits are reserved-zero */\n\tif (param & ~KVM_HYPERV_CONN_ID_MASK)\n\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t/* the eventfd is protected by vcpu->kvm->srcu, but conn_to_evt isn't */\n\trcu_read_lock();\n\teventfd = idr_find(&vcpu->kvm->arch.hyperv.conn_to_evt, param);\n\trcu_read_unlock();\n\tif (!eventfd)\n\t\treturn HV_STATUS_INVALID_PORT_ID;\n\n\teventfd_signal(eventfd, 1);\n\treturn HV_STATUS_SUCCESS;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "eventfd_signal",
          "args": [
            "eventfd",
            "1"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&vcpu->kvm->arch.hyperv.conn_to_evt",
            "param"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest",
          "args": [
            "vcpu",
            "gpa",
            "&param",
            "sizeof(param)"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "offset_in_page",
          "args": [
            "gpa"
          ],
          "line": 1570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!fast"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u16 kvm_hvcall_signal_event(struct kvm_vcpu *vcpu, bool fast, u64 param)\n{\n\tstruct eventfd_ctx *eventfd;\n\n\tif (unlikely(!fast)) {\n\t\tint ret;\n\t\tgpa_t gpa = param;\n\n\t\tif ((gpa & (__alignof__(param) - 1)) ||\n\t\t    offset_in_page(gpa) + sizeof(param) > PAGE_SIZE)\n\t\t\treturn HV_STATUS_INVALID_ALIGNMENT;\n\n\t\tret = kvm_vcpu_read_guest(vcpu, gpa, &param, sizeof(param));\n\t\tif (ret < 0)\n\t\t\treturn HV_STATUS_INVALID_ALIGNMENT;\n\t}\n\n\t/*\n\t * Per spec, bits 32-47 contain the extra \"flag number\".  However, we\n\t * have no use for it, and in all known usecases it is zero, so just\n\t * report lookup failure if it isn't.\n\t */\n\tif (param & 0xffff00000000ULL)\n\t\treturn HV_STATUS_INVALID_PORT_ID;\n\t/* remaining bits are reserved-zero */\n\tif (param & ~KVM_HYPERV_CONN_ID_MASK)\n\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t/* the eventfd is protected by vcpu->kvm->srcu, but conn_to_evt isn't */\n\trcu_read_lock();\n\teventfd = idr_find(&vcpu->kvm->arch.hyperv.conn_to_evt, param);\n\trcu_read_unlock();\n\tif (!eventfd)\n\t\treturn HV_STATUS_INVALID_PORT_ID;\n\n\teventfd_signal(eventfd, 1);\n\treturn HV_STATUS_SUCCESS;\n}"
  },
  {
    "function_name": "kvm_hv_hypercall_complete_userspace",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1556-1559",
    "snippet": "static int kvm_hv_hypercall_complete_userspace(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_hv_hypercall_complete(vcpu, vcpu->run->hyperv.u.hcall.result);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_hypercall_complete",
          "args": [
            "vcpu",
            "vcpu->run->hyperv.u.hcall.result"
          ],
          "line": 1558
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_hypercall_complete",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1549-1554",
          "snippet": "static int kvm_hv_hypercall_complete(struct kvm_vcpu *vcpu, u64 result)\n{\n\tkvm_hv_hypercall_set_result(vcpu, result);\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_hypercall_complete(struct kvm_vcpu *vcpu, u64 result)\n{\n\tkvm_hv_hypercall_set_result(vcpu, result);\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_hypercall_complete_userspace(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_hv_hypercall_complete(vcpu, vcpu->run->hyperv.u.hcall.result);\n}"
  },
  {
    "function_name": "kvm_hv_hypercall_complete",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1549-1554",
    "snippet": "static int kvm_hv_hypercall_complete(struct kvm_vcpu *vcpu, u64 result)\n{\n\tkvm_hv_hypercall_set_result(vcpu, result);\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 1553
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_hypercall_set_result",
          "args": [
            "vcpu",
            "result"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_hypercall_set_result",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1536-1547",
          "snippet": "static void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\n{\n\tbool longmode;\n\n\tlongmode = is_64_bit_mode(vcpu);\n\tif (longmode)\n\t\tkvm_rax_write(vcpu, result);\n\telse {\n\t\tkvm_rdx_write(vcpu, result >> 32);\n\t\tkvm_rax_write(vcpu, result & 0xffffffff);\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\n{\n\tbool longmode;\n\n\tlongmode = is_64_bit_mode(vcpu);\n\tif (longmode)\n\t\tkvm_rax_write(vcpu, result);\n\telse {\n\t\tkvm_rdx_write(vcpu, result >> 32);\n\t\tkvm_rax_write(vcpu, result & 0xffffffff);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_hypercall_complete(struct kvm_vcpu *vcpu, u64 result)\n{\n\tkvm_hv_hypercall_set_result(vcpu, result);\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
  },
  {
    "function_name": "kvm_hv_hypercall_set_result",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1536-1547",
    "snippet": "static void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\n{\n\tbool longmode;\n\n\tlongmode = is_64_bit_mode(vcpu);\n\tif (longmode)\n\t\tkvm_rax_write(vcpu, result);\n\telse {\n\t\tkvm_rdx_write(vcpu, result >> 32);\n\t\tkvm_rax_write(vcpu, result & 0xffffffff);\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rax_write",
          "args": [
            "vcpu",
            "result & 0xffffffff"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rdx_write",
          "args": [
            "vcpu",
            "result >> 32"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rax_write",
          "args": [
            "vcpu",
            "result"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_64_bit_mode",
          "args": [
            "vcpu"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "is_64_bit_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "94-102",
          "snippet": "static inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool is_64_bit_mode(struct kvm_vcpu *vcpu)\n{\n\tint cs_db, cs_l;\n\n\tif (!is_long_mode(vcpu))\n\t\treturn false;\n\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\treturn cs_l;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_hv_hypercall_set_result(struct kvm_vcpu *vcpu, u64 result)\n{\n\tbool longmode;\n\n\tlongmode = is_64_bit_mode(vcpu);\n\tif (longmode)\n\t\tkvm_rax_write(vcpu, result);\n\telse {\n\t\tkvm_rdx_write(vcpu, result >> 32);\n\t\tkvm_rax_write(vcpu, result & 0xffffffff);\n\t}\n}"
  },
  {
    "function_name": "kvm_hv_hypercall_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1531-1534",
    "snippet": "bool kvm_hv_hypercall_enabled(struct kvm *kvm)\n{\n\treturn READ_ONCE(kvm->arch.hyperv.hv_hypercall) & HV_X64_MSR_HYPERCALL_ENABLE;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "kvm->arch.hyperv.hv_hypercall"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nbool kvm_hv_hypercall_enabled(struct kvm *kvm)\n{\n\treturn READ_ONCE(kvm->arch.hyperv.hv_hypercall) & HV_X64_MSR_HYPERCALL_ENABLE;\n}"
  },
  {
    "function_name": "kvm_hv_send_ipi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1457-1529",
    "snippet": "static u64 kvm_hv_send_ipi(struct kvm_vcpu *current_vcpu, u64 ingpa, u64 outgpa,\n\t\t\t   bool ex, bool fast)\n{\n\tstruct kvm *kvm = current_vcpu->kvm;\n\tstruct hv_send_ipi_ex send_ipi_ex;\n\tstruct hv_send_ipi send_ipi;\n\tu64 vp_bitmap[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];\n\tDECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);\n\tunsigned long *vcpu_mask;\n\tunsigned long valid_bank_mask;\n\tu64 sparse_banks[64];\n\tint sparse_banks_len;\n\tu32 vector;\n\tbool all_cpus;\n\n\tif (!ex) {\n\t\tif (!fast) {\n\t\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &send_ipi,\n\t\t\t\t\t\t    sizeof(send_ipi))))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tsparse_banks[0] = send_ipi.cpu_mask;\n\t\t\tvector = send_ipi.vector;\n\t\t} else {\n\t\t\t/* 'reserved' part of hv_send_ipi should be 0 */\n\t\t\tif (unlikely(ingpa >> 32 != 0))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tsparse_banks[0] = outgpa;\n\t\t\tvector = (u32)ingpa;\n\t\t}\n\t\tall_cpus = false;\n\t\tvalid_bank_mask = BIT_ULL(0);\n\n\t\ttrace_kvm_hv_send_ipi(vector, sparse_banks[0]);\n\t} else {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &send_ipi_ex,\n\t\t\t\t\t    sizeof(send_ipi_ex))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_send_ipi_ex(send_ipi_ex.vector,\n\t\t\t\t\t send_ipi_ex.vp_set.format,\n\t\t\t\t\t send_ipi_ex.vp_set.valid_bank_mask);\n\n\t\tvector = send_ipi_ex.vector;\n\t\tvalid_bank_mask = send_ipi_ex.vp_set.valid_bank_mask;\n\t\tsparse_banks_len = bitmap_weight(&valid_bank_mask, 64) *\n\t\t\tsizeof(sparse_banks[0]);\n\n\t\tall_cpus = send_ipi_ex.vp_set.format == HV_GENERIC_SET_ALL;\n\n\t\tif (!sparse_banks_len)\n\t\t\tgoto ret_success;\n\n\t\tif (!all_cpus &&\n\t\t    kvm_read_guest(kvm,\n\t\t\t\t   ingpa + offsetof(struct hv_send_ipi_ex,\n\t\t\t\t\t\t    vp_set.bank_contents),\n\t\t\t\t   sparse_banks,\n\t\t\t\t   sparse_banks_len))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t}\n\n\tif ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))\n\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\tvcpu_mask = all_cpus ? NULL :\n\t\tsparse_set_to_vcpu_mask(kvm, sparse_banks, valid_bank_mask,\n\t\t\t\t\tvp_bitmap, vcpu_bitmap);\n\n\tkvm_send_ipi_to_many(kvm, vector, vcpu_mask);\n\nret_success:\n\treturn HV_STATUS_SUCCESS;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [
      "#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_send_ipi_to_many",
          "args": [
            "kvm",
            "vector",
            "vcpu_mask"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_send_ipi_to_many",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1438-1455",
          "snippet": "static void kvm_send_ipi_to_many(struct kvm *kvm, u32 vector,\n\t\t\t\t unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = vector\n\t};\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu_bitmap && !test_bit(i, vcpu_bitmap))\n\t\t\tcontinue;\n\n\t\t/* We fail only when APIC is disabled */\n\t\tkvm_apic_set_irq(vcpu, &irq, NULL);\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_send_ipi_to_many(struct kvm *kvm, u32 vector,\n\t\t\t\t unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = vector\n\t};\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu_bitmap && !test_bit(i, vcpu_bitmap))\n\t\t\tcontinue;\n\n\t\t/* We fail only when APIC is disabled */\n\t\tkvm_apic_set_irq(vcpu, &irq, NULL);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sparse_set_to_vcpu_mask",
          "args": [
            "kvm",
            "sparse_banks",
            "valid_bank_mask",
            "vp_bitmap",
            "vcpu_bitmap"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_set_to_vcpu_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1326-1352",
          "snippet": "static __always_inline unsigned long *sparse_set_to_vcpu_mask(\n\tstruct kvm *kvm, u64 *sparse_banks, u64 valid_bank_mask,\n\tu64 *vp_bitmap, unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tint i, bank, sbank = 0;\n\n\tmemset(vp_bitmap, 0,\n\t       KVM_HV_MAX_SPARSE_VCPU_SET_BITS * sizeof(*vp_bitmap));\n\tfor_each_set_bit(bank, (unsigned long *)&valid_bank_mask,\n\t\t\t KVM_HV_MAX_SPARSE_VCPU_SET_BITS)\n\t\tvp_bitmap[bank] = sparse_banks[sbank++];\n\n\tif (likely(!atomic_read(&hv->num_mismatched_vp_indexes))) {\n\t\t/* for all vcpus vp_index == vcpu_idx */\n\t\treturn (unsigned long *)vp_bitmap;\n\t}\n\n\tbitmap_zero(vcpu_bitmap, KVM_MAX_VCPUS);\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (test_bit(vcpu_to_hv_vcpu(vcpu)->vp_index,\n\t\t\t     (unsigned long *)vp_bitmap))\n\t\t\t__set_bit(i, vcpu_bitmap);\n\t}\n\treturn vcpu_bitmap;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [
            "#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\n#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)\n\nstatic __always_inline unsigned long *sparse_set_to_vcpu_mask(\n\tstruct kvm *kvm, u64 *sparse_banks, u64 valid_bank_mask,\n\tu64 *vp_bitmap, unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tint i, bank, sbank = 0;\n\n\tmemset(vp_bitmap, 0,\n\t       KVM_HV_MAX_SPARSE_VCPU_SET_BITS * sizeof(*vp_bitmap));\n\tfor_each_set_bit(bank, (unsigned long *)&valid_bank_mask,\n\t\t\t KVM_HV_MAX_SPARSE_VCPU_SET_BITS)\n\t\tvp_bitmap[bank] = sparse_banks[sbank++];\n\n\tif (likely(!atomic_read(&hv->num_mismatched_vp_indexes))) {\n\t\t/* for all vcpus vp_index == vcpu_idx */\n\t\treturn (unsigned long *)vp_bitmap;\n\t}\n\n\tbitmap_zero(vcpu_bitmap, KVM_MAX_VCPUS);\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (test_bit(vcpu_to_hv_vcpu(vcpu)->vp_index,\n\t\t\t     (unsigned long *)vp_bitmap))\n\t\t\t__set_bit(i, vcpu_bitmap);\n\t}\n\treturn vcpu_bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_guest",
          "args": [
            "kvm",
            "ingpa + offsetof(struct hv_send_ipi_ex,\n\t\t\t\t\t\t    vp_set.bank_contents)",
            "sparse_banks",
            "sparse_banks_len"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_guest_phys_system",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "5478-5485",
          "snippet": "static int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "&valid_bank_mask",
            "64"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_send_ipi_ex",
          "args": [
            "send_ipi_ex.vector",
            "send_ipi_ex.vp_set.format",
            "send_ipi_ex.vp_set.valid_bank_mask"
          ],
          "line": 1495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kvm_read_guest(kvm, ingpa, &send_ipi_ex,\n\t\t\t\t\t    sizeof(send_ipi_ex))"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_send_ipi",
          "args": [
            "vector",
            "sparse_banks[0]"
          ],
          "line": 1489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT_ULL",
          "args": [
            "0"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ingpa >> 32 != 0"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kvm_read_guest(kvm, ingpa, &send_ipi,\n\t\t\t\t\t\t    sizeof(send_ipi))"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_BITMAP",
          "args": [
            "vcpu_bitmap",
            "KVM_MAX_VCPUS"
          ],
          "line": 1464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\n#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)\n\nstatic u64 kvm_hv_send_ipi(struct kvm_vcpu *current_vcpu, u64 ingpa, u64 outgpa,\n\t\t\t   bool ex, bool fast)\n{\n\tstruct kvm *kvm = current_vcpu->kvm;\n\tstruct hv_send_ipi_ex send_ipi_ex;\n\tstruct hv_send_ipi send_ipi;\n\tu64 vp_bitmap[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];\n\tDECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);\n\tunsigned long *vcpu_mask;\n\tunsigned long valid_bank_mask;\n\tu64 sparse_banks[64];\n\tint sparse_banks_len;\n\tu32 vector;\n\tbool all_cpus;\n\n\tif (!ex) {\n\t\tif (!fast) {\n\t\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &send_ipi,\n\t\t\t\t\t\t    sizeof(send_ipi))))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tsparse_banks[0] = send_ipi.cpu_mask;\n\t\t\tvector = send_ipi.vector;\n\t\t} else {\n\t\t\t/* 'reserved' part of hv_send_ipi should be 0 */\n\t\t\tif (unlikely(ingpa >> 32 != 0))\n\t\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t\t\tsparse_banks[0] = outgpa;\n\t\t\tvector = (u32)ingpa;\n\t\t}\n\t\tall_cpus = false;\n\t\tvalid_bank_mask = BIT_ULL(0);\n\n\t\ttrace_kvm_hv_send_ipi(vector, sparse_banks[0]);\n\t} else {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &send_ipi_ex,\n\t\t\t\t\t    sizeof(send_ipi_ex))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_send_ipi_ex(send_ipi_ex.vector,\n\t\t\t\t\t send_ipi_ex.vp_set.format,\n\t\t\t\t\t send_ipi_ex.vp_set.valid_bank_mask);\n\n\t\tvector = send_ipi_ex.vector;\n\t\tvalid_bank_mask = send_ipi_ex.vp_set.valid_bank_mask;\n\t\tsparse_banks_len = bitmap_weight(&valid_bank_mask, 64) *\n\t\t\tsizeof(sparse_banks[0]);\n\n\t\tall_cpus = send_ipi_ex.vp_set.format == HV_GENERIC_SET_ALL;\n\n\t\tif (!sparse_banks_len)\n\t\t\tgoto ret_success;\n\n\t\tif (!all_cpus &&\n\t\t    kvm_read_guest(kvm,\n\t\t\t\t   ingpa + offsetof(struct hv_send_ipi_ex,\n\t\t\t\t\t\t    vp_set.bank_contents),\n\t\t\t\t   sparse_banks,\n\t\t\t\t   sparse_banks_len))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t}\n\n\tif ((vector < HV_IPI_LOW_VECTOR) || (vector > HV_IPI_HIGH_VECTOR))\n\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\tvcpu_mask = all_cpus ? NULL :\n\t\tsparse_set_to_vcpu_mask(kvm, sparse_banks, valid_bank_mask,\n\t\t\t\t\tvp_bitmap, vcpu_bitmap);\n\n\tkvm_send_ipi_to_many(kvm, vector, vcpu_mask);\n\nret_success:\n\treturn HV_STATUS_SUCCESS;\n}"
  },
  {
    "function_name": "kvm_send_ipi_to_many",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1438-1455",
    "snippet": "static void kvm_send_ipi_to_many(struct kvm *kvm, u32 vector,\n\t\t\t\t unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = vector\n\t};\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu_bitmap && !test_bit(i, vcpu_bitmap))\n\t\t\tcontinue;\n\n\t\t/* We fail only when APIC is disabled */\n\t\tkvm_apic_set_irq(vcpu, &irq, NULL);\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_set_irq",
          "args": [
            "vcpu",
            "&irq",
            "NULL"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "563-570",
          "snippet": "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "i",
            "vcpu_bitmap"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_send_ipi_to_many(struct kvm *kvm, u32 vector,\n\t\t\t\t unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = vector\n\t};\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (vcpu_bitmap && !test_bit(i, vcpu_bitmap))\n\t\t\tcontinue;\n\n\t\t/* We fail only when APIC is disabled */\n\t\tkvm_apic_set_irq(vcpu, &irq, NULL);\n\t}\n}"
  },
  {
    "function_name": "kvm_hv_flush_tlb",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1354-1436",
    "snippet": "static u64 kvm_hv_flush_tlb(struct kvm_vcpu *current_vcpu, u64 ingpa,\n\t\t\t    u16 rep_cnt, bool ex)\n{\n\tstruct kvm *kvm = current_vcpu->kvm;\n\tstruct kvm_vcpu_hv *hv_vcpu = &current_vcpu->arch.hyperv;\n\tstruct hv_tlb_flush_ex flush_ex;\n\tstruct hv_tlb_flush flush;\n\tu64 vp_bitmap[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];\n\tDECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);\n\tunsigned long *vcpu_mask;\n\tu64 valid_bank_mask;\n\tu64 sparse_banks[64];\n\tint sparse_banks_len;\n\tbool all_cpus;\n\n\tif (!ex) {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &flush, sizeof(flush))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_flush_tlb(flush.processor_mask,\n\t\t\t\t       flush.address_space, flush.flags);\n\n\t\tvalid_bank_mask = BIT_ULL(0);\n\t\tsparse_banks[0] = flush.processor_mask;\n\n\t\t/*\n\t\t * Work around possible WS2012 bug: it sends hypercalls\n\t\t * with processor_mask = 0x0 and HV_FLUSH_ALL_PROCESSORS clear,\n\t\t * while also expecting us to flush something and crashing if\n\t\t * we don't. Let's treat processor_mask == 0 same as\n\t\t * HV_FLUSH_ALL_PROCESSORS.\n\t\t */\n\t\tall_cpus = (flush.flags & HV_FLUSH_ALL_PROCESSORS) ||\n\t\t\tflush.processor_mask == 0;\n\t} else {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &flush_ex,\n\t\t\t\t\t    sizeof(flush_ex))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_flush_tlb_ex(flush_ex.hv_vp_set.valid_bank_mask,\n\t\t\t\t\t  flush_ex.hv_vp_set.format,\n\t\t\t\t\t  flush_ex.address_space,\n\t\t\t\t\t  flush_ex.flags);\n\n\t\tvalid_bank_mask = flush_ex.hv_vp_set.valid_bank_mask;\n\t\tall_cpus = flush_ex.hv_vp_set.format !=\n\t\t\tHV_GENERIC_SET_SPARSE_4K;\n\n\t\tsparse_banks_len =\n\t\t\tbitmap_weight((unsigned long *)&valid_bank_mask, 64) *\n\t\t\tsizeof(sparse_banks[0]);\n\n\t\tif (!sparse_banks_len && !all_cpus)\n\t\t\tgoto ret_success;\n\n\t\tif (!all_cpus &&\n\t\t    kvm_read_guest(kvm,\n\t\t\t\t   ingpa + offsetof(struct hv_tlb_flush_ex,\n\t\t\t\t\t\t    hv_vp_set.bank_contents),\n\t\t\t\t   sparse_banks,\n\t\t\t\t   sparse_banks_len))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t}\n\n\tcpumask_clear(&hv_vcpu->tlb_flush);\n\n\tvcpu_mask = all_cpus ? NULL :\n\t\tsparse_set_to_vcpu_mask(kvm, sparse_banks, valid_bank_mask,\n\t\t\t\t\tvp_bitmap, vcpu_bitmap);\n\n\t/*\n\t * vcpu->arch.cr3 may not be up-to-date for running vCPUs so we can't\n\t * analyze it here, flush TLB regardless of the specified address space.\n\t */\n\tkvm_make_vcpus_request_mask(kvm,\n\t\t\t\t    KVM_REQ_TLB_FLUSH | KVM_REQUEST_NO_WAKEUP,\n\t\t\t\t    vcpu_mask, &hv_vcpu->tlb_flush);\n\nret_success:\n\t/* We always do full TLB flush, set rep_done = rep_cnt. */\n\treturn (u64)HV_STATUS_SUCCESS |\n\t\t((u64)rep_cnt << HV_HYPERCALL_REP_COMP_OFFSET);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [
      "#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_vcpus_request_mask",
          "args": [
            "kvm",
            "KVM_REQ_TLB_FLUSH | KVM_REQUEST_NO_WAKEUP",
            "vcpu_mask",
            "&hv_vcpu->tlb_flush"
          ],
          "line": 1428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sparse_set_to_vcpu_mask",
          "args": [
            "kvm",
            "sparse_banks",
            "valid_bank_mask",
            "vp_bitmap",
            "vcpu_bitmap"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "sparse_set_to_vcpu_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1326-1352",
          "snippet": "static __always_inline unsigned long *sparse_set_to_vcpu_mask(\n\tstruct kvm *kvm, u64 *sparse_banks, u64 valid_bank_mask,\n\tu64 *vp_bitmap, unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tint i, bank, sbank = 0;\n\n\tmemset(vp_bitmap, 0,\n\t       KVM_HV_MAX_SPARSE_VCPU_SET_BITS * sizeof(*vp_bitmap));\n\tfor_each_set_bit(bank, (unsigned long *)&valid_bank_mask,\n\t\t\t KVM_HV_MAX_SPARSE_VCPU_SET_BITS)\n\t\tvp_bitmap[bank] = sparse_banks[sbank++];\n\n\tif (likely(!atomic_read(&hv->num_mismatched_vp_indexes))) {\n\t\t/* for all vcpus vp_index == vcpu_idx */\n\t\treturn (unsigned long *)vp_bitmap;\n\t}\n\n\tbitmap_zero(vcpu_bitmap, KVM_MAX_VCPUS);\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (test_bit(vcpu_to_hv_vcpu(vcpu)->vp_index,\n\t\t\t     (unsigned long *)vp_bitmap))\n\t\t\t__set_bit(i, vcpu_bitmap);\n\t}\n\treturn vcpu_bitmap;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [
            "#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\n#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)\n\nstatic __always_inline unsigned long *sparse_set_to_vcpu_mask(\n\tstruct kvm *kvm, u64 *sparse_banks, u64 valid_bank_mask,\n\tu64 *vp_bitmap, unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tint i, bank, sbank = 0;\n\n\tmemset(vp_bitmap, 0,\n\t       KVM_HV_MAX_SPARSE_VCPU_SET_BITS * sizeof(*vp_bitmap));\n\tfor_each_set_bit(bank, (unsigned long *)&valid_bank_mask,\n\t\t\t KVM_HV_MAX_SPARSE_VCPU_SET_BITS)\n\t\tvp_bitmap[bank] = sparse_banks[sbank++];\n\n\tif (likely(!atomic_read(&hv->num_mismatched_vp_indexes))) {\n\t\t/* for all vcpus vp_index == vcpu_idx */\n\t\treturn (unsigned long *)vp_bitmap;\n\t}\n\n\tbitmap_zero(vcpu_bitmap, KVM_MAX_VCPUS);\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (test_bit(vcpu_to_hv_vcpu(vcpu)->vp_index,\n\t\t\t     (unsigned long *)vp_bitmap))\n\t\t\t__set_bit(i, vcpu_bitmap);\n\t}\n\treturn vcpu_bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_clear",
          "args": [
            "&hv_vcpu->tlb_flush"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_guest",
          "args": [
            "kvm",
            "ingpa + offsetof(struct hv_tlb_flush_ex,\n\t\t\t\t\t\t    hv_vp_set.bank_contents)",
            "sparse_banks",
            "sparse_banks_len"
          ],
          "line": 1410
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_guest_phys_system",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "5478-5485",
          "snippet": "static int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_weight",
          "args": [
            "(unsigned long *)&valid_bank_mask",
            "64"
          ],
          "line": 1403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_flush_tlb_ex",
          "args": [
            "flush_ex.hv_vp_set.valid_bank_mask",
            "flush_ex.hv_vp_set.format",
            "flush_ex.address_space",
            "flush_ex.flags"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kvm_read_guest(kvm, ingpa, &flush_ex,\n\t\t\t\t\t    sizeof(flush_ex))"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT_ULL",
          "args": [
            "0"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_flush_tlb",
          "args": [
            "flush.processor_mask",
            "flush.address_space",
            "flush.flags"
          ],
          "line": 1373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kvm_read_guest(kvm, ingpa, &flush, sizeof(flush))"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_BITMAP",
          "args": [
            "vcpu_bitmap",
            "KVM_MAX_VCPUS"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\n#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)\n\nstatic u64 kvm_hv_flush_tlb(struct kvm_vcpu *current_vcpu, u64 ingpa,\n\t\t\t    u16 rep_cnt, bool ex)\n{\n\tstruct kvm *kvm = current_vcpu->kvm;\n\tstruct kvm_vcpu_hv *hv_vcpu = &current_vcpu->arch.hyperv;\n\tstruct hv_tlb_flush_ex flush_ex;\n\tstruct hv_tlb_flush flush;\n\tu64 vp_bitmap[KVM_HV_MAX_SPARSE_VCPU_SET_BITS];\n\tDECLARE_BITMAP(vcpu_bitmap, KVM_MAX_VCPUS);\n\tunsigned long *vcpu_mask;\n\tu64 valid_bank_mask;\n\tu64 sparse_banks[64];\n\tint sparse_banks_len;\n\tbool all_cpus;\n\n\tif (!ex) {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &flush, sizeof(flush))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_flush_tlb(flush.processor_mask,\n\t\t\t\t       flush.address_space, flush.flags);\n\n\t\tvalid_bank_mask = BIT_ULL(0);\n\t\tsparse_banks[0] = flush.processor_mask;\n\n\t\t/*\n\t\t * Work around possible WS2012 bug: it sends hypercalls\n\t\t * with processor_mask = 0x0 and HV_FLUSH_ALL_PROCESSORS clear,\n\t\t * while also expecting us to flush something and crashing if\n\t\t * we don't. Let's treat processor_mask == 0 same as\n\t\t * HV_FLUSH_ALL_PROCESSORS.\n\t\t */\n\t\tall_cpus = (flush.flags & HV_FLUSH_ALL_PROCESSORS) ||\n\t\t\tflush.processor_mask == 0;\n\t} else {\n\t\tif (unlikely(kvm_read_guest(kvm, ingpa, &flush_ex,\n\t\t\t\t\t    sizeof(flush_ex))))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\n\t\ttrace_kvm_hv_flush_tlb_ex(flush_ex.hv_vp_set.valid_bank_mask,\n\t\t\t\t\t  flush_ex.hv_vp_set.format,\n\t\t\t\t\t  flush_ex.address_space,\n\t\t\t\t\t  flush_ex.flags);\n\n\t\tvalid_bank_mask = flush_ex.hv_vp_set.valid_bank_mask;\n\t\tall_cpus = flush_ex.hv_vp_set.format !=\n\t\t\tHV_GENERIC_SET_SPARSE_4K;\n\n\t\tsparse_banks_len =\n\t\t\tbitmap_weight((unsigned long *)&valid_bank_mask, 64) *\n\t\t\tsizeof(sparse_banks[0]);\n\n\t\tif (!sparse_banks_len && !all_cpus)\n\t\t\tgoto ret_success;\n\n\t\tif (!all_cpus &&\n\t\t    kvm_read_guest(kvm,\n\t\t\t\t   ingpa + offsetof(struct hv_tlb_flush_ex,\n\t\t\t\t\t\t    hv_vp_set.bank_contents),\n\t\t\t\t   sparse_banks,\n\t\t\t\t   sparse_banks_len))\n\t\t\treturn HV_STATUS_INVALID_HYPERCALL_INPUT;\n\t}\n\n\tcpumask_clear(&hv_vcpu->tlb_flush);\n\n\tvcpu_mask = all_cpus ? NULL :\n\t\tsparse_set_to_vcpu_mask(kvm, sparse_banks, valid_bank_mask,\n\t\t\t\t\tvp_bitmap, vcpu_bitmap);\n\n\t/*\n\t * vcpu->arch.cr3 may not be up-to-date for running vCPUs so we can't\n\t * analyze it here, flush TLB regardless of the specified address space.\n\t */\n\tkvm_make_vcpus_request_mask(kvm,\n\t\t\t\t    KVM_REQ_TLB_FLUSH | KVM_REQUEST_NO_WAKEUP,\n\t\t\t\t    vcpu_mask, &hv_vcpu->tlb_flush);\n\nret_success:\n\t/* We always do full TLB flush, set rep_done = rep_cnt. */\n\treturn (u64)HV_STATUS_SUCCESS |\n\t\t((u64)rep_cnt << HV_HYPERCALL_REP_COMP_OFFSET);\n}"
  },
  {
    "function_name": "sparse_set_to_vcpu_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1326-1352",
    "snippet": "static __always_inline unsigned long *sparse_set_to_vcpu_mask(\n\tstruct kvm *kvm, u64 *sparse_banks, u64 valid_bank_mask,\n\tu64 *vp_bitmap, unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tint i, bank, sbank = 0;\n\n\tmemset(vp_bitmap, 0,\n\t       KVM_HV_MAX_SPARSE_VCPU_SET_BITS * sizeof(*vp_bitmap));\n\tfor_each_set_bit(bank, (unsigned long *)&valid_bank_mask,\n\t\t\t KVM_HV_MAX_SPARSE_VCPU_SET_BITS)\n\t\tvp_bitmap[bank] = sparse_banks[sbank++];\n\n\tif (likely(!atomic_read(&hv->num_mismatched_vp_indexes))) {\n\t\t/* for all vcpus vp_index == vcpu_idx */\n\t\treturn (unsigned long *)vp_bitmap;\n\t}\n\n\tbitmap_zero(vcpu_bitmap, KVM_MAX_VCPUS);\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (test_bit(vcpu_to_hv_vcpu(vcpu)->vp_index,\n\t\t\t     (unsigned long *)vp_bitmap))\n\t\t\t__set_bit(i, vcpu_bitmap);\n\t}\n\treturn vcpu_bitmap;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [
      "#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "i",
            "vcpu_bitmap"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vcpu_to_hv_vcpu(vcpu)->vp_index",
            "(unsigned long *)vp_bitmap"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "26-29",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "vcpu_bitmap",
            "KVM_MAX_VCPUS"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!atomic_read(&hv->num_mismatched_vp_indexes)"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&hv->num_mismatched_vp_indexes"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "bank",
            "(unsigned long *)&valid_bank_mask",
            "KVM_HV_MAX_SPARSE_VCPU_SET_BITS"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vp_bitmap",
            "0",
            "KVM_HV_MAX_SPARSE_VCPU_SET_BITS * sizeof(*vp_bitmap)"
          ],
          "line": 1334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\n#define KVM_HV_MAX_SPARSE_VCPU_SET_BITS DIV_ROUND_UP(KVM_MAX_VCPUS, 64)\n\nstatic __always_inline unsigned long *sparse_set_to_vcpu_mask(\n\tstruct kvm *kvm, u64 *sparse_banks, u64 valid_bank_mask,\n\tu64 *vp_bitmap, unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tint i, bank, sbank = 0;\n\n\tmemset(vp_bitmap, 0,\n\t       KVM_HV_MAX_SPARSE_VCPU_SET_BITS * sizeof(*vp_bitmap));\n\tfor_each_set_bit(bank, (unsigned long *)&valid_bank_mask,\n\t\t\t KVM_HV_MAX_SPARSE_VCPU_SET_BITS)\n\t\tvp_bitmap[bank] = sparse_banks[sbank++];\n\n\tif (likely(!atomic_read(&hv->num_mismatched_vp_indexes))) {\n\t\t/* for all vcpus vp_index == vcpu_idx */\n\t\treturn (unsigned long *)vp_bitmap;\n\t}\n\n\tbitmap_zero(vcpu_bitmap, KVM_MAX_VCPUS);\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (test_bit(vcpu_to_hv_vcpu(vcpu)->vp_index,\n\t\t\t     (unsigned long *)vp_bitmap))\n\t\t\t__set_bit(i, vcpu_bitmap);\n\t}\n\treturn vcpu_bitmap;\n}"
  },
  {
    "function_name": "kvm_hv_get_msr_common",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1313-1324",
    "snippet": "int kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\tr = kvm_hv_get_msr_pw(vcpu, msr, pdata);\n\t\tmutex_unlock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_get_msr(vcpu, msr, pdata, host);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_get_msr",
          "args": [
            "vcpu",
            "msr",
            "pdata",
            "host"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_get_msr_common",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1313-1324",
          "snippet": "int kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\tr = kvm_hv_get_msr_pw(vcpu, msr, pdata);\n\t\tmutex_unlock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_get_msr(vcpu, msr, pdata, host);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcpu->kvm->arch.hyperv.hv_lock"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_get_msr_pw",
          "args": [
            "vcpu",
            "msr",
            "pdata"
          ],
          "line": 1319
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_get_msr_pw",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1193-1237",
          "snippet": "static int kvm_hv_get_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = hv->hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = hv->hv_hypercall;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tdata = get_time_ref_counter(kvm);\n\t\tbreak;\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\tdata = hv->hv_tsc_page;\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_get_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t pdata);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_get_crash_ctl(vcpu, pdata);\n\tcase HV_X64_MSR_RESET:\n\t\tdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\t\tdata = hv->hv_reenlightenment_control;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\t\tdata = hv->hv_tsc_emulation_control;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tdata = hv->hv_tsc_emulation_status;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_get_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = hv->hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = hv->hv_hypercall;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tdata = get_time_ref_counter(kvm);\n\t\tbreak;\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\tdata = hv->hv_tsc_page;\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_get_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t pdata);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_get_crash_ctl(vcpu, pdata);\n\tcase HV_X64_MSR_RESET:\n\t\tdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\t\tdata = hv->hv_reenlightenment_control;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\t\tdata = hv->hv_tsc_emulation_control;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tdata = hv->hv_tsc_emulation_status;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcpu->kvm->arch.hyperv.hv_lock"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_partition_wide",
          "args": [
            "msr"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_partition_wide",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "788-808",
          "snippet": "static bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata, bool host)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\tr = kvm_hv_get_msr_pw(vcpu, msr, pdata);\n\t\tmutex_unlock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_get_msr(vcpu, msr, pdata, host);\n}"
  },
  {
    "function_name": "kvm_hv_set_msr_common",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1300-1311",
    "snippet": "int kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\tr = kvm_hv_set_msr_pw(vcpu, msr, data, host);\n\t\tmutex_unlock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_set_msr(vcpu, msr, data, host);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_set_msr",
          "args": [
            "vcpu",
            "msr",
            "data",
            "host"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_set_msr_common",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1300-1311",
          "snippet": "int kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\tr = kvm_hv_set_msr_pw(vcpu, msr, data, host);\n\t\tmutex_unlock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_set_msr(vcpu, msr, data, host);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&vcpu->kvm->arch.hyperv.hv_lock"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_set_msr_pw",
          "args": [
            "vcpu",
            "msr",
            "data",
            "host"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_set_msr_pw",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "996-1070",
          "snippet": "static int kvm_hv_set_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data,\n\t\t\t     bool host)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\thv->hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\thv->hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\thv->hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops.patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\thv->hv_hypercall = data;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\thv->hv_tsc_page = data;\n\t\tif (hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_set_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t data);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_set_crash_ctl(vcpu, data, host);\n\tcase HV_X64_MSR_RESET:\n\t\tif (data == 1) {\n\t\t\tvcpu_debug(vcpu, \"hyper-v reset requested\\n\");\n\t\t\tkvm_make_request(KVM_REQ_HV_RESET, vcpu);\n\t\t}\n\t\tbreak;\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\t\thv->hv_reenlightenment_control = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\t\thv->hv_tsc_emulation_control = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\thv->hv_tsc_emulation_status = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\t/* read-only, but still ignore it if host-initiated */\n\t\tif (!host)\n\t\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_set_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data,\n\t\t\t     bool host)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\thv->hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\thv->hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\thv->hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops.patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\thv->hv_hypercall = data;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\thv->hv_tsc_page = data;\n\t\tif (hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_set_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t data);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_set_crash_ctl(vcpu, data, host);\n\tcase HV_X64_MSR_RESET:\n\t\tif (data == 1) {\n\t\t\tvcpu_debug(vcpu, \"hyper-v reset requested\\n\");\n\t\t\tkvm_make_request(KVM_REQ_HV_RESET, vcpu);\n\t\t}\n\t\tbreak;\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\t\thv->hv_reenlightenment_control = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\t\thv->hv_tsc_emulation_control = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\thv->hv_tsc_emulation_status = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\t/* read-only, but still ignore it if host-initiated */\n\t\tif (!host)\n\t\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&vcpu->kvm->arch.hyperv.hv_lock"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_partition_wide",
          "args": [
            "msr"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_partition_wide",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "788-808",
          "snippet": "static bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_set_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tif (kvm_hv_msr_partition_wide(msr)) {\n\t\tint r;\n\n\t\tmutex_lock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\tr = kvm_hv_set_msr_pw(vcpu, msr, data, host);\n\t\tmutex_unlock(&vcpu->kvm->arch.hyperv.hv_lock);\n\t\treturn r;\n\t} else\n\t\treturn kvm_hv_set_msr(vcpu, msr, data, host);\n}"
  },
  {
    "function_name": "kvm_hv_get_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1239-1298",
    "snippet": "static int kvm_hv_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata,\n\t\t\t  bool host)\n{\n\tu64 data = 0;\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX:\n\t\tdata = hv_vcpu->vp_index;\n\t\tbreak;\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tcase HV_X64_MSR_VP_ASSIST_PAGE:\n\t\tdata = hv_vcpu->hv_vapic;\n\t\tbreak;\n\tcase HV_X64_MSR_VP_RUNTIME:\n\t\tdata = current_task_runtime_100ns() + hv_vcpu->runtime_offset;\n\t\tbreak;\n\tcase HV_X64_MSR_SCONTROL:\n\tcase HV_X64_MSR_SVERSION:\n\tcase HV_X64_MSR_SIEFP:\n\tcase HV_X64_MSR_SIMP:\n\tcase HV_X64_MSR_EOM:\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\treturn synic_get_msr(vcpu_to_synic(vcpu), msr, pdata, host);\n\tcase HV_X64_MSR_STIMER0_CONFIG:\n\tcase HV_X64_MSR_STIMER1_CONFIG:\n\tcase HV_X64_MSR_STIMER2_CONFIG:\n\tcase HV_X64_MSR_STIMER3_CONFIG: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\n\n\t\treturn stimer_get_config(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\t pdata);\n\t}\n\tcase HV_X64_MSR_STIMER0_COUNT:\n\tcase HV_X64_MSR_STIMER1_COUNT:\n\tcase HV_X64_MSR_STIMER2_COUNT:\n\tcase HV_X64_MSR_STIMER3_COUNT: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\n\n\t\treturn stimer_get_count(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\tpdata);\n\t}\n\tcase HV_X64_MSR_TSC_FREQUENCY:\n\t\tdata = (u64)vcpu->arch.virtual_tsc_khz * 1000;\n\t\tbreak;\n\tcase HV_X64_MSR_APIC_FREQUENCY:\n\t\tdata = APIC_BUS_FREQUENCY;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"Hyper-V unhandled rdmsr: 0x%x\\n\"",
            "msr"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_get_count",
          "args": [
            "vcpu_to_stimer(vcpu, timer_index)",
            "pdata"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_get_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "559-563",
          "snippet": "static int stimer_get_count(struct kvm_vcpu_hv_stimer *stimer, u64 *pcount)\n{\n\t*pcount = stimer->count;\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_get_count(struct kvm_vcpu_hv_stimer *stimer, u64 *pcount)\n{\n\t*pcount = stimer->count;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_stimer",
          "args": [
            "vcpu",
            "timer_index"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_stimer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "68-72",
          "snippet": "static inline struct kvm_vcpu_hv_stimer *vcpu_to_stimer(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\tint timer_index)\n{\n\treturn &vcpu_to_hv_vcpu(vcpu)->stimer[timer_index];\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_stimer *vcpu_to_stimer(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\tint timer_index)\n{\n\treturn &vcpu_to_hv_vcpu(vcpu)->stimer[timer_index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_get_config",
          "args": [
            "vcpu_to_stimer(vcpu, timer_index)",
            "pdata"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_get_config",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "553-557",
          "snippet": "static int stimer_get_config(struct kvm_vcpu_hv_stimer *stimer, u64 *pconfig)\n{\n\t*pconfig = stimer->config.as_uint64;\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_get_config(struct kvm_vcpu_hv_stimer *stimer, u64 *pconfig)\n{\n\t*pconfig = stimer->config.as_uint64;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_get_msr",
          "args": [
            "vcpu_to_synic(vcpu)",
            "msr",
            "pdata",
            "host"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "269-302",
          "snippet": "static int synic_get_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 *pdata,\n\t\t\t bool host)\n{\n\tint ret;\n\n\tif (!synic->active && !host)\n\t\treturn 1;\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\t*pdata = synic->control;\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\t*pdata = synic->version;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\t*pdata = synic->evt_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\t*pdata = synic->msg_page;\n\t\tbreak;\n\tcase HV_X64_MSR_EOM:\n\t\t*pdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\t*pdata = atomic64_read(&synic->sint[msr - HV_X64_MSR_SINT0]);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_get_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 *pdata,\n\t\t\t bool host)\n{\n\tint ret;\n\n\tif (!synic->active && !host)\n\t\treturn 1;\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\t*pdata = synic->control;\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\t*pdata = synic->version;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\t*pdata = synic->evt_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\t*pdata = synic->msg_page;\n\t\tbreak;\n\tcase HV_X64_MSR_EOM:\n\t\t*pdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\t*pdata = atomic64_read(&synic->sint[msr - HV_X64_MSR_SINT0]);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 1267
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "39-42",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_task_runtime_100ns",
          "args": [],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "current_task_runtime_100ns",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1073-1080",
          "snippet": "static u64 current_task_runtime_100ns(void)\n{\n\tu64 utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\n\treturn div_u64(utime + stime, 100);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 current_task_runtime_100ns(void)\n{\n\tu64 utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\n\treturn div_u64(utime + stime, 100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_vapic_msr_read",
          "args": [
            "vcpu",
            "APIC_TASKPRI",
            "pdata"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_vapic_msr_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2729-2745",
          "snippet": "int kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_hv_vapic_msr_read(struct kvm_vcpu *vcpu, u32 reg, u64 *data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tu32 low, high = 0;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\tif (kvm_lapic_reg_read(apic, reg, 4, &low))\n\t\treturn 1;\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_read(apic, APIC_ICR2, 4, &high);\n\n\t*data = (((u64)high) << 32) | low;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_get_msr(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata,\n\t\t\t  bool host)\n{\n\tu64 data = 0;\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX:\n\t\tdata = hv_vcpu->vp_index;\n\t\tbreak;\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_EOI, pdata);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_ICR, pdata);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_read(vcpu, APIC_TASKPRI, pdata);\n\tcase HV_X64_MSR_VP_ASSIST_PAGE:\n\t\tdata = hv_vcpu->hv_vapic;\n\t\tbreak;\n\tcase HV_X64_MSR_VP_RUNTIME:\n\t\tdata = current_task_runtime_100ns() + hv_vcpu->runtime_offset;\n\t\tbreak;\n\tcase HV_X64_MSR_SCONTROL:\n\tcase HV_X64_MSR_SVERSION:\n\tcase HV_X64_MSR_SIEFP:\n\tcase HV_X64_MSR_SIMP:\n\tcase HV_X64_MSR_EOM:\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\treturn synic_get_msr(vcpu_to_synic(vcpu), msr, pdata, host);\n\tcase HV_X64_MSR_STIMER0_CONFIG:\n\tcase HV_X64_MSR_STIMER1_CONFIG:\n\tcase HV_X64_MSR_STIMER2_CONFIG:\n\tcase HV_X64_MSR_STIMER3_CONFIG: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\n\n\t\treturn stimer_get_config(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\t pdata);\n\t}\n\tcase HV_X64_MSR_STIMER0_COUNT:\n\tcase HV_X64_MSR_STIMER1_COUNT:\n\tcase HV_X64_MSR_STIMER2_COUNT:\n\tcase HV_X64_MSR_STIMER3_COUNT: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\n\n\t\treturn stimer_get_count(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\tpdata);\n\t}\n\tcase HV_X64_MSR_TSC_FREQUENCY:\n\t\tdata = (u64)vcpu->arch.virtual_tsc_khz * 1000;\n\t\tbreak;\n\tcase HV_X64_MSR_APIC_FREQUENCY:\n\t\tdata = APIC_BUS_FREQUENCY;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\t*pdata = data;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_get_msr_pw",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1193-1237",
    "snippet": "static int kvm_hv_get_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = hv->hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = hv->hv_hypercall;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tdata = get_time_ref_counter(kvm);\n\t\tbreak;\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\tdata = hv->hv_tsc_page;\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_get_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t pdata);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_get_crash_ctl(vcpu, pdata);\n\tcase HV_X64_MSR_RESET:\n\t\tdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\t\tdata = hv->hv_reenlightenment_control;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\t\tdata = hv->hv_tsc_emulation_control;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tdata = hv->hv_tsc_emulation_status;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"Hyper-V unhandled rdmsr: 0x%x\\n\"",
            "msr"
          ],
          "line": 1231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_get_crash_ctl",
          "args": [
            "vcpu",
            "pdata"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_get_crash_ctl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "823-829",
          "snippet": "static int kvm_hv_msr_get_crash_ctl(struct kvm_vcpu *vcpu, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\t*pdata = hv->hv_crash_ctl;\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_get_crash_ctl(struct kvm_vcpu *vcpu, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\t*pdata = hv->hv_crash_ctl;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_get_crash_data",
          "args": [
            "vcpu",
            "msr - HV_X64_MSR_CRASH_P0",
            "pdata"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_get_crash_data",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "810-821",
          "snippet": "static int kvm_hv_msr_get_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\tsize_t size = ARRAY_SIZE(hv->hv_crash_param);\n\n\tif (WARN_ON_ONCE(index >= size))\n\t\treturn -EINVAL;\n\n\t*pdata = hv->hv_crash_param[array_index_nospec(index, size)];\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_get_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\tsize_t size = ARRAY_SIZE(hv->hv_crash_param);\n\n\tif (WARN_ON_ONCE(index >= size))\n\t\treturn -EINVAL;\n\n\t*pdata = hv->hv_crash_param[array_index_nospec(index, size)];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_time_ref_counter",
          "args": [
            "kvm"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "get_time_ref_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "397-414",
          "snippet": "static u64 get_time_ref_counter(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tu64 tsc;\n\n\t/*\n\t * The guest has not set up the TSC page or the clock isn't\n\t * stable, fall back to get_kvmclock_ns.\n\t */\n\tif (!hv->tsc_ref.tsc_sequence)\n\t\treturn div_u64(get_kvmclock_ns(kvm), 100);\n\n\tvcpu = kvm_get_vcpu(kvm, 0);\n\ttsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\treturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\n\t\t+ hv->tsc_ref.tsc_offset;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 get_time_ref_counter(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tu64 tsc;\n\n\t/*\n\t * The guest has not set up the TSC page or the clock isn't\n\t * stable, fall back to get_kvmclock_ns.\n\t */\n\tif (!hv->tsc_ref.tsc_sequence)\n\t\treturn div_u64(get_kvmclock_ns(kvm), 100);\n\n\tvcpu = kvm_get_vcpu(kvm, 0);\n\ttsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\treturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\n\t\t+ hv->tsc_ref.tsc_offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_get_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)\n{\n\tu64 data = 0;\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\tdata = hv->hv_guest_os_id;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL:\n\t\tdata = hv->hv_hypercall;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\tdata = get_time_ref_counter(kvm);\n\t\tbreak;\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\tdata = hv->hv_tsc_page;\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_get_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t pdata);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_get_crash_ctl(vcpu, pdata);\n\tcase HV_X64_MSR_RESET:\n\t\tdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\t\tdata = hv->hv_reenlightenment_control;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\t\tdata = hv->hv_tsc_emulation_control;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tdata = hv->hv_tsc_emulation_status;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled rdmsr: 0x%x\\n\", msr);\n\t\treturn 1;\n\t}\n\n\t*pdata = data;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_set_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1082-1191",
    "snippet": "static int kvm_hv_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\t\tint vcpu_idx = kvm_vcpu_get_idx(vcpu);\n\t\tu32 new_vp_index = (u32)data;\n\n\t\tif (!host || new_vp_index >= KVM_MAX_VCPUS)\n\t\t\treturn 1;\n\n\t\tif (new_vp_index == hv_vcpu->vp_index)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * The VP index is initialized to vcpu_index by\n\t\t * kvm_hv_vcpu_postcreate so they initially match.  Now the\n\t\t * VP index is changing, adjust num_mismatched_vp_indexes if\n\t\t * it now matches or no longer matches vcpu_idx.\n\t\t */\n\t\tif (hv_vcpu->vp_index == vcpu_idx)\n\t\t\tatomic_inc(&hv->num_mismatched_vp_indexes);\n\t\telse if (new_vp_index == vcpu_idx)\n\t\t\tatomic_dec(&hv->num_mismatched_vp_indexes);\n\n\t\thv_vcpu->vp_index = new_vp_index;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_VP_ASSIST_PAGE: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\n\t\tif (!(data & HV_X64_MSR_VP_ASSIST_PAGE_ENABLE)) {\n\t\t\thv_vcpu->hv_vapic = data;\n\t\t\tif (kvm_lapic_enable_pv_eoi(vcpu, 0, 0))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_VP_ASSIST_PAGE_ADDRESS_SHIFT;\n\t\taddr = kvm_vcpu_gfn_to_hva(vcpu, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * Clear apic_assist portion of struct hv_vp_assist_page\n\t\t * only, there can be valuable data in the rest which needs\n\t\t * to be preserved e.g. on migration.\n\t\t */\n\t\tif (__clear_user((void __user *)addr, sizeof(u32)))\n\t\t\treturn 1;\n\t\thv_vcpu->hv_vapic = data;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu,\n\t\t\t\t\t    gfn_to_gpa(gfn) | KVM_MSR_ENABLED,\n\t\t\t\t\t    sizeof(struct hv_vp_assist_page)))\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data);\n\tcase HV_X64_MSR_VP_RUNTIME:\n\t\tif (!host)\n\t\t\treturn 1;\n\t\thv_vcpu->runtime_offset = data - current_task_runtime_100ns();\n\t\tbreak;\n\tcase HV_X64_MSR_SCONTROL:\n\tcase HV_X64_MSR_SVERSION:\n\tcase HV_X64_MSR_SIEFP:\n\tcase HV_X64_MSR_SIMP:\n\tcase HV_X64_MSR_EOM:\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\treturn synic_set_msr(vcpu_to_synic(vcpu), msr, data, host);\n\tcase HV_X64_MSR_STIMER0_CONFIG:\n\tcase HV_X64_MSR_STIMER1_CONFIG:\n\tcase HV_X64_MSR_STIMER2_CONFIG:\n\tcase HV_X64_MSR_STIMER3_CONFIG: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\n\n\t\treturn stimer_set_config(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\t data, host);\n\t}\n\tcase HV_X64_MSR_STIMER0_COUNT:\n\tcase HV_X64_MSR_STIMER1_COUNT:\n\tcase HV_X64_MSR_STIMER2_COUNT:\n\tcase HV_X64_MSR_STIMER3_COUNT: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\n\n\t\treturn stimer_set_count(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\tdata, host);\n\t}\n\tcase HV_X64_MSR_TSC_FREQUENCY:\n\tcase HV_X64_MSR_APIC_FREQUENCY:\n\t\t/* read-only, but still ignore it if host-initiated */\n\t\tif (!host)\n\t\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"Hyper-V unhandled wrmsr: 0x%x data 0x%llx\\n\"",
            "msr",
            "data"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_set_count",
          "args": [
            "vcpu_to_stimer(vcpu, timer_index)",
            "data",
            "host"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_set_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "534-551",
          "snippet": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\ttrace_kvm_hv_stimer_set_count(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\ttrace_kvm_hv_stimer_set_count(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_stimer",
          "args": [
            "vcpu",
            "timer_index"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_stimer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "68-72",
          "snippet": "static inline struct kvm_vcpu_hv_stimer *vcpu_to_stimer(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\tint timer_index)\n{\n\treturn &vcpu_to_hv_vcpu(vcpu)->stimer[timer_index];\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_stimer *vcpu_to_stimer(struct kvm_vcpu *vcpu,\n\t\t\t\t\t\t\tint timer_index)\n{\n\treturn &vcpu_to_hv_vcpu(vcpu)->stimer[timer_index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_set_config",
          "args": [
            "vcpu_to_stimer(vcpu, timer_index)",
            "data",
            "host"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_set_config",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "513-532",
          "snippet": "static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\n\ttrace_kvm_hv_stimer_set_config(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\n\ttrace_kvm_hv_stimer_set_config(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_set_msr",
          "args": [
            "vcpu_to_synic(vcpu)",
            "msr",
            "data",
            "host"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "synic_set_msr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "203-267",
          "snippet": "static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint ret;\n\n\tif (!synic->active && !host)\n\t\treturn 1;\n\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif ((data & HV_SYNIC_SIMP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint ret;\n\n\tif (!synic->active && !host)\n\t\treturn 1;\n\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif ((data & HV_SYNIC_SIMP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "39-42",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_task_runtime_100ns",
          "args": [],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "current_task_runtime_100ns",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "1073-1080",
          "snippet": "static u64 current_task_runtime_100ns(void)\n{\n\tu64 utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\n\treturn div_u64(utime + stime, 100);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 current_task_runtime_100ns(void)\n{\n\tu64 utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\n\treturn div_u64(utime + stime, 100);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_vapic_msr_write",
          "args": [
            "vcpu",
            "APIC_TASKPRI",
            "data"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_vapic_msr_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2716-2727",
          "snippet": "int kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_hv_vapic_msr_write(struct kvm_vcpu *vcpu, u32 reg, u64 data)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn 1;\n\n\t/* if this is ICR write vector before command */\n\tif (reg == APIC_ICR)\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, (u32)(data >> 32));\n\treturn kvm_lapic_reg_write(apic, reg, (u32)data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_enable_pv_eoi",
          "args": [
            "vcpu",
            "gfn_to_gpa(gfn) | KVM_MSR_ENABLED",
            "sizeof(struct hv_vp_assist_page)"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_enable_pv_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "2747-2766",
          "snippet": "int kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tstruct gfn_to_hva_cache *ghc = &vcpu->arch.pv_eoi.data;\n\tunsigned long new_len;\n\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\n\tif (addr == ghc->gpa && len <= ghc->len)\n\t\tnew_len = ghc->len;\n\telse\n\t\tnew_len = len;\n\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc, addr, new_len);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nint kvm_lapic_enable_pv_eoi(struct kvm_vcpu *vcpu, u64 data, unsigned long len)\n{\n\tu64 addr = data & ~KVM_MSR_ENABLED;\n\tstruct gfn_to_hva_cache *ghc = &vcpu->arch.pv_eoi.data;\n\tunsigned long new_len;\n\n\tif (!IS_ALIGNED(addr, 4))\n\t\treturn 1;\n\n\tvcpu->arch.pv_eoi.msr_val = data;\n\tif (!pv_eoi_enabled(vcpu))\n\t\treturn 0;\n\n\tif (addr == ghc->gpa && len <= ghc->len)\n\t\tnew_len = ghc->len;\n\telse\n\t\tnew_len = len;\n\n\treturn kvm_gfn_to_hva_cache_init(vcpu->kvm, ghc, addr, new_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_mark_page_dirty",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_user",
          "args": [
            "(void __user *)addr",
            "sizeof(u32)"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_error_hva",
          "args": [
            "addr"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_gfn_to_hva",
          "args": [
            "vcpu",
            "gfn"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&hv->num_mismatched_vp_indexes"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&hv->num_mismatched_vp_indexes"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_get_idx",
          "args": [
            "vcpu"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_set_msr(struct kvm_vcpu *vcpu, u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_VP_INDEX: {\n\t\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\t\tint vcpu_idx = kvm_vcpu_get_idx(vcpu);\n\t\tu32 new_vp_index = (u32)data;\n\n\t\tif (!host || new_vp_index >= KVM_MAX_VCPUS)\n\t\t\treturn 1;\n\n\t\tif (new_vp_index == hv_vcpu->vp_index)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * The VP index is initialized to vcpu_index by\n\t\t * kvm_hv_vcpu_postcreate so they initially match.  Now the\n\t\t * VP index is changing, adjust num_mismatched_vp_indexes if\n\t\t * it now matches or no longer matches vcpu_idx.\n\t\t */\n\t\tif (hv_vcpu->vp_index == vcpu_idx)\n\t\t\tatomic_inc(&hv->num_mismatched_vp_indexes);\n\t\telse if (new_vp_index == vcpu_idx)\n\t\t\tatomic_dec(&hv->num_mismatched_vp_indexes);\n\n\t\thv_vcpu->vp_index = new_vp_index;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_VP_ASSIST_PAGE: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\n\t\tif (!(data & HV_X64_MSR_VP_ASSIST_PAGE_ENABLE)) {\n\t\t\thv_vcpu->hv_vapic = data;\n\t\t\tif (kvm_lapic_enable_pv_eoi(vcpu, 0, 0))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_VP_ASSIST_PAGE_ADDRESS_SHIFT;\n\t\taddr = kvm_vcpu_gfn_to_hva(vcpu, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * Clear apic_assist portion of struct hv_vp_assist_page\n\t\t * only, there can be valuable data in the rest which needs\n\t\t * to be preserved e.g. on migration.\n\t\t */\n\t\tif (__clear_user((void __user *)addr, sizeof(u32)))\n\t\t\treturn 1;\n\t\thv_vcpu->hv_vapic = data;\n\t\tkvm_vcpu_mark_page_dirty(vcpu, gfn);\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu,\n\t\t\t\t\t    gfn_to_gpa(gfn) | KVM_MSR_ENABLED,\n\t\t\t\t\t    sizeof(struct hv_vp_assist_page)))\n\t\t\treturn 1;\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_EOI:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_EOI, data);\n\tcase HV_X64_MSR_ICR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_ICR, data);\n\tcase HV_X64_MSR_TPR:\n\t\treturn kvm_hv_vapic_msr_write(vcpu, APIC_TASKPRI, data);\n\tcase HV_X64_MSR_VP_RUNTIME:\n\t\tif (!host)\n\t\t\treturn 1;\n\t\thv_vcpu->runtime_offset = data - current_task_runtime_100ns();\n\t\tbreak;\n\tcase HV_X64_MSR_SCONTROL:\n\tcase HV_X64_MSR_SVERSION:\n\tcase HV_X64_MSR_SIEFP:\n\tcase HV_X64_MSR_SIMP:\n\tcase HV_X64_MSR_EOM:\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\treturn synic_set_msr(vcpu_to_synic(vcpu), msr, data, host);\n\tcase HV_X64_MSR_STIMER0_CONFIG:\n\tcase HV_X64_MSR_STIMER1_CONFIG:\n\tcase HV_X64_MSR_STIMER2_CONFIG:\n\tcase HV_X64_MSR_STIMER3_CONFIG: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_CONFIG)/2;\n\n\t\treturn stimer_set_config(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\t data, host);\n\t}\n\tcase HV_X64_MSR_STIMER0_COUNT:\n\tcase HV_X64_MSR_STIMER1_COUNT:\n\tcase HV_X64_MSR_STIMER2_COUNT:\n\tcase HV_X64_MSR_STIMER3_COUNT: {\n\t\tint timer_index = (msr - HV_X64_MSR_STIMER0_COUNT)/2;\n\n\t\treturn stimer_set_count(vcpu_to_stimer(vcpu, timer_index),\n\t\t\t\t\tdata, host);\n\t}\n\tcase HV_X64_MSR_TSC_FREQUENCY:\n\tcase HV_X64_MSR_APIC_FREQUENCY:\n\t\t/* read-only, but still ignore it if host-initiated */\n\t\tif (!host)\n\t\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "current_task_runtime_100ns",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "1073-1080",
    "snippet": "static u64 current_task_runtime_100ns(void)\n{\n\tu64 utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\n\treturn div_u64(utime + stime, 100);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "utime + stime",
            "100"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime_adjusted",
          "args": [
            "current",
            "&utime",
            "&stime"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 current_task_runtime_100ns(void)\n{\n\tu64 utime, stime;\n\n\ttask_cputime_adjusted(current, &utime, &stime);\n\n\treturn div_u64(utime + stime, 100);\n}"
  },
  {
    "function_name": "kvm_hv_set_msr_pw",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "996-1070",
    "snippet": "static int kvm_hv_set_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data,\n\t\t\t     bool host)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\thv->hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\thv->hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\thv->hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops.patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\thv->hv_hypercall = data;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\thv->hv_tsc_page = data;\n\t\tif (hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_set_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t data);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_set_crash_ctl(vcpu, data, host);\n\tcase HV_X64_MSR_RESET:\n\t\tif (data == 1) {\n\t\t\tvcpu_debug(vcpu, \"hyper-v reset requested\\n\");\n\t\t\tkvm_make_request(KVM_REQ_HV_RESET, vcpu);\n\t\t}\n\t\tbreak;\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\t\thv->hv_reenlightenment_control = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\t\thv->hv_tsc_emulation_control = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\thv->hv_tsc_emulation_status = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\t/* read-only, but still ignore it if host-initiated */\n\t\tif (!host)\n\t\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"Hyper-V unhandled wrmsr: 0x%x data 0x%llx\\n\"",
            "msr",
            "data"
          ],
          "line": 1065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_HV_RESET",
            "vcpu"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_debug",
          "args": [
            "vcpu",
            "\"hyper-v reset requested\\n\""
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_set_crash_ctl",
          "args": [
            "vcpu",
            "data",
            "host"
          ],
          "line": 1043
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_set_crash_ctl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "831-852",
          "snippet": "static int kvm_hv_msr_set_crash_ctl(struct kvm_vcpu *vcpu, u64 data, bool host)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (host)\n\t\thv->hv_crash_ctl = data & HV_CRASH_CTL_CRASH_NOTIFY;\n\n\tif (!host && (data & HV_CRASH_CTL_CRASH_NOTIFY)) {\n\n\t\tvcpu_debug(vcpu, \"hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\\n\",\n\t\t\t  hv->hv_crash_param[0],\n\t\t\t  hv->hv_crash_param[1],\n\t\t\t  hv->hv_crash_param[2],\n\t\t\t  hv->hv_crash_param[3],\n\t\t\t  hv->hv_crash_param[4]);\n\n\t\t/* Send notification about crash to user space */\n\t\tkvm_make_request(KVM_REQ_HV_CRASH, vcpu);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_set_crash_ctl(struct kvm_vcpu *vcpu, u64 data, bool host)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (host)\n\t\thv->hv_crash_ctl = data & HV_CRASH_CTL_CRASH_NOTIFY;\n\n\tif (!host && (data & HV_CRASH_CTL_CRASH_NOTIFY)) {\n\n\t\tvcpu_debug(vcpu, \"hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\\n\",\n\t\t\t  hv->hv_crash_param[0],\n\t\t\t  hv->hv_crash_param[1],\n\t\t\t  hv->hv_crash_param[2],\n\t\t\t  hv->hv_crash_param[3],\n\t\t\t  hv->hv_crash_param[4]);\n\n\t\t/* Send notification about crash to user space */\n\t\tkvm_make_request(KVM_REQ_HV_CRASH, vcpu);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_msr_set_crash_data",
          "args": [
            "vcpu",
            "msr - HV_X64_MSR_CRASH_P0",
            "data"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_msr_set_crash_data",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "854-865",
          "snippet": "static int kvm_hv_msr_set_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 data)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\tsize_t size = ARRAY_SIZE(hv->hv_crash_param);\n\n\tif (WARN_ON_ONCE(index >= size))\n\t\treturn -EINVAL;\n\n\thv->hv_crash_param[array_index_nospec(index, size)] = data;\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_set_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 data)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\tsize_t size = ARRAY_SIZE(hv->hv_crash_param);\n\n\tif (WARN_ON_ONCE(index >= size))\n\t\treturn -EINVAL;\n\n\thv->hv_crash_param[array_index_nospec(index, size)] = data;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_MASTERCLOCK_UPDATE",
            "vcpu"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_page_dirty",
          "args": [
            "kvm",
            "gfn"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__copy_to_user",
          "args": [
            "(void __user *)addr",
            "instructions",
            "4"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_x86_ops.patch_hypercall",
          "args": [
            "vcpu",
            "instructions"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_is_error_hva",
          "args": [
            "addr"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_hva",
          "args": [
            "kvm",
            "gfn"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_set_msr_pw(struct kvm_vcpu *vcpu, u32 msr, u64 data,\n\t\t\t     bool host)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\t\thv->hv_guest_os_id = data;\n\t\t/* setting guest os id to zero disables hypercall page */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\thv->hv_hypercall &= ~HV_X64_MSR_HYPERCALL_ENABLE;\n\t\tbreak;\n\tcase HV_X64_MSR_HYPERCALL: {\n\t\tu64 gfn;\n\t\tunsigned long addr;\n\t\tu8 instructions[4];\n\n\t\t/* if guest os id is not set hypercall should remain disabled */\n\t\tif (!hv->hv_guest_os_id)\n\t\t\tbreak;\n\t\tif (!(data & HV_X64_MSR_HYPERCALL_ENABLE)) {\n\t\t\thv->hv_hypercall = data;\n\t\t\tbreak;\n\t\t}\n\t\tgfn = data >> HV_X64_MSR_HYPERCALL_PAGE_ADDRESS_SHIFT;\n\t\taddr = gfn_to_hva(kvm, gfn);\n\t\tif (kvm_is_error_hva(addr))\n\t\t\treturn 1;\n\t\tkvm_x86_ops.patch_hypercall(vcpu, instructions);\n\t\t((unsigned char *)instructions)[3] = 0xc3; /* ret */\n\t\tif (__copy_to_user((void __user *)addr, instructions, 4))\n\t\t\treturn 1;\n\t\thv->hv_hypercall = data;\n\t\tmark_page_dirty(kvm, gfn);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\t\thv->hv_tsc_page = data;\n\t\tif (hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE)\n\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\t\tbreak;\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\t\treturn kvm_hv_msr_set_crash_data(vcpu,\n\t\t\t\t\t\t msr - HV_X64_MSR_CRASH_P0,\n\t\t\t\t\t\t data);\n\tcase HV_X64_MSR_CRASH_CTL:\n\t\treturn kvm_hv_msr_set_crash_ctl(vcpu, data, host);\n\tcase HV_X64_MSR_RESET:\n\t\tif (data == 1) {\n\t\t\tvcpu_debug(vcpu, \"hyper-v reset requested\\n\");\n\t\t\tkvm_make_request(KVM_REQ_HV_RESET, vcpu);\n\t\t}\n\t\tbreak;\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\t\thv->hv_reenlightenment_control = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\t\thv->hv_tsc_emulation_control = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\thv->hv_tsc_emulation_status = data;\n\t\tbreak;\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\t\t/* read-only, but still ignore it if host-initiated */\n\t\tif (!host)\n\t\t\treturn 1;\n\t\tbreak;\n\tdefault:\n\t\tvcpu_unimpl(vcpu, \"Hyper-V unhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t    msr, data);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_setup_tsc_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "936-994",
    "snippet": "void kvm_hv_setup_tsc_page(struct kvm *kvm,\n\t\t\t   struct pvclock_vcpu_time_info *hv_clock)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tu32 tsc_seq;\n\tu64 gfn;\n\n\tBUILD_BUG_ON(sizeof(tsc_seq) != sizeof(hv->tsc_ref.tsc_sequence));\n\tBUILD_BUG_ON(offsetof(HV_REFERENCE_TSC_PAGE, tsc_sequence) != 0);\n\n\tif (!(hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE))\n\t\treturn;\n\n\tmutex_lock(&kvm->arch.hyperv.hv_lock);\n\tif (!(hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE))\n\t\tgoto out_unlock;\n\n\tgfn = hv->hv_tsc_page >> HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT;\n\t/*\n\t * Because the TSC parameters only vary when there is a\n\t * change in the master clock, do not bother with caching.\n\t */\n\tif (unlikely(kvm_read_guest(kvm, gfn_to_gpa(gfn),\n\t\t\t\t    &tsc_seq, sizeof(tsc_seq))))\n\t\tgoto out_unlock;\n\n\t/*\n\t * While we're computing and writing the parameters, force the\n\t * guest to use the time reference count MSR.\n\t */\n\thv->tsc_ref.tsc_sequence = 0;\n\tif (kvm_write_guest(kvm, gfn_to_gpa(gfn),\n\t\t\t    &hv->tsc_ref, sizeof(hv->tsc_ref.tsc_sequence)))\n\t\tgoto out_unlock;\n\n\tif (!compute_tsc_page_parameters(hv_clock, &hv->tsc_ref))\n\t\tgoto out_unlock;\n\n\t/* Ensure sequence is zero before writing the rest of the struct.  */\n\tsmp_wmb();\n\tif (kvm_write_guest(kvm, gfn_to_gpa(gfn), &hv->tsc_ref, sizeof(hv->tsc_ref)))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Now switch to the TSC page mechanism by writing the sequence.\n\t */\n\ttsc_seq++;\n\tif (tsc_seq == 0xFFFFFFFF || tsc_seq == 0)\n\t\ttsc_seq = 1;\n\n\t/* Write the struct entirely before the non-zero sequence.  */\n\tsmp_wmb();\n\n\thv->tsc_ref.tsc_sequence = tsc_seq;\n\tkvm_write_guest(kvm, gfn_to_gpa(gfn),\n\t\t\t&hv->tsc_ref, sizeof(hv->tsc_ref.tsc_sequence));\nout_unlock:\n\tmutex_unlock(&kvm->arch.hyperv.hv_lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->arch.hyperv.hv_lock"
          ],
          "line": 993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest",
          "args": [
            "kvm",
            "gfn_to_gpa(gfn)",
            "&hv->tsc_ref",
            "sizeof(hv->tsc_ref.tsc_sequence)"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_write_guest",
          "args": [
            "kvm",
            "gfn_to_gpa(gfn)",
            "&hv->tsc_ref",
            "sizeof(hv->tsc_ref)"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compute_tsc_page_parameters",
          "args": [
            "hv_clock",
            "&hv->tsc_ref"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "compute_tsc_page_parameters",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "902-934",
          "snippet": "static bool compute_tsc_page_parameters(struct pvclock_vcpu_time_info *hv_clock,\n\t\t\t\t\tHV_REFERENCE_TSC_PAGE *tsc_ref)\n{\n\tu64 max_mul;\n\n\tif (!(hv_clock->flags & PVCLOCK_TSC_STABLE_BIT))\n\t\treturn false;\n\n\t/*\n\t * check if scale would overflow, if so we use the time ref counter\n\t *    tsc_to_system_mul * 2^(tsc_shift+32) / 100 >= 2^64\n\t *    tsc_to_system_mul / 100 >= 2^(32-tsc_shift)\n\t *    tsc_to_system_mul >= 100 * 2^(32-tsc_shift)\n\t */\n\tmax_mul = 100ull << (32 - hv_clock->tsc_shift);\n\tif (hv_clock->tsc_to_system_mul >= max_mul)\n\t\treturn false;\n\n\t/*\n\t * Otherwise compute the scale and offset according to the formulas\n\t * derived above.\n\t */\n\ttsc_ref->tsc_scale =\n\t\tmul_u64_u32_div(1ULL << (32 + hv_clock->tsc_shift),\n\t\t\t\thv_clock->tsc_to_system_mul,\n\t\t\t\t100);\n\n\ttsc_ref->tsc_offset = hv_clock->system_time;\n\tdo_div(tsc_ref->tsc_offset, 100);\n\ttsc_ref->tsc_offset -=\n\t\tmul_u64_u64_shr(hv_clock->tsc_timestamp, tsc_ref->tsc_scale, 64);\n\treturn true;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool compute_tsc_page_parameters(struct pvclock_vcpu_time_info *hv_clock,\n\t\t\t\t\tHV_REFERENCE_TSC_PAGE *tsc_ref)\n{\n\tu64 max_mul;\n\n\tif (!(hv_clock->flags & PVCLOCK_TSC_STABLE_BIT))\n\t\treturn false;\n\n\t/*\n\t * check if scale would overflow, if so we use the time ref counter\n\t *    tsc_to_system_mul * 2^(tsc_shift+32) / 100 >= 2^64\n\t *    tsc_to_system_mul / 100 >= 2^(32-tsc_shift)\n\t *    tsc_to_system_mul >= 100 * 2^(32-tsc_shift)\n\t */\n\tmax_mul = 100ull << (32 - hv_clock->tsc_shift);\n\tif (hv_clock->tsc_to_system_mul >= max_mul)\n\t\treturn false;\n\n\t/*\n\t * Otherwise compute the scale and offset according to the formulas\n\t * derived above.\n\t */\n\ttsc_ref->tsc_scale =\n\t\tmul_u64_u32_div(1ULL << (32 + hv_clock->tsc_shift),\n\t\t\t\thv_clock->tsc_to_system_mul,\n\t\t\t\t100);\n\n\ttsc_ref->tsc_offset = hv_clock->system_time;\n\tdo_div(tsc_ref->tsc_offset, 100);\n\ttsc_ref->tsc_offset -=\n\t\tmul_u64_u64_shr(hv_clock->tsc_timestamp, tsc_ref->tsc_scale, 64);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_write_guest",
          "args": [
            "kvm",
            "gfn_to_gpa(gfn)",
            "&hv->tsc_ref",
            "sizeof(hv->tsc_ref.tsc_sequence)"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "kvm_read_guest(kvm, gfn_to_gpa(gfn),\n\t\t\t\t    &tsc_seq, sizeof(tsc_seq))"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_guest",
          "args": [
            "kvm",
            "gfn_to_gpa(gfn)",
            "&tsc_seq",
            "sizeof(tsc_seq)"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_guest_phys_system",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "5478-5485",
          "snippet": "static int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic int kvm_read_guest_phys_system(struct x86_emulate_ctxt *ctxt,\n\t\tunsigned long addr, void *val, unsigned int bytes)\n{\n\tstruct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n\tint r = kvm_vcpu_read_guest(vcpu, addr, val, bytes);\n\n\treturn r < 0 ? X86EMUL_IO_NEEDED : X86EMUL_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gfn_to_gpa",
          "args": [
            "gfn"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->arch.hyperv.hv_lock"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(HV_REFERENCE_TSC_PAGE, tsc_sequence) != 0"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(tsc_seq) != sizeof(hv->tsc_ref.tsc_sequence)"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_setup_tsc_page(struct kvm *kvm,\n\t\t\t   struct pvclock_vcpu_time_info *hv_clock)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tu32 tsc_seq;\n\tu64 gfn;\n\n\tBUILD_BUG_ON(sizeof(tsc_seq) != sizeof(hv->tsc_ref.tsc_sequence));\n\tBUILD_BUG_ON(offsetof(HV_REFERENCE_TSC_PAGE, tsc_sequence) != 0);\n\n\tif (!(hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE))\n\t\treturn;\n\n\tmutex_lock(&kvm->arch.hyperv.hv_lock);\n\tif (!(hv->hv_tsc_page & HV_X64_MSR_TSC_REFERENCE_ENABLE))\n\t\tgoto out_unlock;\n\n\tgfn = hv->hv_tsc_page >> HV_X64_MSR_TSC_REFERENCE_ADDRESS_SHIFT;\n\t/*\n\t * Because the TSC parameters only vary when there is a\n\t * change in the master clock, do not bother with caching.\n\t */\n\tif (unlikely(kvm_read_guest(kvm, gfn_to_gpa(gfn),\n\t\t\t\t    &tsc_seq, sizeof(tsc_seq))))\n\t\tgoto out_unlock;\n\n\t/*\n\t * While we're computing and writing the parameters, force the\n\t * guest to use the time reference count MSR.\n\t */\n\thv->tsc_ref.tsc_sequence = 0;\n\tif (kvm_write_guest(kvm, gfn_to_gpa(gfn),\n\t\t\t    &hv->tsc_ref, sizeof(hv->tsc_ref.tsc_sequence)))\n\t\tgoto out_unlock;\n\n\tif (!compute_tsc_page_parameters(hv_clock, &hv->tsc_ref))\n\t\tgoto out_unlock;\n\n\t/* Ensure sequence is zero before writing the rest of the struct.  */\n\tsmp_wmb();\n\tif (kvm_write_guest(kvm, gfn_to_gpa(gfn), &hv->tsc_ref, sizeof(hv->tsc_ref)))\n\t\tgoto out_unlock;\n\n\t/*\n\t * Now switch to the TSC page mechanism by writing the sequence.\n\t */\n\ttsc_seq++;\n\tif (tsc_seq == 0xFFFFFFFF || tsc_seq == 0)\n\t\ttsc_seq = 1;\n\n\t/* Write the struct entirely before the non-zero sequence.  */\n\tsmp_wmb();\n\n\thv->tsc_ref.tsc_sequence = tsc_seq;\n\tkvm_write_guest(kvm, gfn_to_gpa(gfn),\n\t\t\t&hv->tsc_ref, sizeof(hv->tsc_ref.tsc_sequence));\nout_unlock:\n\tmutex_unlock(&kvm->arch.hyperv.hv_lock);\n}"
  },
  {
    "function_name": "compute_tsc_page_parameters",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "902-934",
    "snippet": "static bool compute_tsc_page_parameters(struct pvclock_vcpu_time_info *hv_clock,\n\t\t\t\t\tHV_REFERENCE_TSC_PAGE *tsc_ref)\n{\n\tu64 max_mul;\n\n\tif (!(hv_clock->flags & PVCLOCK_TSC_STABLE_BIT))\n\t\treturn false;\n\n\t/*\n\t * check if scale would overflow, if so we use the time ref counter\n\t *    tsc_to_system_mul * 2^(tsc_shift+32) / 100 >= 2^64\n\t *    tsc_to_system_mul / 100 >= 2^(32-tsc_shift)\n\t *    tsc_to_system_mul >= 100 * 2^(32-tsc_shift)\n\t */\n\tmax_mul = 100ull << (32 - hv_clock->tsc_shift);\n\tif (hv_clock->tsc_to_system_mul >= max_mul)\n\t\treturn false;\n\n\t/*\n\t * Otherwise compute the scale and offset according to the formulas\n\t * derived above.\n\t */\n\ttsc_ref->tsc_scale =\n\t\tmul_u64_u32_div(1ULL << (32 + hv_clock->tsc_shift),\n\t\t\t\thv_clock->tsc_to_system_mul,\n\t\t\t\t100);\n\n\ttsc_ref->tsc_offset = hv_clock->system_time;\n\tdo_div(tsc_ref->tsc_offset, 100);\n\ttsc_ref->tsc_offset -=\n\t\tmul_u64_u64_shr(hv_clock->tsc_timestamp, tsc_ref->tsc_scale, 64);\n\treturn true;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mul_u64_u64_shr",
          "args": [
            "hv_clock->tsc_timestamp",
            "tsc_ref->tsc_scale",
            "64"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "tsc_ref->tsc_offset",
            "100"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mul_u64_u32_div",
          "args": [
            "1ULL << (32 + hv_clock->tsc_shift)",
            "hv_clock->tsc_to_system_mul",
            "100"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool compute_tsc_page_parameters(struct pvclock_vcpu_time_info *hv_clock,\n\t\t\t\t\tHV_REFERENCE_TSC_PAGE *tsc_ref)\n{\n\tu64 max_mul;\n\n\tif (!(hv_clock->flags & PVCLOCK_TSC_STABLE_BIT))\n\t\treturn false;\n\n\t/*\n\t * check if scale would overflow, if so we use the time ref counter\n\t *    tsc_to_system_mul * 2^(tsc_shift+32) / 100 >= 2^64\n\t *    tsc_to_system_mul / 100 >= 2^(32-tsc_shift)\n\t *    tsc_to_system_mul >= 100 * 2^(32-tsc_shift)\n\t */\n\tmax_mul = 100ull << (32 - hv_clock->tsc_shift);\n\tif (hv_clock->tsc_to_system_mul >= max_mul)\n\t\treturn false;\n\n\t/*\n\t * Otherwise compute the scale and offset according to the formulas\n\t * derived above.\n\t */\n\ttsc_ref->tsc_scale =\n\t\tmul_u64_u32_div(1ULL << (32 + hv_clock->tsc_shift),\n\t\t\t\thv_clock->tsc_to_system_mul,\n\t\t\t\t100);\n\n\ttsc_ref->tsc_offset = hv_clock->system_time;\n\tdo_div(tsc_ref->tsc_offset, 100);\n\ttsc_ref->tsc_offset -=\n\t\tmul_u64_u64_shr(hv_clock->tsc_timestamp, tsc_ref->tsc_scale, 64);\n\treturn true;\n}"
  },
  {
    "function_name": "kvm_hv_msr_set_crash_data",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "854-865",
    "snippet": "static int kvm_hv_msr_set_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 data)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\tsize_t size = ARRAY_SIZE(hv->hv_crash_param);\n\n\tif (WARN_ON_ONCE(index >= size))\n\t\treturn -EINVAL;\n\n\thv->hv_crash_param[array_index_nospec(index, size)] = data;\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "index",
            "size"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "index >= size"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv->hv_crash_param"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_set_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 data)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\tsize_t size = ARRAY_SIZE(hv->hv_crash_param);\n\n\tif (WARN_ON_ONCE(index >= size))\n\t\treturn -EINVAL;\n\n\thv->hv_crash_param[array_index_nospec(index, size)] = data;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_msr_set_crash_ctl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "831-852",
    "snippet": "static int kvm_hv_msr_set_crash_ctl(struct kvm_vcpu *vcpu, u64 data, bool host)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (host)\n\t\thv->hv_crash_ctl = data & HV_CRASH_CTL_CRASH_NOTIFY;\n\n\tif (!host && (data & HV_CRASH_CTL_CRASH_NOTIFY)) {\n\n\t\tvcpu_debug(vcpu, \"hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\\n\",\n\t\t\t  hv->hv_crash_param[0],\n\t\t\t  hv->hv_crash_param[1],\n\t\t\t  hv->hv_crash_param[2],\n\t\t\t  hv->hv_crash_param[3],\n\t\t\t  hv->hv_crash_param[4]);\n\n\t\t/* Send notification about crash to user space */\n\t\tkvm_make_request(KVM_REQ_HV_CRASH, vcpu);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_HV_CRASH",
            "vcpu"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_debug",
          "args": [
            "vcpu",
            "\"hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\\n\"",
            "hv->hv_crash_param[0]",
            "hv->hv_crash_param[1]",
            "hv->hv_crash_param[2]",
            "hv->hv_crash_param[3]",
            "hv->hv_crash_param[4]"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_set_crash_ctl(struct kvm_vcpu *vcpu, u64 data, bool host)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\tif (host)\n\t\thv->hv_crash_ctl = data & HV_CRASH_CTL_CRASH_NOTIFY;\n\n\tif (!host && (data & HV_CRASH_CTL_CRASH_NOTIFY)) {\n\n\t\tvcpu_debug(vcpu, \"hv crash (0x%llx 0x%llx 0x%llx 0x%llx 0x%llx)\\n\",\n\t\t\t  hv->hv_crash_param[0],\n\t\t\t  hv->hv_crash_param[1],\n\t\t\t  hv->hv_crash_param[2],\n\t\t\t  hv->hv_crash_param[3],\n\t\t\t  hv->hv_crash_param[4]);\n\n\t\t/* Send notification about crash to user space */\n\t\tkvm_make_request(KVM_REQ_HV_CRASH, vcpu);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_msr_get_crash_ctl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "823-829",
    "snippet": "static int kvm_hv_msr_get_crash_ctl(struct kvm_vcpu *vcpu, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\t*pdata = hv->hv_crash_ctl;\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_get_crash_ctl(struct kvm_vcpu *vcpu, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\n\t*pdata = hv->hv_crash_ctl;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_msr_get_crash_data",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "810-821",
    "snippet": "static int kvm_hv_msr_get_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\tsize_t size = ARRAY_SIZE(hv->hv_crash_param);\n\n\tif (WARN_ON_ONCE(index >= size))\n\t\treturn -EINVAL;\n\n\t*pdata = hv->hv_crash_param[array_index_nospec(index, size)];\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "index",
            "size"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "index >= size"
          ],
          "line": 816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv->hv_crash_param"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_msr_get_crash_data(struct kvm_vcpu *vcpu,\n\t\t\t\t     u32 index, u64 *pdata)\n{\n\tstruct kvm_hv *hv = &vcpu->kvm->arch.hyperv;\n\tsize_t size = ARRAY_SIZE(hv->hv_crash_param);\n\n\tif (WARN_ON_ONCE(index >= size))\n\t\treturn -EINVAL;\n\n\t*pdata = hv->hv_crash_param[array_index_nospec(index, size)];\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_msr_partition_wide",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "788-808",
    "snippet": "static bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool kvm_hv_msr_partition_wide(u32 msr)\n{\n\tbool r = false;\n\n\tswitch (msr) {\n\tcase HV_X64_MSR_GUEST_OS_ID:\n\tcase HV_X64_MSR_HYPERCALL:\n\tcase HV_X64_MSR_REFERENCE_TSC:\n\tcase HV_X64_MSR_TIME_REF_COUNT:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_RESET:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\tr = true;\n\t\tbreak;\n\t}\n\n\treturn r;\n}"
  },
  {
    "function_name": "kvm_hv_activate_synic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "773-786",
    "snippet": "int kvm_hv_activate_synic(struct kvm_vcpu *vcpu, bool dont_zero_synic_pages)\n{\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\n\t/*\n\t * Hyper-V SynIC auto EOI SINT's are\n\t * not compatible with APICV, so request\n\t * to deactivate APICV permanently.\n\t */\n\tkvm_request_apicv_update(vcpu->kvm, false, APICV_INHIBIT_REASON_HYPERV);\n\tsynic->active = true;\n\tsynic->dont_zero_synic_pages = dont_zero_synic_pages;\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_request_apicv_update",
          "args": [
            "vcpu->kvm",
            "false",
            "APICV_INHIBIT_REASON_HYPERV"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_request_apicv_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8057-8084",
          "snippet": "void kvm_request_apicv_update(struct kvm *kvm, bool activate, ulong bit)\n{\n\tunsigned long old, new, expected;\n\n\tif (!kvm_x86_ops.check_apicv_inhibit_reasons ||\n\t    !kvm_x86_ops.check_apicv_inhibit_reasons(bit))\n\t\treturn;\n\n\told = READ_ONCE(kvm->arch.apicv_inhibit_reasons);\n\tdo {\n\t\texpected = new = old;\n\t\tif (activate)\n\t\t\t__clear_bit(bit, &new);\n\t\telse\n\t\t\t__set_bit(bit, &new);\n\t\tif (new == old)\n\t\t\tbreak;\n\t\told = cmpxchg(&kvm->arch.apicv_inhibit_reasons, expected, new);\n\t} while (old != expected);\n\n\tif (!!old == !!new)\n\t\treturn;\n\n\ttrace_kvm_apicv_update_request(activate, bit);\n\tif (kvm_x86_ops.pre_update_apicv_exec_ctrl)\n\t\tkvm_x86_ops.pre_update_apicv_exec_ctrl(kvm, activate);\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kvm_x86_ops kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops kvm_x86_ops;\n\nvoid kvm_request_apicv_update(struct kvm *kvm, bool activate, ulong bit)\n{\n\tunsigned long old, new, expected;\n\n\tif (!kvm_x86_ops.check_apicv_inhibit_reasons ||\n\t    !kvm_x86_ops.check_apicv_inhibit_reasons(bit))\n\t\treturn;\n\n\told = READ_ONCE(kvm->arch.apicv_inhibit_reasons);\n\tdo {\n\t\texpected = new = old;\n\t\tif (activate)\n\t\t\t__clear_bit(bit, &new);\n\t\telse\n\t\t\t__set_bit(bit, &new);\n\t\tif (new == old)\n\t\t\tbreak;\n\t\told = cmpxchg(&kvm->arch.apicv_inhibit_reasons, expected, new);\n\t} while (old != expected);\n\n\tif (!!old == !!new)\n\t\treturn;\n\n\ttrace_kvm_apicv_update_request(activate, bit);\n\tif (kvm_x86_ops.pre_update_apicv_exec_ctrl)\n\t\tkvm_x86_ops.pre_update_apicv_exec_ctrl(kvm, activate);\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 775
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "39-42",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_activate_synic(struct kvm_vcpu *vcpu, bool dont_zero_synic_pages)\n{\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\n\t/*\n\t * Hyper-V SynIC auto EOI SINT's are\n\t * not compatible with APICV, so request\n\t * to deactivate APICV permanently.\n\t */\n\tkvm_request_apicv_update(vcpu->kvm, false, APICV_INHIBIT_REASON_HYPERV);\n\tsynic->active = true;\n\tsynic->dont_zero_synic_pages = dont_zero_synic_pages;\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_vcpu_postcreate",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "766-771",
    "snippet": "void kvm_hv_vcpu_postcreate(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\n\thv_vcpu->vp_index = kvm_vcpu_get_idx(vcpu);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_get_idx",
          "args": [
            "vcpu"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "26-29",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_vcpu_postcreate(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\n\thv_vcpu->vp_index = kvm_vcpu_get_idx(vcpu);\n}"
  },
  {
    "function_name": "kvm_hv_vcpu_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "754-764",
    "snippet": "void kvm_hv_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tsynic_init(&hv_vcpu->synic);\n\n\tbitmap_zero(hv_vcpu->stimer_pending_bitmap, HV_SYNIC_STIMER_COUNT);\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_init(&hv_vcpu->stimer[i], i);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_init",
          "args": [
            "&hv_vcpu->stimer[i]",
            "i"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_init",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "745-752",
          "snippet": "static void stimer_init(struct kvm_vcpu_hv_stimer *stimer, int timer_index)\n{\n\tmemset(stimer, 0, sizeof(*stimer));\n\tstimer->index = timer_index;\n\thrtimer_init(&stimer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tstimer->timer.function = stimer_timer_callback;\n\tstimer_prepare_msg(stimer);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_init(struct kvm_vcpu_hv_stimer *stimer, int timer_index)\n{\n\tmemset(stimer, 0, sizeof(*stimer));\n\tstimer->index = timer_index;\n\thrtimer_init(&stimer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tstimer->timer.function = stimer_timer_callback;\n\tstimer_prepare_msg(stimer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv_vcpu->stimer"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "hv_vcpu->stimer_pending_bitmap",
            "HV_SYNIC_STIMER_COUNT"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_init",
          "args": [
            "&hv_vcpu->synic"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "synic_init",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "385-395",
          "snippet": "static void synic_init(struct kvm_vcpu_hv_synic *synic)\n{\n\tint i;\n\n\tmemset(synic, 0, sizeof(*synic));\n\tsynic->version = HV_SYNIC_VERSION_1;\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tatomic64_set(&synic->sint[i], HV_SYNIC_SINT_MASKED);\n\t\tatomic_set(&synic->sint_to_gsi[i], -1);\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_init(struct kvm_vcpu_hv_synic *synic)\n{\n\tint i;\n\n\tmemset(synic, 0, sizeof(*synic));\n\tsynic->version = HV_SYNIC_VERSION_1;\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tatomic64_set(&synic->sint[i], HV_SYNIC_SINT_MASKED);\n\t\tatomic_set(&synic->sint_to_gsi[i], -1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "26-29",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_vcpu_init(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tsynic_init(&hv_vcpu->synic);\n\n\tbitmap_zero(hv_vcpu->stimer_pending_bitmap, HV_SYNIC_STIMER_COUNT);\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_init(&hv_vcpu->stimer[i], i);\n}"
  },
  {
    "function_name": "stimer_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "745-752",
    "snippet": "static void stimer_init(struct kvm_vcpu_hv_stimer *stimer, int timer_index)\n{\n\tmemset(stimer, 0, sizeof(*stimer));\n\tstimer->index = timer_index;\n\thrtimer_init(&stimer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tstimer->timer.function = stimer_timer_callback;\n\tstimer_prepare_msg(stimer);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_prepare_msg",
          "args": [
            "stimer"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_prepare_msg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "730-743",
          "snippet": "static void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tmemset(&msg->header, 0, sizeof(msg->header));\n\tmsg->header.message_type = HVMSG_TIMER_EXPIRED;\n\tmsg->header.payload_size = sizeof(*payload);\n\n\tpayload->timer_index = stimer->index;\n\tpayload->expiration_time = 0;\n\tpayload->delivery_time = 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tmemset(&msg->header, 0, sizeof(msg->header));\n\tmsg->header.message_type = HVMSG_TIMER_EXPIRED;\n\tmsg->header.payload_size = sizeof(*payload);\n\n\tpayload->timer_index = stimer->index;\n\tpayload->expiration_time = 0;\n\tpayload->delivery_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&stimer->timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stimer",
            "0",
            "sizeof(*stimer)"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_init(struct kvm_vcpu_hv_stimer *stimer, int timer_index)\n{\n\tmemset(stimer, 0, sizeof(*stimer));\n\tstimer->index = timer_index;\n\thrtimer_init(&stimer->timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tstimer->timer.function = stimer_timer_callback;\n\tstimer_prepare_msg(stimer);\n}"
  },
  {
    "function_name": "stimer_prepare_msg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "730-743",
    "snippet": "static void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tmemset(&msg->header, 0, sizeof(msg->header));\n\tmsg->header.message_type = HVMSG_TIMER_EXPIRED;\n\tmsg->header.payload_size = sizeof(*payload);\n\n\tpayload->timer_index = stimer->index;\n\tpayload->expiration_time = 0;\n\tpayload->delivery_time = 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&msg->header",
            "0",
            "sizeof(msg->header)"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_prepare_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\tmemset(&msg->header, 0, sizeof(msg->header));\n\tmsg->header.message_type = HVMSG_TIMER_EXPIRED;\n\tmsg->header.payload_size = sizeof(*payload);\n\n\tpayload->timer_index = stimer->index;\n\tpayload->expiration_time = 0;\n\tpayload->delivery_time = 0;\n}"
  },
  {
    "function_name": "kvm_hv_get_assist_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "720-727",
    "snippet": "bool kvm_hv_get_assist_page(struct kvm_vcpu *vcpu,\n\t\t\t    struct hv_vp_assist_page *assist_page)\n{\n\tif (!kvm_hv_assist_page_enabled(vcpu))\n\t\treturn false;\n\treturn !kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t      assist_page, sizeof(*assist_page));\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_read_guest_cached",
          "args": [
            "vcpu->kvm",
            "&vcpu->arch.pv_eoi.data",
            "assist_page",
            "sizeof(*assist_page)"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hv_assist_page_enabled",
          "args": [
            "vcpu"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_assist_page_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "712-717",
          "snippet": "bool kvm_hv_assist_page_enabled(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.hyperv.hv_vapic & HV_X64_MSR_VP_ASSIST_PAGE_ENABLE))\n\t\treturn false;\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nbool kvm_hv_assist_page_enabled(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.hyperv.hv_vapic & HV_X64_MSR_VP_ASSIST_PAGE_ENABLE))\n\t\treturn false;\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nbool kvm_hv_get_assist_page(struct kvm_vcpu *vcpu,\n\t\t\t    struct hv_vp_assist_page *assist_page)\n{\n\tif (!kvm_hv_assist_page_enabled(vcpu))\n\t\treturn false;\n\treturn !kvm_read_guest_cached(vcpu->kvm, &vcpu->arch.pv_eoi.data,\n\t\t\t\t      assist_page, sizeof(*assist_page));\n}"
  },
  {
    "function_name": "kvm_hv_assist_page_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "712-717",
    "snippet": "bool kvm_hv_assist_page_enabled(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.hyperv.hv_vapic & HV_X64_MSR_VP_ASSIST_PAGE_ENABLE))\n\t\treturn false;\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nbool kvm_hv_assist_page_enabled(struct kvm_vcpu *vcpu)\n{\n\tif (!(vcpu->arch.hyperv.hv_vapic & HV_X64_MSR_VP_ASSIST_PAGE_ENABLE))\n\t\treturn false;\n\treturn vcpu->arch.pv_eoi.msr_val & KVM_MSR_ENABLED;\n}"
  },
  {
    "function_name": "kvm_hv_vcpu_uninit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "703-710",
    "snippet": "void kvm_hv_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_cleanup(&hv_vcpu->stimer[i]);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_cleanup",
          "args": [
            "&hv_vcpu->stimer[i]"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_cleanup",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "428-440",
          "snippet": "static void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv_vcpu->stimer"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "26-29",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_vcpu_uninit(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tstimer_cleanup(&hv_vcpu->stimer[i]);\n}"
  },
  {
    "function_name": "kvm_hv_process_stimers",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "673-701",
    "snippet": "void kvm_hv_process_stimers(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tu64 time_now, exp_time;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tif (test_and_clear_bit(i, hv_vcpu->stimer_pending_bitmap)) {\n\t\t\tstimer = &hv_vcpu->stimer[i];\n\t\t\tif (stimer->config.enable) {\n\t\t\t\texp_time = stimer->exp_time;\n\n\t\t\t\tif (exp_time) {\n\t\t\t\t\ttime_now =\n\t\t\t\t\t\tget_time_ref_counter(vcpu->kvm);\n\t\t\t\t\tif (time_now >= exp_time)\n\t\t\t\t\t\tstimer_expiration(stimer);\n\t\t\t\t}\n\n\t\t\t\tif ((stimer->config.enable) &&\n\t\t\t\t    stimer->count) {\n\t\t\t\t\tif (!stimer->msg_pending)\n\t\t\t\t\t\tstimer_start(stimer);\n\t\t\t\t} else\n\t\t\t\t\tstimer_cleanup(stimer);\n\t\t\t}\n\t\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_cleanup",
          "args": [
            "stimer"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_cleanup",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "428-440",
          "snippet": "static void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_start",
          "args": [
            "stimer"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_start",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "459-511",
          "snippet": "static int stimer_start(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tu64 time_now;\n\tktime_t ktime_now;\n\n\ttime_now = get_time_ref_counter(stimer_to_vcpu(stimer)->kvm);\n\tktime_now = ktime_get();\n\n\tif (stimer->config.periodic) {\n\t\tif (stimer->exp_time) {\n\t\t\tif (time_now >= stimer->exp_time) {\n\t\t\t\tu64 remainder;\n\n\t\t\t\tdiv64_u64_rem(time_now - stimer->exp_time,\n\t\t\t\t\t      stimer->count, &remainder);\n\t\t\t\tstimer->exp_time =\n\t\t\t\t\ttime_now + (stimer->count - remainder);\n\t\t\t}\n\t\t} else\n\t\t\tstimer->exp_time = time_now + stimer->count;\n\n\t\ttrace_kvm_hv_stimer_start_periodic(\n\t\t\t\t\tstimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\tstimer->index,\n\t\t\t\t\ttime_now, stimer->exp_time);\n\n\t\thrtimer_start(&stimer->timer,\n\t\t\t      ktime_add_ns(ktime_now,\n\t\t\t\t\t   100 * (stimer->exp_time - time_now)),\n\t\t\t      HRTIMER_MODE_ABS);\n\t\treturn 0;\n\t}\n\tstimer->exp_time = stimer->count;\n\tif (time_now >= stimer->count) {\n\t\t/*\n\t\t * Expire timer according to Hypervisor Top-Level Functional\n\t\t * specification v4(15.3.1):\n\t\t * \"If a one shot is enabled and the specified count is in\n\t\t * the past, it will expire immediately.\"\n\t\t */\n\t\tstimer_mark_pending(stimer, false);\n\t\treturn 0;\n\t}\n\n\ttrace_kvm_hv_stimer_start_one_shot(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\t   stimer->index,\n\t\t\t\t\t   time_now, stimer->count);\n\n\thrtimer_start(&stimer->timer,\n\t\t      ktime_add_ns(ktime_now, 100 * (stimer->count - time_now)),\n\t\t      HRTIMER_MODE_ABS);\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_start(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tu64 time_now;\n\tktime_t ktime_now;\n\n\ttime_now = get_time_ref_counter(stimer_to_vcpu(stimer)->kvm);\n\tktime_now = ktime_get();\n\n\tif (stimer->config.periodic) {\n\t\tif (stimer->exp_time) {\n\t\t\tif (time_now >= stimer->exp_time) {\n\t\t\t\tu64 remainder;\n\n\t\t\t\tdiv64_u64_rem(time_now - stimer->exp_time,\n\t\t\t\t\t      stimer->count, &remainder);\n\t\t\t\tstimer->exp_time =\n\t\t\t\t\ttime_now + (stimer->count - remainder);\n\t\t\t}\n\t\t} else\n\t\t\tstimer->exp_time = time_now + stimer->count;\n\n\t\ttrace_kvm_hv_stimer_start_periodic(\n\t\t\t\t\tstimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\tstimer->index,\n\t\t\t\t\ttime_now, stimer->exp_time);\n\n\t\thrtimer_start(&stimer->timer,\n\t\t\t      ktime_add_ns(ktime_now,\n\t\t\t\t\t   100 * (stimer->exp_time - time_now)),\n\t\t\t      HRTIMER_MODE_ABS);\n\t\treturn 0;\n\t}\n\tstimer->exp_time = stimer->count;\n\tif (time_now >= stimer->count) {\n\t\t/*\n\t\t * Expire timer according to Hypervisor Top-Level Functional\n\t\t * specification v4(15.3.1):\n\t\t * \"If a one shot is enabled and the specified count is in\n\t\t * the past, it will expire immediately.\"\n\t\t */\n\t\tstimer_mark_pending(stimer, false);\n\t\treturn 0;\n\t}\n\n\ttrace_kvm_hv_stimer_start_one_shot(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\t   stimer->index,\n\t\t\t\t\t   time_now, stimer->count);\n\n\thrtimer_start(&stimer->timer,\n\t\t      ktime_add_ns(ktime_now, 100 * (stimer->count - time_now)),\n\t\t      HRTIMER_MODE_ABS);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_expiration",
          "args": [
            "stimer"
          ],
          "line": 690
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_expiration",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "655-671",
          "snippet": "static void stimer_expiration(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tint r, direct = stimer->config.direct_mode;\n\n\tstimer->msg_pending = true;\n\tif (!direct)\n\t\tr = stimer_send_msg(stimer);\n\telse\n\t\tr = stimer_notify_direct(stimer);\n\ttrace_kvm_hv_stimer_expiration(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, direct, r);\n\tif (!r) {\n\t\tstimer->msg_pending = false;\n\t\tif (!(stimer->config.periodic))\n\t\t\tstimer->config.enable = 0;\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_expiration(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tint r, direct = stimer->config.direct_mode;\n\n\tstimer->msg_pending = true;\n\tif (!direct)\n\t\tr = stimer_send_msg(stimer);\n\telse\n\t\tr = stimer_notify_direct(stimer);\n\ttrace_kvm_hv_stimer_expiration(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, direct, r);\n\tif (!r) {\n\t\tstimer->msg_pending = false;\n\t\tif (!(stimer->config.periodic))\n\t\t\tstimer->config.enable = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_time_ref_counter",
          "args": [
            "vcpu->kvm"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "get_time_ref_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "397-414",
          "snippet": "static u64 get_time_ref_counter(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tu64 tsc;\n\n\t/*\n\t * The guest has not set up the TSC page or the clock isn't\n\t * stable, fall back to get_kvmclock_ns.\n\t */\n\tif (!hv->tsc_ref.tsc_sequence)\n\t\treturn div_u64(get_kvmclock_ns(kvm), 100);\n\n\tvcpu = kvm_get_vcpu(kvm, 0);\n\ttsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\treturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\n\t\t+ hv->tsc_ref.tsc_offset;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 get_time_ref_counter(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tu64 tsc;\n\n\t/*\n\t * The guest has not set up the TSC page or the clock isn't\n\t * stable, fall back to get_kvmclock_ns.\n\t */\n\tif (!hv->tsc_ref.tsc_sequence)\n\t\treturn div_u64(get_kvmclock_ns(kvm), 100);\n\n\tvcpu = kvm_get_vcpu(kvm, 0);\n\ttsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\treturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\n\t\t+ hv->tsc_ref.tsc_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "i",
            "hv_vcpu->stimer_pending_bitmap"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv_vcpu->stimer"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "26-29",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_process_stimers(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tu64 time_now, exp_time;\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(hv_vcpu->stimer); i++)\n\t\tif (test_and_clear_bit(i, hv_vcpu->stimer_pending_bitmap)) {\n\t\t\tstimer = &hv_vcpu->stimer[i];\n\t\t\tif (stimer->config.enable) {\n\t\t\t\texp_time = stimer->exp_time;\n\n\t\t\t\tif (exp_time) {\n\t\t\t\t\ttime_now =\n\t\t\t\t\t\tget_time_ref_counter(vcpu->kvm);\n\t\t\t\t\tif (time_now >= exp_time)\n\t\t\t\t\t\tstimer_expiration(stimer);\n\t\t\t\t}\n\n\t\t\t\tif ((stimer->config.enable) &&\n\t\t\t\t    stimer->count) {\n\t\t\t\t\tif (!stimer->msg_pending)\n\t\t\t\t\t\tstimer_start(stimer);\n\t\t\t\t} else\n\t\t\t\t\tstimer_cleanup(stimer);\n\t\t\t}\n\t\t}\n}"
  },
  {
    "function_name": "stimer_expiration",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "655-671",
    "snippet": "static void stimer_expiration(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tint r, direct = stimer->config.direct_mode;\n\n\tstimer->msg_pending = true;\n\tif (!direct)\n\t\tr = stimer_send_msg(stimer);\n\telse\n\t\tr = stimer_notify_direct(stimer);\n\ttrace_kvm_hv_stimer_expiration(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, direct, r);\n\tif (!r) {\n\t\tstimer->msg_pending = false;\n\t\tif (!(stimer->config.periodic))\n\t\t\tstimer->config.enable = 0;\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_expiration",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index",
            "direct",
            "r"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "74-81",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_notify_direct",
          "args": [
            "stimer"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_notify_direct",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "642-653",
          "snippet": "static int stimer_notify_direct(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = stimer->config.apic_vector\n\t};\n\n\tif (lapic_in_kernel(vcpu))\n\t\treturn !kvm_apic_set_irq(vcpu, &irq, NULL);\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_notify_direct(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = stimer->config.apic_vector\n\t};\n\n\tif (lapic_in_kernel(vcpu))\n\t\treturn !kvm_apic_set_irq(vcpu, &irq, NULL);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_send_msg",
          "args": [
            "stimer"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_send_msg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "622-640",
          "snippet": "static int stimer_send_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\t/*\n\t * To avoid piling up periodic ticks, don't retry message\n\t * delivery for them (within \"lazy\" lost ticks policy).\n\t */\n\tbool no_retry = stimer->config.periodic;\n\n\tpayload->expiration_time = stimer->exp_time;\n\tpayload->delivery_time = get_time_ref_counter(vcpu->kvm);\n\treturn synic_deliver_msg(vcpu_to_synic(vcpu),\n\t\t\t\t stimer->config.sintx, msg,\n\t\t\t\t no_retry);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_send_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\t/*\n\t * To avoid piling up periodic ticks, don't retry message\n\t * delivery for them (within \"lazy\" lost ticks policy).\n\t */\n\tbool no_retry = stimer->config.periodic;\n\n\tpayload->expiration_time = stimer->exp_time;\n\tpayload->delivery_time = get_time_ref_counter(vcpu->kvm);\n\treturn synic_deliver_msg(vcpu_to_synic(vcpu),\n\t\t\t\t stimer->config.sintx, msg,\n\t\t\t\t no_retry);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_expiration(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tint r, direct = stimer->config.direct_mode;\n\n\tstimer->msg_pending = true;\n\tif (!direct)\n\t\tr = stimer_send_msg(stimer);\n\telse\n\t\tr = stimer_notify_direct(stimer);\n\ttrace_kvm_hv_stimer_expiration(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, direct, r);\n\tif (!r) {\n\t\tstimer->msg_pending = false;\n\t\tif (!(stimer->config.periodic))\n\t\t\tstimer->config.enable = 0;\n\t}\n}"
  },
  {
    "function_name": "stimer_notify_direct",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "642-653",
    "snippet": "static int stimer_notify_direct(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = stimer->config.apic_vector\n\t};\n\n\tif (lapic_in_kernel(vcpu))\n\t\treturn !kvm_apic_set_irq(vcpu, &irq, NULL);\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apic_set_irq",
          "args": [
            "vcpu",
            "&irq",
            "NULL"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "563-570",
          "snippet": "int kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int __apic_accept_irq(struct kvm_lapic *apic, int delivery_mode,\n\t\t\t     int vector, int level, int trig_mode,\n\t\t\t     struct dest_map *dest_map);\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_apic_set_irq(struct kvm_vcpu *vcpu, struct kvm_lapic_irq *irq,\n\t\t     struct dest_map *dest_map)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn __apic_accept_irq(apic, irq->delivery_mode, irq->vector,\n\t\t\tirq->level, irq->trig_mode, dest_map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "74-81",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_notify_direct(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct kvm_lapic_irq irq = {\n\t\t.delivery_mode = APIC_DM_FIXED,\n\t\t.vector = stimer->config.apic_vector\n\t};\n\n\tif (lapic_in_kernel(vcpu))\n\t\treturn !kvm_apic_set_irq(vcpu, &irq, NULL);\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_send_msg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "622-640",
    "snippet": "static int stimer_send_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\t/*\n\t * To avoid piling up periodic ticks, don't retry message\n\t * delivery for them (within \"lazy\" lost ticks policy).\n\t */\n\tbool no_retry = stimer->config.periodic;\n\n\tpayload->expiration_time = stimer->exp_time;\n\tpayload->delivery_time = get_time_ref_counter(vcpu->kvm);\n\treturn synic_deliver_msg(vcpu_to_synic(vcpu),\n\t\t\t\t stimer->config.sintx, msg,\n\t\t\t\t no_retry);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synic_deliver_msg",
          "args": [
            "vcpu_to_synic(vcpu)",
            "stimer->config.sintx",
            "msg",
            "no_retry"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "synic_deliver_msg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "565-620",
          "snippet": "static int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,\n\t\t\t     struct hv_message *src_msg, bool no_retry)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint msg_off = offsetof(struct hv_message_page, sint_message[sint]);\n\tgfn_t msg_page_gfn;\n\tstruct hv_message_header hv_hdr;\n\tint r;\n\n\tif (!(synic->msg_page & HV_SYNIC_SIMP_ENABLE))\n\t\treturn -ENOENT;\n\n\tmsg_page_gfn = synic->msg_page >> PAGE_SHIFT;\n\n\t/*\n\t * Strictly following the spec-mandated ordering would assume setting\n\t * .msg_pending before checking .message_type.  However, this function\n\t * is only called in vcpu context so the entire update is atomic from\n\t * guest POV and thus the exact order here doesn't matter.\n\t */\n\tr = kvm_vcpu_read_guest_page(vcpu, msg_page_gfn, &hv_hdr.message_type,\n\t\t\t\t     msg_off + offsetof(struct hv_message,\n\t\t\t\t\t\t\theader.message_type),\n\t\t\t\t     sizeof(hv_hdr.message_type));\n\tif (r < 0)\n\t\treturn r;\n\n\tif (hv_hdr.message_type != HVMSG_NONE) {\n\t\tif (no_retry)\n\t\t\treturn 0;\n\n\t\thv_hdr.message_flags.msg_pending = 1;\n\t\tr = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn,\n\t\t\t\t\t      &hv_hdr.message_flags,\n\t\t\t\t\t      msg_off +\n\t\t\t\t\t      offsetof(struct hv_message,\n\t\t\t\t\t\t       header.message_flags),\n\t\t\t\t\t      sizeof(hv_hdr.message_flags));\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\treturn -EAGAIN;\n\t}\n\n\tr = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn, src_msg, msg_off,\n\t\t\t\t      sizeof(src_msg->header) +\n\t\t\t\t      src_msg->header.payload_size);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = synic_set_irq(synic, sint);\n\tif (r < 0)\n\t\treturn r;\n\tif (r == 0)\n\t\treturn -EFAULT;\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,\n\t\t\t     struct hv_message *src_msg, bool no_retry)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint msg_off = offsetof(struct hv_message_page, sint_message[sint]);\n\tgfn_t msg_page_gfn;\n\tstruct hv_message_header hv_hdr;\n\tint r;\n\n\tif (!(synic->msg_page & HV_SYNIC_SIMP_ENABLE))\n\t\treturn -ENOENT;\n\n\tmsg_page_gfn = synic->msg_page >> PAGE_SHIFT;\n\n\t/*\n\t * Strictly following the spec-mandated ordering would assume setting\n\t * .msg_pending before checking .message_type.  However, this function\n\t * is only called in vcpu context so the entire update is atomic from\n\t * guest POV and thus the exact order here doesn't matter.\n\t */\n\tr = kvm_vcpu_read_guest_page(vcpu, msg_page_gfn, &hv_hdr.message_type,\n\t\t\t\t     msg_off + offsetof(struct hv_message,\n\t\t\t\t\t\t\theader.message_type),\n\t\t\t\t     sizeof(hv_hdr.message_type));\n\tif (r < 0)\n\t\treturn r;\n\n\tif (hv_hdr.message_type != HVMSG_NONE) {\n\t\tif (no_retry)\n\t\t\treturn 0;\n\n\t\thv_hdr.message_flags.msg_pending = 1;\n\t\tr = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn,\n\t\t\t\t\t      &hv_hdr.message_flags,\n\t\t\t\t\t      msg_off +\n\t\t\t\t\t      offsetof(struct hv_message,\n\t\t\t\t\t\t       header.message_flags),\n\t\t\t\t\t      sizeof(hv_hdr.message_flags));\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\treturn -EAGAIN;\n\t}\n\n\tr = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn, src_msg, msg_off,\n\t\t\t\t      sizeof(src_msg->header) +\n\t\t\t\t      src_msg->header.payload_size);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = synic_set_irq(synic, sint);\n\tif (r < 0)\n\t\treturn r;\n\tif (r == 0)\n\t\treturn -EFAULT;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 637
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "39-42",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_time_ref_counter",
          "args": [
            "vcpu->kvm"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "get_time_ref_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "397-414",
          "snippet": "static u64 get_time_ref_counter(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tu64 tsc;\n\n\t/*\n\t * The guest has not set up the TSC page or the clock isn't\n\t * stable, fall back to get_kvmclock_ns.\n\t */\n\tif (!hv->tsc_ref.tsc_sequence)\n\t\treturn div_u64(get_kvmclock_ns(kvm), 100);\n\n\tvcpu = kvm_get_vcpu(kvm, 0);\n\ttsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\treturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\n\t\t+ hv->tsc_ref.tsc_offset;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 get_time_ref_counter(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tu64 tsc;\n\n\t/*\n\t * The guest has not set up the TSC page or the clock isn't\n\t * stable, fall back to get_kvmclock_ns.\n\t */\n\tif (!hv->tsc_ref.tsc_sequence)\n\t\treturn div_u64(get_kvmclock_ns(kvm), 100);\n\n\tvcpu = kvm_get_vcpu(kvm, 0);\n\ttsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\treturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\n\t\t+ hv->tsc_ref.tsc_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "74-81",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_send_msg(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\tstruct hv_message *msg = &stimer->msg;\n\tstruct hv_timer_message_payload *payload =\n\t\t\t(struct hv_timer_message_payload *)&msg->u.payload;\n\n\t/*\n\t * To avoid piling up periodic ticks, don't retry message\n\t * delivery for them (within \"lazy\" lost ticks policy).\n\t */\n\tbool no_retry = stimer->config.periodic;\n\n\tpayload->expiration_time = stimer->exp_time;\n\tpayload->delivery_time = get_time_ref_counter(vcpu->kvm);\n\treturn synic_deliver_msg(vcpu_to_synic(vcpu),\n\t\t\t\t stimer->config.sintx, msg,\n\t\t\t\t no_retry);\n}"
  },
  {
    "function_name": "synic_deliver_msg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "565-620",
    "snippet": "static int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,\n\t\t\t     struct hv_message *src_msg, bool no_retry)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint msg_off = offsetof(struct hv_message_page, sint_message[sint]);\n\tgfn_t msg_page_gfn;\n\tstruct hv_message_header hv_hdr;\n\tint r;\n\n\tif (!(synic->msg_page & HV_SYNIC_SIMP_ENABLE))\n\t\treturn -ENOENT;\n\n\tmsg_page_gfn = synic->msg_page >> PAGE_SHIFT;\n\n\t/*\n\t * Strictly following the spec-mandated ordering would assume setting\n\t * .msg_pending before checking .message_type.  However, this function\n\t * is only called in vcpu context so the entire update is atomic from\n\t * guest POV and thus the exact order here doesn't matter.\n\t */\n\tr = kvm_vcpu_read_guest_page(vcpu, msg_page_gfn, &hv_hdr.message_type,\n\t\t\t\t     msg_off + offsetof(struct hv_message,\n\t\t\t\t\t\t\theader.message_type),\n\t\t\t\t     sizeof(hv_hdr.message_type));\n\tif (r < 0)\n\t\treturn r;\n\n\tif (hv_hdr.message_type != HVMSG_NONE) {\n\t\tif (no_retry)\n\t\t\treturn 0;\n\n\t\thv_hdr.message_flags.msg_pending = 1;\n\t\tr = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn,\n\t\t\t\t\t      &hv_hdr.message_flags,\n\t\t\t\t\t      msg_off +\n\t\t\t\t\t      offsetof(struct hv_message,\n\t\t\t\t\t\t       header.message_flags),\n\t\t\t\t\t      sizeof(hv_hdr.message_flags));\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\treturn -EAGAIN;\n\t}\n\n\tr = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn, src_msg, msg_off,\n\t\t\t\t      sizeof(src_msg->header) +\n\t\t\t\t      src_msg->header.payload_size);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = synic_set_irq(synic, sint);\n\tif (r < 0)\n\t\treturn r;\n\tif (r == 0)\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synic_set_irq",
          "args": [
            "synic",
            "sint"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "synic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "304-327",
          "snippet": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_write_guest_page",
          "args": [
            "vcpu",
            "msg_page_gfn",
            "src_msg",
            "msg_off",
            "sizeof(src_msg->header) +\n\t\t\t\t      src_msg->header.payload_size"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_write_guest_page",
          "args": [
            "vcpu",
            "msg_page_gfn",
            "&hv_hdr.message_flags",
            "msg_off +\n\t\t\t\t\t      offsetof(struct hv_message,\n\t\t\t\t\t\t       header.message_flags"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_read_guest_page",
          "args": [
            "vcpu",
            "msg_page_gfn",
            "&hv_hdr.message_type",
            "msg_off + offsetof(struct hv_message,\n\t\t\t\t\t\t\theader.message_type"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_to_vcpu",
          "args": [
            "synic"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "synic_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "44-47",
          "snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_deliver_msg(struct kvm_vcpu_hv_synic *synic, u32 sint,\n\t\t\t     struct hv_message *src_msg, bool no_retry)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint msg_off = offsetof(struct hv_message_page, sint_message[sint]);\n\tgfn_t msg_page_gfn;\n\tstruct hv_message_header hv_hdr;\n\tint r;\n\n\tif (!(synic->msg_page & HV_SYNIC_SIMP_ENABLE))\n\t\treturn -ENOENT;\n\n\tmsg_page_gfn = synic->msg_page >> PAGE_SHIFT;\n\n\t/*\n\t * Strictly following the spec-mandated ordering would assume setting\n\t * .msg_pending before checking .message_type.  However, this function\n\t * is only called in vcpu context so the entire update is atomic from\n\t * guest POV and thus the exact order here doesn't matter.\n\t */\n\tr = kvm_vcpu_read_guest_page(vcpu, msg_page_gfn, &hv_hdr.message_type,\n\t\t\t\t     msg_off + offsetof(struct hv_message,\n\t\t\t\t\t\t\theader.message_type),\n\t\t\t\t     sizeof(hv_hdr.message_type));\n\tif (r < 0)\n\t\treturn r;\n\n\tif (hv_hdr.message_type != HVMSG_NONE) {\n\t\tif (no_retry)\n\t\t\treturn 0;\n\n\t\thv_hdr.message_flags.msg_pending = 1;\n\t\tr = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn,\n\t\t\t\t\t      &hv_hdr.message_flags,\n\t\t\t\t\t      msg_off +\n\t\t\t\t\t      offsetof(struct hv_message,\n\t\t\t\t\t\t       header.message_flags),\n\t\t\t\t\t      sizeof(hv_hdr.message_flags));\n\t\tif (r < 0)\n\t\t\treturn r;\n\t\treturn -EAGAIN;\n\t}\n\n\tr = kvm_vcpu_write_guest_page(vcpu, msg_page_gfn, src_msg, msg_off,\n\t\t\t\t      sizeof(src_msg->header) +\n\t\t\t\t      src_msg->header.payload_size);\n\tif (r < 0)\n\t\treturn r;\n\n\tr = synic_set_irq(synic, sint);\n\tif (r < 0)\n\t\treturn r;\n\tif (r == 0)\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_get_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "559-563",
    "snippet": "static int stimer_get_count(struct kvm_vcpu_hv_stimer *stimer, u64 *pcount)\n{\n\t*pcount = stimer->count;\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_get_count(struct kvm_vcpu_hv_stimer *stimer, u64 *pcount)\n{\n\t*pcount = stimer->count;\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_get_config",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "553-557",
    "snippet": "static int stimer_get_config(struct kvm_vcpu_hv_stimer *stimer, u64 *pconfig)\n{\n\t*pconfig = stimer->config.as_uint64;\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_get_config(struct kvm_vcpu_hv_stimer *stimer, u64 *pconfig)\n{\n\t*pconfig = stimer->config.as_uint64;\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_set_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "534-551",
    "snippet": "static int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\ttrace_kvm_hv_stimer_set_count(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_mark_pending",
          "args": [
            "stimer",
            "false"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_mark_pending",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "416-426",
          "snippet": "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_cleanup",
          "args": [
            "stimer"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_cleanup",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "428-440",
          "snippet": "static void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_set_count",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index",
            "count",
            "host"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "74-81",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_set_count(struct kvm_vcpu_hv_stimer *stimer, u64 count,\n\t\t\t    bool host)\n{\n\ttrace_kvm_hv_stimer_set_count(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t      stimer->index, count, host);\n\n\tstimer_cleanup(stimer);\n\tstimer->count = count;\n\tif (stimer->count == 0)\n\t\tstimer->config.enable = 0;\n\telse if (stimer->config.auto_enable)\n\t\tstimer->config.enable = 1;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_set_config",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "513-532",
    "snippet": "static int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\n\ttrace_kvm_hv_stimer_set_config(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_mark_pending",
          "args": [
            "stimer",
            "false"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_mark_pending",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "416-426",
          "snippet": "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_cleanup",
          "args": [
            "stimer"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_cleanup",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "428-440",
          "snippet": "static void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_set_config",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index",
            "config",
            "host"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "74-81",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_set_config(struct kvm_vcpu_hv_stimer *stimer, u64 config,\n\t\t\t     bool host)\n{\n\tunion hv_stimer_config new_config = {.as_uint64 = config},\n\t\told_config = {.as_uint64 = stimer->config.as_uint64};\n\n\ttrace_kvm_hv_stimer_set_config(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t       stimer->index, config, host);\n\n\tstimer_cleanup(stimer);\n\tif (old_config.enable &&\n\t    !new_config.direct_mode && new_config.sintx == 0)\n\t\tnew_config.enable = 0;\n\tstimer->config.as_uint64 = new_config.as_uint64;\n\n\tif (stimer->config.enable)\n\t\tstimer_mark_pending(stimer, false);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_start",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "459-511",
    "snippet": "static int stimer_start(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tu64 time_now;\n\tktime_t ktime_now;\n\n\ttime_now = get_time_ref_counter(stimer_to_vcpu(stimer)->kvm);\n\tktime_now = ktime_get();\n\n\tif (stimer->config.periodic) {\n\t\tif (stimer->exp_time) {\n\t\t\tif (time_now >= stimer->exp_time) {\n\t\t\t\tu64 remainder;\n\n\t\t\t\tdiv64_u64_rem(time_now - stimer->exp_time,\n\t\t\t\t\t      stimer->count, &remainder);\n\t\t\t\tstimer->exp_time =\n\t\t\t\t\ttime_now + (stimer->count - remainder);\n\t\t\t}\n\t\t} else\n\t\t\tstimer->exp_time = time_now + stimer->count;\n\n\t\ttrace_kvm_hv_stimer_start_periodic(\n\t\t\t\t\tstimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\tstimer->index,\n\t\t\t\t\ttime_now, stimer->exp_time);\n\n\t\thrtimer_start(&stimer->timer,\n\t\t\t      ktime_add_ns(ktime_now,\n\t\t\t\t\t   100 * (stimer->exp_time - time_now)),\n\t\t\t      HRTIMER_MODE_ABS);\n\t\treturn 0;\n\t}\n\tstimer->exp_time = stimer->count;\n\tif (time_now >= stimer->count) {\n\t\t/*\n\t\t * Expire timer according to Hypervisor Top-Level Functional\n\t\t * specification v4(15.3.1):\n\t\t * \"If a one shot is enabled and the specified count is in\n\t\t * the past, it will expire immediately.\"\n\t\t */\n\t\tstimer_mark_pending(stimer, false);\n\t\treturn 0;\n\t}\n\n\ttrace_kvm_hv_stimer_start_one_shot(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\t   stimer->index,\n\t\t\t\t\t   time_now, stimer->count);\n\n\thrtimer_start(&stimer->timer,\n\t\t      ktime_add_ns(ktime_now, 100 * (stimer->count - time_now)),\n\t\t      HRTIMER_MODE_ABS);\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&stimer->timer",
            "ktime_add_ns(ktime_now, 100 * (stimer->count - time_now))",
            "HRTIMER_MODE_ABS"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "ktime_now",
            "100 * (stimer->count - time_now)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_start_one_shot",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index",
            "time_now",
            "stimer->count"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "74-81",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_mark_pending",
          "args": [
            "stimer",
            "false"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_mark_pending",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "416-426",
          "snippet": "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&stimer->timer",
            "ktime_add_ns(ktime_now,\n\t\t\t\t\t   100 * (stimer->exp_time - time_now))",
            "HRTIMER_MODE_ABS"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "ktime_now",
            "100 * (stimer->exp_time - time_now)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_start_periodic",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index",
            "time_now",
            "stimer->exp_time"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div64_u64_rem",
          "args": [
            "time_now - stimer->exp_time",
            "stimer->count",
            "&remainder"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_time_ref_counter",
          "args": [
            "stimer_to_vcpu(stimer)->kvm"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "get_time_ref_counter",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "397-414",
          "snippet": "static u64 get_time_ref_counter(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tu64 tsc;\n\n\t/*\n\t * The guest has not set up the TSC page or the clock isn't\n\t * stable, fall back to get_kvmclock_ns.\n\t */\n\tif (!hv->tsc_ref.tsc_sequence)\n\t\treturn div_u64(get_kvmclock_ns(kvm), 100);\n\n\tvcpu = kvm_get_vcpu(kvm, 0);\n\ttsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\treturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\n\t\t+ hv->tsc_ref.tsc_offset;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 get_time_ref_counter(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tu64 tsc;\n\n\t/*\n\t * The guest has not set up the TSC page or the clock isn't\n\t * stable, fall back to get_kvmclock_ns.\n\t */\n\tif (!hv->tsc_ref.tsc_sequence)\n\t\treturn div_u64(get_kvmclock_ns(kvm), 100);\n\n\tvcpu = kvm_get_vcpu(kvm, 0);\n\ttsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\treturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\n\t\t+ hv->tsc_ref.tsc_offset;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int stimer_start(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tu64 time_now;\n\tktime_t ktime_now;\n\n\ttime_now = get_time_ref_counter(stimer_to_vcpu(stimer)->kvm);\n\tktime_now = ktime_get();\n\n\tif (stimer->config.periodic) {\n\t\tif (stimer->exp_time) {\n\t\t\tif (time_now >= stimer->exp_time) {\n\t\t\t\tu64 remainder;\n\n\t\t\t\tdiv64_u64_rem(time_now - stimer->exp_time,\n\t\t\t\t\t      stimer->count, &remainder);\n\t\t\t\tstimer->exp_time =\n\t\t\t\t\ttime_now + (stimer->count - remainder);\n\t\t\t}\n\t\t} else\n\t\t\tstimer->exp_time = time_now + stimer->count;\n\n\t\ttrace_kvm_hv_stimer_start_periodic(\n\t\t\t\t\tstimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\tstimer->index,\n\t\t\t\t\ttime_now, stimer->exp_time);\n\n\t\thrtimer_start(&stimer->timer,\n\t\t\t      ktime_add_ns(ktime_now,\n\t\t\t\t\t   100 * (stimer->exp_time - time_now)),\n\t\t\t      HRTIMER_MODE_ABS);\n\t\treturn 0;\n\t}\n\tstimer->exp_time = stimer->count;\n\tif (time_now >= stimer->count) {\n\t\t/*\n\t\t * Expire timer according to Hypervisor Top-Level Functional\n\t\t * specification v4(15.3.1):\n\t\t * \"If a one shot is enabled and the specified count is in\n\t\t * the past, it will expire immediately.\"\n\t\t */\n\t\tstimer_mark_pending(stimer, false);\n\t\treturn 0;\n\t}\n\n\ttrace_kvm_hv_stimer_start_one_shot(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t\t   stimer->index,\n\t\t\t\t\t   time_now, stimer->count);\n\n\thrtimer_start(&stimer->timer,\n\t\t      ktime_add_ns(ktime_now, 100 * (stimer->count - time_now)),\n\t\t      HRTIMER_MODE_ABS);\n\treturn 0;\n}"
  },
  {
    "function_name": "stimer_timer_callback",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "442-452",
    "snippet": "static enum hrtimer_restart stimer_timer_callback(struct hrtimer *timer)\n{\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\n\tstimer = container_of(timer, struct kvm_vcpu_hv_stimer, timer);\n\ttrace_kvm_hv_stimer_callback(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t     stimer->index);\n\tstimer_mark_pending(stimer, true);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "stimer_mark_pending",
          "args": [
            "stimer",
            "true"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_mark_pending",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "416-426",
          "snippet": "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_callback",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "74-81",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structkvm_vcpu_hv_stimer",
            "timer"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic enum hrtimer_restart stimer_timer_callback(struct hrtimer *timer)\n{\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\n\tstimer = container_of(timer, struct kvm_vcpu_hv_stimer, timer);\n\ttrace_kvm_hv_stimer_callback(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t     stimer->index);\n\tstimer_mark_pending(stimer, true);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "stimer_cleanup",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "428-440",
    "snippet": "static void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "stimer->index",
            "vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "214-222",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "26-29",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_cancel",
          "args": [
            "&stimer->timer"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_stimer_cleanup",
          "args": [
            "stimer_to_vcpu(stimer)->vcpu_id",
            "stimer->index"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 432
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "74-81",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_cleanup(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\ttrace_kvm_hv_stimer_cleanup(stimer_to_vcpu(stimer)->vcpu_id,\n\t\t\t\t    stimer->index);\n\n\thrtimer_cancel(&stimer->timer);\n\tclear_bit(stimer->index,\n\t\t  vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tstimer->msg_pending = false;\n\tstimer->exp_time = 0;\n}"
  },
  {
    "function_name": "stimer_mark_pending",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "416-426",
    "snippet": "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_kick",
          "args": [
            "vcpu"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_HV_STIMER",
            "vcpu"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "stimer->index",
            "vcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "224-232",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "26-29",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "stimer_to_vcpu",
          "args": [
            "stimer"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "74-81",
          "snippet": "static inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *stimer_to_vcpu(struct kvm_vcpu_hv_stimer *stimer)\n{\n\tstruct kvm_vcpu_hv *hv_vcpu;\n\n\thv_vcpu = container_of(stimer - stimer->index, struct kvm_vcpu_hv,\n\t\t\t       stimer[0]);\n\treturn hv_vcpu_to_vcpu(hv_vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}"
  },
  {
    "function_name": "get_time_ref_counter",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "397-414",
    "snippet": "static u64 get_time_ref_counter(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tu64 tsc;\n\n\t/*\n\t * The guest has not set up the TSC page or the clock isn't\n\t * stable, fall back to get_kvmclock_ns.\n\t */\n\tif (!hv->tsc_ref.tsc_sequence)\n\t\treturn div_u64(get_kvmclock_ns(kvm), 100);\n\n\tvcpu = kvm_get_vcpu(kvm, 0);\n\ttsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\treturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\n\t\t+ hv->tsc_ref.tsc_offset;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mul_u64_u64_shr",
          "args": [
            "tsc",
            "hv->tsc_ref.tsc_scale",
            "64"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_l1_tsc",
          "args": [
            "vcpu",
            "rdtsc()"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_l1_tsc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1951-1956",
          "snippet": "u64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nu64 kvm_read_l1_tsc(struct kvm_vcpu *vcpu, u64 host_tsc)\n{\n\tu64 tsc_offset = kvm_x86_ops.read_l1_tsc_offset(vcpu);\n\n\treturn tsc_offset + kvm_scale_tsc(vcpu, host_tsc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdtsc",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_has_vmx_rdtscp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/capabilities.h",
          "lines": "149-153",
          "snippet": "static inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include <asm/vmx.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include <asm/vmx.h>\n\nstatic inline bool cpu_has_vmx_rdtscp(void)\n{\n\treturn vmcs_config.cpu_based_2nd_exec_ctrl &\n\t\tSECONDARY_EXEC_RDTSCP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_vcpu",
          "args": [
            "kvm",
            "0"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "get_kvmclock_ns(kvm)",
            "100"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_kvmclock_ns",
          "args": [
            "kvm"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "get_kvmclock_ns",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "2318-2348",
          "snippet": "u64 get_kvmclock_ns(struct kvm *kvm)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\tstruct pvclock_vcpu_time_info hv_clock;\n\tu64 ret;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tif (!ka->use_master_clock) {\n\t\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\t\treturn get_kvmclock_base_ns() + ka->kvmclock_offset;\n\t}\n\n\thv_clock.tsc_timestamp = ka->master_cycle_now;\n\thv_clock.system_time = ka->master_kernel_ns + ka->kvmclock_offset;\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\n\t/* both __this_cpu_read() and rdtsc() should be on the same cpu */\n\tget_cpu();\n\n\tif (__this_cpu_read(cpu_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC, __this_cpu_read(cpu_tsc_khz) * 1000LL,\n\t\t\t\t   &hv_clock.tsc_shift,\n\t\t\t\t   &hv_clock.tsc_to_system_mul);\n\t\tret = __pvclock_read_cycles(&hv_clock, rdtsc());\n\t} else\n\t\tret = get_kvmclock_base_ns() + ka->kvmclock_offset;\n\n\tput_cpu();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_PER_CPU(unsigned long, cpu_tsc_khz);\n\nu64 get_kvmclock_ns(struct kvm *kvm)\n{\n\tstruct kvm_arch *ka = &kvm->arch;\n\tstruct pvclock_vcpu_time_info hv_clock;\n\tu64 ret;\n\n\tspin_lock(&ka->pvclock_gtod_sync_lock);\n\tif (!ka->use_master_clock) {\n\t\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\t\treturn get_kvmclock_base_ns() + ka->kvmclock_offset;\n\t}\n\n\thv_clock.tsc_timestamp = ka->master_cycle_now;\n\thv_clock.system_time = ka->master_kernel_ns + ka->kvmclock_offset;\n\tspin_unlock(&ka->pvclock_gtod_sync_lock);\n\n\t/* both __this_cpu_read() and rdtsc() should be on the same cpu */\n\tget_cpu();\n\n\tif (__this_cpu_read(cpu_tsc_khz)) {\n\t\tkvm_get_time_scale(NSEC_PER_SEC, __this_cpu_read(cpu_tsc_khz) * 1000LL,\n\t\t\t\t   &hv_clock.tsc_shift,\n\t\t\t\t   &hv_clock.tsc_to_system_mul);\n\t\tret = __pvclock_read_cycles(&hv_clock, rdtsc());\n\t} else\n\t\tret = get_kvmclock_base_ns() + ka->kvmclock_offset;\n\n\tput_cpu();\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic u64 get_time_ref_counter(struct kvm *kvm)\n{\n\tstruct kvm_hv *hv = &kvm->arch.hyperv;\n\tstruct kvm_vcpu *vcpu;\n\tu64 tsc;\n\n\t/*\n\t * The guest has not set up the TSC page or the clock isn't\n\t * stable, fall back to get_kvmclock_ns.\n\t */\n\tif (!hv->tsc_ref.tsc_sequence)\n\t\treturn div_u64(get_kvmclock_ns(kvm), 100);\n\n\tvcpu = kvm_get_vcpu(kvm, 0);\n\ttsc = kvm_read_l1_tsc(vcpu, rdtsc());\n\treturn mul_u64_u64_shr(tsc, hv->tsc_ref.tsc_scale, 64)\n\t\t+ hv->tsc_ref.tsc_offset;\n}"
  },
  {
    "function_name": "synic_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "385-395",
    "snippet": "static void synic_init(struct kvm_vcpu_hv_synic *synic)\n{\n\tint i;\n\n\tmemset(synic, 0, sizeof(*synic));\n\tsynic->version = HV_SYNIC_VERSION_1;\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tatomic64_set(&synic->sint[i], HV_SYNIC_SINT_MASKED);\n\t\tatomic_set(&synic->sint_to_gsi[i], -1);\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&synic->sint_to_gsi[i]",
            "-1"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&synic->sint[i]",
            "HV_SYNIC_SINT_MASKED"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "synic",
            "0",
            "sizeof(*synic)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_init(struct kvm_vcpu_hv_synic *synic)\n{\n\tint i;\n\n\tmemset(synic, 0, sizeof(*synic));\n\tsynic->version = HV_SYNIC_VERSION_1;\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tatomic64_set(&synic->sint[i], HV_SYNIC_SINT_MASKED);\n\t\tatomic_set(&synic->sint_to_gsi[i], -1);\n\t}\n}"
  },
  {
    "function_name": "kvm_hv_irq_routing_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "367-383",
    "snippet": "void kvm_hv_irq_routing_update(struct kvm *kvm)\n{\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tu32 gsi;\n\n\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));\n\n\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {\n\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {\n\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)\n\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,\n\t\t\t\t\t\t    e->hv_sint.sint, gsi);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_set_sint_gsi",
          "args": [
            "kvm",
            "e->hv_sint.vcpu",
            "e->hv_sint.sint",
            "gsi"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_set_sint_gsi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "352-365",
          "snippet": "static int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vpidx, u32 sint, int gsi)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vpidx);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))\n\t\treturn -EINVAL;\n\n\tatomic_set(&synic->sint_to_gsi[sint], gsi);\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vpidx, u32 sint, int gsi)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vpidx);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))\n\t\treturn -EINVAL;\n\n\tatomic_set(&synic->sint_to_gsi[sint], gsi);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "e",
            "&irq_rt->map[gsi]",
            "link"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference_check",
          "args": [
            "kvm->irq_routing",
            "&kvm->irq_srcu",
            "lockdep_is_held(&kvm->irq_lock)"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&kvm->irq_lock"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_irq_routing_update(struct kvm *kvm)\n{\n\tstruct kvm_irq_routing_table *irq_rt;\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tu32 gsi;\n\n\tirq_rt = srcu_dereference_check(kvm->irq_routing, &kvm->irq_srcu,\n\t\t\t\t\tlockdep_is_held(&kvm->irq_lock));\n\n\tfor (gsi = 0; gsi < irq_rt->nr_rt_entries; gsi++) {\n\t\thlist_for_each_entry(e, &irq_rt->map[gsi], link) {\n\t\t\tif (e->type == KVM_IRQ_ROUTING_HV_SINT)\n\t\t\t\tkvm_hv_set_sint_gsi(kvm, e->hv_sint.vcpu,\n\t\t\t\t\t\t    e->hv_sint.sint, gsi);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kvm_hv_set_sint_gsi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "352-365",
    "snippet": "static int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vpidx, u32 sint, int gsi)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vpidx);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))\n\t\treturn -EINVAL;\n\n\tatomic_set(&synic->sint_to_gsi[sint], gsi);\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&synic->sint_to_gsi[sint]",
            "gsi"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint_to_gsi"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_get",
          "args": [
            "kvm",
            "vpidx"
          ],
          "line": 356
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "151-161",
          "snippet": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int kvm_hv_set_sint_gsi(struct kvm *kvm, u32 vpidx, u32 sint, int gsi)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vpidx);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\tif (sint >= ARRAY_SIZE(synic->sint_to_gsi))\n\t\treturn -EINVAL;\n\n\tatomic_set(&synic->sint_to_gsi[sint], gsi);\n\treturn 0;\n}"
  },
  {
    "function_name": "kvm_hv_synic_send_eoi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "340-350",
    "snippet": "void kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tint i;\n\n\ttrace_kvm_hv_synic_send_eoi(vcpu->vcpu_id, vector);\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_hv_notify_acked_sint",
          "args": [
            "vcpu",
            "i"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_notify_acked_sint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "163-187",
          "snippet": "static void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending && stimer->config.enable &&\n\t\t    !stimer->config.direct_mode &&\n\t\t    stimer->config.sintx == sint)\n\t\t\tstimer_mark_pending(stimer, false);\n\t}\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending && stimer->config.enable &&\n\t\t    !stimer->config.direct_mode &&\n\t\t    stimer->config.sintx == sint)\n\t\t\tstimer_mark_pending(stimer, false);\n\t}\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_get_sint_vector",
          "args": [
            "synic_read_sint(synic, i)"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get_sint_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "48-53",
          "snippet": "static inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_read_sint",
          "args": [
            "synic",
            "i"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "synic_read_sint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "43-46",
          "snippet": "static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_synic_send_eoi",
          "args": [
            "vcpu->vcpu_id",
            "vector"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "39-42",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nvoid kvm_hv_synic_send_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tint i;\n\n\ttrace_kvm_hv_synic_send_eoi(vcpu->vcpu_id, vector);\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n}"
  },
  {
    "function_name": "kvm_hv_synic_set_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "329-338",
    "snippet": "int kvm_hv_synic_set_irq(struct kvm *kvm, u32 vpidx, u32 sint)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vpidx);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\treturn synic_set_irq(synic, sint);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synic_set_irq",
          "args": [
            "synic",
            "sint"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "synic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "304-327",
          "snippet": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_get",
          "args": [
            "kvm",
            "vpidx"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "151-161",
          "snippet": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nint kvm_hv_synic_set_irq(struct kvm *kvm, u32 vpidx, u32 sint)\n{\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tsynic = synic_get(kvm, vpidx);\n\tif (!synic)\n\t\treturn -EINVAL;\n\n\treturn synic_set_irq(synic, sint);\n}"
  },
  {
    "function_name": "synic_set_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "304-327",
    "snippet": "static int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_hv_synic_set_irq",
          "args": [
            "vcpu->vcpu_id",
            "sint",
            "irq.vector",
            "ret"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic",
          "args": [
            "vcpu->kvm",
            "vcpu->arch.apic",
            "&irq",
            "NULL"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "47-102",
          "snippet": "int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL &&\n\t    irq->dest_id == 0xff && kvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL &&\n\t    irq->dest_id == 0xff && kvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&irq",
            "0",
            "sizeof(irq)"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_get_sint_vector",
          "args": [
            "synic_read_sint(synic, sint)"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get_sint_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "48-53",
          "snippet": "static inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_read_sint",
          "args": [
            "synic",
            "sint"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "synic_read_sint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "43-46",
          "snippet": "static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_to_vcpu",
          "args": [
            "synic"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "synic_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "44-47",
          "snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_set_irq(struct kvm_vcpu_hv_synic *synic, u32 sint)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_lapic_irq irq;\n\tint ret, vector;\n\n\tif (sint >= ARRAY_SIZE(synic->sint))\n\t\treturn -EINVAL;\n\n\tvector = synic_get_sint_vector(synic_read_sint(synic, sint));\n\tif (vector < 0)\n\t\treturn -ENOENT;\n\n\tmemset(&irq, 0, sizeof(irq));\n\tirq.shorthand = APIC_DEST_SELF;\n\tirq.dest_mode = APIC_DEST_PHYSICAL;\n\tirq.delivery_mode = APIC_DM_FIXED;\n\tirq.vector = vector;\n\tirq.level = 1;\n\n\tret = kvm_irq_delivery_to_apic(vcpu->kvm, vcpu->arch.apic, &irq, NULL);\n\ttrace_kvm_hv_synic_set_irq(vcpu->vcpu_id, sint, irq.vector, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "synic_get_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "269-302",
    "snippet": "static int synic_get_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 *pdata,\n\t\t\t bool host)\n{\n\tint ret;\n\n\tif (!synic->active && !host)\n\t\treturn 1;\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\t*pdata = synic->control;\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\t*pdata = synic->version;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\t*pdata = synic->evt_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\t*pdata = synic->msg_page;\n\t\tbreak;\n\tcase HV_X64_MSR_EOM:\n\t\t*pdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\t*pdata = atomic64_read(&synic->sint[msr - HV_X64_MSR_SINT0]);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&synic->sint[msr - HV_X64_MSR_SINT0]"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_get_msr(struct kvm_vcpu_hv_synic *synic, u32 msr, u64 *pdata,\n\t\t\t bool host)\n{\n\tint ret;\n\n\tif (!synic->active && !host)\n\t\treturn 1;\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\t*pdata = synic->control;\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\t*pdata = synic->version;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\t*pdata = synic->evt_page;\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\t*pdata = synic->msg_page;\n\t\tbreak;\n\tcase HV_X64_MSR_EOM:\n\t\t*pdata = 0;\n\t\tbreak;\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\t*pdata = atomic64_read(&synic->sint[msr - HV_X64_MSR_SINT0]);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "synic_set_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "203-267",
    "snippet": "static int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint ret;\n\n\tif (!synic->active && !host)\n\t\treturn 1;\n\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif ((data & HV_SYNIC_SIMP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synic_set_sint",
          "args": [
            "synic",
            "msr - HV_X64_MSR_SINT0",
            "data",
            "host"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "synic_set_sint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "99-132",
          "snippet": "static int synic_set_sint(struct kvm_vcpu_hv_synic *synic, int sint,\n\t\t\t  u64 data, bool host)\n{\n\tint vector, old_vector;\n\tbool masked;\n\n\tvector = data & HV_SYNIC_SINT_VECTOR_MASK;\n\tmasked = data & HV_SYNIC_SINT_MASKED;\n\n\t/*\n\t * Valid vectors are 16-255, however, nested Hyper-V attempts to write\n\t * default '0x10000' value on boot and this should not #GP. We need to\n\t * allow zero-initing the register from host as well.\n\t */\n\tif (vector < HV_SYNIC_FIRST_VALID_VECTOR && !host && !masked)\n\t\treturn 1;\n\t/*\n\t * Guest may configure multiple SINTs to use the same vector, so\n\t * we maintain a bitmap of vectors handled by synic, and a\n\t * bitmap of vectors with auto-eoi behavior.  The bitmaps are\n\t * updated here, and atomically queried on fast paths.\n\t */\n\told_vector = synic_read_sint(synic, sint) & HV_SYNIC_SINT_VECTOR_MASK;\n\n\tatomic64_set(&synic->sint[sint], data);\n\n\tsynic_update_vector(synic, old_vector);\n\n\tsynic_update_vector(synic, vector);\n\n\t/* Load SynIC vectors into EOI exit bitmap */\n\tkvm_make_request(KVM_REQ_SCAN_IOAPIC, synic_to_vcpu(synic));\n\treturn 0;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_set_sint(struct kvm_vcpu_hv_synic *synic, int sint,\n\t\t\t  u64 data, bool host)\n{\n\tint vector, old_vector;\n\tbool masked;\n\n\tvector = data & HV_SYNIC_SINT_VECTOR_MASK;\n\tmasked = data & HV_SYNIC_SINT_MASKED;\n\n\t/*\n\t * Valid vectors are 16-255, however, nested Hyper-V attempts to write\n\t * default '0x10000' value on boot and this should not #GP. We need to\n\t * allow zero-initing the register from host as well.\n\t */\n\tif (vector < HV_SYNIC_FIRST_VALID_VECTOR && !host && !masked)\n\t\treturn 1;\n\t/*\n\t * Guest may configure multiple SINTs to use the same vector, so\n\t * we maintain a bitmap of vectors handled by synic, and a\n\t * bitmap of vectors with auto-eoi behavior.  The bitmaps are\n\t * updated here, and atomically queried on fast paths.\n\t */\n\told_vector = synic_read_sint(synic, sint) & HV_SYNIC_SINT_VECTOR_MASK;\n\n\tatomic64_set(&synic->sint[sint], data);\n\n\tsynic_update_vector(synic, old_vector);\n\n\tsynic_update_vector(synic, vector);\n\n\t/* Load SynIC vectors into EOI exit bitmap */\n\tkvm_make_request(KVM_REQ_SCAN_IOAPIC, synic_to_vcpu(synic));\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_hv_notify_acked_sint",
          "args": [
            "vcpu",
            "i"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hv_notify_acked_sint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "163-187",
          "snippet": "static void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending && stimer->config.enable &&\n\t\t    !stimer->config.direct_mode &&\n\t\t    stimer->config.sintx == sint)\n\t\t\tstimer_mark_pending(stimer, false);\n\t}\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending && stimer->config.enable &&\n\t\t    !stimer->config.direct_mode &&\n\t\t    stimer->config.sintx == sint)\n\t\t\tstimer_mark_pending(stimer, false);\n\t}\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_exit",
          "args": [
            "synic",
            "msr"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "synic_exit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "189-201",
          "snippet": "static void synic_exit(struct kvm_vcpu_hv_synic *synic, u32 msr)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\thv_vcpu->exit.type = KVM_EXIT_HYPERV_SYNIC;\n\thv_vcpu->exit.u.synic.msr = msr;\n\thv_vcpu->exit.u.synic.control = synic->control;\n\thv_vcpu->exit.u.synic.evt_page = synic->evt_page;\n\thv_vcpu->exit.u.synic.msg_page = synic->msg_page;\n\n\tkvm_make_request(KVM_REQ_HV_EXIT, vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_exit(struct kvm_vcpu_hv_synic *synic, u32 msr)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\thv_vcpu->exit.type = KVM_EXIT_HYPERV_SYNIC;\n\thv_vcpu->exit.u.synic.msr = msr;\n\thv_vcpu->exit.u.synic.control = synic->control;\n\thv_vcpu->exit.u.synic.evt_page = synic->evt_page;\n\thv_vcpu->exit.u.synic.msg_page = synic->msg_page;\n\n\tkvm_make_request(KVM_REQ_HV_EXIT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_guest",
          "args": [
            "vcpu->kvm",
            "data & PAGE_MASK",
            "PAGE_SIZE"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_clear_guest",
          "args": [
            "vcpu->kvm",
            "data & PAGE_MASK",
            "PAGE_SIZE"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_synic_set_msr",
          "args": [
            "vcpu->vcpu_id",
            "msr",
            "data",
            "host"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_to_vcpu",
          "args": [
            "synic"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "synic_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "44-47",
          "snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_set_msr(struct kvm_vcpu_hv_synic *synic,\n\t\t\t u32 msr, u64 data, bool host)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tint ret;\n\n\tif (!synic->active && !host)\n\t\treturn 1;\n\n\ttrace_kvm_hv_synic_set_msr(vcpu->vcpu_id, msr, data, host);\n\n\tret = 0;\n\tswitch (msr) {\n\tcase HV_X64_MSR_SCONTROL:\n\t\tsynic->control = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SVERSION:\n\t\tif (!host) {\n\t\t\tret = 1;\n\t\t\tbreak;\n\t\t}\n\t\tsynic->version = data;\n\t\tbreak;\n\tcase HV_X64_MSR_SIEFP:\n\t\tif ((data & HV_SYNIC_SIEFP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->evt_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_SIMP:\n\t\tif ((data & HV_SYNIC_SIMP_ENABLE) && !host &&\n\t\t    !synic->dont_zero_synic_pages)\n\t\t\tif (kvm_clear_guest(vcpu->kvm,\n\t\t\t\t\t    data & PAGE_MASK, PAGE_SIZE)) {\n\t\t\t\tret = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tsynic->msg_page = data;\n\t\tif (!host)\n\t\t\tsynic_exit(synic, msr);\n\t\tbreak;\n\tcase HV_X64_MSR_EOM: {\n\t\tint i;\n\n\t\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++)\n\t\t\tkvm_hv_notify_acked_sint(vcpu, i);\n\t\tbreak;\n\t}\n\tcase HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15:\n\t\tret = synic_set_sint(synic, msr - HV_X64_MSR_SINT0, data, host);\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "synic_exit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "189-201",
    "snippet": "static void synic_exit(struct kvm_vcpu_hv_synic *synic, u32 msr)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\thv_vcpu->exit.type = KVM_EXIT_HYPERV_SYNIC;\n\thv_vcpu->exit.u.synic.msr = msr;\n\thv_vcpu->exit.u.synic.control = synic->control;\n\thv_vcpu->exit.u.synic.evt_page = synic->evt_page;\n\thv_vcpu->exit.u.synic.msg_page = synic->msg_page;\n\n\tkvm_make_request(KVM_REQ_HV_EXIT, vcpu);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_HV_EXIT",
            "vcpu"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_to_vcpu",
          "args": [
            "synic"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "synic_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "44-47",
          "snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_exit(struct kvm_vcpu_hv_synic *synic, u32 msr)\n{\n\tstruct kvm_vcpu *vcpu = synic_to_vcpu(synic);\n\tstruct kvm_vcpu_hv *hv_vcpu = &vcpu->arch.hyperv;\n\n\thv_vcpu->exit.type = KVM_EXIT_HYPERV_SYNIC;\n\thv_vcpu->exit.u.synic.msr = msr;\n\thv_vcpu->exit.u.synic.control = synic->control;\n\thv_vcpu->exit.u.synic.evt_page = synic->evt_page;\n\thv_vcpu->exit.u.synic.msg_page = synic->msg_page;\n\n\tkvm_make_request(KVM_REQ_HV_EXIT, vcpu);\n}"
  },
  {
    "function_name": "kvm_hv_notify_acked_sint",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "163-187",
    "snippet": "static void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending && stimer->config.enable &&\n\t\t    !stimer->config.direct_mode &&\n\t\t    stimer->config.sintx == sint)\n\t\t\tstimer_mark_pending(stimer, false);\n\t}\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->irq_srcu",
            "idx"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_notify_acked_gsi",
          "args": [
            "kvm",
            "gsi"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&synic->sint_to_gsi[sint]"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->irq_srcu"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stimer_mark_pending",
          "args": [
            "stimer",
            "false"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "stimer_mark_pending",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "416-426",
          "snippet": "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick);\n\nstatic void stimer_mark_pending(struct kvm_vcpu_hv_stimer *stimer,\n\t\t\t\tbool vcpu_kick)\n{\n\tstruct kvm_vcpu *vcpu = stimer_to_vcpu(stimer);\n\n\tset_bit(stimer->index,\n\t\tvcpu_to_hv_vcpu(vcpu)->stimer_pending_bitmap);\n\tkvm_make_request(KVM_REQ_HV_STIMER, vcpu);\n\tif (vcpu_kick)\n\t\tkvm_vcpu_kick(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "hv_vcpu->stimer"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_hv_notify_acked_sint",
          "args": [
            "vcpu->vcpu_id",
            "sint"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "26-29",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "39-42",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void kvm_hv_notify_acked_sint(struct kvm_vcpu *vcpu, u32 sint)\n{\n\tstruct kvm *kvm = vcpu->kvm;\n\tstruct kvm_vcpu_hv_synic *synic = vcpu_to_synic(vcpu);\n\tstruct kvm_vcpu_hv *hv_vcpu = vcpu_to_hv_vcpu(vcpu);\n\tstruct kvm_vcpu_hv_stimer *stimer;\n\tint gsi, idx;\n\n\ttrace_kvm_hv_notify_acked_sint(vcpu->vcpu_id, sint);\n\n\t/* Try to deliver pending Hyper-V SynIC timers messages */\n\tfor (idx = 0; idx < ARRAY_SIZE(hv_vcpu->stimer); idx++) {\n\t\tstimer = &hv_vcpu->stimer[idx];\n\t\tif (stimer->msg_pending && stimer->config.enable &&\n\t\t    !stimer->config.direct_mode &&\n\t\t    stimer->config.sintx == sint)\n\t\t\tstimer_mark_pending(stimer, false);\n\t}\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = atomic_read(&synic->sint_to_gsi[sint]);\n\tif (gsi != -1)\n\t\tkvm_notify_acked_gsi(kvm, gsi);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
  },
  {
    "function_name": "synic_get",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "151-161",
    "snippet": "static struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_synic",
          "args": [
            "vcpu"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_synic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "39-42",
          "snippet": "static inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv_synic *vcpu_to_synic(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv.synic;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vcpu_by_vpidx",
          "args": [
            "kvm",
            "vpidx"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "get_vcpu_by_vpidx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "134-149",
          "snippet": "static struct kvm_vcpu *get_vcpu_by_vpidx(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tint i;\n\n\tif (vpidx >= KVM_MAX_VCPUS)\n\t\treturn NULL;\n\n\tvcpu = kvm_get_vcpu(kvm, vpidx);\n\tif (vcpu && vcpu_to_hv_vcpu(vcpu)->vp_index == vpidx)\n\t\treturn vcpu;\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (vcpu_to_hv_vcpu(vcpu)->vp_index == vpidx)\n\t\t\treturn vcpu;\n\treturn NULL;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic struct kvm_vcpu *get_vcpu_by_vpidx(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tint i;\n\n\tif (vpidx >= KVM_MAX_VCPUS)\n\t\treturn NULL;\n\n\tvcpu = kvm_get_vcpu(kvm, vpidx);\n\tif (vcpu && vcpu_to_hv_vcpu(vcpu)->vp_index == vpidx)\n\t\treturn vcpu;\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (vcpu_to_hv_vcpu(vcpu)->vp_index == vpidx)\n\t\t\treturn vcpu;\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic struct kvm_vcpu_hv_synic *synic_get(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu;\n\tstruct kvm_vcpu_hv_synic *synic;\n\n\tvcpu = get_vcpu_by_vpidx(kvm, vpidx);\n\tif (!vcpu)\n\t\treturn NULL;\n\tsynic = vcpu_to_synic(vcpu);\n\treturn (synic->active) ? synic : NULL;\n}"
  },
  {
    "function_name": "get_vcpu_by_vpidx",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "134-149",
    "snippet": "static struct kvm_vcpu *get_vcpu_by_vpidx(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tint i;\n\n\tif (vpidx >= KVM_MAX_VCPUS)\n\t\treturn NULL;\n\n\tvcpu = kvm_get_vcpu(kvm, vpidx);\n\tif (vcpu && vcpu_to_hv_vcpu(vcpu)->vp_index == vpidx)\n\t\treturn vcpu;\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (vcpu_to_hv_vcpu(vcpu)->vp_index == vpidx)\n\t\t\treturn vcpu;\n\treturn NULL;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vcpu_to_hv_vcpu",
          "args": [
            "vcpu"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "vcpu_to_hv_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "26-29",
          "snippet": "static inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu_hv *vcpu_to_hv_vcpu(struct kvm_vcpu *vcpu)\n{\n\treturn &vcpu->arch.hyperv;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_vcpu",
          "args": [
            "kvm",
            "vpidx"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic struct kvm_vcpu *get_vcpu_by_vpidx(struct kvm *kvm, u32 vpidx)\n{\n\tstruct kvm_vcpu *vcpu = NULL;\n\tint i;\n\n\tif (vpidx >= KVM_MAX_VCPUS)\n\t\treturn NULL;\n\n\tvcpu = kvm_get_vcpu(kvm, vpidx);\n\tif (vcpu && vcpu_to_hv_vcpu(vcpu)->vp_index == vpidx)\n\t\treturn vcpu;\n\tkvm_for_each_vcpu(i, vcpu, kvm)\n\t\tif (vcpu_to_hv_vcpu(vcpu)->vp_index == vpidx)\n\t\t\treturn vcpu;\n\treturn NULL;\n}"
  },
  {
    "function_name": "synic_set_sint",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "99-132",
    "snippet": "static int synic_set_sint(struct kvm_vcpu_hv_synic *synic, int sint,\n\t\t\t  u64 data, bool host)\n{\n\tint vector, old_vector;\n\tbool masked;\n\n\tvector = data & HV_SYNIC_SINT_VECTOR_MASK;\n\tmasked = data & HV_SYNIC_SINT_MASKED;\n\n\t/*\n\t * Valid vectors are 16-255, however, nested Hyper-V attempts to write\n\t * default '0x10000' value on boot and this should not #GP. We need to\n\t * allow zero-initing the register from host as well.\n\t */\n\tif (vector < HV_SYNIC_FIRST_VALID_VECTOR && !host && !masked)\n\t\treturn 1;\n\t/*\n\t * Guest may configure multiple SINTs to use the same vector, so\n\t * we maintain a bitmap of vectors handled by synic, and a\n\t * bitmap of vectors with auto-eoi behavior.  The bitmaps are\n\t * updated here, and atomically queried on fast paths.\n\t */\n\told_vector = synic_read_sint(synic, sint) & HV_SYNIC_SINT_VECTOR_MASK;\n\n\tatomic64_set(&synic->sint[sint], data);\n\n\tsynic_update_vector(synic, old_vector);\n\n\tsynic_update_vector(synic, vector);\n\n\t/* Load SynIC vectors into EOI exit bitmap */\n\tkvm_make_request(KVM_REQ_SCAN_IOAPIC, synic_to_vcpu(synic));\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_SCAN_IOAPIC",
            "synic_to_vcpu(synic)"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_to_vcpu",
          "args": [
            "synic"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "synic_to_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.h",
          "lines": "44-47",
          "snippet": "static inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline struct kvm_vcpu *synic_to_vcpu(struct kvm_vcpu_hv_synic *synic)\n{\n\treturn hv_vcpu_to_vcpu(container_of(synic, struct kvm_vcpu_hv, synic));\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_update_vector",
          "args": [
            "synic",
            "vector"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "synic_update_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "82-97",
          "snippet": "static void synic_update_vector(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\tint vector)\n{\n\tif (vector < HV_SYNIC_FIRST_VALID_VECTOR)\n\t\treturn;\n\n\tif (synic_has_vector_connected(synic, vector))\n\t\t__set_bit(vector, synic->vec_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->vec_bitmap);\n\n\tif (synic_has_vector_auto_eoi(synic, vector))\n\t\t__set_bit(vector, synic->auto_eoi_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->auto_eoi_bitmap);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_update_vector(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\tint vector)\n{\n\tif (vector < HV_SYNIC_FIRST_VALID_VECTOR)\n\t\treturn;\n\n\tif (synic_has_vector_connected(synic, vector))\n\t\t__set_bit(vector, synic->vec_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->vec_bitmap);\n\n\tif (synic_has_vector_auto_eoi(synic, vector))\n\t\t__set_bit(vector, synic->auto_eoi_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->auto_eoi_bitmap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_set",
          "args": [
            "&synic->sint[sint]",
            "data"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_read_sint",
          "args": [
            "synic",
            "sint"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "synic_read_sint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "43-46",
          "snippet": "static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic int synic_set_sint(struct kvm_vcpu_hv_synic *synic, int sint,\n\t\t\t  u64 data, bool host)\n{\n\tint vector, old_vector;\n\tbool masked;\n\n\tvector = data & HV_SYNIC_SINT_VECTOR_MASK;\n\tmasked = data & HV_SYNIC_SINT_MASKED;\n\n\t/*\n\t * Valid vectors are 16-255, however, nested Hyper-V attempts to write\n\t * default '0x10000' value on boot and this should not #GP. We need to\n\t * allow zero-initing the register from host as well.\n\t */\n\tif (vector < HV_SYNIC_FIRST_VALID_VECTOR && !host && !masked)\n\t\treturn 1;\n\t/*\n\t * Guest may configure multiple SINTs to use the same vector, so\n\t * we maintain a bitmap of vectors handled by synic, and a\n\t * bitmap of vectors with auto-eoi behavior.  The bitmaps are\n\t * updated here, and atomically queried on fast paths.\n\t */\n\told_vector = synic_read_sint(synic, sint) & HV_SYNIC_SINT_VECTOR_MASK;\n\n\tatomic64_set(&synic->sint[sint], data);\n\n\tsynic_update_vector(synic, old_vector);\n\n\tsynic_update_vector(synic, vector);\n\n\t/* Load SynIC vectors into EOI exit bitmap */\n\tkvm_make_request(KVM_REQ_SCAN_IOAPIC, synic_to_vcpu(synic));\n\treturn 0;\n}"
  },
  {
    "function_name": "synic_update_vector",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "82-97",
    "snippet": "static void synic_update_vector(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\tint vector)\n{\n\tif (vector < HV_SYNIC_FIRST_VALID_VECTOR)\n\t\treturn;\n\n\tif (synic_has_vector_connected(synic, vector))\n\t\t__set_bit(vector, synic->vec_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->vec_bitmap);\n\n\tif (synic_has_vector_auto_eoi(synic, vector))\n\t\t__set_bit(vector, synic->auto_eoi_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->auto_eoi_bitmap);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "vector",
            "synic->auto_eoi_bitmap"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "vector",
            "synic->auto_eoi_bitmap"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_has_vector_auto_eoi",
          "args": [
            "synic",
            "vector"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "synic_has_vector_auto_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "67-80",
          "snippet": "static bool synic_has_vector_auto_eoi(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t     int vector)\n{\n\tint i;\n\tu64 sint_value;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tsint_value = synic_read_sint(synic, i);\n\t\tif (synic_get_sint_vector(sint_value) == vector &&\n\t\t    sint_value & HV_SYNIC_SINT_AUTO_EOI)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool synic_has_vector_auto_eoi(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t     int vector)\n{\n\tint i;\n\tu64 sint_value;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tsint_value = synic_read_sint(synic, i);\n\t\tif (synic_get_sint_vector(sint_value) == vector &&\n\t\t    sint_value & HV_SYNIC_SINT_AUTO_EOI)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "vector",
            "synic->vec_bitmap"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "vector",
            "synic->vec_bitmap"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synic_has_vector_connected",
          "args": [
            "synic",
            "vector"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "synic_has_vector_connected",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "55-65",
          "snippet": "static bool synic_has_vector_connected(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t      int vector)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool synic_has_vector_connected(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t      int vector)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic void synic_update_vector(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\tint vector)\n{\n\tif (vector < HV_SYNIC_FIRST_VALID_VECTOR)\n\t\treturn;\n\n\tif (synic_has_vector_connected(synic, vector))\n\t\t__set_bit(vector, synic->vec_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->vec_bitmap);\n\n\tif (synic_has_vector_auto_eoi(synic, vector))\n\t\t__set_bit(vector, synic->auto_eoi_bitmap);\n\telse\n\t\t__clear_bit(vector, synic->auto_eoi_bitmap);\n}"
  },
  {
    "function_name": "synic_has_vector_auto_eoi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "67-80",
    "snippet": "static bool synic_has_vector_auto_eoi(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t     int vector)\n{\n\tint i;\n\tu64 sint_value;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tsint_value = synic_read_sint(synic, i);\n\t\tif (synic_get_sint_vector(sint_value) == vector &&\n\t\t    sint_value & HV_SYNIC_SINT_AUTO_EOI)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synic_get_sint_vector",
          "args": [
            "sint_value"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get_sint_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "48-53",
          "snippet": "static inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_read_sint",
          "args": [
            "synic",
            "i"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "synic_read_sint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "43-46",
          "snippet": "static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool synic_has_vector_auto_eoi(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t     int vector)\n{\n\tint i;\n\tu64 sint_value;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tsint_value = synic_read_sint(synic, i);\n\t\tif (synic_get_sint_vector(sint_value) == vector &&\n\t\t    sint_value & HV_SYNIC_SINT_AUTO_EOI)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "synic_has_vector_connected",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "55-65",
    "snippet": "static bool synic_has_vector_connected(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t      int vector)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synic_get_sint_vector",
          "args": [
            "synic_read_sint(synic, i)"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "synic_get_sint_vector",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "48-53",
          "snippet": "static inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synic_read_sint",
          "args": [
            "synic",
            "i"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "synic_read_sint",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
          "lines": "43-46",
          "snippet": "static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"trace.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/apicdef.h>",
            "#include <linux/eventfd.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/highmem.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/cpu.h>",
            "#include \"hyperv.h\"",
            "#include \"ioapic.h\"",
            "#include \"lapic.h\"",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "synic->sint"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic bool synic_has_vector_connected(struct kvm_vcpu_hv_synic *synic,\n\t\t\t\t      int vector)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(synic->sint); i++) {\n\t\tif (synic_get_sint_vector(synic_read_sint(synic, i)) == vector)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "synic_get_sint_vector",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "48-53",
    "snippet": "static inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline int synic_get_sint_vector(u64 sint_value)\n{\n\tif (sint_value & HV_SYNIC_SINT_MASKED)\n\t\treturn -1;\n\treturn sint_value & HV_SYNIC_SINT_VECTOR_MASK;\n}"
  },
  {
    "function_name": "synic_read_sint",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/hyperv.c",
    "lines": "43-46",
    "snippet": "static inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"trace.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/apicdef.h>",
      "#include <linux/eventfd.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/highmem.h>",
      "#include <linux/kvm_host.h>",
      "#include <linux/cpu.h>",
      "#include \"hyperv.h\"",
      "#include \"ioapic.h\"",
      "#include \"lapic.h\"",
      "#include \"x86.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&synic->sint[sint]"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"trace.h\"\n#include <trace/events/kvm.h>\n#include <asm/apicdef.h>\n#include <linux/eventfd.h>\n#include <linux/sched/cputime.h>\n#include <linux/highmem.h>\n#include <linux/kvm_host.h>\n#include <linux/cpu.h>\n#include \"hyperv.h\"\n#include \"ioapic.h\"\n#include \"lapic.h\"\n#include \"x86.h\"\n\nstatic inline u64 synic_read_sint(struct kvm_vcpu_hv_synic *synic, int sint)\n{\n\treturn atomic64_read(&synic->sint[sint]);\n}"
  }
]