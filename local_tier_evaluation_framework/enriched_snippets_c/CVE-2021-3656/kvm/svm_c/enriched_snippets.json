[
  {
    "function_name": "svm_exit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "6375-6378",
    "snippet": "static void __exit svm_exit(void)\n{\n\tkvm_exit();\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_exit",
          "args": [],
          "line": 6377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void __exit svm_exit(void)\n{\n\tkvm_exit();\n}"
  },
  {
    "function_name": "svm_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "6369-6373",
    "snippet": "static int __init svm_init(void)\n{\n\treturn kvm_init(&svm_init_ops, sizeof(struct vcpu_svm),\n\t\t\t__alignof__(struct vcpu_svm), THIS_MODULE);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_init",
          "args": [
            "&svm_init_ops",
            "sizeof(struct vcpu_svm)",
            "__alignof__(struct vcpu_svm)",
            "THIS_MODULE"
          ],
          "line": 6371
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_init_shadow_ept_mmu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5041-5073",
          "snippet": "void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly,\n\t\t\t     bool accessed_dirty, gpa_t new_eptp)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tu8 level = vmx_eptp_page_walk_level(new_eptp);\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_shadow_ept_root_page_role(vcpu, accessed_dirty,\n\t\t\t\t\t\t   execonly, level);\n\n\t__kvm_mmu_new_cr3(vcpu, new_eptp, new_role.base, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tcontext->shadow_root_level = level;\n\n\tcontext->nx = true;\n\tcontext->ept_ad = accessed_dirty;\n\tcontext->page_fault = ept_page_fault;\n\tcontext->gva_to_gpa = ept_gva_to_gpa;\n\tcontext->sync_page = ept_sync_page;\n\tcontext->invlpg = ept_invlpg;\n\tcontext->update_pte = ept_update_pte;\n\tcontext->root_level = level;\n\tcontext->direct_map = false;\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\n\tupdate_permission_bitmask(vcpu, context, true);\n\tupdate_pkru_bitmask(vcpu, context, true);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_rsvds_bits_mask_ept(vcpu, context, execonly);\n\treset_ept_shadow_zero_bits_mask(vcpu, context, execonly);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly,\n\t\t\t     bool accessed_dirty, gpa_t new_eptp)\n{\n\tstruct kvm_mmu *context = vcpu->arch.mmu;\n\tu8 level = vmx_eptp_page_walk_level(new_eptp);\n\tunion kvm_mmu_role new_role =\n\t\tkvm_calc_shadow_ept_root_page_role(vcpu, accessed_dirty,\n\t\t\t\t\t\t   execonly, level);\n\n\t__kvm_mmu_new_cr3(vcpu, new_eptp, new_role.base, false);\n\n\tif (new_role.as_u64 == context->mmu_role.as_u64)\n\t\treturn;\n\n\tcontext->shadow_root_level = level;\n\n\tcontext->nx = true;\n\tcontext->ept_ad = accessed_dirty;\n\tcontext->page_fault = ept_page_fault;\n\tcontext->gva_to_gpa = ept_gva_to_gpa;\n\tcontext->sync_page = ept_sync_page;\n\tcontext->invlpg = ept_invlpg;\n\tcontext->update_pte = ept_update_pte;\n\tcontext->root_level = level;\n\tcontext->direct_map = false;\n\tcontext->mmu_role.as_u64 = new_role.as_u64;\n\n\tupdate_permission_bitmask(vcpu, context, true);\n\tupdate_pkru_bitmask(vcpu, context, true);\n\tupdate_last_nonleaf_level(vcpu, context);\n\treset_rsvds_bits_mask_ept(vcpu, context, execonly);\n\treset_ept_shadow_zero_bits_mask(vcpu, context, execonly);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __init svm_init(void)\n{\n\treturn kvm_init(&svm_init_ops, sizeof(struct vcpu_svm),\n\t\t\t__alignof__(struct vcpu_svm), THIS_MODULE);\n}"
  },
  {
    "function_name": "svm_pre_update_apicv_exec_ctrl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "6229-6232",
    "snippet": "static void svm_pre_update_apicv_exec_ctrl(struct kvm *kvm, bool activate)\n{\n\tavic_update_access_page(kvm, activate);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_update_access_page",
          "args": [
            "kvm",
            "activate"
          ],
          "line": 6231
        },
        "resolved": true,
        "details": {
          "function_name": "avic_update_access_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1429-1454",
          "snippet": "static int avic_update_access_page(struct kvm *kvm, bool activate)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\t/*\n\t * During kvm_destroy_vm(), kvm_pit_set_reinject() could trigger\n\t * APICv mode change, which update APIC_ACCESS_PAGE_PRIVATE_MEMSLOT\n\t * memory region. So, we need to ensure that kvm->mm == current->mm.\n\t */\n\tif ((kvm->arch.apic_access_page_done == activate) ||\n\t    (kvm->mm != current->mm))\n\t\tgoto out;\n\n\tret = __x86_set_memory_region(kvm,\n\t\t\t\t      APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t      APIC_DEFAULT_PHYS_BASE,\n\t\t\t\t      activate ? PAGE_SIZE : 0);\n\tif (ret)\n\t\tgoto out;\n\n\tkvm->arch.apic_access_page_done = activate;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);\n\nstatic int avic_update_access_page(struct kvm *kvm, bool activate)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\t/*\n\t * During kvm_destroy_vm(), kvm_pit_set_reinject() could trigger\n\t * APICv mode change, which update APIC_ACCESS_PAGE_PRIVATE_MEMSLOT\n\t * memory region. So, we need to ensure that kvm->mm == current->mm.\n\t */\n\tif ((kvm->arch.apic_access_page_done == activate) ||\n\t    (kvm->mm != current->mm))\n\t\tgoto out;\n\n\tret = __x86_set_memory_region(kvm,\n\t\t\t\t      APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t      APIC_DEFAULT_PHYS_BASE,\n\t\t\t\t      activate ? PAGE_SIZE : 0);\n\tif (ret)\n\t\tgoto out;\n\n\tkvm->arch.apic_access_page_done = activate;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);\n\nstatic void svm_pre_update_apicv_exec_ctrl(struct kvm *kvm, bool activate)\n{\n\tavic_update_access_page(kvm, activate);\n}"
  },
  {
    "function_name": "svm_check_apicv_inhibit_reasons",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "6217-6227",
    "snippet": "static bool svm_check_apicv_inhibit_reasons(ulong bit)\n{\n\tulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_HYPERV) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_NESTED) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_IRQWIN) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_PIT_REINJ) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_X2APIC);\n\n\treturn supported & BIT(bit);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "bit"
          ],
          "line": 6226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "APICV_INHIBIT_REASON_X2APIC"
          ],
          "line": 6224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "APICV_INHIBIT_REASON_PIT_REINJ"
          ],
          "line": 6223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "APICV_INHIBIT_REASON_IRQWIN"
          ],
          "line": 6222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "APICV_INHIBIT_REASON_NESTED"
          ],
          "line": 6221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "APICV_INHIBIT_REASON_HYPERV"
          ],
          "line": 6220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BIT",
          "args": [
            "APICV_INHIBIT_REASON_DISABLE"
          ],
          "line": 6219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_check_apicv_inhibit_reasons(ulong bit)\n{\n\tulong supported = BIT(APICV_INHIBIT_REASON_DISABLE) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_HYPERV) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_NESTED) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_IRQWIN) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_PIT_REINJ) |\n\t\t\t  BIT(APICV_INHIBIT_REASON_X2APIC);\n\n\treturn supported & BIT(bit);\n}"
  },
  {
    "function_name": "svm_apic_init_signal_blocked",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "6202-6215",
    "snippet": "static bool svm_apic_init_signal_blocked(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * TODO: Last condition latch INIT signals on vCPU when\n\t * vCPU is in guest-mode and vmcb12 defines intercept on INIT.\n\t * To properly emulate the INIT intercept, SVM should implement\n\t * kvm_x86_ops.check_nested_events() and call nested_svm_vmexit()\n\t * there if an INIT signal is pending.\n\t */\n\treturn !gif_set(svm) ||\n\t\t   (svm->vmcb->control.intercept & (1ULL << INTERCEPT_INIT));\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 6213
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "325-331",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 6204
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic bool svm_apic_init_signal_blocked(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * TODO: Last condition latch INIT signals on vCPU when\n\t * vCPU is in guest-mode and vmcb12 defines intercept on INIT.\n\t * To properly emulate the INIT intercept, SVM should implement\n\t * kvm_x86_ops.check_nested_events() and call nested_svm_vmexit()\n\t * there if an INIT signal is pending.\n\t */\n\treturn !gif_set(svm) ||\n\t\t   (svm->vmcb->control.intercept & (1ULL << INTERCEPT_INIT));\n}"
  },
  {
    "function_name": "svm_need_emulation_on_page_fault",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "6144-6200",
    "snippet": "static bool svm_need_emulation_on_page_fault(struct kvm_vcpu *vcpu)\n{\n\tunsigned long cr4 = kvm_read_cr4(vcpu);\n\tbool smep = cr4 & X86_CR4_SMEP;\n\tbool smap = cr4 & X86_CR4_SMAP;\n\tbool is_user = svm_get_cpl(vcpu) == 3;\n\n\t/*\n\t * Detect and workaround Errata 1096 Fam_17h_00_0Fh.\n\t *\n\t * Errata:\n\t * When CPU raise #NPF on guest data access and vCPU CR4.SMAP=1, it is\n\t * possible that CPU microcode implementing DecodeAssist will fail\n\t * to read bytes of instruction which caused #NPF. In this case,\n\t * GuestIntrBytes field of the VMCB on a VMEXIT will incorrectly\n\t * return 0 instead of the correct guest instruction bytes.\n\t *\n\t * This happens because CPU microcode reading instruction bytes\n\t * uses a special opcode which attempts to read data using CPL=0\n\t * priviledges. The microcode reads CS:RIP and if it hits a SMAP\n\t * fault, it gives up and returns no instruction bytes.\n\t *\n\t * Detection:\n\t * We reach here in case CPU supports DecodeAssist, raised #NPF and\n\t * returned 0 in GuestIntrBytes field of the VMCB.\n\t * First, errata can only be triggered in case vCPU CR4.SMAP=1.\n\t * Second, if vCPU CR4.SMEP=1, errata could only be triggered\n\t * in case vCPU CPL==3 (Because otherwise guest would have triggered\n\t * a SMEP fault instead of #NPF).\n\t * Otherwise, vCPU CR4.SMEP=0, errata could be triggered by any vCPU CPL.\n\t * As most guests enable SMAP if they have also enabled SMEP, use above\n\t * logic in order to attempt minimize false-positive of detecting errata\n\t * while still preserving all cases semantic correctness.\n\t *\n\t * Workaround:\n\t * To determine what instruction the guest was executing, the hypervisor\n\t * will have to decode the instruction at the instruction pointer.\n\t *\n\t * In non SEV guest, hypervisor will be able to read the guest\n\t * memory to decode the instruction pointer when insn_len is zero\n\t * so we return true to indicate that decoding is possible.\n\t *\n\t * But in the SEV guest, the guest memory is encrypted with the\n\t * guest specific key and hypervisor will not be able to decode the\n\t * instruction pointer so we will not able to workaround it. Lets\n\t * print the error and request to kill the guest.\n\t */\n\tif (smap && (!smep || is_user)) {\n\t\tif (!sev_guest(vcpu->kvm))\n\t\t\treturn true;\n\n\t\tpr_err_ratelimited(\"KVM: SEV Guest triggered AMD Erratum 1096\\n\");\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TRIPLE_FAULT",
            "vcpu"
          ],
          "line": 6196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err_ratelimited",
          "args": [
            "\"KVM: SEV Guest triggered AMD Erratum 1096\\n\""
          ],
          "line": 6195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "vcpu->kvm"
          ],
          "line": 6192
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 6149
        },
        "resolved": true,
        "details": {
          "function_name": "svm_get_cpl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2229-2234",
          "snippet": "static int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4",
          "args": [
            "vcpu"
          ],
          "line": 6146
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "144-147",
          "snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic bool svm_need_emulation_on_page_fault(struct kvm_vcpu *vcpu)\n{\n\tunsigned long cr4 = kvm_read_cr4(vcpu);\n\tbool smep = cr4 & X86_CR4_SMEP;\n\tbool smap = cr4 & X86_CR4_SMAP;\n\tbool is_user = svm_get_cpl(vcpu) == 3;\n\n\t/*\n\t * Detect and workaround Errata 1096 Fam_17h_00_0Fh.\n\t *\n\t * Errata:\n\t * When CPU raise #NPF on guest data access and vCPU CR4.SMAP=1, it is\n\t * possible that CPU microcode implementing DecodeAssist will fail\n\t * to read bytes of instruction which caused #NPF. In this case,\n\t * GuestIntrBytes field of the VMCB on a VMEXIT will incorrectly\n\t * return 0 instead of the correct guest instruction bytes.\n\t *\n\t * This happens because CPU microcode reading instruction bytes\n\t * uses a special opcode which attempts to read data using CPL=0\n\t * priviledges. The microcode reads CS:RIP and if it hits a SMAP\n\t * fault, it gives up and returns no instruction bytes.\n\t *\n\t * Detection:\n\t * We reach here in case CPU supports DecodeAssist, raised #NPF and\n\t * returned 0 in GuestIntrBytes field of the VMCB.\n\t * First, errata can only be triggered in case vCPU CR4.SMAP=1.\n\t * Second, if vCPU CR4.SMEP=1, errata could only be triggered\n\t * in case vCPU CPL==3 (Because otherwise guest would have triggered\n\t * a SMEP fault instead of #NPF).\n\t * Otherwise, vCPU CR4.SMEP=0, errata could be triggered by any vCPU CPL.\n\t * As most guests enable SMAP if they have also enabled SMEP, use above\n\t * logic in order to attempt minimize false-positive of detecting errata\n\t * while still preserving all cases semantic correctness.\n\t *\n\t * Workaround:\n\t * To determine what instruction the guest was executing, the hypervisor\n\t * will have to decode the instruction at the instruction pointer.\n\t *\n\t * In non SEV guest, hypervisor will be able to read the guest\n\t * memory to decode the instruction pointer when insn_len is zero\n\t * so we return true to indicate that decoding is possible.\n\t *\n\t * But in the SEV guest, the guest memory is encrypted with the\n\t * guest specific key and hypervisor will not be able to decode the\n\t * instruction pointer so we will not able to workaround it. Lets\n\t * print the error and request to kill the guest.\n\t */\n\tif (smap && (!smep || is_user)) {\n\t\tif (!sev_guest(vcpu->kvm))\n\t\t\treturn true;\n\n\t\tpr_err_ratelimited(\"KVM: SEV Guest triggered AMD Erratum 1096\\n\");\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, vcpu);\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "svm_unregister_enc_region",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "6108-6142",
    "snippet": "static int svm_unregister_enc_region(struct kvm *kvm,\n\t\t\t\t     struct kvm_enc_region *range)\n{\n\tstruct enc_region *region;\n\tint ret;\n\n\tmutex_lock(&kvm->lock);\n\n\tif (!sev_guest(kvm)) {\n\t\tret = -ENOTTY;\n\t\tgoto failed;\n\t}\n\n\tregion = find_enc_region(kvm, range);\n\tif (!region) {\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * Ensure that all guest tagged cache entries are flushed before\n\t * releasing the pages back to the system for use. CLFLUSH will\n\t * not do this, so issue a WBINVD.\n\t */\n\twbinvd_on_all_cpus();\n\n\t__unregister_enc_region_locked(kvm, region);\n\n\tmutex_unlock(&kvm->lock);\n\treturn 0;\n\nfailed:\n\tmutex_unlock(&kvm->lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 6140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 6136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_enc_region_locked",
          "args": [
            "kvm",
            "region"
          ],
          "line": 6134
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_enc_region_locked",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1625-1631",
          "snippet": "static void __unregister_enc_region_locked(struct kvm *kvm,\n\t\t\t\t\t   struct enc_region *region)\n{\n\tsev_unpin_memory(kvm, region->pages, region->npages);\n\tlist_del(&region->list);\n\tkfree(region);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void __unregister_enc_region_locked(struct kvm *kvm,\n\t\t\t\t\t   struct enc_region *region)\n{\n\tsev_unpin_memory(kvm, region->pages, region->npages);\n\tlist_del(&region->list);\n\tkfree(region);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wbinvd_on_all_cpus",
          "args": [],
          "line": 6132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_enc_region",
          "args": [
            "kvm",
            "range"
          ],
          "line": 6121
        },
        "resolved": true,
        "details": {
          "function_name": "find_enc_region",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "6091-6105",
          "snippet": "static struct enc_region *\nfind_enc_region(struct kvm *kvm, struct kvm_enc_region *range)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct list_head *head = &sev->regions_list;\n\tstruct enc_region *i;\n\n\tlist_for_each_entry(i, head, list) {\n\t\tif (i->uaddr == range->addr &&\n\t\t    i->size == range->size)\n\t\t\treturn i;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic struct enc_region *\nfind_enc_region(struct kvm *kvm, struct kvm_enc_region *range)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct list_head *head = &sev->regions_list;\n\tstruct enc_region *i;\n\n\tlist_for_each_entry(i, head, list) {\n\t\tif (i->uaddr == range->addr &&\n\t\t    i->size == range->size)\n\t\t\treturn i;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "kvm"
          ],
          "line": 6116
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 6114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int svm_unregister_enc_region(struct kvm *kvm,\n\t\t\t\t     struct kvm_enc_region *range)\n{\n\tstruct enc_region *region;\n\tint ret;\n\n\tmutex_lock(&kvm->lock);\n\n\tif (!sev_guest(kvm)) {\n\t\tret = -ENOTTY;\n\t\tgoto failed;\n\t}\n\n\tregion = find_enc_region(kvm, range);\n\tif (!region) {\n\t\tret = -EINVAL;\n\t\tgoto failed;\n\t}\n\n\t/*\n\t * Ensure that all guest tagged cache entries are flushed before\n\t * releasing the pages back to the system for use. CLFLUSH will\n\t * not do this, so issue a WBINVD.\n\t */\n\twbinvd_on_all_cpus();\n\n\t__unregister_enc_region_locked(kvm, region);\n\n\tmutex_unlock(&kvm->lock);\n\treturn 0;\n\nfailed:\n\tmutex_unlock(&kvm->lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "find_enc_region",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "6091-6105",
    "snippet": "static struct enc_region *\nfind_enc_region(struct kvm *kvm, struct kvm_enc_region *range)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct list_head *head = &sev->regions_list;\n\tstruct enc_region *i;\n\n\tlist_for_each_entry(i, head, list) {\n\t\tif (i->uaddr == range->addr &&\n\t\t    i->size == range->size)\n\t\t\treturn i;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "i",
            "head",
            "list"
          ],
          "line": 6098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 6094
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic struct enc_region *\nfind_enc_region(struct kvm *kvm, struct kvm_enc_region *range)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct list_head *head = &sev->regions_list;\n\tstruct enc_region *i;\n\n\tlist_for_each_entry(i, head, list) {\n\t\tif (i->uaddr == range->addr &&\n\t\t    i->size == range->size)\n\t\t\treturn i;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "svm_register_enc_region",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "6046-6089",
    "snippet": "static int svm_register_enc_region(struct kvm *kvm,\n\t\t\t\t   struct kvm_enc_region *range)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct enc_region *region;\n\tint ret = 0;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (range->addr > ULONG_MAX || range->size > ULONG_MAX)\n\t\treturn -EINVAL;\n\n\tregion = kzalloc(sizeof(*region), GFP_KERNEL_ACCOUNT);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tregion->pages = sev_pin_memory(kvm, range->addr, range->size, &region->npages, 1);\n\tif (!region->pages) {\n\t\tret = -ENOMEM;\n\t\tgoto e_free;\n\t}\n\n\t/*\n\t * The guest may change the memory encryption attribute from C=0 -> C=1\n\t * or vice versa for this memory range. Lets make sure caches are\n\t * flushed to ensure that guest data gets written into memory with\n\t * correct C-bit.\n\t */\n\tsev_clflush_pages(region->pages, region->npages);\n\n\tregion->uaddr = range->addr;\n\tregion->size = range->size;\n\n\tmutex_lock(&kvm->lock);\n\tlist_add_tail(&region->list, &sev->regions_list);\n\tmutex_unlock(&kvm->lock);\n\n\treturn ret;\n\ne_free:\n\tkfree(region);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "region"
          ],
          "line": 6087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 6082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&region->list",
            "&sev->regions_list"
          ],
          "line": 6081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 6080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_clflush_pages",
          "args": [
            "region->pages",
            "region->npages"
          ],
          "line": 6075
        },
        "resolved": true,
        "details": {
          "function_name": "sev_clflush_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1610-1623",
          "snippet": "static void sev_clflush_pages(struct page *pages[], unsigned long npages)\n{\n\tuint8_t *page_virtual;\n\tunsigned long i;\n\n\tif (npages == 0 || pages == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpage_virtual = kmap_atomic(pages[i]);\n\t\tclflush_cache_range(page_virtual, PAGE_SIZE);\n\t\tkunmap_atomic(page_virtual);\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void sev_clflush_pages(struct page *pages[], unsigned long npages)\n{\n\tuint8_t *page_virtual;\n\tunsigned long i;\n\n\tif (npages == 0 || pages == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpage_virtual = kmap_atomic(pages[i]);\n\t\tclflush_cache_range(page_virtual, PAGE_SIZE);\n\t\tkunmap_atomic(page_virtual);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_pin_memory",
          "args": [
            "kvm",
            "range->addr",
            "range->size",
            "&region->npages",
            "1"
          ],
          "line": 6063
        },
        "resolved": true,
        "details": {
          "function_name": "sev_pin_memory",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1544-1598",
          "snippet": "static struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, npinned, size;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn NULL;\n\n\t/* Calculate number of pages. */\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn NULL;\n\t}\n\n\t/* Avoid using vmalloc for smaller buffers. */\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO,\n\t\t\t\t  PAGE_KERNEL);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\n\tif (!pages)\n\t\treturn NULL;\n\n\t/* Pin the user virtual address. */\n\tnpinned = get_user_pages_fast(uaddr, npages, FOLL_WRITE, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tgoto err;\n\t}\n\n\t*n = npages;\n\tsev->pages_locked = locked;\n\n\treturn pages;\n\nerr:\n\tif (npinned > 0)\n\t\trelease_pages(pages, npinned);\n\n\tkvfree(pages);\n\treturn NULL;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, npinned, size;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn NULL;\n\n\t/* Calculate number of pages. */\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn NULL;\n\t}\n\n\t/* Avoid using vmalloc for smaller buffers. */\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO,\n\t\t\t\t  PAGE_KERNEL);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\n\tif (!pages)\n\t\treturn NULL;\n\n\t/* Pin the user virtual address. */\n\tnpinned = get_user_pages_fast(uaddr, npages, FOLL_WRITE, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tgoto err;\n\t}\n\n\t*n = npages;\n\tsev->pages_locked = locked;\n\n\treturn pages;\n\nerr:\n\tif (npinned > 0)\n\t\trelease_pages(pages, npinned);\n\n\tkvfree(pages);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*region)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 6059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "kvm"
          ],
          "line": 6053
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 6049
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int svm_register_enc_region(struct kvm *kvm,\n\t\t\t\t   struct kvm_enc_region *range)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct enc_region *region;\n\tint ret = 0;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (range->addr > ULONG_MAX || range->size > ULONG_MAX)\n\t\treturn -EINVAL;\n\n\tregion = kzalloc(sizeof(*region), GFP_KERNEL_ACCOUNT);\n\tif (!region)\n\t\treturn -ENOMEM;\n\n\tregion->pages = sev_pin_memory(kvm, range->addr, range->size, &region->npages, 1);\n\tif (!region->pages) {\n\t\tret = -ENOMEM;\n\t\tgoto e_free;\n\t}\n\n\t/*\n\t * The guest may change the memory encryption attribute from C=0 -> C=1\n\t * or vice versa for this memory range. Lets make sure caches are\n\t * flushed to ensure that guest data gets written into memory with\n\t * correct C-bit.\n\t */\n\tsev_clflush_pages(region->pages, region->npages);\n\n\tregion->uaddr = range->addr;\n\tregion->size = range->size;\n\n\tmutex_lock(&kvm->lock);\n\tlist_add_tail(&region->list, &sev->regions_list);\n\tmutex_unlock(&kvm->lock);\n\n\treturn ret;\n\ne_free:\n\tkfree(region);\n\treturn ret;\n}"
  },
  {
    "function_name": "svm_mem_enc_op",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5989-6044",
    "snippet": "static int svm_mem_enc_op(struct kvm *kvm, void __user *argp)\n{\n\tstruct kvm_sev_cmd sev_cmd;\n\tint r;\n\n\tif (!svm_sev_enabled())\n\t\treturn -ENOTTY;\n\n\tif (!argp)\n\t\treturn 0;\n\n\tif (copy_from_user(&sev_cmd, argp, sizeof(struct kvm_sev_cmd)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&kvm->lock);\n\n\tswitch (sev_cmd.id) {\n\tcase KVM_SEV_INIT:\n\t\tr = sev_guest_init(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_START:\n\t\tr = sev_launch_start(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_UPDATE_DATA:\n\t\tr = sev_launch_update_data(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_MEASURE:\n\t\tr = sev_launch_measure(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_FINISH:\n\t\tr = sev_launch_finish(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_GUEST_STATUS:\n\t\tr = sev_guest_status(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_DBG_DECRYPT:\n\t\tr = sev_dbg_crypt(kvm, &sev_cmd, true);\n\t\tbreak;\n\tcase KVM_SEV_DBG_ENCRYPT:\n\t\tr = sev_dbg_crypt(kvm, &sev_cmd, false);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_SECRET:\n\t\tr = sev_launch_secret(kvm, &sev_cmd);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(argp, &sev_cmd, sizeof(struct kvm_sev_cmd)))\n\t\tr = -EFAULT;\n\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 6042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "argp",
            "&sev_cmd",
            "sizeof(struct kvm_sev_cmd)"
          ],
          "line": 6038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_launch_secret",
          "args": [
            "kvm",
            "&sev_cmd"
          ],
          "line": 6031
        },
        "resolved": true,
        "details": {
          "function_name": "sev_launch_secret",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5920-5987",
          "snippet": "static int sev_launch_secret(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_secret *data;\n\tstruct kvm_sev_launch_secret params;\n\tstruct page **pages;\n\tvoid *blob, *hdr;\n\tunsigned long n;\n\tint ret, offset;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tpages = sev_pin_memory(kvm, params.guest_uaddr, params.guest_len, &n, 1);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The secret must be copied into contiguous memory region, lets verify\n\t * that userspace memory pages are contiguous before we issue command.\n\t */\n\tif (get_num_contig_pages(0, pages, n) != n) {\n\t\tret = -EINVAL;\n\t\tgoto e_unpin_memory;\n\t}\n\n\tret = -ENOMEM;\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto e_unpin_memory;\n\n\toffset = params.guest_uaddr & (PAGE_SIZE - 1);\n\tdata->guest_address = __sme_page_pa(pages[0]) + offset;\n\tdata->guest_len = params.guest_len;\n\n\tblob = psp_copy_user_blob(params.trans_uaddr, params.trans_len);\n\tif (IS_ERR(blob)) {\n\t\tret = PTR_ERR(blob);\n\t\tgoto e_free;\n\t}\n\n\tdata->trans_address = __psp_pa(blob);\n\tdata->trans_len = params.trans_len;\n\n\thdr = psp_copy_user_blob(params.hdr_uaddr, params.hdr_len);\n\tif (IS_ERR(hdr)) {\n\t\tret = PTR_ERR(hdr);\n\t\tgoto e_free_blob;\n\t}\n\tdata->hdr_address = __psp_pa(hdr);\n\tdata->hdr_len = params.hdr_len;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_UPDATE_SECRET, data, &argp->error);\n\n\tkfree(hdr);\n\ne_free_blob:\n\tkfree(blob);\ne_free:\n\tkfree(data);\ne_unpin_memory:\n\tsev_unpin_memory(kvm, pages, n);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_launch_secret(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_secret *data;\n\tstruct kvm_sev_launch_secret params;\n\tstruct page **pages;\n\tvoid *blob, *hdr;\n\tunsigned long n;\n\tint ret, offset;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tpages = sev_pin_memory(kvm, params.guest_uaddr, params.guest_len, &n, 1);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The secret must be copied into contiguous memory region, lets verify\n\t * that userspace memory pages are contiguous before we issue command.\n\t */\n\tif (get_num_contig_pages(0, pages, n) != n) {\n\t\tret = -EINVAL;\n\t\tgoto e_unpin_memory;\n\t}\n\n\tret = -ENOMEM;\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto e_unpin_memory;\n\n\toffset = params.guest_uaddr & (PAGE_SIZE - 1);\n\tdata->guest_address = __sme_page_pa(pages[0]) + offset;\n\tdata->guest_len = params.guest_len;\n\n\tblob = psp_copy_user_blob(params.trans_uaddr, params.trans_len);\n\tif (IS_ERR(blob)) {\n\t\tret = PTR_ERR(blob);\n\t\tgoto e_free;\n\t}\n\n\tdata->trans_address = __psp_pa(blob);\n\tdata->trans_len = params.trans_len;\n\n\thdr = psp_copy_user_blob(params.hdr_uaddr, params.hdr_len);\n\tif (IS_ERR(hdr)) {\n\t\tret = PTR_ERR(hdr);\n\t\tgoto e_free_blob;\n\t}\n\tdata->hdr_address = __psp_pa(hdr);\n\tdata->hdr_len = params.hdr_len;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_UPDATE_SECRET, data, &argp->error);\n\n\tkfree(hdr);\n\ne_free_blob:\n\tkfree(blob);\ne_free:\n\tkfree(data);\ne_unpin_memory:\n\tsev_unpin_memory(kvm, pages, n);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_dbg_crypt",
          "args": [
            "kvm",
            "&sev_cmd",
            "false"
          ],
          "line": 6028
        },
        "resolved": true,
        "details": {
          "function_name": "sev_dbg_crypt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5835-5918",
          "snippet": "static int sev_dbg_crypt(struct kvm *kvm, struct kvm_sev_cmd *argp, bool dec)\n{\n\tunsigned long vaddr, vaddr_end, next_vaddr;\n\tunsigned long dst_vaddr;\n\tstruct page **src_p, **dst_p;\n\tstruct kvm_sev_dbg debug;\n\tunsigned long n;\n\tunsigned int size;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&debug, (void __user *)(uintptr_t)argp->data, sizeof(debug)))\n\t\treturn -EFAULT;\n\n\tif (!debug.len || debug.src_uaddr + debug.len < debug.src_uaddr)\n\t\treturn -EINVAL;\n\tif (!debug.dst_uaddr)\n\t\treturn -EINVAL;\n\n\tvaddr = debug.src_uaddr;\n\tsize = debug.len;\n\tvaddr_end = vaddr + size;\n\tdst_vaddr = debug.dst_uaddr;\n\n\tfor (; vaddr < vaddr_end; vaddr = next_vaddr) {\n\t\tint len, s_off, d_off;\n\n\t\t/* lock userspace source and destination page */\n\t\tsrc_p = sev_pin_memory(kvm, vaddr & PAGE_MASK, PAGE_SIZE, &n, 0);\n\t\tif (!src_p)\n\t\t\treturn -EFAULT;\n\n\t\tdst_p = sev_pin_memory(kvm, dst_vaddr & PAGE_MASK, PAGE_SIZE, &n, 1);\n\t\tif (!dst_p) {\n\t\t\tsev_unpin_memory(kvm, src_p, n);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * The DBG_{DE,EN}CRYPT commands will perform {dec,en}cryption of the\n\t\t * memory content (i.e it will write the same memory region with C=1).\n\t\t * It's possible that the cache may contain the data with C=0, i.e.,\n\t\t * unencrypted so invalidate it first.\n\t\t */\n\t\tsev_clflush_pages(src_p, 1);\n\t\tsev_clflush_pages(dst_p, 1);\n\n\t\t/*\n\t\t * Since user buffer may not be page aligned, calculate the\n\t\t * offset within the page.\n\t\t */\n\t\ts_off = vaddr & ~PAGE_MASK;\n\t\td_off = dst_vaddr & ~PAGE_MASK;\n\t\tlen = min_t(size_t, (PAGE_SIZE - s_off), size);\n\n\t\tif (dec)\n\t\t\tret = __sev_dbg_decrypt_user(kvm,\n\t\t\t\t\t\t     __sme_page_pa(src_p[0]) + s_off,\n\t\t\t\t\t\t     dst_vaddr,\n\t\t\t\t\t\t     __sme_page_pa(dst_p[0]) + d_off,\n\t\t\t\t\t\t     len, &argp->error);\n\t\telse\n\t\t\tret = __sev_dbg_encrypt_user(kvm,\n\t\t\t\t\t\t     __sme_page_pa(src_p[0]) + s_off,\n\t\t\t\t\t\t     vaddr,\n\t\t\t\t\t\t     __sme_page_pa(dst_p[0]) + d_off,\n\t\t\t\t\t\t     dst_vaddr,\n\t\t\t\t\t\t     len, &argp->error);\n\n\t\tsev_unpin_memory(kvm, src_p, n);\n\t\tsev_unpin_memory(kvm, dst_p, n);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tnext_vaddr = vaddr + len;\n\t\tdst_vaddr = dst_vaddr + len;\n\t\tsize -= len;\n\t}\nerr:\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev_dbg_crypt(struct kvm *kvm, struct kvm_sev_cmd *argp, bool dec)\n{\n\tunsigned long vaddr, vaddr_end, next_vaddr;\n\tunsigned long dst_vaddr;\n\tstruct page **src_p, **dst_p;\n\tstruct kvm_sev_dbg debug;\n\tunsigned long n;\n\tunsigned int size;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&debug, (void __user *)(uintptr_t)argp->data, sizeof(debug)))\n\t\treturn -EFAULT;\n\n\tif (!debug.len || debug.src_uaddr + debug.len < debug.src_uaddr)\n\t\treturn -EINVAL;\n\tif (!debug.dst_uaddr)\n\t\treturn -EINVAL;\n\n\tvaddr = debug.src_uaddr;\n\tsize = debug.len;\n\tvaddr_end = vaddr + size;\n\tdst_vaddr = debug.dst_uaddr;\n\n\tfor (; vaddr < vaddr_end; vaddr = next_vaddr) {\n\t\tint len, s_off, d_off;\n\n\t\t/* lock userspace source and destination page */\n\t\tsrc_p = sev_pin_memory(kvm, vaddr & PAGE_MASK, PAGE_SIZE, &n, 0);\n\t\tif (!src_p)\n\t\t\treturn -EFAULT;\n\n\t\tdst_p = sev_pin_memory(kvm, dst_vaddr & PAGE_MASK, PAGE_SIZE, &n, 1);\n\t\tif (!dst_p) {\n\t\t\tsev_unpin_memory(kvm, src_p, n);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * The DBG_{DE,EN}CRYPT commands will perform {dec,en}cryption of the\n\t\t * memory content (i.e it will write the same memory region with C=1).\n\t\t * It's possible that the cache may contain the data with C=0, i.e.,\n\t\t * unencrypted so invalidate it first.\n\t\t */\n\t\tsev_clflush_pages(src_p, 1);\n\t\tsev_clflush_pages(dst_p, 1);\n\n\t\t/*\n\t\t * Since user buffer may not be page aligned, calculate the\n\t\t * offset within the page.\n\t\t */\n\t\ts_off = vaddr & ~PAGE_MASK;\n\t\td_off = dst_vaddr & ~PAGE_MASK;\n\t\tlen = min_t(size_t, (PAGE_SIZE - s_off), size);\n\n\t\tif (dec)\n\t\t\tret = __sev_dbg_decrypt_user(kvm,\n\t\t\t\t\t\t     __sme_page_pa(src_p[0]) + s_off,\n\t\t\t\t\t\t     dst_vaddr,\n\t\t\t\t\t\t     __sme_page_pa(dst_p[0]) + d_off,\n\t\t\t\t\t\t     len, &argp->error);\n\t\telse\n\t\t\tret = __sev_dbg_encrypt_user(kvm,\n\t\t\t\t\t\t     __sme_page_pa(src_p[0]) + s_off,\n\t\t\t\t\t\t     vaddr,\n\t\t\t\t\t\t     __sme_page_pa(dst_p[0]) + d_off,\n\t\t\t\t\t\t     dst_vaddr,\n\t\t\t\t\t\t     len, &argp->error);\n\n\t\tsev_unpin_memory(kvm, src_p, n);\n\t\tsev_unpin_memory(kvm, dst_p, n);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tnext_vaddr = vaddr + len;\n\t\tdst_vaddr = dst_vaddr + len;\n\t\tsize -= len;\n\t}\nerr:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_guest_status",
          "args": [
            "kvm",
            "&sev_cmd"
          ],
          "line": 6022
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest_status",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5651-5679",
          "snippet": "static int sev_guest_status(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct kvm_sev_guest_status params;\n\tstruct sev_data_guest_status *data;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_GUEST_STATUS, data, &argp->error);\n\tif (ret)\n\t\tgoto e_free;\n\n\tparams.policy = data->policy;\n\tparams.state = data->state;\n\tparams.handle = data->handle;\n\n\tif (copy_to_user((void __user *)(uintptr_t)argp->data, &params, sizeof(params)))\n\t\tret = -EFAULT;\ne_free:\n\tkfree(data);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_guest_status(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct kvm_sev_guest_status params;\n\tstruct sev_data_guest_status *data;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_GUEST_STATUS, data, &argp->error);\n\tif (ret)\n\t\tgoto e_free;\n\n\tparams.policy = data->policy;\n\tparams.state = data->state;\n\tparams.handle = data->handle;\n\n\tif (copy_to_user((void __user *)(uintptr_t)argp->data, &params, sizeof(params)))\n\t\tret = -EFAULT;\ne_free:\n\tkfree(data);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_launch_finish",
          "args": [
            "kvm",
            "&sev_cmd"
          ],
          "line": 6019
        },
        "resolved": true,
        "details": {
          "function_name": "sev_launch_finish",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5631-5649",
          "snippet": "static int sev_launch_finish(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_finish *data;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_FINISH, data, &argp->error);\n\n\tkfree(data);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_launch_finish(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_finish *data;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_FINISH, data, &argp->error);\n\n\tkfree(data);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_launch_measure",
          "args": [
            "kvm",
            "&sev_cmd"
          ],
          "line": 6016
        },
        "resolved": true,
        "details": {
          "function_name": "sev_launch_measure",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5562-5629",
          "snippet": "static int sev_launch_measure(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tvoid __user *measure = (void __user *)(uintptr_t)argp->data;\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_measure *data;\n\tstruct kvm_sev_launch_measure params;\n\tvoid __user *p = NULL;\n\tvoid *blob = NULL;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, measure, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/* User wants to query the blob length */\n\tif (!params.len)\n\t\tgoto cmd;\n\n\tp = (void __user *)(uintptr_t)params.uaddr;\n\tif (p) {\n\t\tif (params.len > SEV_FW_BLOB_MAX_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tret = -ENOMEM;\n\t\tblob = kmalloc(params.len, GFP_KERNEL);\n\t\tif (!blob)\n\t\t\tgoto e_free;\n\n\t\tdata->address = __psp_pa(blob);\n\t\tdata->len = params.len;\n\t}\n\ncmd:\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_MEASURE, data, &argp->error);\n\n\t/*\n\t * If we query the session length, FW responded with expected data.\n\t */\n\tif (!params.len)\n\t\tgoto done;\n\n\tif (ret)\n\t\tgoto e_free_blob;\n\n\tif (blob) {\n\t\tif (copy_to_user(p, blob, params.len))\n\t\t\tret = -EFAULT;\n\t}\n\ndone:\n\tparams.len = data->len;\n\tif (copy_to_user(measure, &params, sizeof(params)))\n\t\tret = -EFAULT;\ne_free_blob:\n\tkfree(blob);\ne_free:\n\tkfree(data);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_launch_measure(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tvoid __user *measure = (void __user *)(uintptr_t)argp->data;\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_measure *data;\n\tstruct kvm_sev_launch_measure params;\n\tvoid __user *p = NULL;\n\tvoid *blob = NULL;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, measure, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/* User wants to query the blob length */\n\tif (!params.len)\n\t\tgoto cmd;\n\n\tp = (void __user *)(uintptr_t)params.uaddr;\n\tif (p) {\n\t\tif (params.len > SEV_FW_BLOB_MAX_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tret = -ENOMEM;\n\t\tblob = kmalloc(params.len, GFP_KERNEL);\n\t\tif (!blob)\n\t\t\tgoto e_free;\n\n\t\tdata->address = __psp_pa(blob);\n\t\tdata->len = params.len;\n\t}\n\ncmd:\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_MEASURE, data, &argp->error);\n\n\t/*\n\t * If we query the session length, FW responded with expected data.\n\t */\n\tif (!params.len)\n\t\tgoto done;\n\n\tif (ret)\n\t\tgoto e_free_blob;\n\n\tif (blob) {\n\t\tif (copy_to_user(p, blob, params.len))\n\t\t\tret = -EFAULT;\n\t}\n\ndone:\n\tparams.len = data->len;\n\tif (copy_to_user(measure, &params, sizeof(params)))\n\t\tret = -EFAULT;\ne_free_blob:\n\tkfree(blob);\ne_free:\n\tkfree(data);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_launch_update_data",
          "args": [
            "kvm",
            "&sev_cmd"
          ],
          "line": 6013
        },
        "resolved": true,
        "details": {
          "function_name": "sev_launch_update_data",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5486-5560",
          "snippet": "static int sev_launch_update_data(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tunsigned long vaddr, vaddr_end, next_vaddr, npages, pages, size, i;\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct kvm_sev_launch_update_data params;\n\tstruct sev_data_launch_update_data *data;\n\tstruct page **inpages;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tvaddr = params.uaddr;\n\tsize = params.len;\n\tvaddr_end = vaddr + size;\n\n\t/* Lock the user memory. */\n\tinpages = sev_pin_memory(kvm, vaddr, size, &npages, 1);\n\tif (!inpages) {\n\t\tret = -ENOMEM;\n\t\tgoto e_free;\n\t}\n\n\t/*\n\t * The LAUNCH_UPDATE command will perform in-place encryption of the\n\t * memory content (i.e it will write the same memory region with C=1).\n\t * It's possible that the cache may contain the data with C=0, i.e.,\n\t * unencrypted so invalidate it first.\n\t */\n\tsev_clflush_pages(inpages, npages);\n\n\tfor (i = 0; vaddr < vaddr_end; vaddr = next_vaddr, i += pages) {\n\t\tint offset, len;\n\n\t\t/*\n\t\t * If the user buffer is not page-aligned, calculate the offset\n\t\t * within the page.\n\t\t */\n\t\toffset = vaddr & (PAGE_SIZE - 1);\n\n\t\t/* Calculate the number of pages that can be encrypted in one go. */\n\t\tpages = get_num_contig_pages(i, inpages, npages);\n\n\t\tlen = min_t(size_t, ((pages * PAGE_SIZE) - offset), size);\n\n\t\tdata->handle = sev->handle;\n\t\tdata->len = len;\n\t\tdata->address = __sme_page_pa(inpages[i]) + offset;\n\t\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_UPDATE_DATA, data, &argp->error);\n\t\tif (ret)\n\t\t\tgoto e_unpin;\n\n\t\tsize -= len;\n\t\tnext_vaddr = vaddr + len;\n\t}\n\ne_unpin:\n\t/* content of memory is updated, mark pages dirty */\n\tfor (i = 0; i < npages; i++) {\n\t\tset_page_dirty_lock(inpages[i]);\n\t\tmark_page_accessed(inpages[i]);\n\t}\n\t/* unlock the user pages */\n\tsev_unpin_memory(kvm, inpages, npages);\ne_free:\n\tkfree(data);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_launch_update_data(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tunsigned long vaddr, vaddr_end, next_vaddr, npages, pages, size, i;\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct kvm_sev_launch_update_data params;\n\tstruct sev_data_launch_update_data *data;\n\tstruct page **inpages;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tvaddr = params.uaddr;\n\tsize = params.len;\n\tvaddr_end = vaddr + size;\n\n\t/* Lock the user memory. */\n\tinpages = sev_pin_memory(kvm, vaddr, size, &npages, 1);\n\tif (!inpages) {\n\t\tret = -ENOMEM;\n\t\tgoto e_free;\n\t}\n\n\t/*\n\t * The LAUNCH_UPDATE command will perform in-place encryption of the\n\t * memory content (i.e it will write the same memory region with C=1).\n\t * It's possible that the cache may contain the data with C=0, i.e.,\n\t * unencrypted so invalidate it first.\n\t */\n\tsev_clflush_pages(inpages, npages);\n\n\tfor (i = 0; vaddr < vaddr_end; vaddr = next_vaddr, i += pages) {\n\t\tint offset, len;\n\n\t\t/*\n\t\t * If the user buffer is not page-aligned, calculate the offset\n\t\t * within the page.\n\t\t */\n\t\toffset = vaddr & (PAGE_SIZE - 1);\n\n\t\t/* Calculate the number of pages that can be encrypted in one go. */\n\t\tpages = get_num_contig_pages(i, inpages, npages);\n\n\t\tlen = min_t(size_t, ((pages * PAGE_SIZE) - offset), size);\n\n\t\tdata->handle = sev->handle;\n\t\tdata->len = len;\n\t\tdata->address = __sme_page_pa(inpages[i]) + offset;\n\t\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_UPDATE_DATA, data, &argp->error);\n\t\tif (ret)\n\t\t\tgoto e_unpin;\n\n\t\tsize -= len;\n\t\tnext_vaddr = vaddr + len;\n\t}\n\ne_unpin:\n\t/* content of memory is updated, mark pages dirty */\n\tfor (i = 0; i < npages; i++) {\n\t\tset_page_dirty_lock(inpages[i]);\n\t\tmark_page_accessed(inpages[i]);\n\t}\n\t/* unlock the user pages */\n\tsev_unpin_memory(kvm, inpages, npages);\ne_free:\n\tkfree(data);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_launch_start",
          "args": [
            "kvm",
            "&sev_cmd"
          ],
          "line": 6010
        },
        "resolved": true,
        "details": {
          "function_name": "sev_launch_start",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5389-5463",
          "snippet": "static int sev_launch_start(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_start *start;\n\tstruct kvm_sev_launch_start params;\n\tvoid *dh_blob, *session_blob;\n\tint *error = &argp->error;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tstart = kzalloc(sizeof(*start), GFP_KERNEL_ACCOUNT);\n\tif (!start)\n\t\treturn -ENOMEM;\n\n\tdh_blob = NULL;\n\tif (params.dh_uaddr) {\n\t\tdh_blob = psp_copy_user_blob(params.dh_uaddr, params.dh_len);\n\t\tif (IS_ERR(dh_blob)) {\n\t\t\tret = PTR_ERR(dh_blob);\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tstart->dh_cert_address = __sme_set(__pa(dh_blob));\n\t\tstart->dh_cert_len = params.dh_len;\n\t}\n\n\tsession_blob = NULL;\n\tif (params.session_uaddr) {\n\t\tsession_blob = psp_copy_user_blob(params.session_uaddr, params.session_len);\n\t\tif (IS_ERR(session_blob)) {\n\t\t\tret = PTR_ERR(session_blob);\n\t\t\tgoto e_free_dh;\n\t\t}\n\n\t\tstart->session_address = __sme_set(__pa(session_blob));\n\t\tstart->session_len = params.session_len;\n\t}\n\n\tstart->handle = params.handle;\n\tstart->policy = params.policy;\n\n\t/* create memory encryption context */\n\tret = __sev_issue_cmd(argp->sev_fd, SEV_CMD_LAUNCH_START, start, error);\n\tif (ret)\n\t\tgoto e_free_session;\n\n\t/* Bind ASID to this guest */\n\tret = sev_bind_asid(kvm, start->handle, error);\n\tif (ret)\n\t\tgoto e_free_session;\n\n\t/* return handle to userspace */\n\tparams.handle = start->handle;\n\tif (copy_to_user((void __user *)(uintptr_t)argp->data, &params, sizeof(params))) {\n\t\tsev_unbind_asid(kvm, start->handle);\n\t\tret = -EFAULT;\n\t\tgoto e_free_session;\n\t}\n\n\tsev->handle = start->handle;\n\tsev->fd = argp->sev_fd;\n\ne_free_session:\n\tkfree(session_blob);\ne_free_dh:\n\tkfree(dh_blob);\ne_free:\n\tkfree(start);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_launch_start(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_start *start;\n\tstruct kvm_sev_launch_start params;\n\tvoid *dh_blob, *session_blob;\n\tint *error = &argp->error;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tstart = kzalloc(sizeof(*start), GFP_KERNEL_ACCOUNT);\n\tif (!start)\n\t\treturn -ENOMEM;\n\n\tdh_blob = NULL;\n\tif (params.dh_uaddr) {\n\t\tdh_blob = psp_copy_user_blob(params.dh_uaddr, params.dh_len);\n\t\tif (IS_ERR(dh_blob)) {\n\t\t\tret = PTR_ERR(dh_blob);\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tstart->dh_cert_address = __sme_set(__pa(dh_blob));\n\t\tstart->dh_cert_len = params.dh_len;\n\t}\n\n\tsession_blob = NULL;\n\tif (params.session_uaddr) {\n\t\tsession_blob = psp_copy_user_blob(params.session_uaddr, params.session_len);\n\t\tif (IS_ERR(session_blob)) {\n\t\t\tret = PTR_ERR(session_blob);\n\t\t\tgoto e_free_dh;\n\t\t}\n\n\t\tstart->session_address = __sme_set(__pa(session_blob));\n\t\tstart->session_len = params.session_len;\n\t}\n\n\tstart->handle = params.handle;\n\tstart->policy = params.policy;\n\n\t/* create memory encryption context */\n\tret = __sev_issue_cmd(argp->sev_fd, SEV_CMD_LAUNCH_START, start, error);\n\tif (ret)\n\t\tgoto e_free_session;\n\n\t/* Bind ASID to this guest */\n\tret = sev_bind_asid(kvm, start->handle, error);\n\tif (ret)\n\t\tgoto e_free_session;\n\n\t/* return handle to userspace */\n\tparams.handle = start->handle;\n\tif (copy_to_user((void __user *)(uintptr_t)argp->data, &params, sizeof(params))) {\n\t\tsev_unbind_asid(kvm, start->handle);\n\t\tret = -EFAULT;\n\t\tgoto e_free_session;\n\t}\n\n\tsev->handle = start->handle;\n\tsev->fd = argp->sev_fd;\n\ne_free_session:\n\tkfree(session_blob);\ne_free_dh:\n\tkfree(dh_blob);\ne_free:\n\tkfree(start);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_guest_init",
          "args": [
            "kvm",
            "&sev_cmd"
          ],
          "line": 6007
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest_init",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5320-5346",
          "snippet": "static int sev_guest_init(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tint asid, ret;\n\n\tret = -EBUSY;\n\tif (unlikely(sev->active))\n\t\treturn ret;\n\n\tasid = sev_asid_new();\n\tif (asid < 0)\n\t\treturn ret;\n\n\tret = sev_platform_init(&argp->error);\n\tif (ret)\n\t\tgoto e_free;\n\n\tsev->active = true;\n\tsev->asid = asid;\n\tINIT_LIST_HEAD(&sev->regions_list);\n\n\treturn 0;\n\ne_free:\n\tsev_asid_free(asid);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_guest_init(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tint asid, ret;\n\n\tret = -EBUSY;\n\tif (unlikely(sev->active))\n\t\treturn ret;\n\n\tasid = sev_asid_new();\n\tif (asid < 0)\n\t\treturn ret;\n\n\tret = sev_platform_init(&argp->error);\n\tif (ret)\n\t\tgoto e_free;\n\n\tsev->active = true;\n\tsev->asid = asid;\n\tINIT_LIST_HEAD(&sev->regions_list);\n\n\treturn 0;\n\ne_free:\n\tsev_asid_free(asid);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 6003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&sev_cmd",
            "argp",
            "sizeof(struct kvm_sev_cmd)"
          ],
          "line": 6000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_sev_enabled",
          "args": [],
          "line": 5994
        },
        "resolved": true,
        "details": {
          "function_name": "svm_sev_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "290-293",
          "snippet": "static inline bool svm_sev_enabled(void)\n{\n\treturn IS_ENABLED(CONFIG_KVM_AMD_SEV) ? max_sev_asid : 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int max_sev_asid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned int max_sev_asid;\n\nstatic inline bool svm_sev_enabled(void)\n{\n\treturn IS_ENABLED(CONFIG_KVM_AMD_SEV) ? max_sev_asid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int svm_mem_enc_op(struct kvm *kvm, void __user *argp)\n{\n\tstruct kvm_sev_cmd sev_cmd;\n\tint r;\n\n\tif (!svm_sev_enabled())\n\t\treturn -ENOTTY;\n\n\tif (!argp)\n\t\treturn 0;\n\n\tif (copy_from_user(&sev_cmd, argp, sizeof(struct kvm_sev_cmd)))\n\t\treturn -EFAULT;\n\n\tmutex_lock(&kvm->lock);\n\n\tswitch (sev_cmd.id) {\n\tcase KVM_SEV_INIT:\n\t\tr = sev_guest_init(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_START:\n\t\tr = sev_launch_start(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_UPDATE_DATA:\n\t\tr = sev_launch_update_data(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_MEASURE:\n\t\tr = sev_launch_measure(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_FINISH:\n\t\tr = sev_launch_finish(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_GUEST_STATUS:\n\t\tr = sev_guest_status(kvm, &sev_cmd);\n\t\tbreak;\n\tcase KVM_SEV_DBG_DECRYPT:\n\t\tr = sev_dbg_crypt(kvm, &sev_cmd, true);\n\t\tbreak;\n\tcase KVM_SEV_DBG_ENCRYPT:\n\t\tr = sev_dbg_crypt(kvm, &sev_cmd, false);\n\t\tbreak;\n\tcase KVM_SEV_LAUNCH_SECRET:\n\t\tr = sev_launch_secret(kvm, &sev_cmd);\n\t\tbreak;\n\tdefault:\n\t\tr = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(argp, &sev_cmd, sizeof(struct kvm_sev_cmd)))\n\t\tr = -EFAULT;\n\nout:\n\tmutex_unlock(&kvm->lock);\n\treturn r;\n}"
  },
  {
    "function_name": "sev_launch_secret",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5920-5987",
    "snippet": "static int sev_launch_secret(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_secret *data;\n\tstruct kvm_sev_launch_secret params;\n\tstruct page **pages;\n\tvoid *blob, *hdr;\n\tunsigned long n;\n\tint ret, offset;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tpages = sev_pin_memory(kvm, params.guest_uaddr, params.guest_len, &n, 1);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The secret must be copied into contiguous memory region, lets verify\n\t * that userspace memory pages are contiguous before we issue command.\n\t */\n\tif (get_num_contig_pages(0, pages, n) != n) {\n\t\tret = -EINVAL;\n\t\tgoto e_unpin_memory;\n\t}\n\n\tret = -ENOMEM;\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto e_unpin_memory;\n\n\toffset = params.guest_uaddr & (PAGE_SIZE - 1);\n\tdata->guest_address = __sme_page_pa(pages[0]) + offset;\n\tdata->guest_len = params.guest_len;\n\n\tblob = psp_copy_user_blob(params.trans_uaddr, params.trans_len);\n\tif (IS_ERR(blob)) {\n\t\tret = PTR_ERR(blob);\n\t\tgoto e_free;\n\t}\n\n\tdata->trans_address = __psp_pa(blob);\n\tdata->trans_len = params.trans_len;\n\n\thdr = psp_copy_user_blob(params.hdr_uaddr, params.hdr_len);\n\tif (IS_ERR(hdr)) {\n\t\tret = PTR_ERR(hdr);\n\t\tgoto e_free_blob;\n\t}\n\tdata->hdr_address = __psp_pa(hdr);\n\tdata->hdr_len = params.hdr_len;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_UPDATE_SECRET, data, &argp->error);\n\n\tkfree(hdr);\n\ne_free_blob:\n\tkfree(blob);\ne_free:\n\tkfree(data);\ne_unpin_memory:\n\tsev_unpin_memory(kvm, pages, n);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sev_unpin_memory",
          "args": [
            "kvm",
            "pages",
            "n"
          ],
          "line": 5985
        },
        "resolved": true,
        "details": {
          "function_name": "sev_unpin_memory",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1600-1608",
          "snippet": "static void sev_unpin_memory(struct kvm *kvm, struct page **pages,\n\t\t\t     unsigned long npages)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\trelease_pages(pages, npages);\n\tkvfree(pages);\n\tsev->pages_locked -= npages;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic void sev_unpin_memory(struct kvm *kvm, struct page **pages,\n\t\t\t     unsigned long npages)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\trelease_pages(pages, npages);\n\tkvfree(pages);\n\tsev->pages_locked -= npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 5983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "blob"
          ],
          "line": 5981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hdr"
          ],
          "line": 5978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_issue_cmd",
          "args": [
            "kvm",
            "SEV_CMD_LAUNCH_UPDATE_SECRET",
            "data",
            "&argp->error"
          ],
          "line": 5976
        },
        "resolved": true,
        "details": {
          "function_name": "sev_issue_cmd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5382-5387",
          "snippet": "static int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__psp_pa",
          "args": [
            "hdr"
          ],
          "line": 5972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hdr"
          ],
          "line": 5969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hdr"
          ],
          "line": 5968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psp_copy_user_blob",
          "args": [
            "params.hdr_uaddr",
            "params.hdr_len"
          ],
          "line": 5967
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__psp_pa",
          "args": [
            "blob"
          ],
          "line": 5964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "blob"
          ],
          "line": 5960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "blob"
          ],
          "line": 5959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psp_copy_user_blob",
          "args": [
            "params.trans_uaddr",
            "params.trans_len"
          ],
          "line": 5958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "pages[0]"
          ],
          "line": 5955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 5950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_num_contig_pages",
          "args": [
            "0",
            "pages",
            "n"
          ],
          "line": 5944
        },
        "resolved": true,
        "details": {
          "function_name": "get_num_contig_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5465-5484",
          "snippet": "static unsigned long get_num_contig_pages(unsigned long idx,\n\t\t\t\tstruct page **inpages, unsigned long npages)\n{\n\tunsigned long paddr, next_paddr;\n\tunsigned long i = idx + 1, pages = 1;\n\n\t/* find the number of contiguous pages starting from idx */\n\tpaddr = __sme_page_pa(inpages[idx]);\n\twhile (i < npages) {\n\t\tnext_paddr = __sme_page_pa(inpages[i++]);\n\t\tif ((paddr + PAGE_SIZE) == next_paddr) {\n\t\t\tpages++;\n\t\t\tpaddr = next_paddr;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned long get_num_contig_pages(unsigned long idx,\n\t\t\t\tstruct page **inpages, unsigned long npages)\n{\n\tunsigned long paddr, next_paddr;\n\tunsigned long i = idx + 1, pages = 1;\n\n\t/* find the number of contiguous pages starting from idx */\n\tpaddr = __sme_page_pa(inpages[idx]);\n\twhile (i < npages) {\n\t\tnext_paddr = __sme_page_pa(inpages[i++]);\n\t\tif ((paddr + PAGE_SIZE) == next_paddr) {\n\t\t\tpages++;\n\t\t\tpaddr = next_paddr;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_pin_memory",
          "args": [
            "kvm",
            "params.guest_uaddr",
            "params.guest_len",
            "&n",
            "1"
          ],
          "line": 5936
        },
        "resolved": true,
        "details": {
          "function_name": "sev_pin_memory",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1544-1598",
          "snippet": "static struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, npinned, size;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn NULL;\n\n\t/* Calculate number of pages. */\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn NULL;\n\t}\n\n\t/* Avoid using vmalloc for smaller buffers. */\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO,\n\t\t\t\t  PAGE_KERNEL);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\n\tif (!pages)\n\t\treturn NULL;\n\n\t/* Pin the user virtual address. */\n\tnpinned = get_user_pages_fast(uaddr, npages, FOLL_WRITE, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tgoto err;\n\t}\n\n\t*n = npages;\n\tsev->pages_locked = locked;\n\n\treturn pages;\n\nerr:\n\tif (npinned > 0)\n\t\trelease_pages(pages, npinned);\n\n\tkvfree(pages);\n\treturn NULL;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, npinned, size;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn NULL;\n\n\t/* Calculate number of pages. */\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn NULL;\n\t}\n\n\t/* Avoid using vmalloc for smaller buffers. */\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO,\n\t\t\t\t  PAGE_KERNEL);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\n\tif (!pages)\n\t\treturn NULL;\n\n\t/* Pin the user virtual address. */\n\tnpinned = get_user_pages_fast(uaddr, npages, FOLL_WRITE, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tgoto err;\n\t}\n\n\t*n = npages;\n\tsev->pages_locked = locked;\n\n\treturn pages;\n\nerr:\n\tif (npinned > 0)\n\t\trelease_pages(pages, npinned);\n\n\tkvfree(pages);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&params",
            "(void __user *)(uintptr_t)argp->data",
            "sizeof(params)"
          ],
          "line": 5933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "kvm"
          ],
          "line": 5930
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 5922
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_launch_secret(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_secret *data;\n\tstruct kvm_sev_launch_secret params;\n\tstruct page **pages;\n\tvoid *blob, *hdr;\n\tunsigned long n;\n\tint ret, offset;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tpages = sev_pin_memory(kvm, params.guest_uaddr, params.guest_len, &n, 1);\n\tif (!pages)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * The secret must be copied into contiguous memory region, lets verify\n\t * that userspace memory pages are contiguous before we issue command.\n\t */\n\tif (get_num_contig_pages(0, pages, n) != n) {\n\t\tret = -EINVAL;\n\t\tgoto e_unpin_memory;\n\t}\n\n\tret = -ENOMEM;\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\tgoto e_unpin_memory;\n\n\toffset = params.guest_uaddr & (PAGE_SIZE - 1);\n\tdata->guest_address = __sme_page_pa(pages[0]) + offset;\n\tdata->guest_len = params.guest_len;\n\n\tblob = psp_copy_user_blob(params.trans_uaddr, params.trans_len);\n\tif (IS_ERR(blob)) {\n\t\tret = PTR_ERR(blob);\n\t\tgoto e_free;\n\t}\n\n\tdata->trans_address = __psp_pa(blob);\n\tdata->trans_len = params.trans_len;\n\n\thdr = psp_copy_user_blob(params.hdr_uaddr, params.hdr_len);\n\tif (IS_ERR(hdr)) {\n\t\tret = PTR_ERR(hdr);\n\t\tgoto e_free_blob;\n\t}\n\tdata->hdr_address = __psp_pa(hdr);\n\tdata->hdr_len = params.hdr_len;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_UPDATE_SECRET, data, &argp->error);\n\n\tkfree(hdr);\n\ne_free_blob:\n\tkfree(blob);\ne_free:\n\tkfree(data);\ne_unpin_memory:\n\tsev_unpin_memory(kvm, pages, n);\n\treturn ret;\n}"
  },
  {
    "function_name": "sev_dbg_crypt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5835-5918",
    "snippet": "static int sev_dbg_crypt(struct kvm *kvm, struct kvm_sev_cmd *argp, bool dec)\n{\n\tunsigned long vaddr, vaddr_end, next_vaddr;\n\tunsigned long dst_vaddr;\n\tstruct page **src_p, **dst_p;\n\tstruct kvm_sev_dbg debug;\n\tunsigned long n;\n\tunsigned int size;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&debug, (void __user *)(uintptr_t)argp->data, sizeof(debug)))\n\t\treturn -EFAULT;\n\n\tif (!debug.len || debug.src_uaddr + debug.len < debug.src_uaddr)\n\t\treturn -EINVAL;\n\tif (!debug.dst_uaddr)\n\t\treturn -EINVAL;\n\n\tvaddr = debug.src_uaddr;\n\tsize = debug.len;\n\tvaddr_end = vaddr + size;\n\tdst_vaddr = debug.dst_uaddr;\n\n\tfor (; vaddr < vaddr_end; vaddr = next_vaddr) {\n\t\tint len, s_off, d_off;\n\n\t\t/* lock userspace source and destination page */\n\t\tsrc_p = sev_pin_memory(kvm, vaddr & PAGE_MASK, PAGE_SIZE, &n, 0);\n\t\tif (!src_p)\n\t\t\treturn -EFAULT;\n\n\t\tdst_p = sev_pin_memory(kvm, dst_vaddr & PAGE_MASK, PAGE_SIZE, &n, 1);\n\t\tif (!dst_p) {\n\t\t\tsev_unpin_memory(kvm, src_p, n);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * The DBG_{DE,EN}CRYPT commands will perform {dec,en}cryption of the\n\t\t * memory content (i.e it will write the same memory region with C=1).\n\t\t * It's possible that the cache may contain the data with C=0, i.e.,\n\t\t * unencrypted so invalidate it first.\n\t\t */\n\t\tsev_clflush_pages(src_p, 1);\n\t\tsev_clflush_pages(dst_p, 1);\n\n\t\t/*\n\t\t * Since user buffer may not be page aligned, calculate the\n\t\t * offset within the page.\n\t\t */\n\t\ts_off = vaddr & ~PAGE_MASK;\n\t\td_off = dst_vaddr & ~PAGE_MASK;\n\t\tlen = min_t(size_t, (PAGE_SIZE - s_off), size);\n\n\t\tif (dec)\n\t\t\tret = __sev_dbg_decrypt_user(kvm,\n\t\t\t\t\t\t     __sme_page_pa(src_p[0]) + s_off,\n\t\t\t\t\t\t     dst_vaddr,\n\t\t\t\t\t\t     __sme_page_pa(dst_p[0]) + d_off,\n\t\t\t\t\t\t     len, &argp->error);\n\t\telse\n\t\t\tret = __sev_dbg_encrypt_user(kvm,\n\t\t\t\t\t\t     __sme_page_pa(src_p[0]) + s_off,\n\t\t\t\t\t\t     vaddr,\n\t\t\t\t\t\t     __sme_page_pa(dst_p[0]) + d_off,\n\t\t\t\t\t\t     dst_vaddr,\n\t\t\t\t\t\t     len, &argp->error);\n\n\t\tsev_unpin_memory(kvm, src_p, n);\n\t\tsev_unpin_memory(kvm, dst_p, n);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tnext_vaddr = vaddr + len;\n\t\tdst_vaddr = dst_vaddr + len;\n\t\tsize -= len;\n\t}\nerr:\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sev_unpin_memory",
          "args": [
            "kvm",
            "dst_p",
            "n"
          ],
          "line": 5907
        },
        "resolved": true,
        "details": {
          "function_name": "sev_unpin_memory",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1600-1608",
          "snippet": "static void sev_unpin_memory(struct kvm *kvm, struct page **pages,\n\t\t\t     unsigned long npages)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\trelease_pages(pages, npages);\n\tkvfree(pages);\n\tsev->pages_locked -= npages;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic void sev_unpin_memory(struct kvm *kvm, struct page **pages,\n\t\t\t     unsigned long npages)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\trelease_pages(pages, npages);\n\tkvfree(pages);\n\tsev->pages_locked -= npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sev_dbg_encrypt_user",
          "args": [
            "kvm",
            "__sme_page_pa(src_p[0]) + s_off",
            "vaddr",
            "__sme_page_pa(dst_p[0]) + d_off",
            "dst_vaddr",
            "len",
            "&argp->error"
          ],
          "line": 5899
        },
        "resolved": true,
        "details": {
          "function_name": "__sev_dbg_encrypt_user",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5758-5833",
          "snippet": "static int __sev_dbg_encrypt_user(struct kvm *kvm, unsigned long paddr,\n\t\t\t\t  unsigned long __user vaddr,\n\t\t\t\t  unsigned long dst_paddr,\n\t\t\t\t  unsigned long __user dst_vaddr,\n\t\t\t\t  int size, int *error)\n{\n\tstruct page *src_tpage = NULL;\n\tstruct page *dst_tpage = NULL;\n\tint ret, len = size;\n\n\t/* If source buffer is not aligned then use an intermediate buffer */\n\tif (!IS_ALIGNED(vaddr, 16)) {\n\t\tsrc_tpage = alloc_page(GFP_KERNEL);\n\t\tif (!src_tpage)\n\t\t\treturn -ENOMEM;\n\n\t\tif (copy_from_user(page_address(src_tpage),\n\t\t\t\t(void __user *)(uintptr_t)vaddr, size)) {\n\t\t\t__free_page(src_tpage);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tpaddr = __sme_page_pa(src_tpage);\n\t}\n\n\t/*\n\t *  If destination buffer or length is not aligned then do read-modify-write:\n\t *   - decrypt destination in an intermediate buffer\n\t *   - copy the source buffer in an intermediate buffer\n\t *   - use the intermediate buffer as source buffer\n\t */\n\tif (!IS_ALIGNED(dst_vaddr, 16) || !IS_ALIGNED(size, 16)) {\n\t\tint dst_offset;\n\n\t\tdst_tpage = alloc_page(GFP_KERNEL);\n\t\tif (!dst_tpage) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tret = __sev_dbg_decrypt(kvm, dst_paddr,\n\t\t\t\t\t__sme_page_pa(dst_tpage), size, error);\n\t\tif (ret)\n\t\t\tgoto e_free;\n\n\t\t/*\n\t\t *  If source is kernel buffer then use memcpy() otherwise\n\t\t *  copy_from_user().\n\t\t */\n\t\tdst_offset = dst_paddr & 15;\n\n\t\tif (src_tpage)\n\t\t\tmemcpy(page_address(dst_tpage) + dst_offset,\n\t\t\t       page_address(src_tpage), size);\n\t\telse {\n\t\t\tif (copy_from_user(page_address(dst_tpage) + dst_offset,\n\t\t\t\t\t   (void __user *)(uintptr_t)vaddr, size)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto e_free;\n\t\t\t}\n\t\t}\n\n\t\tpaddr = __sme_page_pa(dst_tpage);\n\t\tdst_paddr = round_down(dst_paddr, 16);\n\t\tlen = round_up(size, 16);\n\t}\n\n\tret = __sev_issue_dbg_cmd(kvm, paddr, dst_paddr, len, error, true);\n\ne_free:\n\tif (src_tpage)\n\t\t__free_page(src_tpage);\n\tif (dst_tpage)\n\t\t__free_page(dst_tpage);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __sev_dbg_encrypt_user(struct kvm *kvm, unsigned long paddr,\n\t\t\t\t  unsigned long __user vaddr,\n\t\t\t\t  unsigned long dst_paddr,\n\t\t\t\t  unsigned long __user dst_vaddr,\n\t\t\t\t  int size, int *error)\n{\n\tstruct page *src_tpage = NULL;\n\tstruct page *dst_tpage = NULL;\n\tint ret, len = size;\n\n\t/* If source buffer is not aligned then use an intermediate buffer */\n\tif (!IS_ALIGNED(vaddr, 16)) {\n\t\tsrc_tpage = alloc_page(GFP_KERNEL);\n\t\tif (!src_tpage)\n\t\t\treturn -ENOMEM;\n\n\t\tif (copy_from_user(page_address(src_tpage),\n\t\t\t\t(void __user *)(uintptr_t)vaddr, size)) {\n\t\t\t__free_page(src_tpage);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tpaddr = __sme_page_pa(src_tpage);\n\t}\n\n\t/*\n\t *  If destination buffer or length is not aligned then do read-modify-write:\n\t *   - decrypt destination in an intermediate buffer\n\t *   - copy the source buffer in an intermediate buffer\n\t *   - use the intermediate buffer as source buffer\n\t */\n\tif (!IS_ALIGNED(dst_vaddr, 16) || !IS_ALIGNED(size, 16)) {\n\t\tint dst_offset;\n\n\t\tdst_tpage = alloc_page(GFP_KERNEL);\n\t\tif (!dst_tpage) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tret = __sev_dbg_decrypt(kvm, dst_paddr,\n\t\t\t\t\t__sme_page_pa(dst_tpage), size, error);\n\t\tif (ret)\n\t\t\tgoto e_free;\n\n\t\t/*\n\t\t *  If source is kernel buffer then use memcpy() otherwise\n\t\t *  copy_from_user().\n\t\t */\n\t\tdst_offset = dst_paddr & 15;\n\n\t\tif (src_tpage)\n\t\t\tmemcpy(page_address(dst_tpage) + dst_offset,\n\t\t\t       page_address(src_tpage), size);\n\t\telse {\n\t\t\tif (copy_from_user(page_address(dst_tpage) + dst_offset,\n\t\t\t\t\t   (void __user *)(uintptr_t)vaddr, size)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto e_free;\n\t\t\t}\n\t\t}\n\n\t\tpaddr = __sme_page_pa(dst_tpage);\n\t\tdst_paddr = round_down(dst_paddr, 16);\n\t\tlen = round_up(size, 16);\n\t}\n\n\tret = __sev_issue_dbg_cmd(kvm, paddr, dst_paddr, len, error, true);\n\ne_free:\n\tif (src_tpage)\n\t\t__free_page(src_tpage);\n\tif (dst_tpage)\n\t\t__free_page(dst_tpage);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "dst_p[0]"
          ],
          "line": 5902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "src_p[0]"
          ],
          "line": 5900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sev_dbg_decrypt_user",
          "args": [
            "kvm",
            "__sme_page_pa(src_p[0]) + s_off",
            "dst_vaddr",
            "__sme_page_pa(dst_p[0]) + d_off",
            "len",
            "&argp->error"
          ],
          "line": 5893
        },
        "resolved": true,
        "details": {
          "function_name": "__sev_dbg_decrypt_user",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5721-5756",
          "snippet": "static int __sev_dbg_decrypt_user(struct kvm *kvm, unsigned long paddr,\n\t\t\t\t  unsigned long __user dst_uaddr,\n\t\t\t\t  unsigned long dst_paddr,\n\t\t\t\t  int size, int *err)\n{\n\tstruct page *tpage = NULL;\n\tint ret, offset;\n\n\t/* if inputs are not 16-byte then use intermediate buffer */\n\tif (!IS_ALIGNED(dst_paddr, 16) ||\n\t    !IS_ALIGNED(paddr,     16) ||\n\t    !IS_ALIGNED(size,      16)) {\n\t\ttpage = (void *)alloc_page(GFP_KERNEL);\n\t\tif (!tpage)\n\t\t\treturn -ENOMEM;\n\n\t\tdst_paddr = __sme_page_pa(tpage);\n\t}\n\n\tret = __sev_dbg_decrypt(kvm, paddr, dst_paddr, size, err);\n\tif (ret)\n\t\tgoto e_free;\n\n\tif (tpage) {\n\t\toffset = paddr & 15;\n\t\tif (copy_to_user((void __user *)(uintptr_t)dst_uaddr,\n\t\t\t\t page_address(tpage) + offset, size))\n\t\t\tret = -EFAULT;\n\t}\n\ne_free:\n\tif (tpage)\n\t\t__free_page(tpage);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __sev_dbg_decrypt_user(struct kvm *kvm, unsigned long paddr,\n\t\t\t\t  unsigned long __user dst_uaddr,\n\t\t\t\t  unsigned long dst_paddr,\n\t\t\t\t  int size, int *err)\n{\n\tstruct page *tpage = NULL;\n\tint ret, offset;\n\n\t/* if inputs are not 16-byte then use intermediate buffer */\n\tif (!IS_ALIGNED(dst_paddr, 16) ||\n\t    !IS_ALIGNED(paddr,     16) ||\n\t    !IS_ALIGNED(size,      16)) {\n\t\ttpage = (void *)alloc_page(GFP_KERNEL);\n\t\tif (!tpage)\n\t\t\treturn -ENOMEM;\n\n\t\tdst_paddr = __sme_page_pa(tpage);\n\t}\n\n\tret = __sev_dbg_decrypt(kvm, paddr, dst_paddr, size, err);\n\tif (ret)\n\t\tgoto e_free;\n\n\tif (tpage) {\n\t\toffset = paddr & 15;\n\t\tif (copy_to_user((void __user *)(uintptr_t)dst_uaddr,\n\t\t\t\t page_address(tpage) + offset, size))\n\t\t\tret = -EFAULT;\n\t}\n\ne_free:\n\tif (tpage)\n\t\t__free_page(tpage);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "dst_p[0]"
          ],
          "line": 5896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "src_p[0]"
          ],
          "line": 5894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "(PAGE_SIZE - s_off)",
            "size"
          ],
          "line": 5890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_clflush_pages",
          "args": [
            "dst_p",
            "1"
          ],
          "line": 5882
        },
        "resolved": true,
        "details": {
          "function_name": "sev_clflush_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1610-1623",
          "snippet": "static void sev_clflush_pages(struct page *pages[], unsigned long npages)\n{\n\tuint8_t *page_virtual;\n\tunsigned long i;\n\n\tif (npages == 0 || pages == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpage_virtual = kmap_atomic(pages[i]);\n\t\tclflush_cache_range(page_virtual, PAGE_SIZE);\n\t\tkunmap_atomic(page_virtual);\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void sev_clflush_pages(struct page *pages[], unsigned long npages)\n{\n\tuint8_t *page_virtual;\n\tunsigned long i;\n\n\tif (npages == 0 || pages == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpage_virtual = kmap_atomic(pages[i]);\n\t\tclflush_cache_range(page_virtual, PAGE_SIZE);\n\t\tkunmap_atomic(page_virtual);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_pin_memory",
          "args": [
            "kvm",
            "dst_vaddr & PAGE_MASK",
            "PAGE_SIZE",
            "&n",
            "1"
          ],
          "line": 5869
        },
        "resolved": true,
        "details": {
          "function_name": "sev_pin_memory",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1544-1598",
          "snippet": "static struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, npinned, size;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn NULL;\n\n\t/* Calculate number of pages. */\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn NULL;\n\t}\n\n\t/* Avoid using vmalloc for smaller buffers. */\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO,\n\t\t\t\t  PAGE_KERNEL);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\n\tif (!pages)\n\t\treturn NULL;\n\n\t/* Pin the user virtual address. */\n\tnpinned = get_user_pages_fast(uaddr, npages, FOLL_WRITE, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tgoto err;\n\t}\n\n\t*n = npages;\n\tsev->pages_locked = locked;\n\n\treturn pages;\n\nerr:\n\tif (npinned > 0)\n\t\trelease_pages(pages, npinned);\n\n\tkvfree(pages);\n\treturn NULL;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, npinned, size;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn NULL;\n\n\t/* Calculate number of pages. */\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn NULL;\n\t}\n\n\t/* Avoid using vmalloc for smaller buffers. */\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO,\n\t\t\t\t  PAGE_KERNEL);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\n\tif (!pages)\n\t\treturn NULL;\n\n\t/* Pin the user virtual address. */\n\tnpinned = get_user_pages_fast(uaddr, npages, FOLL_WRITE, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tgoto err;\n\t}\n\n\t*n = npages;\n\tsev->pages_locked = locked;\n\n\treturn pages;\n\nerr:\n\tif (npinned > 0)\n\t\trelease_pages(pages, npinned);\n\n\tkvfree(pages);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&debug",
            "(void __user *)(uintptr_t)argp->data",
            "sizeof(debug)"
          ],
          "line": 5848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "kvm"
          ],
          "line": 5845
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev_dbg_crypt(struct kvm *kvm, struct kvm_sev_cmd *argp, bool dec)\n{\n\tunsigned long vaddr, vaddr_end, next_vaddr;\n\tunsigned long dst_vaddr;\n\tstruct page **src_p, **dst_p;\n\tstruct kvm_sev_dbg debug;\n\tunsigned long n;\n\tunsigned int size;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&debug, (void __user *)(uintptr_t)argp->data, sizeof(debug)))\n\t\treturn -EFAULT;\n\n\tif (!debug.len || debug.src_uaddr + debug.len < debug.src_uaddr)\n\t\treturn -EINVAL;\n\tif (!debug.dst_uaddr)\n\t\treturn -EINVAL;\n\n\tvaddr = debug.src_uaddr;\n\tsize = debug.len;\n\tvaddr_end = vaddr + size;\n\tdst_vaddr = debug.dst_uaddr;\n\n\tfor (; vaddr < vaddr_end; vaddr = next_vaddr) {\n\t\tint len, s_off, d_off;\n\n\t\t/* lock userspace source and destination page */\n\t\tsrc_p = sev_pin_memory(kvm, vaddr & PAGE_MASK, PAGE_SIZE, &n, 0);\n\t\tif (!src_p)\n\t\t\treturn -EFAULT;\n\n\t\tdst_p = sev_pin_memory(kvm, dst_vaddr & PAGE_MASK, PAGE_SIZE, &n, 1);\n\t\tif (!dst_p) {\n\t\t\tsev_unpin_memory(kvm, src_p, n);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\t/*\n\t\t * The DBG_{DE,EN}CRYPT commands will perform {dec,en}cryption of the\n\t\t * memory content (i.e it will write the same memory region with C=1).\n\t\t * It's possible that the cache may contain the data with C=0, i.e.,\n\t\t * unencrypted so invalidate it first.\n\t\t */\n\t\tsev_clflush_pages(src_p, 1);\n\t\tsev_clflush_pages(dst_p, 1);\n\n\t\t/*\n\t\t * Since user buffer may not be page aligned, calculate the\n\t\t * offset within the page.\n\t\t */\n\t\ts_off = vaddr & ~PAGE_MASK;\n\t\td_off = dst_vaddr & ~PAGE_MASK;\n\t\tlen = min_t(size_t, (PAGE_SIZE - s_off), size);\n\n\t\tif (dec)\n\t\t\tret = __sev_dbg_decrypt_user(kvm,\n\t\t\t\t\t\t     __sme_page_pa(src_p[0]) + s_off,\n\t\t\t\t\t\t     dst_vaddr,\n\t\t\t\t\t\t     __sme_page_pa(dst_p[0]) + d_off,\n\t\t\t\t\t\t     len, &argp->error);\n\t\telse\n\t\t\tret = __sev_dbg_encrypt_user(kvm,\n\t\t\t\t\t\t     __sme_page_pa(src_p[0]) + s_off,\n\t\t\t\t\t\t     vaddr,\n\t\t\t\t\t\t     __sme_page_pa(dst_p[0]) + d_off,\n\t\t\t\t\t\t     dst_vaddr,\n\t\t\t\t\t\t     len, &argp->error);\n\n\t\tsev_unpin_memory(kvm, src_p, n);\n\t\tsev_unpin_memory(kvm, dst_p, n);\n\n\t\tif (ret)\n\t\t\tgoto err;\n\n\t\tnext_vaddr = vaddr + len;\n\t\tdst_vaddr = dst_vaddr + len;\n\t\tsize -= len;\n\t}\nerr:\n\treturn ret;\n}"
  },
  {
    "function_name": "__sev_dbg_encrypt_user",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5758-5833",
    "snippet": "static int __sev_dbg_encrypt_user(struct kvm *kvm, unsigned long paddr,\n\t\t\t\t  unsigned long __user vaddr,\n\t\t\t\t  unsigned long dst_paddr,\n\t\t\t\t  unsigned long __user dst_vaddr,\n\t\t\t\t  int size, int *error)\n{\n\tstruct page *src_tpage = NULL;\n\tstruct page *dst_tpage = NULL;\n\tint ret, len = size;\n\n\t/* If source buffer is not aligned then use an intermediate buffer */\n\tif (!IS_ALIGNED(vaddr, 16)) {\n\t\tsrc_tpage = alloc_page(GFP_KERNEL);\n\t\tif (!src_tpage)\n\t\t\treturn -ENOMEM;\n\n\t\tif (copy_from_user(page_address(src_tpage),\n\t\t\t\t(void __user *)(uintptr_t)vaddr, size)) {\n\t\t\t__free_page(src_tpage);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tpaddr = __sme_page_pa(src_tpage);\n\t}\n\n\t/*\n\t *  If destination buffer or length is not aligned then do read-modify-write:\n\t *   - decrypt destination in an intermediate buffer\n\t *   - copy the source buffer in an intermediate buffer\n\t *   - use the intermediate buffer as source buffer\n\t */\n\tif (!IS_ALIGNED(dst_vaddr, 16) || !IS_ALIGNED(size, 16)) {\n\t\tint dst_offset;\n\n\t\tdst_tpage = alloc_page(GFP_KERNEL);\n\t\tif (!dst_tpage) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tret = __sev_dbg_decrypt(kvm, dst_paddr,\n\t\t\t\t\t__sme_page_pa(dst_tpage), size, error);\n\t\tif (ret)\n\t\t\tgoto e_free;\n\n\t\t/*\n\t\t *  If source is kernel buffer then use memcpy() otherwise\n\t\t *  copy_from_user().\n\t\t */\n\t\tdst_offset = dst_paddr & 15;\n\n\t\tif (src_tpage)\n\t\t\tmemcpy(page_address(dst_tpage) + dst_offset,\n\t\t\t       page_address(src_tpage), size);\n\t\telse {\n\t\t\tif (copy_from_user(page_address(dst_tpage) + dst_offset,\n\t\t\t\t\t   (void __user *)(uintptr_t)vaddr, size)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto e_free;\n\t\t\t}\n\t\t}\n\n\t\tpaddr = __sme_page_pa(dst_tpage);\n\t\tdst_paddr = round_down(dst_paddr, 16);\n\t\tlen = round_up(size, 16);\n\t}\n\n\tret = __sev_issue_dbg_cmd(kvm, paddr, dst_paddr, len, error, true);\n\ne_free:\n\tif (src_tpage)\n\t\t__free_page(src_tpage);\n\tif (dst_tpage)\n\t\t__free_page(dst_tpage);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "dst_tpage"
          ],
          "line": 5831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "src_tpage"
          ],
          "line": 5829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sev_issue_dbg_cmd",
          "args": [
            "kvm",
            "paddr",
            "dst_paddr",
            "len",
            "error",
            "true"
          ],
          "line": 5825
        },
        "resolved": true,
        "details": {
          "function_name": "__sev_issue_dbg_cmd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5681-5703",
          "snippet": "static int __sev_issue_dbg_cmd(struct kvm *kvm, unsigned long src,\n\t\t\t       unsigned long dst, int size,\n\t\t\t       int *error, bool enc)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_dbg *data;\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tdata->dst_addr = dst;\n\tdata->src_addr = src;\n\tdata->len = size;\n\n\tret = sev_issue_cmd(kvm,\n\t\t\t    enc ? SEV_CMD_DBG_ENCRYPT : SEV_CMD_DBG_DECRYPT,\n\t\t\t    data, error);\n\tkfree(data);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int __sev_issue_dbg_cmd(struct kvm *kvm, unsigned long src,\n\t\t\t       unsigned long dst, int size,\n\t\t\t       int *error, bool enc)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_dbg *data;\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tdata->dst_addr = dst;\n\tdata->src_addr = src;\n\tdata->len = size;\n\n\tret = sev_issue_cmd(kvm,\n\t\t\t    enc ? SEV_CMD_DBG_ENCRYPT : SEV_CMD_DBG_DECRYPT,\n\t\t\t    data, error);\n\tkfree(data);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "size",
            "16"
          ],
          "line": 5822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "dst_paddr",
            "16"
          ],
          "line": 5821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "dst_tpage"
          ],
          "line": 5820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "page_address(dst_tpage) + dst_offset",
            "(void __user *)(uintptr_t)vaddr",
            "size"
          ],
          "line": 5813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "dst_tpage"
          ],
          "line": 5813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "page_address(dst_tpage) + dst_offset",
            "page_address(src_tpage)",
            "size"
          ],
          "line": 5810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "src_tpage"
          ],
          "line": 5811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "dst_tpage"
          ],
          "line": 5810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sev_dbg_decrypt",
          "args": [
            "kvm",
            "dst_paddr",
            "__sme_page_pa(dst_tpage)",
            "size",
            "error"
          ],
          "line": 5798
        },
        "resolved": true,
        "details": {
          "function_name": "__sev_dbg_decrypt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5705-5719",
          "snippet": "static int __sev_dbg_decrypt(struct kvm *kvm, unsigned long src_paddr,\n\t\t\t     unsigned long dst_paddr, int sz, int *err)\n{\n\tint offset;\n\n\t/*\n\t * Its safe to read more than we are asked, caller should ensure that\n\t * destination has enough space.\n\t */\n\tsrc_paddr = round_down(src_paddr, 16);\n\toffset = src_paddr & 15;\n\tsz = round_up(sz + offset, 16);\n\n\treturn __sev_issue_dbg_cmd(kvm, src_paddr, dst_paddr, sz, err, false);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __sev_dbg_decrypt(struct kvm *kvm, unsigned long src_paddr,\n\t\t\t     unsigned long dst_paddr, int sz, int *err)\n{\n\tint offset;\n\n\t/*\n\t * Its safe to read more than we are asked, caller should ensure that\n\t * destination has enough space.\n\t */\n\tsrc_paddr = round_down(src_paddr, 16);\n\toffset = src_paddr & 15;\n\tsz = round_up(sz + offset, 16);\n\n\treturn __sev_issue_dbg_cmd(kvm, src_paddr, dst_paddr, sz, err, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "dst_tpage"
          ],
          "line": 5799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 5792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "size",
            "16"
          ],
          "line": 5789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "dst_vaddr",
            "16"
          ],
          "line": 5789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "src_tpage"
          ],
          "line": 5780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "src_tpage"
          ],
          "line": 5776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "page_address(src_tpage)",
            "(void __user *)(uintptr_t)vaddr",
            "size"
          ],
          "line": 5774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "src_tpage"
          ],
          "line": 5774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 5770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "vaddr",
            "16"
          ],
          "line": 5769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __sev_dbg_encrypt_user(struct kvm *kvm, unsigned long paddr,\n\t\t\t\t  unsigned long __user vaddr,\n\t\t\t\t  unsigned long dst_paddr,\n\t\t\t\t  unsigned long __user dst_vaddr,\n\t\t\t\t  int size, int *error)\n{\n\tstruct page *src_tpage = NULL;\n\tstruct page *dst_tpage = NULL;\n\tint ret, len = size;\n\n\t/* If source buffer is not aligned then use an intermediate buffer */\n\tif (!IS_ALIGNED(vaddr, 16)) {\n\t\tsrc_tpage = alloc_page(GFP_KERNEL);\n\t\tif (!src_tpage)\n\t\t\treturn -ENOMEM;\n\n\t\tif (copy_from_user(page_address(src_tpage),\n\t\t\t\t(void __user *)(uintptr_t)vaddr, size)) {\n\t\t\t__free_page(src_tpage);\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tpaddr = __sme_page_pa(src_tpage);\n\t}\n\n\t/*\n\t *  If destination buffer or length is not aligned then do read-modify-write:\n\t *   - decrypt destination in an intermediate buffer\n\t *   - copy the source buffer in an intermediate buffer\n\t *   - use the intermediate buffer as source buffer\n\t */\n\tif (!IS_ALIGNED(dst_vaddr, 16) || !IS_ALIGNED(size, 16)) {\n\t\tint dst_offset;\n\n\t\tdst_tpage = alloc_page(GFP_KERNEL);\n\t\tif (!dst_tpage) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tret = __sev_dbg_decrypt(kvm, dst_paddr,\n\t\t\t\t\t__sme_page_pa(dst_tpage), size, error);\n\t\tif (ret)\n\t\t\tgoto e_free;\n\n\t\t/*\n\t\t *  If source is kernel buffer then use memcpy() otherwise\n\t\t *  copy_from_user().\n\t\t */\n\t\tdst_offset = dst_paddr & 15;\n\n\t\tif (src_tpage)\n\t\t\tmemcpy(page_address(dst_tpage) + dst_offset,\n\t\t\t       page_address(src_tpage), size);\n\t\telse {\n\t\t\tif (copy_from_user(page_address(dst_tpage) + dst_offset,\n\t\t\t\t\t   (void __user *)(uintptr_t)vaddr, size)) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto e_free;\n\t\t\t}\n\t\t}\n\n\t\tpaddr = __sme_page_pa(dst_tpage);\n\t\tdst_paddr = round_down(dst_paddr, 16);\n\t\tlen = round_up(size, 16);\n\t}\n\n\tret = __sev_issue_dbg_cmd(kvm, paddr, dst_paddr, len, error, true);\n\ne_free:\n\tif (src_tpage)\n\t\t__free_page(src_tpage);\n\tif (dst_tpage)\n\t\t__free_page(dst_tpage);\n\treturn ret;\n}"
  },
  {
    "function_name": "__sev_dbg_decrypt_user",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5721-5756",
    "snippet": "static int __sev_dbg_decrypt_user(struct kvm *kvm, unsigned long paddr,\n\t\t\t\t  unsigned long __user dst_uaddr,\n\t\t\t\t  unsigned long dst_paddr,\n\t\t\t\t  int size, int *err)\n{\n\tstruct page *tpage = NULL;\n\tint ret, offset;\n\n\t/* if inputs are not 16-byte then use intermediate buffer */\n\tif (!IS_ALIGNED(dst_paddr, 16) ||\n\t    !IS_ALIGNED(paddr,     16) ||\n\t    !IS_ALIGNED(size,      16)) {\n\t\ttpage = (void *)alloc_page(GFP_KERNEL);\n\t\tif (!tpage)\n\t\t\treturn -ENOMEM;\n\n\t\tdst_paddr = __sme_page_pa(tpage);\n\t}\n\n\tret = __sev_dbg_decrypt(kvm, paddr, dst_paddr, size, err);\n\tif (ret)\n\t\tgoto e_free;\n\n\tif (tpage) {\n\t\toffset = paddr & 15;\n\t\tif (copy_to_user((void __user *)(uintptr_t)dst_uaddr,\n\t\t\t\t page_address(tpage) + offset, size))\n\t\t\tret = -EFAULT;\n\t}\n\ne_free:\n\tif (tpage)\n\t\t__free_page(tpage);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "tpage"
          ],
          "line": 5753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void __user *)(uintptr_t)dst_uaddr",
            "page_address(tpage) + offset",
            "size"
          ],
          "line": 5746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "tpage"
          ],
          "line": 5747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sev_dbg_decrypt",
          "args": [
            "kvm",
            "paddr",
            "dst_paddr",
            "size",
            "err"
          ],
          "line": 5740
        },
        "resolved": true,
        "details": {
          "function_name": "__sev_dbg_decrypt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5705-5719",
          "snippet": "static int __sev_dbg_decrypt(struct kvm *kvm, unsigned long src_paddr,\n\t\t\t     unsigned long dst_paddr, int sz, int *err)\n{\n\tint offset;\n\n\t/*\n\t * Its safe to read more than we are asked, caller should ensure that\n\t * destination has enough space.\n\t */\n\tsrc_paddr = round_down(src_paddr, 16);\n\toffset = src_paddr & 15;\n\tsz = round_up(sz + offset, 16);\n\n\treturn __sev_issue_dbg_cmd(kvm, src_paddr, dst_paddr, sz, err, false);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __sev_dbg_decrypt(struct kvm *kvm, unsigned long src_paddr,\n\t\t\t     unsigned long dst_paddr, int sz, int *err)\n{\n\tint offset;\n\n\t/*\n\t * Its safe to read more than we are asked, caller should ensure that\n\t * destination has enough space.\n\t */\n\tsrc_paddr = round_down(src_paddr, 16);\n\toffset = src_paddr & 15;\n\tsz = round_up(sz + offset, 16);\n\n\treturn __sev_issue_dbg_cmd(kvm, src_paddr, dst_paddr, sz, err, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "tpage"
          ],
          "line": 5737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 5733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "size",
            "16"
          ],
          "line": 5732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "paddr",
            "16"
          ],
          "line": 5731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ALIGNED",
          "args": [
            "dst_paddr",
            "16"
          ],
          "line": 5730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __sev_dbg_decrypt_user(struct kvm *kvm, unsigned long paddr,\n\t\t\t\t  unsigned long __user dst_uaddr,\n\t\t\t\t  unsigned long dst_paddr,\n\t\t\t\t  int size, int *err)\n{\n\tstruct page *tpage = NULL;\n\tint ret, offset;\n\n\t/* if inputs are not 16-byte then use intermediate buffer */\n\tif (!IS_ALIGNED(dst_paddr, 16) ||\n\t    !IS_ALIGNED(paddr,     16) ||\n\t    !IS_ALIGNED(size,      16)) {\n\t\ttpage = (void *)alloc_page(GFP_KERNEL);\n\t\tif (!tpage)\n\t\t\treturn -ENOMEM;\n\n\t\tdst_paddr = __sme_page_pa(tpage);\n\t}\n\n\tret = __sev_dbg_decrypt(kvm, paddr, dst_paddr, size, err);\n\tif (ret)\n\t\tgoto e_free;\n\n\tif (tpage) {\n\t\toffset = paddr & 15;\n\t\tif (copy_to_user((void __user *)(uintptr_t)dst_uaddr,\n\t\t\t\t page_address(tpage) + offset, size))\n\t\t\tret = -EFAULT;\n\t}\n\ne_free:\n\tif (tpage)\n\t\t__free_page(tpage);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__sev_dbg_decrypt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5705-5719",
    "snippet": "static int __sev_dbg_decrypt(struct kvm *kvm, unsigned long src_paddr,\n\t\t\t     unsigned long dst_paddr, int sz, int *err)\n{\n\tint offset;\n\n\t/*\n\t * Its safe to read more than we are asked, caller should ensure that\n\t * destination has enough space.\n\t */\n\tsrc_paddr = round_down(src_paddr, 16);\n\toffset = src_paddr & 15;\n\tsz = round_up(sz + offset, 16);\n\n\treturn __sev_issue_dbg_cmd(kvm, src_paddr, dst_paddr, sz, err, false);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sev_issue_dbg_cmd",
          "args": [
            "kvm",
            "src_paddr",
            "dst_paddr",
            "sz",
            "err",
            "false"
          ],
          "line": 5718
        },
        "resolved": true,
        "details": {
          "function_name": "__sev_issue_dbg_cmd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5681-5703",
          "snippet": "static int __sev_issue_dbg_cmd(struct kvm *kvm, unsigned long src,\n\t\t\t       unsigned long dst, int size,\n\t\t\t       int *error, bool enc)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_dbg *data;\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tdata->dst_addr = dst;\n\tdata->src_addr = src;\n\tdata->len = size;\n\n\tret = sev_issue_cmd(kvm,\n\t\t\t    enc ? SEV_CMD_DBG_ENCRYPT : SEV_CMD_DBG_DECRYPT,\n\t\t\t    data, error);\n\tkfree(data);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int __sev_issue_dbg_cmd(struct kvm *kvm, unsigned long src,\n\t\t\t       unsigned long dst, int size,\n\t\t\t       int *error, bool enc)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_dbg *data;\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tdata->dst_addr = dst;\n\tdata->src_addr = src;\n\tdata->len = size;\n\n\tret = sev_issue_cmd(kvm,\n\t\t\t    enc ? SEV_CMD_DBG_ENCRYPT : SEV_CMD_DBG_DECRYPT,\n\t\t\t    data, error);\n\tkfree(data);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "sz + offset",
            "16"
          ],
          "line": 5716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_down",
          "args": [
            "src_paddr",
            "16"
          ],
          "line": 5714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __sev_dbg_decrypt(struct kvm *kvm, unsigned long src_paddr,\n\t\t\t     unsigned long dst_paddr, int sz, int *err)\n{\n\tint offset;\n\n\t/*\n\t * Its safe to read more than we are asked, caller should ensure that\n\t * destination has enough space.\n\t */\n\tsrc_paddr = round_down(src_paddr, 16);\n\toffset = src_paddr & 15;\n\tsz = round_up(sz + offset, 16);\n\n\treturn __sev_issue_dbg_cmd(kvm, src_paddr, dst_paddr, sz, err, false);\n}"
  },
  {
    "function_name": "__sev_issue_dbg_cmd",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5681-5703",
    "snippet": "static int __sev_issue_dbg_cmd(struct kvm *kvm, unsigned long src,\n\t\t\t       unsigned long dst, int size,\n\t\t\t       int *error, bool enc)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_dbg *data;\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tdata->dst_addr = dst;\n\tdata->src_addr = src;\n\tdata->len = size;\n\n\tret = sev_issue_cmd(kvm,\n\t\t\t    enc ? SEV_CMD_DBG_ENCRYPT : SEV_CMD_DBG_DECRYPT,\n\t\t\t    data, error);\n\tkfree(data);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 5701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_issue_cmd",
          "args": [
            "kvm",
            "enc ? SEV_CMD_DBG_ENCRYPT : SEV_CMD_DBG_DECRYPT",
            "data",
            "error"
          ],
          "line": 5698
        },
        "resolved": true,
        "details": {
          "function_name": "sev_issue_cmd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5382-5387",
          "snippet": "static int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 5689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 5685
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int __sev_issue_dbg_cmd(struct kvm *kvm, unsigned long src,\n\t\t\t       unsigned long dst, int size,\n\t\t\t       int *error, bool enc)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_dbg *data;\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tdata->dst_addr = dst;\n\tdata->src_addr = src;\n\tdata->len = size;\n\n\tret = sev_issue_cmd(kvm,\n\t\t\t    enc ? SEV_CMD_DBG_ENCRYPT : SEV_CMD_DBG_DECRYPT,\n\t\t\t    data, error);\n\tkfree(data);\n\treturn ret;\n}"
  },
  {
    "function_name": "sev_guest_status",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5651-5679",
    "snippet": "static int sev_guest_status(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct kvm_sev_guest_status params;\n\tstruct sev_data_guest_status *data;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_GUEST_STATUS, data, &argp->error);\n\tif (ret)\n\t\tgoto e_free;\n\n\tparams.policy = data->policy;\n\tparams.state = data->state;\n\tparams.handle = data->handle;\n\n\tif (copy_to_user((void __user *)(uintptr_t)argp->data, &params, sizeof(params)))\n\t\tret = -EFAULT;\ne_free:\n\tkfree(data);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 5677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void __user *)(uintptr_t)argp->data",
            "&params",
            "sizeof(params)"
          ],
          "line": 5674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_issue_cmd",
          "args": [
            "kvm",
            "SEV_CMD_GUEST_STATUS",
            "data",
            "&argp->error"
          ],
          "line": 5666
        },
        "resolved": true,
        "details": {
          "function_name": "sev_issue_cmd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5382-5387",
          "snippet": "static int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 5661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "kvm"
          ],
          "line": 5658
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 5653
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_guest_status(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct kvm_sev_guest_status params;\n\tstruct sev_data_guest_status *data;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_GUEST_STATUS, data, &argp->error);\n\tif (ret)\n\t\tgoto e_free;\n\n\tparams.policy = data->policy;\n\tparams.state = data->state;\n\tparams.handle = data->handle;\n\n\tif (copy_to_user((void __user *)(uintptr_t)argp->data, &params, sizeof(params)))\n\t\tret = -EFAULT;\ne_free:\n\tkfree(data);\n\treturn ret;\n}"
  },
  {
    "function_name": "sev_launch_finish",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5631-5649",
    "snippet": "static int sev_launch_finish(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_finish *data;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_FINISH, data, &argp->error);\n\n\tkfree(data);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 5647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_issue_cmd",
          "args": [
            "kvm",
            "SEV_CMD_LAUNCH_FINISH",
            "data",
            "&argp->error"
          ],
          "line": 5645
        },
        "resolved": true,
        "details": {
          "function_name": "sev_issue_cmd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5382-5387",
          "snippet": "static int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 5640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "kvm"
          ],
          "line": 5637
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 5633
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_launch_finish(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_finish *data;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_FINISH, data, &argp->error);\n\n\tkfree(data);\n\treturn ret;\n}"
  },
  {
    "function_name": "sev_launch_measure",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5562-5629",
    "snippet": "static int sev_launch_measure(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tvoid __user *measure = (void __user *)(uintptr_t)argp->data;\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_measure *data;\n\tstruct kvm_sev_launch_measure params;\n\tvoid __user *p = NULL;\n\tvoid *blob = NULL;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, measure, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/* User wants to query the blob length */\n\tif (!params.len)\n\t\tgoto cmd;\n\n\tp = (void __user *)(uintptr_t)params.uaddr;\n\tif (p) {\n\t\tif (params.len > SEV_FW_BLOB_MAX_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tret = -ENOMEM;\n\t\tblob = kmalloc(params.len, GFP_KERNEL);\n\t\tif (!blob)\n\t\t\tgoto e_free;\n\n\t\tdata->address = __psp_pa(blob);\n\t\tdata->len = params.len;\n\t}\n\ncmd:\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_MEASURE, data, &argp->error);\n\n\t/*\n\t * If we query the session length, FW responded with expected data.\n\t */\n\tif (!params.len)\n\t\tgoto done;\n\n\tif (ret)\n\t\tgoto e_free_blob;\n\n\tif (blob) {\n\t\tif (copy_to_user(p, blob, params.len))\n\t\t\tret = -EFAULT;\n\t}\n\ndone:\n\tparams.len = data->len;\n\tif (copy_to_user(measure, &params, sizeof(params)))\n\t\tret = -EFAULT;\ne_free_blob:\n\tkfree(blob);\ne_free:\n\tkfree(data);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 5627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "blob"
          ],
          "line": 5625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "measure",
            "&params",
            "sizeof(params)"
          ],
          "line": 5622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "p",
            "blob",
            "params.len"
          ],
          "line": 5616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_issue_cmd",
          "args": [
            "kvm",
            "SEV_CMD_LAUNCH_MEASURE",
            "data",
            "&argp->error"
          ],
          "line": 5604
        },
        "resolved": true,
        "details": {
          "function_name": "sev_issue_cmd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5382-5387",
          "snippet": "static int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__psp_pa",
          "args": [
            "blob"
          ],
          "line": 5598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "params.len",
            "GFP_KERNEL"
          ],
          "line": 5594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 5578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&params",
            "measure",
            "sizeof(params)"
          ],
          "line": 5575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "kvm"
          ],
          "line": 5572
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 5565
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_launch_measure(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tvoid __user *measure = (void __user *)(uintptr_t)argp->data;\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_measure *data;\n\tstruct kvm_sev_launch_measure params;\n\tvoid __user *p = NULL;\n\tvoid *blob = NULL;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, measure, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/* User wants to query the blob length */\n\tif (!params.len)\n\t\tgoto cmd;\n\n\tp = (void __user *)(uintptr_t)params.uaddr;\n\tif (p) {\n\t\tif (params.len > SEV_FW_BLOB_MAX_SIZE) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tret = -ENOMEM;\n\t\tblob = kmalloc(params.len, GFP_KERNEL);\n\t\tif (!blob)\n\t\t\tgoto e_free;\n\n\t\tdata->address = __psp_pa(blob);\n\t\tdata->len = params.len;\n\t}\n\ncmd:\n\tdata->handle = sev->handle;\n\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_MEASURE, data, &argp->error);\n\n\t/*\n\t * If we query the session length, FW responded with expected data.\n\t */\n\tif (!params.len)\n\t\tgoto done;\n\n\tif (ret)\n\t\tgoto e_free_blob;\n\n\tif (blob) {\n\t\tif (copy_to_user(p, blob, params.len))\n\t\t\tret = -EFAULT;\n\t}\n\ndone:\n\tparams.len = data->len;\n\tif (copy_to_user(measure, &params, sizeof(params)))\n\t\tret = -EFAULT;\ne_free_blob:\n\tkfree(blob);\ne_free:\n\tkfree(data);\n\treturn ret;\n}"
  },
  {
    "function_name": "sev_launch_update_data",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5486-5560",
    "snippet": "static int sev_launch_update_data(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tunsigned long vaddr, vaddr_end, next_vaddr, npages, pages, size, i;\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct kvm_sev_launch_update_data params;\n\tstruct sev_data_launch_update_data *data;\n\tstruct page **inpages;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tvaddr = params.uaddr;\n\tsize = params.len;\n\tvaddr_end = vaddr + size;\n\n\t/* Lock the user memory. */\n\tinpages = sev_pin_memory(kvm, vaddr, size, &npages, 1);\n\tif (!inpages) {\n\t\tret = -ENOMEM;\n\t\tgoto e_free;\n\t}\n\n\t/*\n\t * The LAUNCH_UPDATE command will perform in-place encryption of the\n\t * memory content (i.e it will write the same memory region with C=1).\n\t * It's possible that the cache may contain the data with C=0, i.e.,\n\t * unencrypted so invalidate it first.\n\t */\n\tsev_clflush_pages(inpages, npages);\n\n\tfor (i = 0; vaddr < vaddr_end; vaddr = next_vaddr, i += pages) {\n\t\tint offset, len;\n\n\t\t/*\n\t\t * If the user buffer is not page-aligned, calculate the offset\n\t\t * within the page.\n\t\t */\n\t\toffset = vaddr & (PAGE_SIZE - 1);\n\n\t\t/* Calculate the number of pages that can be encrypted in one go. */\n\t\tpages = get_num_contig_pages(i, inpages, npages);\n\n\t\tlen = min_t(size_t, ((pages * PAGE_SIZE) - offset), size);\n\n\t\tdata->handle = sev->handle;\n\t\tdata->len = len;\n\t\tdata->address = __sme_page_pa(inpages[i]) + offset;\n\t\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_UPDATE_DATA, data, &argp->error);\n\t\tif (ret)\n\t\t\tgoto e_unpin;\n\n\t\tsize -= len;\n\t\tnext_vaddr = vaddr + len;\n\t}\n\ne_unpin:\n\t/* content of memory is updated, mark pages dirty */\n\tfor (i = 0; i < npages; i++) {\n\t\tset_page_dirty_lock(inpages[i]);\n\t\tmark_page_accessed(inpages[i]);\n\t}\n\t/* unlock the user pages */\n\tsev_unpin_memory(kvm, inpages, npages);\ne_free:\n\tkfree(data);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 5558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_unpin_memory",
          "args": [
            "kvm",
            "inpages",
            "npages"
          ],
          "line": 5556
        },
        "resolved": true,
        "details": {
          "function_name": "sev_unpin_memory",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1600-1608",
          "snippet": "static void sev_unpin_memory(struct kvm *kvm, struct page **pages,\n\t\t\t     unsigned long npages)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\trelease_pages(pages, npages);\n\tkvfree(pages);\n\tsev->pages_locked -= npages;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic void sev_unpin_memory(struct kvm *kvm, struct page **pages,\n\t\t\t     unsigned long npages)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\trelease_pages(pages, npages);\n\tkvfree(pages);\n\tsev->pages_locked -= npages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_page_accessed",
          "args": [
            "inpages[i]"
          ],
          "line": 5553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_page_dirty_lock",
          "args": [
            "inpages[i]"
          ],
          "line": 5552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_issue_cmd",
          "args": [
            "kvm",
            "SEV_CMD_LAUNCH_UPDATE_DATA",
            "data",
            "&argp->error"
          ],
          "line": 5541
        },
        "resolved": true,
        "details": {
          "function_name": "sev_issue_cmd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5382-5387",
          "snippet": "static int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "inpages[i]"
          ],
          "line": 5540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "((pages * PAGE_SIZE) - offset)",
            "size"
          ],
          "line": 5536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_num_contig_pages",
          "args": [
            "i",
            "inpages",
            "npages"
          ],
          "line": 5534
        },
        "resolved": true,
        "details": {
          "function_name": "get_num_contig_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5465-5484",
          "snippet": "static unsigned long get_num_contig_pages(unsigned long idx,\n\t\t\t\tstruct page **inpages, unsigned long npages)\n{\n\tunsigned long paddr, next_paddr;\n\tunsigned long i = idx + 1, pages = 1;\n\n\t/* find the number of contiguous pages starting from idx */\n\tpaddr = __sme_page_pa(inpages[idx]);\n\twhile (i < npages) {\n\t\tnext_paddr = __sme_page_pa(inpages[i++]);\n\t\tif ((paddr + PAGE_SIZE) == next_paddr) {\n\t\t\tpages++;\n\t\t\tpaddr = next_paddr;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn pages;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned long get_num_contig_pages(unsigned long idx,\n\t\t\t\tstruct page **inpages, unsigned long npages)\n{\n\tunsigned long paddr, next_paddr;\n\tunsigned long i = idx + 1, pages = 1;\n\n\t/* find the number of contiguous pages starting from idx */\n\tpaddr = __sme_page_pa(inpages[idx]);\n\twhile (i < npages) {\n\t\tnext_paddr = __sme_page_pa(inpages[i++]);\n\t\tif ((paddr + PAGE_SIZE) == next_paddr) {\n\t\t\tpages++;\n\t\t\tpaddr = next_paddr;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn pages;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_clflush_pages",
          "args": [
            "inpages",
            "npages"
          ],
          "line": 5522
        },
        "resolved": true,
        "details": {
          "function_name": "sev_clflush_pages",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1610-1623",
          "snippet": "static void sev_clflush_pages(struct page *pages[], unsigned long npages)\n{\n\tuint8_t *page_virtual;\n\tunsigned long i;\n\n\tif (npages == 0 || pages == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpage_virtual = kmap_atomic(pages[i]);\n\t\tclflush_cache_range(page_virtual, PAGE_SIZE);\n\t\tkunmap_atomic(page_virtual);\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void sev_clflush_pages(struct page *pages[], unsigned long npages)\n{\n\tuint8_t *page_virtual;\n\tunsigned long i;\n\n\tif (npages == 0 || pages == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpage_virtual = kmap_atomic(pages[i]);\n\t\tclflush_cache_range(page_virtual, PAGE_SIZE);\n\t\tkunmap_atomic(page_virtual);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_pin_memory",
          "args": [
            "kvm",
            "vaddr",
            "size",
            "&npages",
            "1"
          ],
          "line": 5510
        },
        "resolved": true,
        "details": {
          "function_name": "sev_pin_memory",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1544-1598",
          "snippet": "static struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, npinned, size;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn NULL;\n\n\t/* Calculate number of pages. */\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn NULL;\n\t}\n\n\t/* Avoid using vmalloc for smaller buffers. */\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO,\n\t\t\t\t  PAGE_KERNEL);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\n\tif (!pages)\n\t\treturn NULL;\n\n\t/* Pin the user virtual address. */\n\tnpinned = get_user_pages_fast(uaddr, npages, FOLL_WRITE, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tgoto err;\n\t}\n\n\t*n = npages;\n\tsev->pages_locked = locked;\n\n\treturn pages;\n\nerr:\n\tif (npinned > 0)\n\t\trelease_pages(pages, npinned);\n\n\tkvfree(pages);\n\treturn NULL;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, npinned, size;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn NULL;\n\n\t/* Calculate number of pages. */\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn NULL;\n\t}\n\n\t/* Avoid using vmalloc for smaller buffers. */\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO,\n\t\t\t\t  PAGE_KERNEL);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\n\tif (!pages)\n\t\treturn NULL;\n\n\t/* Pin the user virtual address. */\n\tnpinned = get_user_pages_fast(uaddr, npages, FOLL_WRITE, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tgoto err;\n\t}\n\n\t*n = npages;\n\tsev->pages_locked = locked;\n\n\treturn pages;\n\nerr:\n\tif (npinned > 0)\n\t\trelease_pages(pages, npinned);\n\n\tkvfree(pages);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 5501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&params",
            "(void __user *)(uintptr_t)argp->data",
            "sizeof(params)"
          ],
          "line": 5498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "kvm"
          ],
          "line": 5495
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 5489
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_launch_update_data(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tunsigned long vaddr, vaddr_end, next_vaddr, npages, pages, size, i;\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct kvm_sev_launch_update_data params;\n\tstruct sev_data_launch_update_data *data;\n\tstruct page **inpages;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tvaddr = params.uaddr;\n\tsize = params.len;\n\tvaddr_end = vaddr + size;\n\n\t/* Lock the user memory. */\n\tinpages = sev_pin_memory(kvm, vaddr, size, &npages, 1);\n\tif (!inpages) {\n\t\tret = -ENOMEM;\n\t\tgoto e_free;\n\t}\n\n\t/*\n\t * The LAUNCH_UPDATE command will perform in-place encryption of the\n\t * memory content (i.e it will write the same memory region with C=1).\n\t * It's possible that the cache may contain the data with C=0, i.e.,\n\t * unencrypted so invalidate it first.\n\t */\n\tsev_clflush_pages(inpages, npages);\n\n\tfor (i = 0; vaddr < vaddr_end; vaddr = next_vaddr, i += pages) {\n\t\tint offset, len;\n\n\t\t/*\n\t\t * If the user buffer is not page-aligned, calculate the offset\n\t\t * within the page.\n\t\t */\n\t\toffset = vaddr & (PAGE_SIZE - 1);\n\n\t\t/* Calculate the number of pages that can be encrypted in one go. */\n\t\tpages = get_num_contig_pages(i, inpages, npages);\n\n\t\tlen = min_t(size_t, ((pages * PAGE_SIZE) - offset), size);\n\n\t\tdata->handle = sev->handle;\n\t\tdata->len = len;\n\t\tdata->address = __sme_page_pa(inpages[i]) + offset;\n\t\tret = sev_issue_cmd(kvm, SEV_CMD_LAUNCH_UPDATE_DATA, data, &argp->error);\n\t\tif (ret)\n\t\t\tgoto e_unpin;\n\n\t\tsize -= len;\n\t\tnext_vaddr = vaddr + len;\n\t}\n\ne_unpin:\n\t/* content of memory is updated, mark pages dirty */\n\tfor (i = 0; i < npages; i++) {\n\t\tset_page_dirty_lock(inpages[i]);\n\t\tmark_page_accessed(inpages[i]);\n\t}\n\t/* unlock the user pages */\n\tsev_unpin_memory(kvm, inpages, npages);\ne_free:\n\tkfree(data);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_num_contig_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5465-5484",
    "snippet": "static unsigned long get_num_contig_pages(unsigned long idx,\n\t\t\t\tstruct page **inpages, unsigned long npages)\n{\n\tunsigned long paddr, next_paddr;\n\tunsigned long i = idx + 1, pages = 1;\n\n\t/* find the number of contiguous pages starting from idx */\n\tpaddr = __sme_page_pa(inpages[idx]);\n\twhile (i < npages) {\n\t\tnext_paddr = __sme_page_pa(inpages[i++]);\n\t\tif ((paddr + PAGE_SIZE) == next_paddr) {\n\t\t\tpages++;\n\t\t\tpaddr = next_paddr;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn pages;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "inpages[i++]"
          ],
          "line": 5474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_page_pa",
          "args": [
            "inpages[idx]"
          ],
          "line": 5472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned long get_num_contig_pages(unsigned long idx,\n\t\t\t\tstruct page **inpages, unsigned long npages)\n{\n\tunsigned long paddr, next_paddr;\n\tunsigned long i = idx + 1, pages = 1;\n\n\t/* find the number of contiguous pages starting from idx */\n\tpaddr = __sme_page_pa(inpages[idx]);\n\twhile (i < npages) {\n\t\tnext_paddr = __sme_page_pa(inpages[i++]);\n\t\tif ((paddr + PAGE_SIZE) == next_paddr) {\n\t\t\tpages++;\n\t\t\tpaddr = next_paddr;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn pages;\n}"
  },
  {
    "function_name": "sev_launch_start",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5389-5463",
    "snippet": "static int sev_launch_start(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_start *start;\n\tstruct kvm_sev_launch_start params;\n\tvoid *dh_blob, *session_blob;\n\tint *error = &argp->error;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tstart = kzalloc(sizeof(*start), GFP_KERNEL_ACCOUNT);\n\tif (!start)\n\t\treturn -ENOMEM;\n\n\tdh_blob = NULL;\n\tif (params.dh_uaddr) {\n\t\tdh_blob = psp_copy_user_blob(params.dh_uaddr, params.dh_len);\n\t\tif (IS_ERR(dh_blob)) {\n\t\t\tret = PTR_ERR(dh_blob);\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tstart->dh_cert_address = __sme_set(__pa(dh_blob));\n\t\tstart->dh_cert_len = params.dh_len;\n\t}\n\n\tsession_blob = NULL;\n\tif (params.session_uaddr) {\n\t\tsession_blob = psp_copy_user_blob(params.session_uaddr, params.session_len);\n\t\tif (IS_ERR(session_blob)) {\n\t\t\tret = PTR_ERR(session_blob);\n\t\t\tgoto e_free_dh;\n\t\t}\n\n\t\tstart->session_address = __sme_set(__pa(session_blob));\n\t\tstart->session_len = params.session_len;\n\t}\n\n\tstart->handle = params.handle;\n\tstart->policy = params.policy;\n\n\t/* create memory encryption context */\n\tret = __sev_issue_cmd(argp->sev_fd, SEV_CMD_LAUNCH_START, start, error);\n\tif (ret)\n\t\tgoto e_free_session;\n\n\t/* Bind ASID to this guest */\n\tret = sev_bind_asid(kvm, start->handle, error);\n\tif (ret)\n\t\tgoto e_free_session;\n\n\t/* return handle to userspace */\n\tparams.handle = start->handle;\n\tif (copy_to_user((void __user *)(uintptr_t)argp->data, &params, sizeof(params))) {\n\t\tsev_unbind_asid(kvm, start->handle);\n\t\tret = -EFAULT;\n\t\tgoto e_free_session;\n\t}\n\n\tsev->handle = start->handle;\n\tsev->fd = argp->sev_fd;\n\ne_free_session:\n\tkfree(session_blob);\ne_free_dh:\n\tkfree(dh_blob);\ne_free:\n\tkfree(start);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "start"
          ],
          "line": 5461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "dh_blob"
          ],
          "line": 5459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "session_blob"
          ],
          "line": 5457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_unbind_asid",
          "args": [
            "kvm",
            "start->handle"
          ],
          "line": 5448
        },
        "resolved": true,
        "details": {
          "function_name": "sev_unbind_asid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1511-1542",
          "snippet": "static void sev_unbind_asid(struct kvm *kvm, unsigned int handle)\n{\n\tstruct sev_data_decommission *decommission;\n\tstruct sev_data_deactivate *data;\n\n\tif (!handle)\n\t\treturn;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\t/* deactivate handle */\n\tdata->handle = handle;\n\n\t/* Guard DEACTIVATE against WBINVD/DF_FLUSH used in ASID recycling */\n\tdown_read(&sev_deactivate_lock);\n\tsev_guest_deactivate(data, NULL);\n\tup_read(&sev_deactivate_lock);\n\n\tkfree(data);\n\n\tdecommission = kzalloc(sizeof(*decommission), GFP_KERNEL);\n\tif (!decommission)\n\t\treturn;\n\n\t/* decommission handle */\n\tdecommission->handle = handle;\n\tsev_guest_decommission(decommission, NULL);\n\n\tkfree(decommission);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(sev_deactivate_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DECLARE_RWSEM(sev_deactivate_lock);\n\nstatic void sev_unbind_asid(struct kvm *kvm, unsigned int handle)\n{\n\tstruct sev_data_decommission *decommission;\n\tstruct sev_data_deactivate *data;\n\n\tif (!handle)\n\t\treturn;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\t/* deactivate handle */\n\tdata->handle = handle;\n\n\t/* Guard DEACTIVATE against WBINVD/DF_FLUSH used in ASID recycling */\n\tdown_read(&sev_deactivate_lock);\n\tsev_guest_deactivate(data, NULL);\n\tup_read(&sev_deactivate_lock);\n\n\tkfree(data);\n\n\tdecommission = kzalloc(sizeof(*decommission), GFP_KERNEL);\n\tif (!decommission)\n\t\treturn;\n\n\t/* decommission handle */\n\tdecommission->handle = handle;\n\tsev_guest_decommission(decommission, NULL);\n\n\tkfree(decommission);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "(void __user *)(uintptr_t)argp->data",
            "&params",
            "sizeof(params)"
          ],
          "line": 5447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_bind_asid",
          "args": [
            "kvm",
            "start->handle",
            "error"
          ],
          "line": 5441
        },
        "resolved": true,
        "details": {
          "function_name": "sev_bind_asid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5348-5365",
          "snippet": "static int sev_bind_asid(struct kvm *kvm, unsigned int handle, int *error)\n{\n\tstruct sev_data_activate *data;\n\tint asid = sev_get_asid(kvm);\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/* activate ASID on the given handle */\n\tdata->handle = handle;\n\tdata->asid   = asid;\n\tret = sev_guest_activate(data, error);\n\tkfree(data);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);\n\nstatic int sev_bind_asid(struct kvm *kvm, unsigned int handle, int *error)\n{\n\tstruct sev_data_activate *data;\n\tint asid = sev_get_asid(kvm);\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/* activate ASID on the given handle */\n\tdata->handle = handle;\n\tdata->asid   = asid;\n\tret = sev_guest_activate(data, error);\n\tkfree(data);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sev_issue_cmd",
          "args": [
            "argp->sev_fd",
            "SEV_CMD_LAUNCH_START",
            "start",
            "error"
          ],
          "line": 5436
        },
        "resolved": true,
        "details": {
          "function_name": "__sev_issue_cmd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5367-5380",
          "snippet": "static int __sev_issue_cmd(int fd, int id, void *data, int *error)\n{\n\tstruct fd f;\n\tint ret;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = sev_issue_cmd_external_user(f.file, id, data, error);\n\n\tfdput(f);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __sev_issue_cmd(int fd, int id, void *data, int *error)\n{\n\tstruct fd f;\n\tint ret;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = sev_issue_cmd_external_user(f.file, id, data, error);\n\n\tfdput(f);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "__pa(session_blob)"
          ],
          "line": 5428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "session_blob"
          ],
          "line": 5428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "session_blob"
          ],
          "line": 5424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "session_blob"
          ],
          "line": 5423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psp_copy_user_blob",
          "args": [
            "params.session_uaddr",
            "params.session_len"
          ],
          "line": 5422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "__pa(dh_blob)"
          ],
          "line": 5416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "dh_blob"
          ],
          "line": 5416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dh_blob"
          ],
          "line": 5412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dh_blob"
          ],
          "line": 5411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "psp_copy_user_blob",
          "args": [
            "params.dh_uaddr",
            "params.dh_len"
          ],
          "line": 5410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*start)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 5404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&params",
            "(void __user *)(uintptr_t)argp->data",
            "sizeof(params)"
          ],
          "line": 5401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "kvm"
          ],
          "line": 5398
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 5391
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_launch_start(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct sev_data_launch_start *start;\n\tstruct kvm_sev_launch_start params;\n\tvoid *dh_blob, *session_blob;\n\tint *error = &argp->error;\n\tint ret;\n\n\tif (!sev_guest(kvm))\n\t\treturn -ENOTTY;\n\n\tif (copy_from_user(&params, (void __user *)(uintptr_t)argp->data, sizeof(params)))\n\t\treturn -EFAULT;\n\n\tstart = kzalloc(sizeof(*start), GFP_KERNEL_ACCOUNT);\n\tif (!start)\n\t\treturn -ENOMEM;\n\n\tdh_blob = NULL;\n\tif (params.dh_uaddr) {\n\t\tdh_blob = psp_copy_user_blob(params.dh_uaddr, params.dh_len);\n\t\tif (IS_ERR(dh_blob)) {\n\t\t\tret = PTR_ERR(dh_blob);\n\t\t\tgoto e_free;\n\t\t}\n\n\t\tstart->dh_cert_address = __sme_set(__pa(dh_blob));\n\t\tstart->dh_cert_len = params.dh_len;\n\t}\n\n\tsession_blob = NULL;\n\tif (params.session_uaddr) {\n\t\tsession_blob = psp_copy_user_blob(params.session_uaddr, params.session_len);\n\t\tif (IS_ERR(session_blob)) {\n\t\t\tret = PTR_ERR(session_blob);\n\t\t\tgoto e_free_dh;\n\t\t}\n\n\t\tstart->session_address = __sme_set(__pa(session_blob));\n\t\tstart->session_len = params.session_len;\n\t}\n\n\tstart->handle = params.handle;\n\tstart->policy = params.policy;\n\n\t/* create memory encryption context */\n\tret = __sev_issue_cmd(argp->sev_fd, SEV_CMD_LAUNCH_START, start, error);\n\tif (ret)\n\t\tgoto e_free_session;\n\n\t/* Bind ASID to this guest */\n\tret = sev_bind_asid(kvm, start->handle, error);\n\tif (ret)\n\t\tgoto e_free_session;\n\n\t/* return handle to userspace */\n\tparams.handle = start->handle;\n\tif (copy_to_user((void __user *)(uintptr_t)argp->data, &params, sizeof(params))) {\n\t\tsev_unbind_asid(kvm, start->handle);\n\t\tret = -EFAULT;\n\t\tgoto e_free_session;\n\t}\n\n\tsev->handle = start->handle;\n\tsev->fd = argp->sev_fd;\n\ne_free_session:\n\tkfree(session_blob);\ne_free_dh:\n\tkfree(dh_blob);\ne_free:\n\tkfree(start);\n\treturn ret;\n}"
  },
  {
    "function_name": "sev_issue_cmd",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5382-5387",
    "snippet": "static int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sev_issue_cmd",
          "args": [
            "sev->fd",
            "id",
            "data",
            "error"
          ],
          "line": 5386
        },
        "resolved": true,
        "details": {
          "function_name": "__sev_issue_cmd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5367-5380",
          "snippet": "static int __sev_issue_cmd(int fd, int id, void *data, int *error)\n{\n\tstruct fd f;\n\tint ret;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = sev_issue_cmd_external_user(f.file, id, data, error);\n\n\tfdput(f);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __sev_issue_cmd(int fd, int id, void *data, int *error)\n{\n\tstruct fd f;\n\tint ret;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = sev_issue_cmd_external_user(f.file, id, data, error);\n\n\tfdput(f);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 5384
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_issue_cmd(struct kvm *kvm, int id, void *data, int *error)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn __sev_issue_cmd(sev->fd, id, data, error);\n}"
  },
  {
    "function_name": "__sev_issue_cmd",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5367-5380",
    "snippet": "static int __sev_issue_cmd(int fd, int id, void *data, int *error)\n{\n\tstruct fd f;\n\tint ret;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = sev_issue_cmd_external_user(f.file, id, data, error);\n\n\tfdput(f);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 5378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_issue_cmd_external_user",
          "args": [
            "f.file",
            "id",
            "data",
            "error"
          ],
          "line": 5376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 5372
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __sev_issue_cmd(int fd, int id, void *data, int *error)\n{\n\tstruct fd f;\n\tint ret;\n\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\n\tret = sev_issue_cmd_external_user(f.file, id, data, error);\n\n\tfdput(f);\n\treturn ret;\n}"
  },
  {
    "function_name": "sev_bind_asid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5348-5365",
    "snippet": "static int sev_bind_asid(struct kvm *kvm, unsigned int handle, int *error)\n{\n\tstruct sev_data_activate *data;\n\tint asid = sev_get_asid(kvm);\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/* activate ASID on the given handle */\n\tdata->handle = handle;\n\tdata->asid   = asid;\n\tret = sev_guest_activate(data, error);\n\tkfree(data);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 5362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest_activate",
          "args": [
            "data",
            "error"
          ],
          "line": 5361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 5354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_get_asid",
          "args": [
            "kvm"
          ],
          "line": 5351
        },
        "resolved": true,
        "details": {
          "function_name": "sev_get_asid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "306-311",
          "snippet": "static inline int sev_get_asid(struct kvm *kvm)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->asid;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline int sev_get_asid(struct kvm *kvm)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->asid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);\n\nstatic int sev_bind_asid(struct kvm *kvm, unsigned int handle, int *error)\n{\n\tstruct sev_data_activate *data;\n\tint asid = sev_get_asid(kvm);\n\tint ret;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL_ACCOUNT);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\t/* activate ASID on the given handle */\n\tdata->handle = handle;\n\tdata->asid   = asid;\n\tret = sev_guest_activate(data, error);\n\tkfree(data);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sev_guest_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5320-5346",
    "snippet": "static int sev_guest_init(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tint asid, ret;\n\n\tret = -EBUSY;\n\tif (unlikely(sev->active))\n\t\treturn ret;\n\n\tasid = sev_asid_new();\n\tif (asid < 0)\n\t\treturn ret;\n\n\tret = sev_platform_init(&argp->error);\n\tif (ret)\n\t\tgoto e_free;\n\n\tsev->active = true;\n\tsev->asid = asid;\n\tINIT_LIST_HEAD(&sev->regions_list);\n\n\treturn 0;\n\ne_free:\n\tsev_asid_free(asid);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sev_asid_free",
          "args": [
            "asid"
          ],
          "line": 5344
        },
        "resolved": true,
        "details": {
          "function_name": "sev_asid_free",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1493-1509",
          "snippet": "static void sev_asid_free(int asid)\n{\n\tstruct svm_cpu_data *sd;\n\tint cpu, pos;\n\n\tmutex_lock(&sev_bitmap_lock);\n\n\tpos = asid - 1;\n\t__set_bit(pos, sev_reclaim_asid_bitmap);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tsd = per_cpu(svm_data, cpu);\n\t\tsd->sev_vmcbs[pos] = NULL;\n\t}\n\n\tmutex_unlock(&sev_bitmap_lock);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sev_bitmap_lock);",
            "static unsigned long *sev_reclaim_asid_bitmap;",
            "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_MUTEX(sev_bitmap_lock);\nstatic unsigned long *sev_reclaim_asid_bitmap;\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void sev_asid_free(int asid)\n{\n\tstruct svm_cpu_data *sd;\n\tint cpu, pos;\n\n\tmutex_lock(&sev_bitmap_lock);\n\n\tpos = asid - 1;\n\t__set_bit(pos, sev_reclaim_asid_bitmap);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tsd = per_cpu(svm_data, cpu);\n\t\tsd->sev_vmcbs[pos] = NULL;\n\t}\n\n\tmutex_unlock(&sev_bitmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sev->regions_list"
          ],
          "line": 5339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_platform_init",
          "args": [
            "&argp->error"
          ],
          "line": 5333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_asid_new",
          "args": [],
          "line": 5329
        },
        "resolved": true,
        "details": {
          "function_name": "sev_asid_new",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5292-5318",
          "snippet": "static int sev_asid_new(void)\n{\n\tbool retry = true;\n\tint pos;\n\n\tmutex_lock(&sev_bitmap_lock);\n\n\t/*\n\t * SEV-enabled guest must use asid from min_sev_asid to max_sev_asid.\n\t */\nagain:\n\tpos = find_next_zero_bit(sev_asid_bitmap, max_sev_asid, min_sev_asid - 1);\n\tif (pos >= max_sev_asid) {\n\t\tif (retry && __sev_recycle_asids()) {\n\t\t\tretry = false;\n\t\t\tgoto again;\n\t\t}\n\t\tmutex_unlock(&sev_bitmap_lock);\n\t\treturn -EBUSY;\n\t}\n\n\t__set_bit(pos, sev_asid_bitmap);\n\n\tmutex_unlock(&sev_bitmap_lock);\n\n\treturn pos + 1;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sev_bitmap_lock);",
            "static unsigned int max_sev_asid;",
            "static unsigned int min_sev_asid;",
            "static unsigned long *sev_asid_bitmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_MUTEX(sev_bitmap_lock);\nstatic unsigned int max_sev_asid;\nstatic unsigned int min_sev_asid;\nstatic unsigned long *sev_asid_bitmap;\n\nstatic int sev_asid_new(void)\n{\n\tbool retry = true;\n\tint pos;\n\n\tmutex_lock(&sev_bitmap_lock);\n\n\t/*\n\t * SEV-enabled guest must use asid from min_sev_asid to max_sev_asid.\n\t */\nagain:\n\tpos = find_next_zero_bit(sev_asid_bitmap, max_sev_asid, min_sev_asid - 1);\n\tif (pos >= max_sev_asid) {\n\t\tif (retry && __sev_recycle_asids()) {\n\t\t\tretry = false;\n\t\t\tgoto again;\n\t\t}\n\t\tmutex_unlock(&sev_bitmap_lock);\n\t\treturn -EBUSY;\n\t}\n\n\t__set_bit(pos, sev_asid_bitmap);\n\n\tmutex_unlock(&sev_bitmap_lock);\n\n\treturn pos + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sev->active"
          ],
          "line": 5326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 5322
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic int sev_guest_init(struct kvm *kvm, struct kvm_sev_cmd *argp)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tint asid, ret;\n\n\tret = -EBUSY;\n\tif (unlikely(sev->active))\n\t\treturn ret;\n\n\tasid = sev_asid_new();\n\tif (asid < 0)\n\t\treturn ret;\n\n\tret = sev_platform_init(&argp->error);\n\tif (ret)\n\t\tgoto e_free;\n\n\tsev->active = true;\n\tsev->asid = asid;\n\tINIT_LIST_HEAD(&sev->regions_list);\n\n\treturn 0;\n\ne_free:\n\tsev_asid_free(asid);\n\treturn ret;\n}"
  },
  {
    "function_name": "sev_asid_new",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5292-5318",
    "snippet": "static int sev_asid_new(void)\n{\n\tbool retry = true;\n\tint pos;\n\n\tmutex_lock(&sev_bitmap_lock);\n\n\t/*\n\t * SEV-enabled guest must use asid from min_sev_asid to max_sev_asid.\n\t */\nagain:\n\tpos = find_next_zero_bit(sev_asid_bitmap, max_sev_asid, min_sev_asid - 1);\n\tif (pos >= max_sev_asid) {\n\t\tif (retry && __sev_recycle_asids()) {\n\t\t\tretry = false;\n\t\t\tgoto again;\n\t\t}\n\t\tmutex_unlock(&sev_bitmap_lock);\n\t\treturn -EBUSY;\n\t}\n\n\t__set_bit(pos, sev_asid_bitmap);\n\n\tmutex_unlock(&sev_bitmap_lock);\n\n\treturn pos + 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(sev_bitmap_lock);",
      "static unsigned int max_sev_asid;",
      "static unsigned int min_sev_asid;",
      "static unsigned long *sev_asid_bitmap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sev_bitmap_lock"
          ],
          "line": 5315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "pos",
            "sev_asid_bitmap"
          ],
          "line": 5313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sev_bitmap_lock"
          ],
          "line": 5309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sev_recycle_asids",
          "args": [],
          "line": 5305
        },
        "resolved": true,
        "details": {
          "function_name": "__sev_recycle_asids",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5272-5290",
          "snippet": "static bool __sev_recycle_asids(void)\n{\n\tint pos;\n\n\t/* Check if there are any ASIDs to reclaim before performing a flush */\n\tpos = find_next_bit(sev_reclaim_asid_bitmap,\n\t\t\t    max_sev_asid, min_sev_asid - 1);\n\tif (pos >= max_sev_asid)\n\t\treturn false;\n\n\tif (sev_flush_asids())\n\t\treturn false;\n\n\tbitmap_xor(sev_asid_bitmap, sev_asid_bitmap, sev_reclaim_asid_bitmap,\n\t\t   max_sev_asid);\n\tbitmap_zero(sev_reclaim_asid_bitmap, max_sev_asid);\n\n\treturn true;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev_flush_asids(void);",
            "static unsigned int max_sev_asid;",
            "static unsigned int min_sev_asid;",
            "static unsigned long *sev_asid_bitmap;",
            "static unsigned long *sev_reclaim_asid_bitmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev_flush_asids(void);\nstatic unsigned int max_sev_asid;\nstatic unsigned int min_sev_asid;\nstatic unsigned long *sev_asid_bitmap;\nstatic unsigned long *sev_reclaim_asid_bitmap;\n\nstatic bool __sev_recycle_asids(void)\n{\n\tint pos;\n\n\t/* Check if there are any ASIDs to reclaim before performing a flush */\n\tpos = find_next_bit(sev_reclaim_asid_bitmap,\n\t\t\t    max_sev_asid, min_sev_asid - 1);\n\tif (pos >= max_sev_asid)\n\t\treturn false;\n\n\tif (sev_flush_asids())\n\t\treturn false;\n\n\tbitmap_xor(sev_asid_bitmap, sev_asid_bitmap, sev_reclaim_asid_bitmap,\n\t\t   max_sev_asid);\n\tbitmap_zero(sev_reclaim_asid_bitmap, max_sev_asid);\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_zero_bit",
          "args": [
            "sev_asid_bitmap",
            "max_sev_asid",
            "min_sev_asid - 1"
          ],
          "line": 5303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sev_bitmap_lock"
          ],
          "line": 5297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_MUTEX(sev_bitmap_lock);\nstatic unsigned int max_sev_asid;\nstatic unsigned int min_sev_asid;\nstatic unsigned long *sev_asid_bitmap;\n\nstatic int sev_asid_new(void)\n{\n\tbool retry = true;\n\tint pos;\n\n\tmutex_lock(&sev_bitmap_lock);\n\n\t/*\n\t * SEV-enabled guest must use asid from min_sev_asid to max_sev_asid.\n\t */\nagain:\n\tpos = find_next_zero_bit(sev_asid_bitmap, max_sev_asid, min_sev_asid - 1);\n\tif (pos >= max_sev_asid) {\n\t\tif (retry && __sev_recycle_asids()) {\n\t\t\tretry = false;\n\t\t\tgoto again;\n\t\t}\n\t\tmutex_unlock(&sev_bitmap_lock);\n\t\treturn -EBUSY;\n\t}\n\n\t__set_bit(pos, sev_asid_bitmap);\n\n\tmutex_unlock(&sev_bitmap_lock);\n\n\treturn pos + 1;\n}"
  },
  {
    "function_name": "__sev_recycle_asids",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5272-5290",
    "snippet": "static bool __sev_recycle_asids(void)\n{\n\tint pos;\n\n\t/* Check if there are any ASIDs to reclaim before performing a flush */\n\tpos = find_next_bit(sev_reclaim_asid_bitmap,\n\t\t\t    max_sev_asid, min_sev_asid - 1);\n\tif (pos >= max_sev_asid)\n\t\treturn false;\n\n\tif (sev_flush_asids())\n\t\treturn false;\n\n\tbitmap_xor(sev_asid_bitmap, sev_asid_bitmap, sev_reclaim_asid_bitmap,\n\t\t   max_sev_asid);\n\tbitmap_zero(sev_reclaim_asid_bitmap, max_sev_asid);\n\n\treturn true;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev_flush_asids(void);",
      "static unsigned int max_sev_asid;",
      "static unsigned int min_sev_asid;",
      "static unsigned long *sev_asid_bitmap;",
      "static unsigned long *sev_reclaim_asid_bitmap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "sev_reclaim_asid_bitmap",
            "max_sev_asid"
          ],
          "line": 5287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_xor",
          "args": [
            "sev_asid_bitmap",
            "sev_asid_bitmap",
            "sev_reclaim_asid_bitmap",
            "max_sev_asid"
          ],
          "line": 5285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_flush_asids",
          "args": [],
          "line": 5282
        },
        "resolved": true,
        "details": {
          "function_name": "sev_flush_asids",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5250-5269",
          "snippet": "static int sev_flush_asids(void)\n{\n\tint ret, error;\n\n\t/*\n\t * DEACTIVATE will clear the WBINVD indicator causing DF_FLUSH to fail,\n\t * so it must be guarded.\n\t */\n\tdown_write(&sev_deactivate_lock);\n\n\twbinvd_on_all_cpus();\n\tret = sev_guest_df_flush(&error);\n\n\tup_write(&sev_deactivate_lock);\n\n\tif (ret)\n\t\tpr_err(\"SEV: DF_FLUSH failed, ret=%d, error=%#x\\n\", ret, error);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev_flush_asids(void);",
            "static DECLARE_RWSEM(sev_deactivate_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev_flush_asids(void);\nstatic DECLARE_RWSEM(sev_deactivate_lock);\n\nstatic int sev_flush_asids(void)\n{\n\tint ret, error;\n\n\t/*\n\t * DEACTIVATE will clear the WBINVD indicator causing DF_FLUSH to fail,\n\t * so it must be guarded.\n\t */\n\tdown_write(&sev_deactivate_lock);\n\n\twbinvd_on_all_cpus();\n\tret = sev_guest_df_flush(&error);\n\n\tup_write(&sev_deactivate_lock);\n\n\tif (ret)\n\t\tpr_err(\"SEV: DF_FLUSH failed, ret=%d, error=%#x\\n\", ret, error);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "sev_reclaim_asid_bitmap",
            "max_sev_asid",
            "min_sev_asid - 1"
          ],
          "line": 5277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev_flush_asids(void);\nstatic unsigned int max_sev_asid;\nstatic unsigned int min_sev_asid;\nstatic unsigned long *sev_asid_bitmap;\nstatic unsigned long *sev_reclaim_asid_bitmap;\n\nstatic bool __sev_recycle_asids(void)\n{\n\tint pos;\n\n\t/* Check if there are any ASIDs to reclaim before performing a flush */\n\tpos = find_next_bit(sev_reclaim_asid_bitmap,\n\t\t\t    max_sev_asid, min_sev_asid - 1);\n\tif (pos >= max_sev_asid)\n\t\treturn false;\n\n\tif (sev_flush_asids())\n\t\treturn false;\n\n\tbitmap_xor(sev_asid_bitmap, sev_asid_bitmap, sev_reclaim_asid_bitmap,\n\t\t   max_sev_asid);\n\tbitmap_zero(sev_reclaim_asid_bitmap, max_sev_asid);\n\n\treturn true;\n}"
  },
  {
    "function_name": "sev_flush_asids",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5250-5269",
    "snippet": "static int sev_flush_asids(void)\n{\n\tint ret, error;\n\n\t/*\n\t * DEACTIVATE will clear the WBINVD indicator causing DF_FLUSH to fail,\n\t * so it must be guarded.\n\t */\n\tdown_write(&sev_deactivate_lock);\n\n\twbinvd_on_all_cpus();\n\tret = sev_guest_df_flush(&error);\n\n\tup_write(&sev_deactivate_lock);\n\n\tif (ret)\n\t\tpr_err(\"SEV: DF_FLUSH failed, ret=%d, error=%#x\\n\", ret, error);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev_flush_asids(void);",
      "static DECLARE_RWSEM(sev_deactivate_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SEV: DF_FLUSH failed, ret=%d, error=%#x\\n\"",
            "ret",
            "error"
          ],
          "line": 5266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&sev_deactivate_lock"
          ],
          "line": 5263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest_df_flush",
          "args": [
            "&error"
          ],
          "line": 5261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbinvd_on_all_cpus",
          "args": [],
          "line": 5260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&sev_deactivate_lock"
          ],
          "line": 5258
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev_flush_asids(void);\nstatic DECLARE_RWSEM(sev_deactivate_lock);\n\nstatic int sev_flush_asids(void)\n{\n\tint ret, error;\n\n\t/*\n\t * DEACTIVATE will clear the WBINVD indicator causing DF_FLUSH to fail,\n\t * so it must be guarded.\n\t */\n\tdown_write(&sev_deactivate_lock);\n\n\twbinvd_on_all_cpus();\n\tret = sev_guest_df_flush(&error);\n\n\tup_write(&sev_deactivate_lock);\n\n\tif (ret)\n\t\tpr_err(\"SEV: DF_FLUSH failed, ret=%d, error=%#x\\n\", ret, error);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "enable_smi_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5237-5248",
    "snippet": "static int enable_smi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!gif_set(svm)) {\n\t\tif (vgif_enabled(svm))\n\t\t\tset_intercept(svm, INTERCEPT_STGI);\n\t\t/* STGI will cause a vm exit */\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_intercept",
          "args": [
            "svm",
            "INTERCEPT_STGI"
          ],
          "line": 5243
        },
        "resolved": true,
        "details": {
          "function_name": "set_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "281-288",
          "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vgif_enabled",
          "args": [
            "svm"
          ],
          "line": 5242
        },
        "resolved": true,
        "details": {
          "function_name": "vgif_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "304-307",
          "snippet": "static inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 5241
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "325-331",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 5239
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int enable_smi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!gif_set(svm)) {\n\t\tif (vgif_enabled(svm))\n\t\t\tset_intercept(svm, INTERCEPT_STGI);\n\t\t/* STGI will cause a vm exit */\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_pre_leave_smm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5217-5235",
    "snippet": "static int svm_pre_leave_smm(struct kvm_vcpu *vcpu, const char *smstate)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *nested_vmcb;\n\tstruct kvm_host_map map;\n\tu64 guest;\n\tu64 vmcb;\n\n\tguest = GET_SMSTATE(u64, smstate, 0x7ed8);\n\tvmcb = GET_SMSTATE(u64, smstate, 0x7ee0);\n\n\tif (guest) {\n\t\tif (kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(vmcb), &map) == -EINVAL)\n\t\t\treturn 1;\n\t\tnested_vmcb = map.hva;\n\t\tenter_svm_guest_mode(svm, vmcb, nested_vmcb, &map);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enter_svm_guest_mode",
          "args": [
            "svm",
            "vmcb",
            "nested_vmcb",
            "&map"
          ],
          "line": 5232
        },
        "resolved": true,
        "details": {
          "function_name": "enter_svm_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "223-333",
          "snippet": "void enter_svm_guest_mode(struct vcpu_svm *svm, u64 vmcb_gpa,\n\t\t\t  struct vmcb *nested_vmcb, struct kvm_host_map *map)\n{\n\tbool evaluate_pending_interrupts =\n\t\tis_intercept(svm, INTERCEPT_VINTR) ||\n\t\tis_intercept(svm, INTERCEPT_IRET);\n\n\tif (kvm_get_rflags(&svm->vcpu) & X86_EFLAGS_IF)\n\t\tsvm->vcpu.arch.hflags |= HF_HIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_HIF_MASK;\n\n\tif (nested_vmcb->control.nested_ctl & SVM_NESTED_CTL_NP_ENABLE) {\n\t\tsvm->nested.nested_cr3 = nested_vmcb->control.nested_cr3;\n\t\tnested_svm_init_mmu_context(&svm->vcpu);\n\t}\n\n\t/* Load the nested guest state */\n\tsvm->vmcb->save.es = nested_vmcb->save.es;\n\tsvm->vmcb->save.cs = nested_vmcb->save.cs;\n\tsvm->vmcb->save.ss = nested_vmcb->save.ss;\n\tsvm->vmcb->save.ds = nested_vmcb->save.ds;\n\tsvm->vmcb->save.gdtr = nested_vmcb->save.gdtr;\n\tsvm->vmcb->save.idtr = nested_vmcb->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, nested_vmcb->save.rflags);\n\tsvm_set_efer(&svm->vcpu, nested_vmcb->save.efer);\n\tsvm_set_cr0(&svm->vcpu, nested_vmcb->save.cr0);\n\tsvm_set_cr4(&svm->vcpu, nested_vmcb->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = nested_vmcb->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = nested_vmcb->save.cr3;\n\t} else\n\t\t(void)kvm_set_cr3(&svm->vcpu, nested_vmcb->save.cr3);\n\n\t/* Guest paging mode is active - reset mmu */\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsvm->vmcb->save.cr2 = svm->vcpu.arch.cr2 = nested_vmcb->save.cr2;\n\tkvm_rax_write(&svm->vcpu, nested_vmcb->save.rax);\n\tkvm_rsp_write(&svm->vcpu, nested_vmcb->save.rsp);\n\tkvm_rip_write(&svm->vcpu, nested_vmcb->save.rip);\n\n\t/* In case we don't even reach vcpu_run, the fields are not updated */\n\tsvm->vmcb->save.rax = nested_vmcb->save.rax;\n\tsvm->vmcb->save.rsp = nested_vmcb->save.rsp;\n\tsvm->vmcb->save.rip = nested_vmcb->save.rip;\n\tsvm->vmcb->save.dr7 = nested_vmcb->save.dr7;\n\tsvm->vmcb->save.dr6 = nested_vmcb->save.dr6;\n\tsvm->vmcb->save.cpl = nested_vmcb->save.cpl;\n\n\tsvm->nested.vmcb_msrpm = nested_vmcb->control.msrpm_base_pa & ~0x0fffULL;\n\tsvm->nested.vmcb_iopm  = nested_vmcb->control.iopm_base_pa  & ~0x0fffULL;\n\n\t/* cache intercepts */\n\tsvm->nested.intercept_cr         = nested_vmcb->control.intercept_cr;\n\tsvm->nested.intercept_dr         = nested_vmcb->control.intercept_dr;\n\tsvm->nested.intercept_exceptions = nested_vmcb->control.intercept_exceptions;\n\tsvm->nested.intercept            = nested_vmcb->control.intercept;\n\n\tsvm_flush_tlb(&svm->vcpu, true);\n\tsvm->vmcb->control.int_ctl = nested_vmcb->control.int_ctl | V_INTR_MASKING_MASK;\n\tif (nested_vmcb->control.int_ctl & V_INTR_MASKING_MASK)\n\t\tsvm->vcpu.arch.hflags |= HF_VINTR_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_VINTR_MASK;\n\n\tsvm->vcpu.arch.tsc_offset += nested_vmcb->control.tsc_offset;\n\tsvm->vmcb->control.tsc_offset = svm->vcpu.arch.tsc_offset;\n\n\tsvm->vmcb->control.virt_ext = nested_vmcb->control.virt_ext;\n\tsvm->vmcb->control.int_vector = nested_vmcb->control.int_vector;\n\tsvm->vmcb->control.int_state = nested_vmcb->control.int_state;\n\tsvm->vmcb->control.event_inj = nested_vmcb->control.event_inj;\n\tsvm->vmcb->control.event_inj_err = nested_vmcb->control.event_inj_err;\n\n\tsvm->vmcb->control.pause_filter_count =\n\t\tnested_vmcb->control.pause_filter_count;\n\tsvm->vmcb->control.pause_filter_thresh =\n\t\tnested_vmcb->control.pause_filter_thresh;\n\n\tkvm_vcpu_unmap(&svm->vcpu, map, true);\n\n\t/* Enter Guest-Mode */\n\tenter_guest_mode(&svm->vcpu);\n\n\t/*\n\t * Merge guest and host intercepts - must be called  with vcpu in\n\t * guest-mode to take affect here\n\t */\n\trecalc_intercepts(svm);\n\n\tsvm->nested.vmcb = vmcb_gpa;\n\n\t/*\n\t * If L1 had a pending IRQ/NMI before executing VMRUN,\n\t * which wasn't delivered because it was disallowed (e.g.\n\t * interrupts disabled), L0 needs to evaluate if this pending\n\t * event should cause an exit from L2 to L1 or be delivered\n\t * directly to L2.\n\t *\n\t * Usually this would be handled by the processor noticing an\n\t * IRQ/NMI window request.  However, VMRUN can unblock interrupts\n\t * by implicitly setting GIF, so force L0 to perform pending event\n\t * evaluation by requesting a KVM_REQ_EVENT.\n\t */\n\tenable_gif(svm);\n\tif (unlikely(evaluate_pending_interrupts))\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tmark_all_dirty(svm->vmcb);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid enter_svm_guest_mode(struct vcpu_svm *svm, u64 vmcb_gpa,\n\t\t\t  struct vmcb *nested_vmcb, struct kvm_host_map *map)\n{\n\tbool evaluate_pending_interrupts =\n\t\tis_intercept(svm, INTERCEPT_VINTR) ||\n\t\tis_intercept(svm, INTERCEPT_IRET);\n\n\tif (kvm_get_rflags(&svm->vcpu) & X86_EFLAGS_IF)\n\t\tsvm->vcpu.arch.hflags |= HF_HIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_HIF_MASK;\n\n\tif (nested_vmcb->control.nested_ctl & SVM_NESTED_CTL_NP_ENABLE) {\n\t\tsvm->nested.nested_cr3 = nested_vmcb->control.nested_cr3;\n\t\tnested_svm_init_mmu_context(&svm->vcpu);\n\t}\n\n\t/* Load the nested guest state */\n\tsvm->vmcb->save.es = nested_vmcb->save.es;\n\tsvm->vmcb->save.cs = nested_vmcb->save.cs;\n\tsvm->vmcb->save.ss = nested_vmcb->save.ss;\n\tsvm->vmcb->save.ds = nested_vmcb->save.ds;\n\tsvm->vmcb->save.gdtr = nested_vmcb->save.gdtr;\n\tsvm->vmcb->save.idtr = nested_vmcb->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, nested_vmcb->save.rflags);\n\tsvm_set_efer(&svm->vcpu, nested_vmcb->save.efer);\n\tsvm_set_cr0(&svm->vcpu, nested_vmcb->save.cr0);\n\tsvm_set_cr4(&svm->vcpu, nested_vmcb->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = nested_vmcb->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = nested_vmcb->save.cr3;\n\t} else\n\t\t(void)kvm_set_cr3(&svm->vcpu, nested_vmcb->save.cr3);\n\n\t/* Guest paging mode is active - reset mmu */\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsvm->vmcb->save.cr2 = svm->vcpu.arch.cr2 = nested_vmcb->save.cr2;\n\tkvm_rax_write(&svm->vcpu, nested_vmcb->save.rax);\n\tkvm_rsp_write(&svm->vcpu, nested_vmcb->save.rsp);\n\tkvm_rip_write(&svm->vcpu, nested_vmcb->save.rip);\n\n\t/* In case we don't even reach vcpu_run, the fields are not updated */\n\tsvm->vmcb->save.rax = nested_vmcb->save.rax;\n\tsvm->vmcb->save.rsp = nested_vmcb->save.rsp;\n\tsvm->vmcb->save.rip = nested_vmcb->save.rip;\n\tsvm->vmcb->save.dr7 = nested_vmcb->save.dr7;\n\tsvm->vmcb->save.dr6 = nested_vmcb->save.dr6;\n\tsvm->vmcb->save.cpl = nested_vmcb->save.cpl;\n\n\tsvm->nested.vmcb_msrpm = nested_vmcb->control.msrpm_base_pa & ~0x0fffULL;\n\tsvm->nested.vmcb_iopm  = nested_vmcb->control.iopm_base_pa  & ~0x0fffULL;\n\n\t/* cache intercepts */\n\tsvm->nested.intercept_cr         = nested_vmcb->control.intercept_cr;\n\tsvm->nested.intercept_dr         = nested_vmcb->control.intercept_dr;\n\tsvm->nested.intercept_exceptions = nested_vmcb->control.intercept_exceptions;\n\tsvm->nested.intercept            = nested_vmcb->control.intercept;\n\n\tsvm_flush_tlb(&svm->vcpu, true);\n\tsvm->vmcb->control.int_ctl = nested_vmcb->control.int_ctl | V_INTR_MASKING_MASK;\n\tif (nested_vmcb->control.int_ctl & V_INTR_MASKING_MASK)\n\t\tsvm->vcpu.arch.hflags |= HF_VINTR_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_VINTR_MASK;\n\n\tsvm->vcpu.arch.tsc_offset += nested_vmcb->control.tsc_offset;\n\tsvm->vmcb->control.tsc_offset = svm->vcpu.arch.tsc_offset;\n\n\tsvm->vmcb->control.virt_ext = nested_vmcb->control.virt_ext;\n\tsvm->vmcb->control.int_vector = nested_vmcb->control.int_vector;\n\tsvm->vmcb->control.int_state = nested_vmcb->control.int_state;\n\tsvm->vmcb->control.event_inj = nested_vmcb->control.event_inj;\n\tsvm->vmcb->control.event_inj_err = nested_vmcb->control.event_inj_err;\n\n\tsvm->vmcb->control.pause_filter_count =\n\t\tnested_vmcb->control.pause_filter_count;\n\tsvm->vmcb->control.pause_filter_thresh =\n\t\tnested_vmcb->control.pause_filter_thresh;\n\n\tkvm_vcpu_unmap(&svm->vcpu, map, true);\n\n\t/* Enter Guest-Mode */\n\tenter_guest_mode(&svm->vcpu);\n\n\t/*\n\t * Merge guest and host intercepts - must be called  with vcpu in\n\t * guest-mode to take affect here\n\t */\n\trecalc_intercepts(svm);\n\n\tsvm->nested.vmcb = vmcb_gpa;\n\n\t/*\n\t * If L1 had a pending IRQ/NMI before executing VMRUN,\n\t * which wasn't delivered because it was disallowed (e.g.\n\t * interrupts disabled), L0 needs to evaluate if this pending\n\t * event should cause an exit from L2 to L1 or be delivered\n\t * directly to L2.\n\t *\n\t * Usually this would be handled by the processor noticing an\n\t * IRQ/NMI window request.  However, VMRUN can unblock interrupts\n\t * by implicitly setting GIF, so force L0 to perform pending event\n\t * evaluation by requesting a KVM_REQ_EVENT.\n\t */\n\tenable_gif(svm);\n\tif (unlikely(evaluate_pending_interrupts))\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tmark_all_dirty(svm->vmcb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_map",
          "args": [
            "&svm->vcpu",
            "gpa_to_gfn(vmcb)",
            "&map"
          ],
          "line": 5229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "vmcb"
          ],
          "line": 5229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u64",
            "smstate",
            "0x7ee0"
          ],
          "line": 5226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GET_SMSTATE",
          "args": [
            "u64",
            "smstate",
            "0x7ed8"
          ],
          "line": 5225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 5219
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_pre_leave_smm(struct kvm_vcpu *vcpu, const char *smstate)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *nested_vmcb;\n\tstruct kvm_host_map map;\n\tu64 guest;\n\tu64 vmcb;\n\n\tguest = GET_SMSTATE(u64, smstate, 0x7ed8);\n\tvmcb = GET_SMSTATE(u64, smstate, 0x7ee0);\n\n\tif (guest) {\n\t\tif (kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(vmcb), &map) == -EINVAL)\n\t\t\treturn 1;\n\t\tnested_vmcb = map.hva;\n\t\tenter_svm_guest_mode(svm, vmcb, nested_vmcb, &map);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_pre_enter_smm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5195-5215",
    "snippet": "static int svm_pre_enter_smm(struct kvm_vcpu *vcpu, char *smstate)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint ret;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/* FED8h - SVM Guest */\n\t\tput_smstate(u64, smstate, 0x7ed8, 1);\n\t\t/* FEE0h - SVM Guest VMCB Physical Address */\n\t\tput_smstate(u64, smstate, 0x7ee0, svm->nested.vmcb);\n\n\t\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\t\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\t\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t\tret = nested_svm_vmexit(svm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_vmexit",
          "args": [
            "svm"
          ],
          "line": 5210
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmexit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "438-579",
          "snippet": "int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tint rc;\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_host_map map;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\trc = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(svm->nested.vmcb), &map);\n\tif (rc) {\n\t\tif (rc == -EINVAL)\n\t\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tnested_vmcb = map.hva;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\tnested_vmcb->control.pause_filter_count =\n\t\tsvm->vmcb->control.pause_filter_count;\n\tnested_vmcb->control.pause_filter_thresh =\n\t\tsvm->vmcb->control.pause_filter_thresh;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tsvm->vcpu.arch.tsc_offset = svm->vmcb->control.tsc_offset;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_rax_write(&svm->vcpu, hsave->save.rax);\n\tkvm_rsp_write(&svm->vcpu, hsave->save.rsp);\n\tkvm_rip_write(&svm->vcpu, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\t/*\n\t * Drop what we picked up for L2 via svm_complete_interrupts() so it\n\t * doesn't end up in L1.\n\t */\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tint rc;\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_host_map map;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\trc = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(svm->nested.vmcb), &map);\n\tif (rc) {\n\t\tif (rc == -EINVAL)\n\t\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tnested_vmcb = map.hva;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\tnested_vmcb->control.pause_filter_count =\n\t\tsvm->vmcb->control.pause_filter_count;\n\tnested_vmcb->control.pause_filter_thresh =\n\t\tsvm->vmcb->control.pause_filter_thresh;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tsvm->vcpu.arch.tsc_offset = svm->vmcb->control.tsc_offset;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_rax_write(&svm->vcpu, hsave->save.rax);\n\tkvm_rsp_write(&svm->vcpu, hsave->save.rsp);\n\tkvm_rip_write(&svm->vcpu, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\t/*\n\t * Drop what we picked up for L2 via svm_complete_interrupts() so it\n\t * doesn't end up in L1.\n\t */\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "smstate",
            "0x7ee0",
            "svm->nested.vmcb"
          ],
          "line": 5204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_smstate",
          "args": [
            "u64",
            "smstate",
            "0x7ed8",
            "1"
          ],
          "line": 5202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 5200
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 5197
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_pre_enter_smm(struct kvm_vcpu *vcpu, char *smstate)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint ret;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/* FED8h - SVM Guest */\n\t\tput_smstate(u64, smstate, 0x7ed8, 1);\n\t\t/* FEE0h - SVM Guest VMCB Physical Address */\n\t\tput_smstate(u64, smstate, 0x7ee0, svm->nested.vmcb);\n\n\t\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\t\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\t\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t\tret = nested_svm_vmexit(svm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_smi_allowed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5176-5193",
    "snippet": "static int svm_smi_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/* Per APM Vol.2 15.22.2 \"Response to SMI\" */\n\tif (!gif_set(svm))\n\t\treturn 0;\n\n\tif (is_guest_mode(&svm->vcpu) &&\n\t    svm->nested.intercept & (1ULL << INTERCEPT_SMI)) {\n\t\t/* TODO: Might need to set exit_info_1 and exit_info_2 here */\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_SMI;\n\t\tsvm->nested.exit_required = true;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 5184
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 5181
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "325-331",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 5178
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_smi_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/* Per APM Vol.2 15.22.2 \"Response to SMI\" */\n\tif (!gif_set(svm))\n\t\treturn 0;\n\n\tif (is_guest_mode(&svm->vcpu) &&\n\t    svm->nested.intercept & (1ULL << INTERCEPT_SMI)) {\n\t\t/* TODO: Might need to set exit_info_1 and exit_info_2 here */\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_SMI;\n\t\tsvm->nested.exit_required = true;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "svm_setup_mce",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5170-5174",
    "snippet": "static void svm_setup_mce(struct kvm_vcpu *vcpu)\n{\n\t/* [63:9] are reserved. */\n\tvcpu->arch.mcg_cap &= 0x1ff;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_setup_mce(struct kvm_vcpu *vcpu)\n{\n\t/* [63:9] are reserved. */\n\tvcpu->arch.mcg_cap &= 0x1ff;\n}"
  },
  {
    "function_name": "avic_post_state_restore",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5162-5168",
    "snippet": "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu)\n{\n\tif (avic_handle_apic_id_update(vcpu) != 0)\n\t\treturn;\n\tavic_handle_dfr_update(vcpu);\n\tavic_handle_ldr_update(vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_handle_ldr_update",
          "args": [
            "vcpu"
          ],
          "line": 5167
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_ldr_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3567-3586",
          "snippet": "static int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret = 0;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (ldr == svm->ldr_reg)\n\t\treturn 0;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\n\tif (ldr)\n\t\tret = avic_ldr_write(vcpu, id, ldr);\n\n\tif (!ret)\n\t\tsvm->ldr_reg = ldr;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret = 0;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (ldr == svm->ldr_reg)\n\t\treturn 0;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\n\tif (ldr)\n\t\tret = avic_ldr_write(vcpu, id, ldr);\n\n\tif (!ret)\n\t\tsvm->ldr_reg = ldr;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_handle_dfr_update",
          "args": [
            "vcpu"
          ],
          "line": 5166
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_dfr_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3617-3627",
          "snippet": "static void avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\n\tif (svm->dfr_reg == dfr)\n\t\treturn;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\tsvm->dfr_reg = dfr;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\n\tif (svm->dfr_reg == dfr)\n\t\treturn;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\tsvm->dfr_reg = dfr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_handle_apic_id_update",
          "args": [
            "vcpu"
          ],
          "line": 5164
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_apic_id_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3588-3615",
          "snippet": "static int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu)\n{\n\tif (avic_handle_apic_id_update(vcpu) != 0)\n\t\treturn;\n\tavic_handle_dfr_update(vcpu);\n\tavic_handle_ldr_update(vcpu);\n}"
  },
  {
    "function_name": "svm_sched_in",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5156-5160",
    "snippet": "static void svm_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (pause_filter_thresh)\n\t\tshrink_ple_window(vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shrink_ple_window",
          "args": [
            "vcpu"
          ],
          "line": 5159
        },
        "resolved": true,
        "details": {
          "function_name": "shrink_ple_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "965-981",
          "snippet": "static void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tcontrol->pause_filter_count =\n\t\t\t\t__shrink_ple_window(old,\n\t\t\t\t\t\t    pause_filter_count,\n\t\t\t\t\t\t    pause_filter_count_shrink,\n\t\t\t\t\t\t    pause_filter_count);\n\tif (control->pause_filter_count != old) {\n\t\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;",
            "static unsigned short pause_filter_count_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nstatic unsigned short pause_filter_count_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tcontrol->pause_filter_count =\n\t\t\t\t__shrink_ple_window(old,\n\t\t\t\t\t\t    pause_filter_count,\n\t\t\t\t\t\t    pause_filter_count_shrink,\n\t\t\t\t\t\t    pause_filter_count);\n\tif (control->pause_filter_count != old) {\n\t\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_sched_in(struct kvm_vcpu *vcpu, int cpu)\n{\n\tif (pause_filter_thresh)\n\t\tshrink_ple_window(vcpu);\n}"
  },
  {
    "function_name": "svm_handle_exit_irqoff",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5147-5154",
    "snippet": "static void svm_handle_exit_irqoff(struct kvm_vcpu *vcpu,\n\tenum exit_fastpath_completion *exit_fastpath)\n{\n\tif (!is_guest_mode(vcpu) &&\n\t    to_svm(vcpu)->vmcb->control.exit_code == SVM_EXIT_MSR &&\n\t    to_svm(vcpu)->vmcb->control.exit_info_1)\n\t\t*exit_fastpath = handle_fastpath_set_msr_irqoff(vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_fastpath_set_msr_irqoff",
          "args": [
            "vcpu"
          ],
          "line": 5153
        },
        "resolved": true,
        "details": {
          "function_name": "handle_fastpath_set_msr_irqoff",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1602-1623",
          "snippet": "enum exit_fastpath_completion handle_fastpath_set_msr_irqoff(struct kvm_vcpu *vcpu)\n{\n\tu32 msr = kvm_rcx_read(vcpu);\n\tu64 data;\n\tint ret = 0;\n\n\tswitch (msr) {\n\tcase APIC_BASE_MSR + (APIC_ICR >> 4):\n\t\tdata = kvm_read_edx_eax(vcpu);\n\t\tret = handle_fastpath_set_x2apic_icr_irqoff(vcpu, data);\n\t\tbreak;\n\tdefault:\n\t\treturn EXIT_FASTPATH_NONE;\n\t}\n\n\tif (!ret) {\n\t\ttrace_kvm_msr_write(msr, data);\n\t\treturn EXIT_FASTPATH_SKIP_EMUL_INS;\n\t}\n\n\treturn EXIT_FASTPATH_NONE;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nenum exit_fastpath_completion handle_fastpath_set_msr_irqoff(struct kvm_vcpu *vcpu)\n{\n\tu32 msr = kvm_rcx_read(vcpu);\n\tu64 data;\n\tint ret = 0;\n\n\tswitch (msr) {\n\tcase APIC_BASE_MSR + (APIC_ICR >> 4):\n\t\tdata = kvm_read_edx_eax(vcpu);\n\t\tret = handle_fastpath_set_x2apic_icr_irqoff(vcpu, data);\n\t\tbreak;\n\tdefault:\n\t\treturn EXIT_FASTPATH_NONE;\n\t}\n\n\tif (!ret) {\n\t\ttrace_kvm_msr_write(msr, data);\n\t\treturn EXIT_FASTPATH_SKIP_EMUL_INS;\n\t}\n\n\treturn EXIT_FASTPATH_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 5152
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 5150
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_handle_exit_irqoff(struct kvm_vcpu *vcpu,\n\tenum exit_fastpath_completion *exit_fastpath)\n{\n\tif (!is_guest_mode(vcpu) &&\n\t    to_svm(vcpu)->vmcb->control.exit_code == SVM_EXIT_MSR &&\n\t    to_svm(vcpu)->vmcb->control.exit_info_1)\n\t\t*exit_fastpath = handle_fastpath_set_msr_irqoff(vcpu);\n}"
  },
  {
    "function_name": "svm_check_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "5025-5145",
    "snippet": "static int svm_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint vmexit, ret = X86EMUL_CONTINUE;\n\tstruct __x86_intercept icpt_info;\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (info->intercept >= ARRAY_SIZE(x86_intercept_map))\n\t\tgoto out;\n\n\ticpt_info = x86_intercept_map[info->intercept];\n\n\tif (stage != icpt_info.stage)\n\t\tgoto out;\n\n\tswitch (icpt_info.exit_code) {\n\tcase SVM_EXIT_READ_CR0:\n\t\tif (info->intercept == x86_intercept_cr_read)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_WRITE_CR0: {\n\t\tunsigned long cr0, val;\n\t\tu64 intercept;\n\n\t\tif (info->intercept == x86_intercept_cr_write)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\n\t\tif (icpt_info.exit_code != SVM_EXIT_WRITE_CR0 ||\n\t\t    info->intercept == x86_intercept_clts)\n\t\t\tbreak;\n\n\t\tintercept = svm->nested.intercept;\n\n\t\tif (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0)))\n\t\t\tbreak;\n\n\t\tcr0 = vcpu->arch.cr0 & ~SVM_CR0_SELECTIVE_MASK;\n\t\tval = info->src_val  & ~SVM_CR0_SELECTIVE_MASK;\n\n\t\tif (info->intercept == x86_intercept_lmsw) {\n\t\t\tcr0 &= 0xfUL;\n\t\t\tval &= 0xfUL;\n\t\t\t/* lmsw can't clear PE - catch this here */\n\t\t\tif (cr0 & X86_CR0_PE)\n\t\t\t\tval |= X86_CR0_PE;\n\t\t}\n\n\t\tif (cr0 ^ val)\n\t\t\ticpt_info.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0:\n\tcase SVM_EXIT_WRITE_DR0:\n\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_MSR:\n\t\tif (info->intercept == x86_intercept_wrmsr)\n\t\t\tvmcb->control.exit_info_1 = 1;\n\t\telse\n\t\t\tvmcb->control.exit_info_1 = 0;\n\t\tbreak;\n\tcase SVM_EXIT_PAUSE:\n\t\t/*\n\t\t * We get this for NOP only, but pause\n\t\t * is rep not, check this here\n\t\t */\n\t\tif (info->rep_prefix != REPE_PREFIX)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SVM_EXIT_IOIO: {\n\t\tu64 exit_info;\n\t\tu32 bytes;\n\n\t\tif (info->intercept == x86_intercept_in ||\n\t\t    info->intercept == x86_intercept_ins) {\n\t\t\texit_info = ((info->src_val & 0xffff) << 16) |\n\t\t\t\tSVM_IOIO_TYPE_MASK;\n\t\t\tbytes = info->dst_bytes;\n\t\t} else {\n\t\t\texit_info = (info->dst_val & 0xffff) << 16;\n\t\t\tbytes = info->src_bytes;\n\t\t}\n\n\t\tif (info->intercept == x86_intercept_outs ||\n\t\t    info->intercept == x86_intercept_ins)\n\t\t\texit_info |= SVM_IOIO_STR_MASK;\n\n\t\tif (info->rep_prefix)\n\t\t\texit_info |= SVM_IOIO_REP_MASK;\n\n\t\tbytes = min(bytes, 4u);\n\n\t\texit_info |= bytes << SVM_IOIO_SIZE_SHIFT;\n\n\t\texit_info |= (u32)info->ad_bytes << (SVM_IOIO_ASIZE_SHIFT - 1);\n\n\t\tvmcb->control.exit_info_1 = exit_info;\n\t\tvmcb->control.exit_info_2 = info->next_rip;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* TODO: Advertise NRIPS to guest hypervisor unconditionally */\n\tif (static_cpu_has(X86_FEATURE_NRIPS))\n\t\tvmcb->control.next_rip  = info->next_rip;\n\tvmcb->control.exit_code = icpt_info.exit_code;\n\tvmexit = nested_svm_exit_handled(svm);\n\n\tret = (vmexit == NESTED_EXIT_DONE) ? X86EMUL_INTERCEPTED\n\t\t\t\t\t   : X86EMUL_CONTINUE;\n\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
      "static const struct __x86_intercept {\n\tu32 exit_code;\n\tenum x86_intercept_stage stage;\n} x86_intercept_map[] = {\n\t[x86_intercept_cr_read]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_cr_write]\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_clts]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_lmsw]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_smsw]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_dr_read]\t\t= POST_EX(SVM_EXIT_READ_DR0),\n\t[x86_intercept_dr_write]\t= POST_EX(SVM_EXIT_WRITE_DR0),\n\t[x86_intercept_sldt]\t\t= POST_EX(SVM_EXIT_LDTR_READ),\n\t[x86_intercept_str]\t\t= POST_EX(SVM_EXIT_TR_READ),\n\t[x86_intercept_lldt]\t\t= POST_EX(SVM_EXIT_LDTR_WRITE),\n\t[x86_intercept_ltr]\t\t= POST_EX(SVM_EXIT_TR_WRITE),\n\t[x86_intercept_sgdt]\t\t= POST_EX(SVM_EXIT_GDTR_READ),\n\t[x86_intercept_sidt]\t\t= POST_EX(SVM_EXIT_IDTR_READ),\n\t[x86_intercept_lgdt]\t\t= POST_EX(SVM_EXIT_GDTR_WRITE),\n\t[x86_intercept_lidt]\t\t= POST_EX(SVM_EXIT_IDTR_WRITE),\n\t[x86_intercept_vmrun]\t\t= POST_EX(SVM_EXIT_VMRUN),\n\t[x86_intercept_vmmcall]\t\t= POST_EX(SVM_EXIT_VMMCALL),\n\t[x86_intercept_vmload]\t\t= POST_EX(SVM_EXIT_VMLOAD),\n\t[x86_intercept_vmsave]\t\t= POST_EX(SVM_EXIT_VMSAVE),\n\t[x86_intercept_stgi]\t\t= POST_EX(SVM_EXIT_STGI),\n\t[x86_intercept_clgi]\t\t= POST_EX(SVM_EXIT_CLGI),\n\t[x86_intercept_skinit]\t\t= POST_EX(SVM_EXIT_SKINIT),\n\t[x86_intercept_invlpga]\t\t= POST_EX(SVM_EXIT_INVLPGA),\n\t[x86_intercept_rdtscp]\t\t= POST_EX(SVM_EXIT_RDTSCP),\n\t[x86_intercept_monitor]\t\t= POST_MEM(SVM_EXIT_MONITOR),\n\t[x86_intercept_mwait]\t\t= POST_EX(SVM_EXIT_MWAIT),\n\t[x86_intercept_invlpg]\t\t= POST_EX(SVM_EXIT_INVLPG),\n\t[x86_intercept_invd]\t\t= POST_EX(SVM_EXIT_INVD),\n\t[x86_intercept_wbinvd]\t\t= POST_EX(SVM_EXIT_WBINVD),\n\t[x86_intercept_wrmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdtsc]\t\t= POST_EX(SVM_EXIT_RDTSC),\n\t[x86_intercept_rdmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdpmc]\t\t= POST_EX(SVM_EXIT_RDPMC),\n\t[x86_intercept_cpuid]\t\t= PRE_EX(SVM_EXIT_CPUID),\n\t[x86_intercept_rsm]\t\t= PRE_EX(SVM_EXIT_RSM),\n\t[x86_intercept_pause]\t\t= PRE_EX(SVM_EXIT_PAUSE),\n\t[x86_intercept_pushf]\t\t= PRE_EX(SVM_EXIT_PUSHF),\n\t[x86_intercept_popf]\t\t= PRE_EX(SVM_EXIT_POPF),\n\t[x86_intercept_intn]\t\t= PRE_EX(SVM_EXIT_SWINT),\n\t[x86_intercept_iret]\t\t= PRE_EX(SVM_EXIT_IRET),\n\t[x86_intercept_icebp]\t\t= PRE_EX(SVM_EXIT_ICEBP),\n\t[x86_intercept_hlt]\t\t= POST_EX(SVM_EXIT_HLT),\n\t[x86_intercept_in]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_ins]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_out]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_outs]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_xsetbv]\t\t= PRE_EX(SVM_EXIT_XSETBV),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_exit_handled",
          "args": [
            "svm"
          ],
          "line": 5138
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_exit_handled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "708-718",
          "snippet": "int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_NRIPS"
          ],
          "line": 5135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "bytes",
            "4u"
          ],
          "line": 5119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "x86_intercept_map"
          ],
          "line": 5035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 5030
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic const struct __x86_intercept {\n\tu32 exit_code;\n\tenum x86_intercept_stage stage;\n} x86_intercept_map[] = {\n\t[x86_intercept_cr_read]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_cr_write]\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_clts]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_lmsw]\t\t= POST_EX(SVM_EXIT_WRITE_CR0),\n\t[x86_intercept_smsw]\t\t= POST_EX(SVM_EXIT_READ_CR0),\n\t[x86_intercept_dr_read]\t\t= POST_EX(SVM_EXIT_READ_DR0),\n\t[x86_intercept_dr_write]\t= POST_EX(SVM_EXIT_WRITE_DR0),\n\t[x86_intercept_sldt]\t\t= POST_EX(SVM_EXIT_LDTR_READ),\n\t[x86_intercept_str]\t\t= POST_EX(SVM_EXIT_TR_READ),\n\t[x86_intercept_lldt]\t\t= POST_EX(SVM_EXIT_LDTR_WRITE),\n\t[x86_intercept_ltr]\t\t= POST_EX(SVM_EXIT_TR_WRITE),\n\t[x86_intercept_sgdt]\t\t= POST_EX(SVM_EXIT_GDTR_READ),\n\t[x86_intercept_sidt]\t\t= POST_EX(SVM_EXIT_IDTR_READ),\n\t[x86_intercept_lgdt]\t\t= POST_EX(SVM_EXIT_GDTR_WRITE),\n\t[x86_intercept_lidt]\t\t= POST_EX(SVM_EXIT_IDTR_WRITE),\n\t[x86_intercept_vmrun]\t\t= POST_EX(SVM_EXIT_VMRUN),\n\t[x86_intercept_vmmcall]\t\t= POST_EX(SVM_EXIT_VMMCALL),\n\t[x86_intercept_vmload]\t\t= POST_EX(SVM_EXIT_VMLOAD),\n\t[x86_intercept_vmsave]\t\t= POST_EX(SVM_EXIT_VMSAVE),\n\t[x86_intercept_stgi]\t\t= POST_EX(SVM_EXIT_STGI),\n\t[x86_intercept_clgi]\t\t= POST_EX(SVM_EXIT_CLGI),\n\t[x86_intercept_skinit]\t\t= POST_EX(SVM_EXIT_SKINIT),\n\t[x86_intercept_invlpga]\t\t= POST_EX(SVM_EXIT_INVLPGA),\n\t[x86_intercept_rdtscp]\t\t= POST_EX(SVM_EXIT_RDTSCP),\n\t[x86_intercept_monitor]\t\t= POST_MEM(SVM_EXIT_MONITOR),\n\t[x86_intercept_mwait]\t\t= POST_EX(SVM_EXIT_MWAIT),\n\t[x86_intercept_invlpg]\t\t= POST_EX(SVM_EXIT_INVLPG),\n\t[x86_intercept_invd]\t\t= POST_EX(SVM_EXIT_INVD),\n\t[x86_intercept_wbinvd]\t\t= POST_EX(SVM_EXIT_WBINVD),\n\t[x86_intercept_wrmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdtsc]\t\t= POST_EX(SVM_EXIT_RDTSC),\n\t[x86_intercept_rdmsr]\t\t= POST_EX(SVM_EXIT_MSR),\n\t[x86_intercept_rdpmc]\t\t= POST_EX(SVM_EXIT_RDPMC),\n\t[x86_intercept_cpuid]\t\t= PRE_EX(SVM_EXIT_CPUID),\n\t[x86_intercept_rsm]\t\t= PRE_EX(SVM_EXIT_RSM),\n\t[x86_intercept_pause]\t\t= PRE_EX(SVM_EXIT_PAUSE),\n\t[x86_intercept_pushf]\t\t= PRE_EX(SVM_EXIT_PUSHF),\n\t[x86_intercept_popf]\t\t= PRE_EX(SVM_EXIT_POPF),\n\t[x86_intercept_intn]\t\t= PRE_EX(SVM_EXIT_SWINT),\n\t[x86_intercept_iret]\t\t= PRE_EX(SVM_EXIT_IRET),\n\t[x86_intercept_icebp]\t\t= PRE_EX(SVM_EXIT_ICEBP),\n\t[x86_intercept_hlt]\t\t= POST_EX(SVM_EXIT_HLT),\n\t[x86_intercept_in]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_ins]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_out]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_outs]\t\t= POST_EX(SVM_EXIT_IOIO),\n\t[x86_intercept_xsetbv]\t\t= PRE_EX(SVM_EXIT_XSETBV),\n};\n\nstatic int svm_check_intercept(struct kvm_vcpu *vcpu,\n\t\t\t       struct x86_instruction_info *info,\n\t\t\t       enum x86_intercept_stage stage,\n\t\t\t       struct x86_exception *exception)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint vmexit, ret = X86EMUL_CONTINUE;\n\tstruct __x86_intercept icpt_info;\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (info->intercept >= ARRAY_SIZE(x86_intercept_map))\n\t\tgoto out;\n\n\ticpt_info = x86_intercept_map[info->intercept];\n\n\tif (stage != icpt_info.stage)\n\t\tgoto out;\n\n\tswitch (icpt_info.exit_code) {\n\tcase SVM_EXIT_READ_CR0:\n\t\tif (info->intercept == x86_intercept_cr_read)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_WRITE_CR0: {\n\t\tunsigned long cr0, val;\n\t\tu64 intercept;\n\n\t\tif (info->intercept == x86_intercept_cr_write)\n\t\t\ticpt_info.exit_code += info->modrm_reg;\n\n\t\tif (icpt_info.exit_code != SVM_EXIT_WRITE_CR0 ||\n\t\t    info->intercept == x86_intercept_clts)\n\t\t\tbreak;\n\n\t\tintercept = svm->nested.intercept;\n\n\t\tif (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0)))\n\t\t\tbreak;\n\n\t\tcr0 = vcpu->arch.cr0 & ~SVM_CR0_SELECTIVE_MASK;\n\t\tval = info->src_val  & ~SVM_CR0_SELECTIVE_MASK;\n\n\t\tif (info->intercept == x86_intercept_lmsw) {\n\t\t\tcr0 &= 0xfUL;\n\t\t\tval &= 0xfUL;\n\t\t\t/* lmsw can't clear PE - catch this here */\n\t\t\tif (cr0 & X86_CR0_PE)\n\t\t\t\tval |= X86_CR0_PE;\n\t\t}\n\n\t\tif (cr0 ^ val)\n\t\t\ticpt_info.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\n\t\tbreak;\n\t}\n\tcase SVM_EXIT_READ_DR0:\n\tcase SVM_EXIT_WRITE_DR0:\n\t\ticpt_info.exit_code += info->modrm_reg;\n\t\tbreak;\n\tcase SVM_EXIT_MSR:\n\t\tif (info->intercept == x86_intercept_wrmsr)\n\t\t\tvmcb->control.exit_info_1 = 1;\n\t\telse\n\t\t\tvmcb->control.exit_info_1 = 0;\n\t\tbreak;\n\tcase SVM_EXIT_PAUSE:\n\t\t/*\n\t\t * We get this for NOP only, but pause\n\t\t * is rep not, check this here\n\t\t */\n\t\tif (info->rep_prefix != REPE_PREFIX)\n\t\t\tgoto out;\n\t\tbreak;\n\tcase SVM_EXIT_IOIO: {\n\t\tu64 exit_info;\n\t\tu32 bytes;\n\n\t\tif (info->intercept == x86_intercept_in ||\n\t\t    info->intercept == x86_intercept_ins) {\n\t\t\texit_info = ((info->src_val & 0xffff) << 16) |\n\t\t\t\tSVM_IOIO_TYPE_MASK;\n\t\t\tbytes = info->dst_bytes;\n\t\t} else {\n\t\t\texit_info = (info->dst_val & 0xffff) << 16;\n\t\t\tbytes = info->src_bytes;\n\t\t}\n\n\t\tif (info->intercept == x86_intercept_outs ||\n\t\t    info->intercept == x86_intercept_ins)\n\t\t\texit_info |= SVM_IOIO_STR_MASK;\n\n\t\tif (info->rep_prefix)\n\t\t\texit_info |= SVM_IOIO_REP_MASK;\n\n\t\tbytes = min(bytes, 4u);\n\n\t\texit_info |= bytes << SVM_IOIO_SIZE_SHIFT;\n\n\t\texit_info |= (u32)info->ad_bytes << (SVM_IOIO_ASIZE_SHIFT - 1);\n\n\t\tvmcb->control.exit_info_1 = exit_info;\n\t\tvmcb->control.exit_info_2 = info->next_rip;\n\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/* TODO: Advertise NRIPS to guest hypervisor unconditionally */\n\tif (static_cpu_has(X86_FEATURE_NRIPS))\n\t\tvmcb->control.next_rip  = info->next_rip;\n\tvmcb->control.exit_code = icpt_info.exit_code;\n\tvmexit = nested_svm_exit_handled(svm);\n\n\tret = (vmexit == NESTED_EXIT_DONE) ? X86EMUL_INTERCEPTED\n\t\t\t\t\t   : X86EMUL_CONTINUE;\n\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "svm_has_wbinvd_exit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4956-4959",
    "snippet": "static bool svm_has_wbinvd_exit(void)\n{\n\treturn true;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_has_wbinvd_exit(void)\n{\n\treturn true;\n}"
  },
  {
    "function_name": "svm_cpuid_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4924-4954",
    "snippet": "static void svm_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tvcpu->arch.xsaves_enabled = guest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\t\t    boot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\t\t    boot_cpu_has(X86_FEATURE_XSAVES);\n\n\t/* Update nrips enabled cache */\n\tsvm->nrips_enabled = kvm_cpu_cap_has(X86_FEATURE_NRIPS) &&\n\t\t\t     guest_cpuid_has(&svm->vcpu, X86_FEATURE_NRIPS);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/*\n\t * AVIC does not work with an x2APIC mode guest. If the X2APIC feature\n\t * is exposed to the guest, disable AVIC.\n\t */\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_X2APIC))\n\t\tkvm_request_apicv_update(vcpu->kvm, false,\n\t\t\t\t\t APICV_INHIBIT_REASON_X2APIC);\n\n\t/*\n\t * Currently, AVIC does not work with nested virtualization.\n\t * So, we disable AVIC when cpuid for SVM is set in the L1 guest.\n\t */\n\tif (nested && guest_cpuid_has(vcpu, X86_FEATURE_SVM))\n\t\tkvm_request_apicv_update(vcpu->kvm, false,\n\t\t\t\t\t APICV_INHIBIT_REASON_NESTED);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static int nrips = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_request_apicv_update",
          "args": [
            "vcpu->kvm",
            "false",
            "APICV_INHIBIT_REASON_NESTED"
          ],
          "line": 4952
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_request_apicv_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8057-8084",
          "snippet": "void kvm_request_apicv_update(struct kvm *kvm, bool activate, ulong bit)\n{\n\tunsigned long old, new, expected;\n\n\tif (!kvm_x86_ops.check_apicv_inhibit_reasons ||\n\t    !kvm_x86_ops.check_apicv_inhibit_reasons(bit))\n\t\treturn;\n\n\told = READ_ONCE(kvm->arch.apicv_inhibit_reasons);\n\tdo {\n\t\texpected = new = old;\n\t\tif (activate)\n\t\t\t__clear_bit(bit, &new);\n\t\telse\n\t\t\t__set_bit(bit, &new);\n\t\tif (new == old)\n\t\t\tbreak;\n\t\told = cmpxchg(&kvm->arch.apicv_inhibit_reasons, expected, new);\n\t} while (old != expected);\n\n\tif (!!old == !!new)\n\t\treturn;\n\n\ttrace_kvm_apicv_update_request(activate, bit);\n\tif (kvm_x86_ops.pre_update_apicv_exec_ctrl)\n\t\tkvm_x86_ops.pre_update_apicv_exec_ctrl(kvm, activate);\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kvm_x86_ops kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops kvm_x86_ops;\n\nvoid kvm_request_apicv_update(struct kvm *kvm, bool activate, ulong bit)\n{\n\tunsigned long old, new, expected;\n\n\tif (!kvm_x86_ops.check_apicv_inhibit_reasons ||\n\t    !kvm_x86_ops.check_apicv_inhibit_reasons(bit))\n\t\treturn;\n\n\told = READ_ONCE(kvm->arch.apicv_inhibit_reasons);\n\tdo {\n\t\texpected = new = old;\n\t\tif (activate)\n\t\t\t__clear_bit(bit, &new);\n\t\telse\n\t\t\t__set_bit(bit, &new);\n\t\tif (new == old)\n\t\t\tbreak;\n\t\told = cmpxchg(&kvm->arch.apicv_inhibit_reasons, expected, new);\n\t} while (old != expected);\n\n\tif (!!old == !!new)\n\t\treturn;\n\n\ttrace_kvm_apicv_update_request(activate, bit);\n\tif (kvm_x86_ops.pre_update_apicv_exec_ctrl)\n\t\tkvm_x86_ops.pre_update_apicv_exec_ctrl(kvm, activate);\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_SVM"
          ],
          "line": 4951
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 4936
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_cap_has",
          "args": [
            "X86_FEATURE_NRIPS"
          ],
          "line": 4933
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_cap_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "295-298",
          "snippet": "static __always_inline bool kvm_cpu_cap_has(unsigned int x86_feature)\n{\n\treturn !!kvm_cpu_cap_get(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool kvm_cpu_cap_has(unsigned int x86_feature)\n{\n\treturn !!kvm_cpu_cap_get(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_XSAVES"
          ],
          "line": 4930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_XSAVE"
          ],
          "line": 4929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4926
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic int nrips = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_cpuid_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tvcpu->arch.xsaves_enabled = guest_cpuid_has(vcpu, X86_FEATURE_XSAVE) &&\n\t\t\t\t    boot_cpu_has(X86_FEATURE_XSAVE) &&\n\t\t\t\t    boot_cpu_has(X86_FEATURE_XSAVES);\n\n\t/* Update nrips enabled cache */\n\tsvm->nrips_enabled = kvm_cpu_cap_has(X86_FEATURE_NRIPS) &&\n\t\t\t     guest_cpuid_has(&svm->vcpu, X86_FEATURE_NRIPS);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/*\n\t * AVIC does not work with an x2APIC mode guest. If the X2APIC feature\n\t * is exposed to the guest, disable AVIC.\n\t */\n\tif (guest_cpuid_has(vcpu, X86_FEATURE_X2APIC))\n\t\tkvm_request_apicv_update(vcpu->kvm, false,\n\t\t\t\t\t APICV_INHIBIT_REASON_X2APIC);\n\n\t/*\n\t * Currently, AVIC does not work with nested virtualization.\n\t * So, we disable AVIC when cpuid for SVM is set in the L1 guest.\n\t */\n\tif (nested && guest_cpuid_has(vcpu, X86_FEATURE_SVM))\n\t\tkvm_request_apicv_update(vcpu->kvm, false,\n\t\t\t\t\t APICV_INHIBIT_REASON_NESTED);\n}"
  },
  {
    "function_name": "svm_get_mt_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4919-4922",
    "snippet": "static u64 svm_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_get_mt_mask(struct kvm_vcpu *vcpu, gfn_t gfn, bool is_mmio)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_has_emulated_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4906-4917",
    "snippet": "static bool svm_has_emulated_msr(int index)\n{\n\tswitch (index) {\n\tcase MSR_IA32_MCG_EXT_CTL:\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\treturn false;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_has_emulated_msr(int index)\n{\n\tswitch (index) {\n\tcase MSR_IA32_MCG_EXT_CTL:\n\tcase MSR_IA32_VMX_BASIC ... MSR_IA32_VMX_VMFUNC:\n\t\treturn false;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "svm_cpu_has_accelerated_tpr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4901-4904",
    "snippet": "static bool svm_cpu_has_accelerated_tpr(void)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool svm_cpu_has_accelerated_tpr(void)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "svm_check_processor_compat",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4896-4899",
    "snippet": "static int __init svm_check_processor_compat(void)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int __init svm_check_processor_compat(void)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_patch_hypercall",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4885-4894",
    "snippet": "static void\nsvm_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xd9;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void\nsvm_patch_hypercall(struct kvm_vcpu *vcpu, unsigned char *hypercall)\n{\n\t/*\n\t * Patch in the VMMCALL instruction:\n\t */\n\thypercall[0] = 0x0f;\n\thypercall[1] = 0x01;\n\thypercall[2] = 0xd9;\n}"
  },
  {
    "function_name": "is_disabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4874-4883",
    "snippet": "static int is_disabled(void)\n{\n\tu64 vm_cr;\n\n\trdmsrl(MSR_VM_CR, vm_cr);\n\tif (vm_cr & (1 << SVM_VM_CR_SVM_DISABLE))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_VM_CR",
            "vm_cr"
          ],
          "line": 4878
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int is_disabled(void)\n{\n\tu64 vm_cr;\n\n\trdmsrl(MSR_VM_CR, vm_cr);\n\tif (vm_cr & (1 << SVM_VM_CR_SVM_DISABLE))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_load_mmu_pgd",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4848-4872",
    "snippet": "static void svm_load_mmu_pgd(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tbool update_guest_cr3 = true;\n\tunsigned long cr3;\n\n\tcr3 = __sme_set(root);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->control.nested_cr3 = cr3;\n\t\tmark_dirty(svm->vmcb, VMCB_NPT);\n\n\t\t/* Loading L2's CR3 is handled by enter_svm_guest_mode.  */\n\t\tif (is_guest_mode(vcpu))\n\t\t\tupdate_guest_cr3 = false;\n\t\telse if (test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\t\tcr3 = vcpu->arch.cr3;\n\t\telse /* CR3 is already up-to-date.  */\n\t\t\tupdate_guest_cr3 = false;\n\t}\n\n\tif (update_guest_cr3) {\n\t\tsvm->vmcb->save.cr3 = cr3;\n\t\tmark_dirty(svm->vmcb, VMCB_CR);\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_CR"
          ],
          "line": 4870
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "VCPU_EXREG_CR3",
            "(ulong *)&vcpu->arch.regs_avail"
          ],
          "line": 4862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 4860
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "root"
          ],
          "line": 4854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4850
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_load_mmu_pgd(struct kvm_vcpu *vcpu, unsigned long root)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tbool update_guest_cr3 = true;\n\tunsigned long cr3;\n\n\tcr3 = __sme_set(root);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->control.nested_cr3 = cr3;\n\t\tmark_dirty(svm->vmcb, VMCB_NPT);\n\n\t\t/* Loading L2's CR3 is handled by enter_svm_guest_mode.  */\n\t\tif (is_guest_mode(vcpu))\n\t\t\tupdate_guest_cr3 = false;\n\t\telse if (test_bit(VCPU_EXREG_CR3, (ulong *)&vcpu->arch.regs_avail))\n\t\t\tcr3 = vcpu->arch.cr3;\n\t\telse /* CR3 is already up-to-date.  */\n\t\t\tupdate_guest_cr3 = false;\n\t}\n\n\tif (update_guest_cr3) {\n\t\tsvm->vmcb->save.cr3 = cr3;\n\t\tmark_dirty(svm->vmcb, VMCB_CR);\n\t}\n}"
  },
  {
    "function_name": "svm_vcpu_run",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4625-4845",
    "snippet": "static void svm_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t/*\n\t * A vmexit emulation is required before the vcpu can be executed\n\t * again.\n\t */\n\tif (unlikely(svm->nested.exit_required))\n\t\treturn;\n\n\t/*\n\t * Disable singlestep if we're injecting an interrupt/exception.\n\t * We don't want our modified rflags to be pushed on the stack where\n\t * we might not be able to easily reset them if we disabled NMI\n\t * singlestep later.\n\t */\n\tif (svm->nmi_singlestep && svm->vmcb->control.event_inj) {\n\t\t/*\n\t\t * Event injection happens before external interrupts cause a\n\t\t * vmexit and interrupts are disabled here, so smp_send_reschedule\n\t\t * is enough to force an immediate vmexit.\n\t\t */\n\t\tdisable_nmi_singlestep(svm);\n\t\tsmp_send_reschedule(vcpu->cpu);\n\t}\n\n\tpre_svm_run(svm);\n\n\tsync_lapic_to_cr8(vcpu);\n\n\tsvm->vmcb->save.cr2 = vcpu->arch.cr2;\n\n\tclgi();\n\tkvm_load_guest_xsave_state(vcpu);\n\n\tif (lapic_in_kernel(vcpu) &&\n\t\tvcpu->arch.apic->lapic_timer.timer_advance_ns)\n\t\tkvm_wait_lapic_expire(vcpu);\n\n\t/*\n\t * If this vCPU has touched SPEC_CTRL, restore the guest's value if\n\t * it's non-zero. Since vmentry is serialising on affected CPUs, there\n\t * is no need to worry about the conditional branch over the wrmsr\n\t * being speculatively taken.\n\t */\n\tx86_spec_ctrl_set_guest(svm->spec_ctrl, svm->virt_spec_ctrl);\n\n\tlocal_irq_enable();\n\n\tasm volatile (\n\t\t\"push %%\" _ASM_BP \"; \\n\\t\"\n\t\t\"mov %c[rbx](%[svm]), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rcx](%[svm]), %%\" _ASM_CX \" \\n\\t\"\n\t\t\"mov %c[rdx](%[svm]), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%[svm]), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%[svm]), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%[svm]), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%[svm]),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%[svm]),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%[svm]), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%[svm]), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%[svm]), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%[svm]), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%[svm]), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%[svm]), %%r15 \\n\\t\"\n#endif\n\n\t\t/* Enter guest mode */\n\t\t\"push %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[vmcb](%[svm]), %%\" _ASM_AX \" \\n\\t\"\n\t\t__ex(\"vmload %%\" _ASM_AX) \"\\n\\t\"\n\t\t__ex(\"vmrun %%\" _ASM_AX) \"\\n\\t\"\n\t\t__ex(\"vmsave %%\" _ASM_AX) \"\\n\\t\"\n\t\t\"pop %%\" _ASM_AX \" \\n\\t\"\n\n\t\t/* Save guest registers, load host registers */\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_CX \", %c[rcx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%[svm]) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%[svm]) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%[svm]) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%[svm]) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%[svm]) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%[svm]) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%[svm]) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%[svm]) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%[svm]) \\n\\t\"\n\t\t/*\n\t\t* Clear host registers marked as clobbered to prevent\n\t\t* speculative use.\n\t\t*/\n\t\t\"xor %%r8d, %%r8d \\n\\t\"\n\t\t\"xor %%r9d, %%r9d \\n\\t\"\n\t\t\"xor %%r10d, %%r10d \\n\\t\"\n\t\t\"xor %%r11d, %%r11d \\n\\t\"\n\t\t\"xor %%r12d, %%r12d \\n\\t\"\n\t\t\"xor %%r13d, %%r13d \\n\\t\"\n\t\t\"xor %%r14d, %%r14d \\n\\t\"\n\t\t\"xor %%r15d, %%r15d \\n\\t\"\n#endif\n\t\t\"xor %%ebx, %%ebx \\n\\t\"\n\t\t\"xor %%ecx, %%ecx \\n\\t\"\n\t\t\"xor %%edx, %%edx \\n\\t\"\n\t\t\"xor %%esi, %%esi \\n\\t\"\n\t\t\"xor %%edi, %%edi \\n\\t\"\n\t\t\"pop %%\" _ASM_BP\n\t\t:\n\t\t: [svm]\"a\"(svm),\n\t\t  [vmcb]\"i\"(offsetof(struct vcpu_svm, vmcb_pa)),\n\t\t  [rbx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t  [rcx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t  [rdx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t  [rsi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t  [rdi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t  [rbp]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBP]))\n#ifdef CONFIG_X86_64\n\t\t  , [r8]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t  [r9]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t  [r10]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t  [r11]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t  [r12]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t  [r13]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t  [r14]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t  [r15]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R15]))\n#endif\n\t\t: \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\" , \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"ebx\", \"ecx\", \"edx\", \"esi\", \"edi\"\n#endif\n\t\t);\n\n\t/* Eliminate branch target predictions from guest mode */\n\tvmexit_fill_RSB();\n\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_GS_BASE, svm->host.gs_base);\n#else\n\tloadsegment(fs, svm->host.fs);\n#ifndef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\n\t/*\n\t * We do not use IBRS in the kernel. If this vCPU has used the\n\t * SPEC_CTRL MSR it may have left it on; save the value and\n\t * turn it off. This is much more efficient than blindly adding\n\t * it to the atomic save/restore list. Especially as the former\n\t * (Saving guest MSRs on vmexit) doesn't even exist in KVM.\n\t *\n\t * For non-nested case:\n\t * If the L01 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t *\n\t * For nested case:\n\t * If the L02 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t */\n\tif (unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))\n\t\tsvm->spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);\n\n\treload_tss(vcpu);\n\n\tlocal_irq_disable();\n\n\tx86_spec_ctrl_restore_host(svm->spec_ctrl, svm->virt_spec_ctrl);\n\n\tvcpu->arch.cr2 = svm->vmcb->save.cr2;\n\tvcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;\n\tvcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;\n\tvcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_before_interrupt(&svm->vcpu);\n\n\tkvm_load_host_xsave_state(vcpu);\n\tstgi();\n\n\t/* Any pending NMI will happen here */\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_after_interrupt(&svm->vcpu);\n\n\tsync_cr8_to_lapic(vcpu);\n\n\tsvm->next_rip = 0;\n\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_DO_NOTHING;\n\n\t/* if exit due to PF check for async PF */\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR)\n\t\tsvm->vcpu.arch.apf.host_apf_reason = kvm_read_and_reset_pf_reason();\n\n\tif (npt_enabled) {\n\t\tvcpu->arch.regs_avail &= ~(1 << VCPU_EXREG_PDPTR);\n\t\tvcpu->arch.regs_dirty &= ~(1 << VCPU_EXREG_PDPTR);\n\t}\n\n\t/*\n\t * We need to handle MC intercepts here before the vcpu has a chance to\n\t * change the physical cpu\n\t */\n\tif (unlikely(svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR))\n\t\tsvm_handle_mce(svm);\n\n\tmark_all_clean(svm->vmcb);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_all_clean",
          "args": [
            "svm->vmcb"
          ],
          "line": 4844
        },
        "resolved": true,
        "details": {
          "function_name": "mark_all_clean",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "181-185",
          "snippet": "static inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [
            "#define VMCB_ALWAYS_DIRTY_MASK\t((1U << VMCB_INTR) | (1U << VMCB_CR2))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\n#define VMCB_ALWAYS_DIRTY_MASK\t((1U << VMCB_INTR) | (1U << VMCB_CR2))\n\nstatic inline void mark_all_clean(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = ((1 << VMCB_DIRTY_MAX) - 1)\n\t\t\t       & ~VMCB_ALWAYS_DIRTY_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_handle_mce",
          "args": [
            "svm"
          ],
          "line": 4842
        },
        "resolved": true,
        "details": {
          "function_name": "svm_handle_mce",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2576-2599",
          "snippet": "static void svm_handle_mce(struct vcpu_svm *svm)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, &svm->vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tasm volatile (\n\t\t\"int $0x12\\n\");\n\t/* not sure if we ever come back to this point */\n\n\treturn;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_handle_mce(struct vcpu_svm *svm)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, &svm->vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tasm volatile (\n\t\t\"int $0x12\\n\");\n\t/* not sure if we ever come back to this point */\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR"
          ],
          "line": 4840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_and_reset_pf_reason",
          "args": [],
          "line": 4829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sync_cr8_to_lapic",
          "args": [
            "vcpu"
          ],
          "line": 4821
        },
        "resolved": true,
        "details": {
          "function_name": "sync_cr8_to_lapic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4523-4534",
          "snippet": "static inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_after_interrupt",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4819
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_after_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "338-341",
          "snippet": "static inline void kvm_after_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_after_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "svm->vmcb->control.exit_code == SVM_EXIT_NMI"
          ],
          "line": 4818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stgi",
          "args": [],
          "line": 4814
        },
        "resolved": true,
        "details": {
          "function_name": "stgi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "393-396",
          "snippet": "static inline void stgi(void)\n{\n\tasm volatile (__ex(\"stgi\"));\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void stgi(void)\n{\n\tasm volatile (__ex(\"stgi\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_load_host_xsave_state",
          "args": [
            "vcpu"
          ],
          "line": 4813
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_load_host_xsave_state",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "842-854",
          "snippet": "void kvm_load_host_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, host_xss);\n\t}\n\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static u64 __read_mostly host_xss;",
            "u64 __read_mostly host_xcr0;",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic u64 __read_mostly host_xss;\nu64 __read_mostly host_xcr0;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_load_host_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, host_xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, host_xss);\n\t}\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_before_interrupt",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4811
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_before_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "333-336",
          "snippet": "static inline void kvm_before_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_before_interrupt(struct kvm_vcpu *vcpu)\n{\n\t__this_cpu_write(current_vcpu, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "svm->vmcb->control.exit_code == SVM_EXIT_NMI"
          ],
          "line": 4810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86_spec_ctrl_restore_host",
          "args": [
            "svm->spec_ctrl",
            "svm->virt_spec_ctrl"
          ],
          "line": 4803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 4801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reload_tss",
          "args": [
            "vcpu"
          ],
          "line": 4799
        },
        "resolved": true,
        "details": {
          "function_name": "reload_tss",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3991-3998",
          "snippet": "static void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
            "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}"
        }
      },
      {
        "call_info": {
          "callee": "native_read_msr",
          "args": [
            "MSR_IA32_SPEC_CTRL"
          ],
          "line": 4797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)"
          ],
          "line": 4796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msr_write_intercepted",
          "args": [
            "vcpu",
            "MSR_IA32_SPEC_CTRL"
          ],
          "line": 4796
        },
        "resolved": true,
        "details": {
          "function_name": "msr_write_intercepted",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "719-736",
          "snippet": "static bool msr_write_intercepted(struct kvm_vcpu *vcpu, unsigned msr)\n{\n\tu8 bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\tu32 *msrpm;\n\n\tmsrpm = is_guest_mode(vcpu) ? to_svm(vcpu)->nested.msrpm:\n\t\t\t\t      to_svm(vcpu)->msrpm;\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\treturn !!test_bit(bit_write,  &tmp);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic bool msr_write_intercepted(struct kvm_vcpu *vcpu, unsigned msr)\n{\n\tu8 bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\tu32 *msrpm;\n\n\tmsrpm = is_guest_mode(vcpu) ? to_svm(vcpu)->nested.msrpm:\n\t\t\t\t      to_svm(vcpu)->msrpm;\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\treturn !!test_bit(bit_write,  &tmp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "gs",
            "svm->host.gs"
          ],
          "line": 4777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "fs",
            "svm->host.fs"
          ],
          "line": 4775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_GS_BASE",
            "svm->host.gs_base"
          ],
          "line": 4773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmexit_fill_RSB",
          "args": [],
          "line": 4770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"i\"",
          "args": [
            "offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R8]"
          ],
          "line": 4751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"\\n\\t\"\n\t\t__ex",
          "args": [
            "\"vmsave %%\" _ASM_AX"
          ],
          "line": 4702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"\\n\\t\"\n\t\t__ex",
          "args": [
            "\"vmrun %%\" _ASM_AX"
          ],
          "line": 4701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asm volatile",
          "args": [
            "\"vmload %%\" _ASM_AX"
          ],
          "line": 4679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 4677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "x86_spec_ctrl_set_guest",
          "args": [
            "svm->spec_ctrl",
            "svm->virt_spec_ctrl"
          ],
          "line": 4675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_wait_lapic_expire",
          "args": [
            "vcpu"
          ],
          "line": 4667
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_wait_lapic_expire",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1579-1583",
          "snippet": "void kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_timer_int_injected(vcpu))\n\t\t__kvm_wait_lapic_expire(vcpu);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_wait_lapic_expire(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_timer_int_injected(vcpu))\n\t\t__kvm_wait_lapic_expire(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 4665
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_load_guest_xsave_state",
          "args": [
            "vcpu"
          ],
          "line": 4663
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_load_guest_xsave_state",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "828-839",
          "snippet": "void kvm_load_guest_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, vcpu->arch.ia32_xss);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static u64 __read_mostly host_xss;",
            "u64 __read_mostly host_xcr0;",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic u64 __read_mostly host_xss;\nu64 __read_mostly host_xcr0;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_load_guest_xsave_state(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_read_cr4_bits(vcpu, X86_CR4_OSXSAVE)) {\n\n\t\tif (vcpu->arch.xcr0 != host_xcr0)\n\t\t\txsetbv(XCR_XFEATURE_ENABLED_MASK, vcpu->arch.xcr0);\n\n\t\tif (vcpu->arch.xsaves_enabled &&\n\t\t    vcpu->arch.ia32_xss != host_xss)\n\t\t\twrmsrl(MSR_IA32_XSS, vcpu->arch.ia32_xss);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clgi",
          "args": [],
          "line": 4662
        },
        "resolved": true,
        "details": {
          "function_name": "clgi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "388-391",
          "snippet": "static inline void clgi(void)\n{\n\tasm volatile (__ex(\"clgi\"));\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void clgi(void)\n{\n\tasm volatile (__ex(\"clgi\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_lapic_to_cr8",
          "args": [
            "vcpu"
          ],
          "line": 4658
        },
        "resolved": true,
        "details": {
          "function_name": "sync_lapic_to_cr8",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4536-4548",
          "snippet": "static inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (svm_nested_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (svm_nested_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pre_svm_run",
          "args": [
            "svm"
          ],
          "line": 4656
        },
        "resolved": true,
        "details": {
          "function_name": "pre_svm_run",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4024-4036",
          "snippet": "static void pre_svm_run(struct vcpu_svm *svm)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\tif (sev_guest(svm->vcpu.kvm))\n\t\treturn pre_sev_run(svm, cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
            "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void pre_svm_run(struct vcpu_svm *svm)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\tif (sev_guest(svm->vcpu.kvm))\n\t\treturn pre_sev_run(svm, cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_send_reschedule",
          "args": [
            "vcpu->cpu"
          ],
          "line": 4653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_nmi_singlestep",
          "args": [
            "svm"
          ],
          "line": 4652
        },
        "resolved": true,
        "details": {
          "function_name": "disable_nmi_singlestep",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "843-854",
          "snippet": "void disable_nmi_singlestep(struct vcpu_svm *svm)\n{\n\tsvm->nmi_singlestep = false;\n\n\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP)) {\n\t\t/* Clear our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_RF;\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nvoid disable_nmi_singlestep(struct vcpu_svm *svm)\n{\n\tsvm->nmi_singlestep = false;\n\n\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP)) {\n\t\t/* Clear our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_RF;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "svm->nested.exit_required"
          ],
          "line": 4637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4627
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.rax = vcpu->arch.regs[VCPU_REGS_RAX];\n\tsvm->vmcb->save.rsp = vcpu->arch.regs[VCPU_REGS_RSP];\n\tsvm->vmcb->save.rip = vcpu->arch.regs[VCPU_REGS_RIP];\n\n\t/*\n\t * A vmexit emulation is required before the vcpu can be executed\n\t * again.\n\t */\n\tif (unlikely(svm->nested.exit_required))\n\t\treturn;\n\n\t/*\n\t * Disable singlestep if we're injecting an interrupt/exception.\n\t * We don't want our modified rflags to be pushed on the stack where\n\t * we might not be able to easily reset them if we disabled NMI\n\t * singlestep later.\n\t */\n\tif (svm->nmi_singlestep && svm->vmcb->control.event_inj) {\n\t\t/*\n\t\t * Event injection happens before external interrupts cause a\n\t\t * vmexit and interrupts are disabled here, so smp_send_reschedule\n\t\t * is enough to force an immediate vmexit.\n\t\t */\n\t\tdisable_nmi_singlestep(svm);\n\t\tsmp_send_reschedule(vcpu->cpu);\n\t}\n\n\tpre_svm_run(svm);\n\n\tsync_lapic_to_cr8(vcpu);\n\n\tsvm->vmcb->save.cr2 = vcpu->arch.cr2;\n\n\tclgi();\n\tkvm_load_guest_xsave_state(vcpu);\n\n\tif (lapic_in_kernel(vcpu) &&\n\t\tvcpu->arch.apic->lapic_timer.timer_advance_ns)\n\t\tkvm_wait_lapic_expire(vcpu);\n\n\t/*\n\t * If this vCPU has touched SPEC_CTRL, restore the guest's value if\n\t * it's non-zero. Since vmentry is serialising on affected CPUs, there\n\t * is no need to worry about the conditional branch over the wrmsr\n\t * being speculatively taken.\n\t */\n\tx86_spec_ctrl_set_guest(svm->spec_ctrl, svm->virt_spec_ctrl);\n\n\tlocal_irq_enable();\n\n\tasm volatile (\n\t\t\"push %%\" _ASM_BP \"; \\n\\t\"\n\t\t\"mov %c[rbx](%[svm]), %%\" _ASM_BX \" \\n\\t\"\n\t\t\"mov %c[rcx](%[svm]), %%\" _ASM_CX \" \\n\\t\"\n\t\t\"mov %c[rdx](%[svm]), %%\" _ASM_DX \" \\n\\t\"\n\t\t\"mov %c[rsi](%[svm]), %%\" _ASM_SI \" \\n\\t\"\n\t\t\"mov %c[rdi](%[svm]), %%\" _ASM_DI \" \\n\\t\"\n\t\t\"mov %c[rbp](%[svm]), %%\" _ASM_BP \" \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %c[r8](%[svm]),  %%r8  \\n\\t\"\n\t\t\"mov %c[r9](%[svm]),  %%r9  \\n\\t\"\n\t\t\"mov %c[r10](%[svm]), %%r10 \\n\\t\"\n\t\t\"mov %c[r11](%[svm]), %%r11 \\n\\t\"\n\t\t\"mov %c[r12](%[svm]), %%r12 \\n\\t\"\n\t\t\"mov %c[r13](%[svm]), %%r13 \\n\\t\"\n\t\t\"mov %c[r14](%[svm]), %%r14 \\n\\t\"\n\t\t\"mov %c[r15](%[svm]), %%r15 \\n\\t\"\n#endif\n\n\t\t/* Enter guest mode */\n\t\t\"push %%\" _ASM_AX \" \\n\\t\"\n\t\t\"mov %c[vmcb](%[svm]), %%\" _ASM_AX \" \\n\\t\"\n\t\t__ex(\"vmload %%\" _ASM_AX) \"\\n\\t\"\n\t\t__ex(\"vmrun %%\" _ASM_AX) \"\\n\\t\"\n\t\t__ex(\"vmsave %%\" _ASM_AX) \"\\n\\t\"\n\t\t\"pop %%\" _ASM_AX \" \\n\\t\"\n\n\t\t/* Save guest registers, load host registers */\n\t\t\"mov %%\" _ASM_BX \", %c[rbx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_CX \", %c[rcx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DX \", %c[rdx](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_SI \", %c[rsi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_DI \", %c[rdi](%[svm]) \\n\\t\"\n\t\t\"mov %%\" _ASM_BP \", %c[rbp](%[svm]) \\n\\t\"\n#ifdef CONFIG_X86_64\n\t\t\"mov %%r8,  %c[r8](%[svm]) \\n\\t\"\n\t\t\"mov %%r9,  %c[r9](%[svm]) \\n\\t\"\n\t\t\"mov %%r10, %c[r10](%[svm]) \\n\\t\"\n\t\t\"mov %%r11, %c[r11](%[svm]) \\n\\t\"\n\t\t\"mov %%r12, %c[r12](%[svm]) \\n\\t\"\n\t\t\"mov %%r13, %c[r13](%[svm]) \\n\\t\"\n\t\t\"mov %%r14, %c[r14](%[svm]) \\n\\t\"\n\t\t\"mov %%r15, %c[r15](%[svm]) \\n\\t\"\n\t\t/*\n\t\t* Clear host registers marked as clobbered to prevent\n\t\t* speculative use.\n\t\t*/\n\t\t\"xor %%r8d, %%r8d \\n\\t\"\n\t\t\"xor %%r9d, %%r9d \\n\\t\"\n\t\t\"xor %%r10d, %%r10d \\n\\t\"\n\t\t\"xor %%r11d, %%r11d \\n\\t\"\n\t\t\"xor %%r12d, %%r12d \\n\\t\"\n\t\t\"xor %%r13d, %%r13d \\n\\t\"\n\t\t\"xor %%r14d, %%r14d \\n\\t\"\n\t\t\"xor %%r15d, %%r15d \\n\\t\"\n#endif\n\t\t\"xor %%ebx, %%ebx \\n\\t\"\n\t\t\"xor %%ecx, %%ecx \\n\\t\"\n\t\t\"xor %%edx, %%edx \\n\\t\"\n\t\t\"xor %%esi, %%esi \\n\\t\"\n\t\t\"xor %%edi, %%edi \\n\\t\"\n\t\t\"pop %%\" _ASM_BP\n\t\t:\n\t\t: [svm]\"a\"(svm),\n\t\t  [vmcb]\"i\"(offsetof(struct vcpu_svm, vmcb_pa)),\n\t\t  [rbx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBX])),\n\t\t  [rcx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RCX])),\n\t\t  [rdx]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDX])),\n\t\t  [rsi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RSI])),\n\t\t  [rdi]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RDI])),\n\t\t  [rbp]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_RBP]))\n#ifdef CONFIG_X86_64\n\t\t  , [r8]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R8])),\n\t\t  [r9]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R9])),\n\t\t  [r10]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R10])),\n\t\t  [r11]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R11])),\n\t\t  [r12]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R12])),\n\t\t  [r13]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R13])),\n\t\t  [r14]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R14])),\n\t\t  [r15]\"i\"(offsetof(struct vcpu_svm, vcpu.arch.regs[VCPU_REGS_R15]))\n#endif\n\t\t: \"cc\", \"memory\"\n#ifdef CONFIG_X86_64\n\t\t, \"rbx\", \"rcx\", \"rdx\", \"rsi\", \"rdi\"\n\t\t, \"r8\", \"r9\", \"r10\", \"r11\" , \"r12\", \"r13\", \"r14\", \"r15\"\n#else\n\t\t, \"ebx\", \"ecx\", \"edx\", \"esi\", \"edi\"\n#endif\n\t\t);\n\n\t/* Eliminate branch target predictions from guest mode */\n\tvmexit_fill_RSB();\n\n#ifdef CONFIG_X86_64\n\twrmsrl(MSR_GS_BASE, svm->host.gs_base);\n#else\n\tloadsegment(fs, svm->host.fs);\n#ifndef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\n\t/*\n\t * We do not use IBRS in the kernel. If this vCPU has used the\n\t * SPEC_CTRL MSR it may have left it on; save the value and\n\t * turn it off. This is much more efficient than blindly adding\n\t * it to the atomic save/restore list. Especially as the former\n\t * (Saving guest MSRs on vmexit) doesn't even exist in KVM.\n\t *\n\t * For non-nested case:\n\t * If the L01 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t *\n\t * For nested case:\n\t * If the L02 MSR bitmap does not intercept the MSR, then we need to\n\t * save it.\n\t */\n\tif (unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))\n\t\tsvm->spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);\n\n\treload_tss(vcpu);\n\n\tlocal_irq_disable();\n\n\tx86_spec_ctrl_restore_host(svm->spec_ctrl, svm->virt_spec_ctrl);\n\n\tvcpu->arch.cr2 = svm->vmcb->save.cr2;\n\tvcpu->arch.regs[VCPU_REGS_RAX] = svm->vmcb->save.rax;\n\tvcpu->arch.regs[VCPU_REGS_RSP] = svm->vmcb->save.rsp;\n\tvcpu->arch.regs[VCPU_REGS_RIP] = svm->vmcb->save.rip;\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_before_interrupt(&svm->vcpu);\n\n\tkvm_load_host_xsave_state(vcpu);\n\tstgi();\n\n\t/* Any pending NMI will happen here */\n\n\tif (unlikely(svm->vmcb->control.exit_code == SVM_EXIT_NMI))\n\t\tkvm_after_interrupt(&svm->vcpu);\n\n\tsync_cr8_to_lapic(vcpu);\n\n\tsvm->next_rip = 0;\n\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_DO_NOTHING;\n\n\t/* if exit due to PF check for async PF */\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_EXCP_BASE + PF_VECTOR)\n\t\tsvm->vcpu.arch.apf.host_apf_reason = kvm_read_and_reset_pf_reason();\n\n\tif (npt_enabled) {\n\t\tvcpu->arch.regs_avail &= ~(1 << VCPU_EXREG_PDPTR);\n\t\tvcpu->arch.regs_dirty &= ~(1 << VCPU_EXREG_PDPTR);\n\t}\n\n\t/*\n\t * We need to handle MC intercepts here before the vcpu has a chance to\n\t * change the physical cpu\n\t */\n\tif (unlikely(svm->vmcb->control.exit_code ==\n\t\t     SVM_EXIT_EXCP_BASE + MC_VECTOR))\n\t\tsvm_handle_mce(svm);\n\n\tmark_all_clean(svm->vmcb);\n}"
  },
  {
    "function_name": "svm_cancel_injection",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4614-4623",
    "snippet": "static void svm_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\n\tcontrol->exit_int_info = control->event_inj;\n\tcontrol->exit_int_info_err = control->event_inj_err;\n\tcontrol->event_inj = 0;\n\tsvm_complete_interrupts(svm);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_complete_interrupts",
          "args": [
            "svm"
          ],
          "line": 4622
        },
        "resolved": true,
        "details": {
          "function_name": "svm_complete_interrupts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4550-4612",
          "snippet": "static void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4616
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_cancel_injection(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\n\tcontrol->exit_int_info = control->event_inj;\n\tcontrol->exit_int_info_err = control->event_inj_err;\n\tcontrol->event_inj = 0;\n\tsvm_complete_interrupts(svm);\n}"
  },
  {
    "function_name": "svm_complete_interrupts",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4550-4612",
    "snippet": "static void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_interrupt",
          "args": [
            "&svm->vcpu",
            "vector",
            "false"
          ],
          "line": 4607
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "56-62",
          "snippet": "static inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.injected = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_queue_interrupt(struct kvm_vcpu *vcpu, u8 vector,\n\tbool soft)\n{\n\tvcpu->arch.interrupt.injected = true;\n\tvcpu->arch.interrupt.soft = soft;\n\tvcpu->arch.interrupt.nr = vector;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_requeue_exception",
          "args": [
            "&svm->vcpu",
            "vector"
          ],
          "line": 4604
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_requeue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "569-572",
          "snippet": "void kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, true);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_requeue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_requeue_exception_e",
          "args": [
            "&svm->vcpu",
            "vector",
            "err"
          ],
          "line": 4601
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_requeue_exception_e",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "637-640",
          "snippet": "void kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, true);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_requeue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "&svm->vcpu",
            "kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected"
          ],
          "line": 4594
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "91-94",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4595
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "86-89",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_is_linear_rip",
          "args": [
            "&svm->vcpu",
            "svm->int3_rip"
          ],
          "line": 4593
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_is_linear_rip",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10215-10218",
          "snippet": "bool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\treturn kvm_get_linear_rip(vcpu) == linear_rip;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_is_linear_rip(struct kvm_vcpu *vcpu, unsigned long linear_rip)\n{\n\treturn kvm_get_linear_rip(vcpu) == linear_rip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_exception_is_soft",
          "args": [
            "vector"
          ],
          "line": 4591
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_exception_is_soft",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "75-78",
          "snippet": "static inline bool kvm_exception_is_soft(unsigned int nr)\n{\n\treturn (nr == BP_VECTOR) || (nr == OF_VECTOR);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_exception_is_soft(unsigned int nr)\n{\n\treturn (nr == BP_VECTOR) || (nr == OF_VECTOR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "&svm->vcpu"
          ],
          "line": 4576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_clear_interrupt_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4571
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_interrupt_queue",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "64-67",
          "snippet": "static inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.injected = false;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.injected = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_exception_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4570
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_exception_queue",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "50-54",
          "snippet": "static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n\tvcpu->arch.exception.injected = false;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n\tvcpu->arch.exception.injected = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "&svm->vcpu"
          ],
          "line": 4566
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "sync_lapic_to_cr8",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4536-4548",
    "snippet": "static inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (svm_nested_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_cr8",
          "args": [
            "vcpu"
          ],
          "line": 4545
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_cr8",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1041-1047",
          "snippet": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 4542
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_nested_virtualize_tpr",
          "args": [
            "vcpu"
          ],
          "line": 4541
        },
        "resolved": true,
        "details": {
          "function_name": "svm_nested_virtualize_tpr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "364-367",
          "snippet": "static inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4538
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline void sync_lapic_to_cr8(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 cr8;\n\n\tif (svm_nested_virtualize_tpr(vcpu) ||\n\t    kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tcr8 = kvm_get_cr8(vcpu);\n\tsvm->vmcb->control.int_ctl &= ~V_TPR_MASK;\n\tsvm->vmcb->control.int_ctl |= cr8 & V_TPR_MASK;\n}"
  },
  {
    "function_name": "sync_cr8_to_lapic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4523-4534",
    "snippet": "static inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_cr8",
          "args": [
            "vcpu",
            "cr8"
          ],
          "line": 4532
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr8",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1029-1038",
          "snippet": "int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR8_WRITE"
          ],
          "line": 4530
        },
        "resolved": true,
        "details": {
          "function_name": "is_cr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "223-228",
          "snippet": "static inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_nested_virtualize_tpr",
          "args": [
            "vcpu"
          ],
          "line": 4527
        },
        "resolved": true,
        "details": {
          "function_name": "svm_nested_virtualize_tpr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "364-367",
          "snippet": "static inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4525
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline void sync_cr8_to_lapic(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR8_WRITE)) {\n\t\tint cr8 = svm->vmcb->control.int_ctl & V_TPR_MASK;\n\t\tkvm_set_cr8(vcpu, cr8);\n\t}\n}"
  },
  {
    "function_name": "svm_prepare_guest_switch",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4519-4521",
    "snippet": "static void svm_prepare_guest_switch(struct kvm_vcpu *vcpu)\n{\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_prepare_guest_switch(struct kvm_vcpu *vcpu)\n{\n}"
  },
  {
    "function_name": "svm_flush_tlb_gva",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4512-4517",
    "snippet": "static void svm_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tinvlpga(gva, svm->vmcb->control.asid);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "invlpga",
          "args": [
            "gva",
            "svm->vmcb->control.asid"
          ],
          "line": 4516
        },
        "resolved": true,
        "details": {
          "function_name": "invlpga",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "398-401",
          "snippet": "static inline void invlpga(unsigned long addr, u32 asid)\n{\n\tasm volatile (__ex(\"invlpga %1, %0\") : : \"c\"(asid), \"a\"(addr));\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void invlpga(unsigned long addr, u32 asid)\n{\n\tasm volatile (__ex(\"invlpga %1, %0\") : : \"c\"(asid), \"a\"(addr));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4514
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tinvlpga(gva, svm->vmcb->control.asid);\n}"
  },
  {
    "function_name": "svm_flush_tlb",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4502-4510",
    "snippet": "void svm_flush_tlb(struct kvm_vcpu *vcpu, bool invalidate_gpa)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_FLUSHBYASID"
          ],
          "line": 4506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4504
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nvoid svm_flush_tlb(struct kvm_vcpu *vcpu, bool invalidate_gpa)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (static_cpu_has(X86_FEATURE_FLUSHBYASID))\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\telse\n\t\tsvm->asid_generation--;\n}"
  },
  {
    "function_name": "svm_set_identity_map_addr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4497-4500",
    "snippet": "static int svm_set_identity_map_addr(struct kvm *kvm, u64 ident_addr)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int svm_set_identity_map_addr(struct kvm *kvm, u64 ident_addr)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_set_tss_addr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4492-4495",
    "snippet": "static int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)\n{\n\treturn 0;\n}"
  },
  {
    "function_name": "enable_nmi_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4466-4490",
    "snippet": "static void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; /* IRET will cause a vm exit */\n\n\tif (!gif_set(svm)) {\n\t\tif (vgif_enabled(svm))\n\t\t\tset_intercept(svm, INTERCEPT_STGI);\n\t\treturn; /* STGI will cause a vm exit */\n\t}\n\n\tif (svm->nested.exit_required)\n\t\treturn; /* we're not going to run the guest yet */\n\n\t/*\n\t * Something prevents NMI from been injected. Single step over possible\n\t * problem (IRET or exception injection or interrupt shadow)\n\t */\n\tsvm->nmi_singlestep_guest_rflags = svm_get_rflags(vcpu);\n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 4487
        },
        "resolved": true,
        "details": {
          "function_name": "svm_get_rflags",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2061-2074",
          "snippet": "static unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long rflags = svm->vmcb->save.rflags;\n\n\tif (svm->nmi_singlestep) {\n\t\t/* Hide our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\trflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\trflags &= ~X86_EFLAGS_RF;\n\t}\n\treturn rflags;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long rflags = svm->vmcb->save.rflags;\n\n\tif (svm->nmi_singlestep) {\n\t\t/* Hide our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\trflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\trflags &= ~X86_EFLAGS_RF;\n\t}\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_intercept",
          "args": [
            "svm",
            "INTERCEPT_STGI"
          ],
          "line": 4476
        },
        "resolved": true,
        "details": {
          "function_name": "set_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "281-288",
          "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vgif_enabled",
          "args": [
            "svm"
          ],
          "line": 4475
        },
        "resolved": true,
        "details": {
          "function_name": "vgif_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "304-307",
          "snippet": "static inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 4474
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "325-331",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4468
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void enable_nmi_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif ((svm->vcpu.arch.hflags & (HF_NMI_MASK | HF_IRET_MASK))\n\t    == HF_NMI_MASK)\n\t\treturn; /* IRET will cause a vm exit */\n\n\tif (!gif_set(svm)) {\n\t\tif (vgif_enabled(svm))\n\t\t\tset_intercept(svm, INTERCEPT_STGI);\n\t\treturn; /* STGI will cause a vm exit */\n\t}\n\n\tif (svm->nested.exit_required)\n\t\treturn; /* we're not going to run the guest yet */\n\n\t/*\n\t * Something prevents NMI from been injected. Single step over possible\n\t * problem (IRET or exception injection or interrupt shadow)\n\t */\n\tsvm->nmi_singlestep_guest_rflags = svm_get_rflags(vcpu);\n\tsvm->nmi_singlestep = true;\n\tsvm->vmcb->save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n}"
  },
  {
    "function_name": "enable_irq_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4442-4464",
    "snippet": "static void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * In case GIF=0 we can't rely on the CPU to tell us when GIF becomes\n\t * 1, because that's a separate STGI/VMRUN intercept.  The next time we\n\t * get that intercept, this function will be called again though and\n\t * we'll get the vintr intercept. However, if the vGIF feature is\n\t * enabled, the STGI interception will not occur. Enable the irq\n\t * window under the assumption that the hardware will set the GIF.\n\t */\n\tif (vgif_enabled(svm) || gif_set(svm)) {\n\t\t/*\n\t\t * IRQ window is not needed when AVIC is enabled,\n\t\t * unless we have pending ExtINT since it cannot be injected\n\t\t * via AVIC. In such case, we need to temporarily disable AVIC,\n\t\t * and fallback to injecting IRQ via V_IRQ.\n\t\t */\n\t\tsvm_toggle_avic_for_irq_window(vcpu, false);\n\t\tsvm_set_vintr(svm);\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_set_vintr",
          "args": [
            "svm"
          ],
          "line": 4462
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_vintr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2120-2125",
          "snippet": "static void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tset_intercept(svm, INTERCEPT_VINTR);\n\tif (is_intercept(svm, INTERCEPT_VINTR))\n\t\tsvm_enable_vintr(svm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tset_intercept(svm, INTERCEPT_VINTR);\n\tif (is_intercept(svm, INTERCEPT_VINTR))\n\t\tsvm_enable_vintr(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_toggle_avic_for_irq_window",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 4461
        },
        "resolved": true,
        "details": {
          "function_name": "svm_toggle_avic_for_irq_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4090-4099",
          "snippet": "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate)\n{\n\tif (!avic || !lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tkvm_request_apicv_update(vcpu->kvm, activate,\n\t\t\t\t APICV_INHIBIT_REASON_IRQWIN);\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int avic;",
            "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate)\n{\n\tif (!avic || !lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tkvm_request_apicv_update(vcpu->kvm, activate,\n\t\t\t\t APICV_INHIBIT_REASON_IRQWIN);\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "325-331",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vgif_enabled",
          "args": [
            "svm"
          ],
          "line": 4454
        },
        "resolved": true,
        "details": {
          "function_name": "vgif_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "304-307",
          "snippet": "static inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4444
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void enable_irq_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * In case GIF=0 we can't rely on the CPU to tell us when GIF becomes\n\t * 1, because that's a separate STGI/VMRUN intercept.  The next time we\n\t * get that intercept, this function will be called again though and\n\t * we'll get the vintr intercept. However, if the vGIF feature is\n\t * enabled, the STGI interception will not occur. Enable the irq\n\t * window under the assumption that the hardware will set the GIF.\n\t */\n\tif (vgif_enabled(svm) || gif_set(svm)) {\n\t\t/*\n\t\t * IRQ window is not needed when AVIC is enabled,\n\t\t * unless we have pending ExtINT since it cannot be injected\n\t\t * via AVIC. In such case, we need to temporarily disable AVIC,\n\t\t * and fallback to injecting IRQ via V_IRQ.\n\t\t */\n\t\tsvm_toggle_avic_for_irq_window(vcpu, false);\n\t\tsvm_set_vintr(svm);\n\t}\n}"
  },
  {
    "function_name": "svm_interrupt_allowed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4427-4440",
    "snippet": "static int svm_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (!gif_set(svm) ||\n\t     (vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK))\n\t\treturn 0;\n\n\tif (is_guest_mode(vcpu) && (svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\treturn !!(svm->vcpu.arch.hflags & HF_HIF_MASK);\n\telse\n\t\treturn !!(kvm_get_rflags(vcpu) & X86_EFLAGS_IF);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_rflags",
          "args": [
            "vcpu"
          ],
          "line": 4439
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_rflags",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10221-10229",
          "snippet": "unsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops.get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags;\n\n\trflags = kvm_x86_ops.get_rflags(vcpu);\n\tif (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)\n\t\trflags &= ~X86_EFLAGS_TF;\n\treturn rflags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 4436
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 4432
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "325-331",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4429
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_interrupt_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\n\tif (!gif_set(svm) ||\n\t     (vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK))\n\t\treturn 0;\n\n\tif (is_guest_mode(vcpu) && (svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\treturn !!(svm->vcpu.arch.hflags & HF_HIF_MASK);\n\telse\n\t\treturn !!(kvm_get_rflags(vcpu) & X86_EFLAGS_IF);\n}"
  },
  {
    "function_name": "svm_set_nmi_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4414-4425",
    "snippet": "static void svm_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (masked) {\n\t\tsvm->vcpu.arch.hflags |= HF_NMI_MASK;\n\t\tset_intercept(svm, INTERCEPT_IRET);\n\t} else {\n\t\tsvm->vcpu.arch.hflags &= ~HF_NMI_MASK;\n\t\tclr_intercept(svm, INTERCEPT_IRET);\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clr_intercept",
          "args": [
            "svm",
            "INTERCEPT_IRET"
          ],
          "line": 4423
        },
        "resolved": true,
        "details": {
          "function_name": "clr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "290-297",
          "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_intercept",
          "args": [
            "svm",
            "INTERCEPT_IRET"
          ],
          "line": 4420
        },
        "resolved": true,
        "details": {
          "function_name": "set_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "281-288",
          "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4416
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_nmi_mask(struct kvm_vcpu *vcpu, bool masked)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (masked) {\n\t\tsvm->vcpu.arch.hflags |= HF_NMI_MASK;\n\t\tset_intercept(svm, INTERCEPT_IRET);\n\t} else {\n\t\tsvm->vcpu.arch.hflags &= ~HF_NMI_MASK;\n\t\tclr_intercept(svm, INTERCEPT_IRET);\n\t}\n}"
  },
  {
    "function_name": "svm_get_nmi_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4407-4412",
    "snippet": "static bool svm_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn !!(svm->vcpu.arch.hflags & HF_NMI_MASK);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4409
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic bool svm_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\treturn !!(svm->vcpu.arch.hflags & HF_NMI_MASK);\n}"
  },
  {
    "function_name": "svm_nmi_allowed",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4395-4405",
    "snippet": "static int svm_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tint ret;\n\tret = !(vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) &&\n\t      !(svm->vcpu.arch.hflags & HF_NMI_MASK);\n\tret = ret && gif_set(svm) && nested_svm_nmi(svm);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_nmi",
          "args": [
            "svm"
          ],
          "line": 4402
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_nmi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "350-362",
          "snippet": "static inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool nested_svm_nmi(struct vcpu_svm *svm)\n{\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn true;\n\n\tif (!(svm->nested.intercept & (1ULL << INTERCEPT_NMI)))\n\t\treturn true;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_NMI;\n\tsvm->nested.exit_required = true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 4402
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "325-331",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4397
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_nmi_allowed(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tint ret;\n\tret = !(vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK) &&\n\t      !(svm->vcpu.arch.hflags & HF_NMI_MASK);\n\tret = ret && gif_set(svm) && nested_svm_nmi(svm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "svm_update_pi_irte",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4295-4393",
    "snippet": "static int svm_update_pi_irte(struct kvm *kvm, unsigned int host_irq,\n\t\t\t      uint32_t guest_irq, bool set)\n{\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tstruct kvm_irq_routing_table *irq_rt;\n\tint idx, ret = -EINVAL;\n\n\tif (!kvm_arch_has_assigned_device(kvm) ||\n\t    !irq_remapping_cap(IRQ_POSTING_CAP))\n\t\treturn 0;\n\n\tpr_debug(\"SVM: %s: host_irq=%#x, guest_irq=%#x, set=%#x\\n\",\n\t\t __func__, host_irq, guest_irq, set);\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tWARN_ON(guest_irq >= irq_rt->nr_rt_entries);\n\n\thlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {\n\t\tstruct vcpu_data vcpu_info;\n\t\tstruct vcpu_svm *svm = NULL;\n\n\t\tif (e->type != KVM_IRQ_ROUTING_MSI)\n\t\t\tcontinue;\n\n\t\t/**\n\t\t * Here, we setup with legacy mode in the following cases:\n\t\t * 1. When cannot target interrupt to a specific vcpu.\n\t\t * 2. Unsetting posted interrupt.\n\t\t * 3. APIC virtialization is disabled for the vcpu.\n\t\t * 4. IRQ has incompatible delivery mode (SMI, INIT, etc)\n\t\t */\n\t\tif (!get_pi_vcpu_info(kvm, e, &vcpu_info, &svm) && set &&\n\t\t    kvm_vcpu_apicv_active(&svm->vcpu)) {\n\t\t\tstruct amd_iommu_pi_data pi;\n\n\t\t\t/* Try to enable guest_mode in IRTE */\n\t\t\tpi.base = __sme_set(page_to_phys(svm->avic_backing_page) &\n\t\t\t\t\t    AVIC_HPA_MASK);\n\t\t\tpi.ga_tag = AVIC_GATAG(to_kvm_svm(kvm)->avic_vm_id,\n\t\t\t\t\t\t     svm->vcpu.vcpu_id);\n\t\t\tpi.is_guest_mode = true;\n\t\t\tpi.vcpu_data = &vcpu_info;\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &pi);\n\n\t\t\t/**\n\t\t\t * Here, we successfully setting up vcpu affinity in\n\t\t\t * IOMMU guest mode. Now, we need to store the posted\n\t\t\t * interrupt information in a per-vcpu ir_list so that\n\t\t\t * we can reference to them directly when we update vcpu\n\t\t\t * scheduling information in IOMMU irte.\n\t\t\t */\n\t\t\tif (!ret && pi.is_guest_mode)\n\t\t\t\tsvm_ir_list_add(svm, &pi);\n\t\t} else {\n\t\t\t/* Use legacy mode in IRTE */\n\t\t\tstruct amd_iommu_pi_data pi;\n\n\t\t\t/**\n\t\t\t * Here, pi is used to:\n\t\t\t * - Tell IOMMU to use legacy mode for this interrupt.\n\t\t\t * - Retrieve ga_tag of prior interrupt remapping data.\n\t\t\t */\n\t\t\tpi.is_guest_mode = false;\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &pi);\n\n\t\t\t/**\n\t\t\t * Check if the posted interrupt was previously\n\t\t\t * setup with the guest_mode by checking if the ga_tag\n\t\t\t * was cached. If so, we need to clean up the per-vcpu\n\t\t\t * ir_list.\n\t\t\t */\n\t\t\tif (!ret && pi.prev_ga_tag) {\n\t\t\t\tint id = AVIC_GATAG_TO_VCPUID(pi.prev_ga_tag);\n\t\t\t\tstruct kvm_vcpu *vcpu;\n\n\t\t\t\tvcpu = kvm_get_vcpu_by_id(kvm, id);\n\t\t\t\tif (vcpu)\n\t\t\t\t\tsvm_ir_list_del(to_svm(vcpu), &pi);\n\t\t\t}\n\t\t}\n\n\t\tif (!ret && svm) {\n\t\t\ttrace_kvm_pi_irte_update(host_irq, svm->vcpu.vcpu_id,\n\t\t\t\t\t\t e->gsi, vcpu_info.vector,\n\t\t\t\t\t\t vcpu_info.pi_desc_addr, set);\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: failed to update PI IRTE\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_HPA_MASK\t~((0xFFFULL << 52) | 0xFFF)"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&kvm->irq_srcu",
            "idx"
          ],
          "line": 4391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: failed to update PI IRTE\\n\"",
            "__func__"
          ],
          "line": 4384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_pi_irte_update",
          "args": [
            "host_irq",
            "svm->vcpu.vcpu_id",
            "e->gsi",
            "vcpu_info.vector",
            "vcpu_info.pi_desc_addr",
            "set"
          ],
          "line": 4378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_ir_list_del",
          "args": [
            "to_svm(vcpu)",
            "&pi"
          ],
          "line": 4373
        },
        "resolved": true,
        "details": {
          "function_name": "svm_ir_list_del",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4190-4204",
          "snippet": "static void svm_ir_list_del(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *cur;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_for_each_entry(cur, &svm->ir_list, node) {\n\t\tif (cur->data != pi->ir_data)\n\t\t\tcontinue;\n\t\tlist_del(&cur->node);\n\t\tkfree(cur);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_ir_list_del(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *cur;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_for_each_entry(cur, &svm->ir_list, node) {\n\t\tif (cur->data != pi->ir_data)\n\t\t\tcontinue;\n\t\tlist_del(&cur->node);\n\t\tkfree(cur);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4373
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_vcpu_by_id",
          "args": [
            "kvm",
            "id"
          ],
          "line": 4371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AVIC_GATAG_TO_VCPUID",
          "args": [
            "pi.prev_ga_tag"
          ],
          "line": 4368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_vcpu_affinity",
          "args": [
            "host_irq",
            "&pi"
          ],
          "line": 4359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_ir_list_add",
          "args": [
            "svm",
            "&pi"
          ],
          "line": 4348
        },
        "resolved": true,
        "details": {
          "function_name": "svm_ir_list_add",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4206-4248",
          "snippet": "static int svm_ir_list_add(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\n\t/**\n\t * In some cases, the existing irte is updaed and re-set,\n\t * so we need to check here if it's already been * added\n\t * to the ir_list.\n\t */\n\tif (pi->ir_data && (pi->prev_ga_tag != 0)) {\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tu32 vcpu_id = AVIC_GATAG_TO_VCPUID(pi->prev_ga_tag);\n\t\tstruct kvm_vcpu *prev_vcpu = kvm_get_vcpu_by_id(kvm, vcpu_id);\n\t\tstruct vcpu_svm *prev_svm;\n\n\t\tif (!prev_vcpu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprev_svm = to_svm(prev_vcpu);\n\t\tsvm_ir_list_del(prev_svm, pi);\n\t}\n\n\t/**\n\t * Allocating new amd_iommu_pi_data, which will get\n\t * add to the per-vcpu ir_list.\n\t */\n\tir = kzalloc(sizeof(struct amd_svm_iommu_ir), GFP_KERNEL_ACCOUNT);\n\tif (!ir) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tir->data = pi->ir_data;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_add(&ir->node, &svm->ir_list);\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_ir_list_add(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\n\t/**\n\t * In some cases, the existing irte is updaed and re-set,\n\t * so we need to check here if it's already been * added\n\t * to the ir_list.\n\t */\n\tif (pi->ir_data && (pi->prev_ga_tag != 0)) {\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tu32 vcpu_id = AVIC_GATAG_TO_VCPUID(pi->prev_ga_tag);\n\t\tstruct kvm_vcpu *prev_vcpu = kvm_get_vcpu_by_id(kvm, vcpu_id);\n\t\tstruct vcpu_svm *prev_svm;\n\n\t\tif (!prev_vcpu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprev_svm = to_svm(prev_vcpu);\n\t\tsvm_ir_list_del(prev_svm, pi);\n\t}\n\n\t/**\n\t * Allocating new amd_iommu_pi_data, which will get\n\t * add to the per-vcpu ir_list.\n\t */\n\tir = kzalloc(sizeof(struct amd_svm_iommu_ir), GFP_KERNEL_ACCOUNT);\n\tif (!ir) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tir->data = pi->ir_data;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_add(&ir->node, &svm->ir_list);\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_vcpu_affinity",
          "args": [
            "host_irq",
            "&pi"
          ],
          "line": 4338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AVIC_GATAG",
          "args": [
            "to_kvm_svm(kvm)->avic_vm_id",
            "svm->vcpu.vcpu_id"
          ],
          "line": 4334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 4334
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "page_to_phys(svm->avic_backing_page) &\n\t\t\t\t\t    AVIC_HPA_MASK"
          ],
          "line": 4332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "svm->avic_backing_page"
          ],
          "line": 4332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "&svm->vcpu"
          ],
          "line": 4328
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pi_vcpu_info",
          "args": [
            "kvm",
            "e",
            "&vcpu_info",
            "&svm"
          ],
          "line": 4327
        },
        "resolved": true,
        "details": {
          "function_name": "get_pi_vcpu_info",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4261-4284",
          "snippet": "static int\nget_pi_vcpu_info(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t struct vcpu_data *vcpu_info, struct vcpu_svm **svm)\n{\n\tstruct kvm_lapic_irq irq;\n\tstruct kvm_vcpu *vcpu = NULL;\n\n\tkvm_set_msi_irq(kvm, e, &irq);\n\n\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu) ||\n\t    !kvm_irq_is_postable(&irq)) {\n\t\tpr_debug(\"SVM: %s: use legacy intr remap mode for irq %u\\n\",\n\t\t\t __func__, irq.vector);\n\t\treturn -1;\n\t}\n\n\tpr_debug(\"SVM: %s: use GA mode for irq %u\\n\", __func__,\n\t\t irq.vector);\n\t*svm = to_svm(vcpu);\n\tvcpu_info->pi_desc_addr = __sme_set(page_to_phys((*svm)->avic_backing_page));\n\tvcpu_info->vector = irq.vector;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int\nget_pi_vcpu_info(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t struct vcpu_data *vcpu_info, struct vcpu_svm **svm)\n{\n\tstruct kvm_lapic_irq irq;\n\tstruct kvm_vcpu *vcpu = NULL;\n\n\tkvm_set_msi_irq(kvm, e, &irq);\n\n\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu) ||\n\t    !kvm_irq_is_postable(&irq)) {\n\t\tpr_debug(\"SVM: %s: use legacy intr remap mode for irq %u\\n\",\n\t\t\t __func__, irq.vector);\n\t\treturn -1;\n\t}\n\n\tpr_debug(\"SVM: %s: use GA mode for irq %u\\n\", __func__,\n\t\t irq.vector);\n\t*svm = to_svm(vcpu);\n\tvcpu_info->pi_desc_addr = __sme_set(page_to_phys((*svm)->avic_backing_page));\n\tvcpu_info->vector = irq.vector;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "e",
            "&irq_rt->map[guest_irq]",
            "link"
          ],
          "line": 4313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "guest_irq >= irq_rt->nr_rt_entries"
          ],
          "line": 4311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_dereference",
          "args": [
            "kvm->irq_routing",
            "&kvm->irq_srcu"
          ],
          "line": 4310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&kvm->irq_srcu"
          ],
          "line": 4309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"SVM: %s: host_irq=%#x, guest_irq=%#x, set=%#x\\n\"",
            "__func__",
            "host_irq",
            "guest_irq",
            "set"
          ],
          "line": 4306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_remapping_cap",
          "args": [
            "IRQ_POSTING_CAP"
          ],
          "line": 4303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_has_assigned_device",
          "args": [
            "kvm"
          ],
          "line": 4302
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_has_assigned_device",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10460-10463",
          "snippet": "bool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_HPA_MASK\t~((0xFFFULL << 52) | 0xFFF)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_update_pi_irte(struct kvm *kvm, unsigned int host_irq,\n\t\t\t      uint32_t guest_irq, bool set)\n{\n\tstruct kvm_kernel_irq_routing_entry *e;\n\tstruct kvm_irq_routing_table *irq_rt;\n\tint idx, ret = -EINVAL;\n\n\tif (!kvm_arch_has_assigned_device(kvm) ||\n\t    !irq_remapping_cap(IRQ_POSTING_CAP))\n\t\treturn 0;\n\n\tpr_debug(\"SVM: %s: host_irq=%#x, guest_irq=%#x, set=%#x\\n\",\n\t\t __func__, host_irq, guest_irq, set);\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tirq_rt = srcu_dereference(kvm->irq_routing, &kvm->irq_srcu);\n\tWARN_ON(guest_irq >= irq_rt->nr_rt_entries);\n\n\thlist_for_each_entry(e, &irq_rt->map[guest_irq], link) {\n\t\tstruct vcpu_data vcpu_info;\n\t\tstruct vcpu_svm *svm = NULL;\n\n\t\tif (e->type != KVM_IRQ_ROUTING_MSI)\n\t\t\tcontinue;\n\n\t\t/**\n\t\t * Here, we setup with legacy mode in the following cases:\n\t\t * 1. When cannot target interrupt to a specific vcpu.\n\t\t * 2. Unsetting posted interrupt.\n\t\t * 3. APIC virtialization is disabled for the vcpu.\n\t\t * 4. IRQ has incompatible delivery mode (SMI, INIT, etc)\n\t\t */\n\t\tif (!get_pi_vcpu_info(kvm, e, &vcpu_info, &svm) && set &&\n\t\t    kvm_vcpu_apicv_active(&svm->vcpu)) {\n\t\t\tstruct amd_iommu_pi_data pi;\n\n\t\t\t/* Try to enable guest_mode in IRTE */\n\t\t\tpi.base = __sme_set(page_to_phys(svm->avic_backing_page) &\n\t\t\t\t\t    AVIC_HPA_MASK);\n\t\t\tpi.ga_tag = AVIC_GATAG(to_kvm_svm(kvm)->avic_vm_id,\n\t\t\t\t\t\t     svm->vcpu.vcpu_id);\n\t\t\tpi.is_guest_mode = true;\n\t\t\tpi.vcpu_data = &vcpu_info;\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &pi);\n\n\t\t\t/**\n\t\t\t * Here, we successfully setting up vcpu affinity in\n\t\t\t * IOMMU guest mode. Now, we need to store the posted\n\t\t\t * interrupt information in a per-vcpu ir_list so that\n\t\t\t * we can reference to them directly when we update vcpu\n\t\t\t * scheduling information in IOMMU irte.\n\t\t\t */\n\t\t\tif (!ret && pi.is_guest_mode)\n\t\t\t\tsvm_ir_list_add(svm, &pi);\n\t\t} else {\n\t\t\t/* Use legacy mode in IRTE */\n\t\t\tstruct amd_iommu_pi_data pi;\n\n\t\t\t/**\n\t\t\t * Here, pi is used to:\n\t\t\t * - Tell IOMMU to use legacy mode for this interrupt.\n\t\t\t * - Retrieve ga_tag of prior interrupt remapping data.\n\t\t\t */\n\t\t\tpi.is_guest_mode = false;\n\t\t\tret = irq_set_vcpu_affinity(host_irq, &pi);\n\n\t\t\t/**\n\t\t\t * Check if the posted interrupt was previously\n\t\t\t * setup with the guest_mode by checking if the ga_tag\n\t\t\t * was cached. If so, we need to clean up the per-vcpu\n\t\t\t * ir_list.\n\t\t\t */\n\t\t\tif (!ret && pi.prev_ga_tag) {\n\t\t\t\tint id = AVIC_GATAG_TO_VCPUID(pi.prev_ga_tag);\n\t\t\t\tstruct kvm_vcpu *vcpu;\n\n\t\t\t\tvcpu = kvm_get_vcpu_by_id(kvm, id);\n\t\t\t\tif (vcpu)\n\t\t\t\t\tsvm_ir_list_del(to_svm(vcpu), &pi);\n\t\t\t}\n\t\t}\n\n\t\tif (!ret && svm) {\n\t\t\ttrace_kvm_pi_irte_update(host_irq, svm->vcpu.vcpu_id,\n\t\t\t\t\t\t e->gsi, vcpu_info.vector,\n\t\t\t\t\t\t vcpu_info.pi_desc_addr, set);\n\t\t}\n\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"%s: failed to update PI IRTE\\n\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = 0;\nout:\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n\treturn ret;\n}"
  },
  {
    "function_name": "get_pi_vcpu_info",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4261-4284",
    "snippet": "static int\nget_pi_vcpu_info(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t struct vcpu_data *vcpu_info, struct vcpu_svm **svm)\n{\n\tstruct kvm_lapic_irq irq;\n\tstruct kvm_vcpu *vcpu = NULL;\n\n\tkvm_set_msi_irq(kvm, e, &irq);\n\n\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu) ||\n\t    !kvm_irq_is_postable(&irq)) {\n\t\tpr_debug(\"SVM: %s: use legacy intr remap mode for irq %u\\n\",\n\t\t\t __func__, irq.vector);\n\t\treturn -1;\n\t}\n\n\tpr_debug(\"SVM: %s: use GA mode for irq %u\\n\", __func__,\n\t\t irq.vector);\n\t*svm = to_svm(vcpu);\n\tvcpu_info->pi_desc_addr = __sme_set(page_to_phys((*svm)->avic_backing_page));\n\tvcpu_info->vector = irq.vector;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "page_to_phys((*svm)->avic_backing_page)"
          ],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "(*svm)->avic_backing_page"
          ],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4279
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"SVM: %s: use GA mode for irq %u\\n\"",
            "__func__",
            "irq.vector"
          ],
          "line": 4277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"SVM: %s: use legacy intr remap mode for irq %u\\n\"",
            "__func__",
            "irq.vector"
          ],
          "line": 4272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_irq_is_postable",
          "args": [
            "&irq"
          ],
          "line": 4271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_intr_is_single_vcpu",
          "args": [
            "kvm",
            "&irq",
            "&vcpu"
          ],
          "line": 4270
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_intr_is_single_vcpu_fast",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "997-1023",
          "snippet": "bool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tbool ret = false;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (kvm_apic_map_get_dest_lapic(kvm, NULL, irq, map, &dst, &bitmap) &&\n\t\t\thweight16(bitmap) == 1) {\n\t\tunsigned long i = find_first_bit(&bitmap, 16);\n\n\t\tif (dst[i]) {\n\t\t\t*dest_vcpu = dst[i]->vcpu;\n\t\t\tret = true;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nbool kvm_intr_is_single_vcpu_fast(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\tstruct kvm_vcpu **dest_vcpu)\n{\n\tstruct kvm_apic_map *map;\n\tunsigned long bitmap;\n\tstruct kvm_lapic **dst = NULL;\n\tbool ret = false;\n\n\tif (irq->shorthand)\n\t\treturn false;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tif (kvm_apic_map_get_dest_lapic(kvm, NULL, irq, map, &dst, &bitmap) &&\n\t\t\thweight16(bitmap) == 1) {\n\t\tunsigned long i = find_first_bit(&bitmap, 16);\n\n\t\tif (dst[i]) {\n\t\t\t*dest_vcpu = dst[i]->vcpu;\n\t\t\tret = true;\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_msi_irq",
          "args": [
            "kvm",
            "e",
            "&irq"
          ],
          "line": 4268
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msi_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "104-125",
          "snippet": "void kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_set_msi_irq(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t     struct kvm_lapic_irq *irq)\n{\n\ttrace_kvm_msi_set_irq(e->msi.address_lo | (kvm->arch.x2apic_format ?\n\t                                     (u64)e->msi.address_hi << 32 : 0),\n\t                      e->msi.data);\n\n\tirq->dest_id = (e->msi.address_lo &\n\t\t\tMSI_ADDR_DEST_ID_MASK) >> MSI_ADDR_DEST_ID_SHIFT;\n\tif (kvm->arch.x2apic_format)\n\t\tirq->dest_id |= MSI_ADDR_EXT_DEST_ID(e->msi.address_hi);\n\tirq->vector = (e->msi.data &\n\t\t\tMSI_DATA_VECTOR_MASK) >> MSI_DATA_VECTOR_SHIFT;\n\tirq->dest_mode = kvm_lapic_irq_dest_mode(\n\t    !!((1 << MSI_ADDR_DEST_MODE_SHIFT) & e->msi.address_lo));\n\tirq->trig_mode = (1 << MSI_DATA_TRIGGER_SHIFT) & e->msi.data;\n\tirq->delivery_mode = e->msi.data & 0x700;\n\tirq->msi_redir_hint = ((e->msi.address_lo\n\t\t& MSI_ADDR_REDIRECTION_LOWPRI) > 0);\n\tirq->level = 1;\n\tirq->shorthand = APIC_DEST_NOSHORT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int\nget_pi_vcpu_info(struct kvm *kvm, struct kvm_kernel_irq_routing_entry *e,\n\t\t struct vcpu_data *vcpu_info, struct vcpu_svm **svm)\n{\n\tstruct kvm_lapic_irq irq;\n\tstruct kvm_vcpu *vcpu = NULL;\n\n\tkvm_set_msi_irq(kvm, e, &irq);\n\n\tif (!kvm_intr_is_single_vcpu(kvm, &irq, &vcpu) ||\n\t    !kvm_irq_is_postable(&irq)) {\n\t\tpr_debug(\"SVM: %s: use legacy intr remap mode for irq %u\\n\",\n\t\t\t __func__, irq.vector);\n\t\treturn -1;\n\t}\n\n\tpr_debug(\"SVM: %s: use GA mode for irq %u\\n\", __func__,\n\t\t irq.vector);\n\t*svm = to_svm(vcpu);\n\tvcpu_info->pi_desc_addr = __sme_set(page_to_phys((*svm)->avic_backing_page));\n\tvcpu_info->vector = irq.vector;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_ir_list_add",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4206-4248",
    "snippet": "static int svm_ir_list_add(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\n\t/**\n\t * In some cases, the existing irte is updaed and re-set,\n\t * so we need to check here if it's already been * added\n\t * to the ir_list.\n\t */\n\tif (pi->ir_data && (pi->prev_ga_tag != 0)) {\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tu32 vcpu_id = AVIC_GATAG_TO_VCPUID(pi->prev_ga_tag);\n\t\tstruct kvm_vcpu *prev_vcpu = kvm_get_vcpu_by_id(kvm, vcpu_id);\n\t\tstruct vcpu_svm *prev_svm;\n\n\t\tif (!prev_vcpu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprev_svm = to_svm(prev_vcpu);\n\t\tsvm_ir_list_del(prev_svm, pi);\n\t}\n\n\t/**\n\t * Allocating new amd_iommu_pi_data, which will get\n\t * add to the per-vcpu ir_list.\n\t */\n\tir = kzalloc(sizeof(struct amd_svm_iommu_ir), GFP_KERNEL_ACCOUNT);\n\tif (!ir) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tir->data = pi->ir_data;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_add(&ir->node, &svm->ir_list);\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&svm->ir_list_lock",
            "flags"
          ],
          "line": 4245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ir->node",
            "&svm->ir_list"
          ],
          "line": 4244
        },
        "resolved": true,
        "details": {
          "function_name": "svm_ir_list_add",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4206-4248",
          "snippet": "static int svm_ir_list_add(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\n\t/**\n\t * In some cases, the existing irte is updaed and re-set,\n\t * so we need to check here if it's already been * added\n\t * to the ir_list.\n\t */\n\tif (pi->ir_data && (pi->prev_ga_tag != 0)) {\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tu32 vcpu_id = AVIC_GATAG_TO_VCPUID(pi->prev_ga_tag);\n\t\tstruct kvm_vcpu *prev_vcpu = kvm_get_vcpu_by_id(kvm, vcpu_id);\n\t\tstruct vcpu_svm *prev_svm;\n\n\t\tif (!prev_vcpu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprev_svm = to_svm(prev_vcpu);\n\t\tsvm_ir_list_del(prev_svm, pi);\n\t}\n\n\t/**\n\t * Allocating new amd_iommu_pi_data, which will get\n\t * add to the per-vcpu ir_list.\n\t */\n\tir = kzalloc(sizeof(struct amd_svm_iommu_ir), GFP_KERNEL_ACCOUNT);\n\tif (!ir) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tir->data = pi->ir_data;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_add(&ir->node, &svm->ir_list);\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\nout:\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&svm->ir_list_lock",
            "flags"
          ],
          "line": 4243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct amd_svm_iommu_ir)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 4236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_ir_list_del",
          "args": [
            "prev_svm",
            "pi"
          ],
          "line": 4229
        },
        "resolved": true,
        "details": {
          "function_name": "svm_ir_list_del",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4190-4204",
          "snippet": "static void svm_ir_list_del(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *cur;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_for_each_entry(cur, &svm->ir_list, node) {\n\t\tif (cur->data != pi->ir_data)\n\t\t\tcontinue;\n\t\tlist_del(&cur->node);\n\t\tkfree(cur);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_ir_list_del(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *cur;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_for_each_entry(cur, &svm->ir_list, node) {\n\t\tif (cur->data != pi->ir_data)\n\t\t\tcontinue;\n\t\tlist_del(&cur->node);\n\t\tkfree(cur);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "prev_vcpu"
          ],
          "line": 4228
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_vcpu_by_id",
          "args": [
            "kvm",
            "vcpu_id"
          ],
          "line": 4220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AVIC_GATAG_TO_VCPUID",
          "args": [
            "pi->prev_ga_tag"
          ],
          "line": 4219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_ir_list_add(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\n\t/**\n\t * In some cases, the existing irte is updaed and re-set,\n\t * so we need to check here if it's already been * added\n\t * to the ir_list.\n\t */\n\tif (pi->ir_data && (pi->prev_ga_tag != 0)) {\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tu32 vcpu_id = AVIC_GATAG_TO_VCPUID(pi->prev_ga_tag);\n\t\tstruct kvm_vcpu *prev_vcpu = kvm_get_vcpu_by_id(kvm, vcpu_id);\n\t\tstruct vcpu_svm *prev_svm;\n\n\t\tif (!prev_vcpu) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tprev_svm = to_svm(prev_vcpu);\n\t\tsvm_ir_list_del(prev_svm, pi);\n\t}\n\n\t/**\n\t * Allocating new amd_iommu_pi_data, which will get\n\t * add to the per-vcpu ir_list.\n\t */\n\tir = kzalloc(sizeof(struct amd_svm_iommu_ir), GFP_KERNEL_ACCOUNT);\n\tif (!ir) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tir->data = pi->ir_data;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_add(&ir->node, &svm->ir_list);\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "svm_ir_list_del",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4190-4204",
    "snippet": "static void svm_ir_list_del(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *cur;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_for_each_entry(cur, &svm->ir_list, node) {\n\t\tif (cur->data != pi->ir_data)\n\t\t\tcontinue;\n\t\tlist_del(&cur->node);\n\t\tkfree(cur);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&svm->ir_list_lock",
            "flags"
          ],
          "line": 4203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cur"
          ],
          "line": 4200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&cur->node"
          ],
          "line": 4199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "cur",
            "&svm->ir_list",
            "node"
          ],
          "line": 4196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&svm->ir_list_lock",
            "flags"
          ],
          "line": 4195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_ir_list_del(struct vcpu_svm *svm, struct amd_iommu_pi_data *pi)\n{\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *cur;\n\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\tlist_for_each_entry(cur, &svm->ir_list, node) {\n\t\tif (cur->data != pi->ir_data)\n\t\t\tcontinue;\n\t\tlist_del(&cur->node);\n\t\tkfree(cur);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n}"
  },
  {
    "function_name": "svm_dy_apicv_has_pending_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4185-4188",
    "snippet": "static bool svm_dy_apicv_has_pending_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic bool svm_dy_apicv_has_pending_interrupt(struct kvm_vcpu *vcpu)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "svm_deliver_avic_intr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4165-4183",
    "snippet": "static int svm_deliver_avic_intr(struct kvm_vcpu *vcpu, int vec)\n{\n\tif (!vcpu->arch.apicv_active)\n\t\treturn -1;\n\n\tkvm_lapic_set_irr(vec, vcpu->arch.apic);\n\tsmp_mb__after_atomic();\n\n\tif (avic_vcpu_is_running(vcpu)) {\n\t\tint cpuid = vcpu->cpu;\n\n\t\tif (cpuid != get_cpu())\n\t\t\twrmsrl(SVM_AVIC_DOORBELL, kvm_cpu_get_apicid(cpuid));\n\t\tput_cpu();\n\t} else\n\t\tkvm_vcpu_wake_up(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define SVM_AVIC_DOORBELL\t0xc001011b"
    ],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_wake_up",
          "args": [
            "vcpu"
          ],
          "line": 4180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cpu",
          "args": [],
          "line": 4178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "SVM_AVIC_DOORBELL",
            "kvm_cpu_get_apicid(cpuid)"
          ],
          "line": 4177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_cpu_get_apicid",
          "args": [
            "cpuid"
          ],
          "line": 4177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cpu",
          "args": [],
          "line": 4176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_vcpu_is_running",
          "args": [
            "vcpu"
          ],
          "line": 4173
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vcpu_is_running",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "319-328",
          "snippet": "static inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb__after_atomic",
          "args": [],
          "line": 4171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_set_irr",
          "args": [
            "vec",
            "vcpu->arch.apic"
          ],
          "line": 4170
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_set_irr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "146-154",
          "snippet": "static inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tkvm_lapic_set_vector(vec, apic->regs + APIC_IRR);\n\t/*\n\t * irr_pending must be true if any interrupt is pending; set it after\n\t * APIC_IRR to avoid race with apic_clear_irr\n\t */\n\tapic->irr_pending = true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline void kvm_lapic_set_irr(int vec, struct kvm_lapic *apic)\n{\n\tkvm_lapic_set_vector(vec, apic->regs + APIC_IRR);\n\t/*\n\t * irr_pending must be true if any interrupt is pending; set it after\n\t * APIC_IRR to avoid race with apic_clear_irr\n\t */\n\tapic->irr_pending = true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define SVM_AVIC_DOORBELL\t0xc001011b\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_deliver_avic_intr(struct kvm_vcpu *vcpu, int vec)\n{\n\tif (!vcpu->arch.apicv_active)\n\t\treturn -1;\n\n\tkvm_lapic_set_irr(vec, vcpu->arch.apic);\n\tsmp_mb__after_atomic();\n\n\tif (avic_vcpu_is_running(vcpu)) {\n\t\tint cpuid = vcpu->cpu;\n\n\t\tif (cpuid != get_cpu())\n\t\t\twrmsrl(SVM_AVIC_DOORBELL, kvm_cpu_get_apicid(cpuid));\n\t\tput_cpu();\n\t} else\n\t\tkvm_vcpu_wake_up(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_load_eoi_exitmap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4160-4163",
    "snippet": "static void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\treturn;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_load_eoi_exitmap(struct kvm_vcpu *vcpu, u64 *eoi_exit_bitmap)\n{\n\treturn;\n}"
  },
  {
    "function_name": "svm_refresh_apicv_exec_ctrl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4133-4158",
    "snippet": "static void svm_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tbool activated = kvm_vcpu_apicv_active(vcpu);\n\n\tif (!avic)\n\t\treturn;\n\n\tif (activated) {\n\t\t/**\n\t\t * During AVIC temporary deactivation, guest could update\n\t\t * APIC ID, DFR and LDR registers, which would not be trapped\n\t\t * by avic_unaccelerated_access_interception(). In this case,\n\t\t * we need to check and update the AVIC logical APIC ID table\n\t\t * accordingly before re-activating.\n\t\t */\n\t\tavic_post_state_restore(vcpu);\n\t\tvmcb->control.int_ctl |= AVIC_ENABLE_MASK;\n\t} else {\n\t\tvmcb->control.int_ctl &= ~AVIC_ENABLE_MASK;\n\t}\n\tmark_dirty(vmcb, VMCB_AVIC);\n\n\tsvm_set_pi_irte_mode(vcpu, activated);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int avic;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_set_pi_irte_mode",
          "args": [
            "vcpu",
            "activated"
          ],
          "line": 4157
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_pi_irte_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4101-4131",
          "snippet": "static int svm_set_pi_irte_mode(struct kvm_vcpu *vcpu, bool activate)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm))\n\t\treturn 0;\n\n\t/*\n\t * Here, we go through the per-vcpu ir_list to update all existing\n\t * interrupt remapping table entry targeting this vcpu.\n\t */\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\n\tif (list_empty(&svm->ir_list))\n\t\tgoto out;\n\n\tlist_for_each_entry(ir, &svm->ir_list, node) {\n\t\tif (activate)\n\t\t\tret = amd_iommu_activate_guest_mode(ir->data);\n\t\telse\n\t\t\tret = amd_iommu_deactivate_guest_mode(ir->data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_set_pi_irte_mode(struct kvm_vcpu *vcpu, bool activate)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm))\n\t\treturn 0;\n\n\t/*\n\t * Here, we go through the per-vcpu ir_list to update all existing\n\t * interrupt remapping table entry targeting this vcpu.\n\t */\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\n\tif (list_empty(&svm->ir_list))\n\t\tgoto out;\n\n\tlist_for_each_entry(ir, &svm->ir_list, node) {\n\t\tif (activate)\n\t\t\tret = amd_iommu_activate_guest_mode(ir->data);\n\t\telse\n\t\t\tret = amd_iommu_deactivate_guest_mode(ir->data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "vmcb",
            "VMCB_AVIC"
          ],
          "line": 4155
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_post_state_restore",
          "args": [
            "vcpu"
          ],
          "line": 4150
        },
        "resolved": true,
        "details": {
          "function_name": "avic_post_state_restore",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5162-5168",
          "snippet": "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu)\n{\n\tif (avic_handle_apic_id_update(vcpu) != 0)\n\t\treturn;\n\tavic_handle_dfr_update(vcpu);\n\tavic_handle_ldr_update(vcpu);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu)\n{\n\tif (avic_handle_apic_id_update(vcpu) != 0)\n\t\treturn;\n\tavic_handle_dfr_update(vcpu);\n\tavic_handle_ldr_update(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 4137
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4135
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_refresh_apicv_exec_ctrl(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb *vmcb = svm->vmcb;\n\tbool activated = kvm_vcpu_apicv_active(vcpu);\n\n\tif (!avic)\n\t\treturn;\n\n\tif (activated) {\n\t\t/**\n\t\t * During AVIC temporary deactivation, guest could update\n\t\t * APIC ID, DFR and LDR registers, which would not be trapped\n\t\t * by avic_unaccelerated_access_interception(). In this case,\n\t\t * we need to check and update the AVIC logical APIC ID table\n\t\t * accordingly before re-activating.\n\t\t */\n\t\tavic_post_state_restore(vcpu);\n\t\tvmcb->control.int_ctl |= AVIC_ENABLE_MASK;\n\t} else {\n\t\tvmcb->control.int_ctl &= ~AVIC_ENABLE_MASK;\n\t}\n\tmark_dirty(vmcb, VMCB_AVIC);\n\n\tsvm_set_pi_irte_mode(vcpu, activated);\n}"
  },
  {
    "function_name": "svm_set_pi_irte_mode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4101-4131",
    "snippet": "static int svm_set_pi_irte_mode(struct kvm_vcpu *vcpu, bool activate)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm))\n\t\treturn 0;\n\n\t/*\n\t * Here, we go through the per-vcpu ir_list to update all existing\n\t * interrupt remapping table entry targeting this vcpu.\n\t */\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\n\tif (list_empty(&svm->ir_list))\n\t\tgoto out;\n\n\tlist_for_each_entry(ir, &svm->ir_list, node) {\n\t\tif (activate)\n\t\t\tret = amd_iommu_activate_guest_mode(ir->data);\n\t\telse\n\t\t\tret = amd_iommu_deactivate_guest_mode(ir->data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&svm->ir_list_lock",
            "flags"
          ],
          "line": 4129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "amd_iommu_deactivate_guest_mode",
          "args": [
            "ir->data"
          ],
          "line": 4124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "amd_iommu_activate_guest_mode",
          "args": [
            "ir->data"
          ],
          "line": 4122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ir",
            "&svm->ir_list",
            "node"
          ],
          "line": 4120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&svm->ir_list"
          ],
          "line": 4117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&svm->ir_list_lock",
            "flags"
          ],
          "line": 4115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_has_assigned_device",
          "args": [
            "vcpu->kvm"
          ],
          "line": 4108
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_has_assigned_device",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10460-10463",
          "snippet": "bool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4106
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_set_pi_irte_mode(struct kvm_vcpu *vcpu, bool activate)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm))\n\t\treturn 0;\n\n\t/*\n\t * Here, we go through the per-vcpu ir_list to update all existing\n\t * interrupt remapping table entry targeting this vcpu.\n\t */\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\n\tif (list_empty(&svm->ir_list))\n\t\tgoto out;\n\n\tlist_for_each_entry(ir, &svm->ir_list, node) {\n\t\tif (activate)\n\t\t\tret = amd_iommu_activate_guest_mode(ir->data);\n\t\telse\n\t\t\tret = amd_iommu_deactivate_guest_mode(ir->data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "svm_toggle_avic_for_irq_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4090-4099",
    "snippet": "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate)\n{\n\tif (!avic || !lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tkvm_request_apicv_update(vcpu->kvm, activate,\n\t\t\t\t APICV_INHIBIT_REASON_IRQWIN);\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int avic;",
      "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srcu_read_lock",
          "args": [
            "&vcpu->kvm->srcu"
          ],
          "line": 4098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_request_apicv_update",
          "args": [
            "vcpu->kvm",
            "activate",
            "APICV_INHIBIT_REASON_IRQWIN"
          ],
          "line": 4096
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_request_apicv_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8057-8084",
          "snippet": "void kvm_request_apicv_update(struct kvm *kvm, bool activate, ulong bit)\n{\n\tunsigned long old, new, expected;\n\n\tif (!kvm_x86_ops.check_apicv_inhibit_reasons ||\n\t    !kvm_x86_ops.check_apicv_inhibit_reasons(bit))\n\t\treturn;\n\n\told = READ_ONCE(kvm->arch.apicv_inhibit_reasons);\n\tdo {\n\t\texpected = new = old;\n\t\tif (activate)\n\t\t\t__clear_bit(bit, &new);\n\t\telse\n\t\t\t__set_bit(bit, &new);\n\t\tif (new == old)\n\t\t\tbreak;\n\t\told = cmpxchg(&kvm->arch.apicv_inhibit_reasons, expected, new);\n\t} while (old != expected);\n\n\tif (!!old == !!new)\n\t\treturn;\n\n\ttrace_kvm_apicv_update_request(activate, bit);\n\tif (kvm_x86_ops.pre_update_apicv_exec_ctrl)\n\t\tkvm_x86_ops.pre_update_apicv_exec_ctrl(kvm, activate);\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kvm_x86_ops kvm_x86_ops"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstruct kvm_x86_ops kvm_x86_ops;\n\nvoid kvm_request_apicv_update(struct kvm *kvm, bool activate, ulong bit)\n{\n\tunsigned long old, new, expected;\n\n\tif (!kvm_x86_ops.check_apicv_inhibit_reasons ||\n\t    !kvm_x86_ops.check_apicv_inhibit_reasons(bit))\n\t\treturn;\n\n\told = READ_ONCE(kvm->arch.apicv_inhibit_reasons);\n\tdo {\n\t\texpected = new = old;\n\t\tif (activate)\n\t\t\t__clear_bit(bit, &new);\n\t\telse\n\t\t\t__set_bit(bit, &new);\n\t\tif (new == old)\n\t\t\tbreak;\n\t\told = cmpxchg(&kvm->arch.apicv_inhibit_reasons, expected, new);\n\t} while (old != expected);\n\n\tif (!!old == !!new)\n\t\treturn;\n\n\ttrace_kvm_apicv_update_request(activate, bit);\n\tif (kvm_x86_ops.pre_update_apicv_exec_ctrl)\n\t\tkvm_x86_ops.pre_update_apicv_exec_ctrl(kvm, activate);\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_APICV_UPDATE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "srcu_read_unlock",
          "args": [
            "&vcpu->kvm->srcu",
            "vcpu->srcu_idx"
          ],
          "line": 4095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "vcpu"
          ],
          "line": 4092
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate)\n{\n\tif (!avic || !lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tkvm_request_apicv_update(vcpu->kvm, activate,\n\t\t\t\t APICV_INHIBIT_REASON_IRQWIN);\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n}"
  },
  {
    "function_name": "svm_hwapic_isr_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4086-4088",
    "snippet": "static void svm_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)\n{\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)\n{\n}"
  },
  {
    "function_name": "svm_hwapic_irr_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4082-4084",
    "snippet": "static void svm_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_hwapic_irr_update(struct kvm_vcpu *vcpu, int max_irr)\n{\n}"
  },
  {
    "function_name": "svm_set_virtual_apic_mode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4077-4080",
    "snippet": "static void svm_set_virtual_apic_mode(struct kvm_vcpu *vcpu)\n{\n\treturn;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_virtual_apic_mode(struct kvm_vcpu *vcpu)\n{\n\treturn;\n}"
  },
  {
    "function_name": "update_cr8_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4061-4075",
    "snippet": "static void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tif (irr == -1)\n\t\treturn;\n\n\tif (tpr >= irr)\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR8_WRITE"
          ],
          "line": 4074
        },
        "resolved": true,
        "details": {
          "function_name": "set_cr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "205-212",
          "snippet": "static inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR8_WRITE"
          ],
          "line": 4068
        },
        "resolved": true,
        "details": {
          "function_name": "clr_cr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "214-221",
          "snippet": "static inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_nested_virtualize_tpr",
          "args": [
            "vcpu"
          ],
          "line": 4065
        },
        "resolved": true,
        "details": {
          "function_name": "svm_nested_virtualize_tpr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "364-367",
          "snippet": "static inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool svm_nested_virtualize_tpr(struct kvm_vcpu *vcpu)\n{\n\treturn is_guest_mode(vcpu) && (vcpu->arch.hflags & HF_VINTR_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4063
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu, int tpr, int irr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (svm_nested_virtualize_tpr(vcpu))\n\t\treturn;\n\n\tclr_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tif (irr == -1)\n\t\treturn;\n\n\tif (tpr >= irr)\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n}"
  },
  {
    "function_name": "svm_set_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4048-4059",
    "snippet": "static void svm_set_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tBUG_ON(!(gif_set(svm)));\n\n\ttrace_kvm_inj_virq(vcpu->arch.interrupt.nr);\n\t++vcpu->stat.irq_injections;\n\n\tsvm->vmcb->control.event_inj = vcpu->arch.interrupt.nr |\n\t\tSVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_inj_virq",
          "args": [
            "vcpu->arch.interrupt.nr"
          ],
          "line": 4054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(gif_set(svm))"
          ],
          "line": 4052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gif_set",
          "args": [
            "svm"
          ],
          "line": 4052
        },
        "resolved": true,
        "details": {
          "function_name": "gif_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "325-331",
          "snippet": "static inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool gif_set(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\treturn !!(svm->vmcb->control.int_ctl & V_GIF_MASK);\n\telse\n\t\treturn !!(svm->vcpu.arch.hflags & HF_GIF_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4050
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_irq(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tBUG_ON(!(gif_set(svm)));\n\n\ttrace_kvm_inj_virq(vcpu->arch.interrupt.nr);\n\t++vcpu->stat.irq_injections;\n\n\tsvm->vmcb->control.event_inj = vcpu->arch.interrupt.nr |\n\t\tSVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR;\n}"
  },
  {
    "function_name": "svm_inject_nmi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4038-4046",
    "snippet": "static void svm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.event_inj = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;\n\tvcpu->arch.hflags |= HF_NMI_MASK;\n\tset_intercept(svm, INTERCEPT_IRET);\n\t++vcpu->stat.nmi_injections;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_intercept",
          "args": [
            "svm",
            "INTERCEPT_IRET"
          ],
          "line": 4044
        },
        "resolved": true,
        "details": {
          "function_name": "set_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "281-288",
          "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 4040
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_inject_nmi(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->control.event_inj = SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_NMI;\n\tvcpu->arch.hflags |= HF_NMI_MASK;\n\tset_intercept(svm, INTERCEPT_IRET);\n\t++vcpu->stat.nmi_injections;\n}"
  },
  {
    "function_name": "pre_svm_run",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4024-4036",
    "snippet": "static void pre_svm_run(struct vcpu_svm *svm)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\tif (sev_guest(svm->vcpu.kvm))\n\t\treturn pre_sev_run(svm, cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "new_asid",
          "args": [
            "svm",
            "sd"
          ],
          "line": 4035
        },
        "resolved": true,
        "details": {
          "function_name": "new_asid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2395-2407",
          "snippet": "static void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = sd->min_asid;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t}\n\n\tsvm->asid_generation = sd->asid_generation;\n\tsvm->vmcb->control.asid = sd->next_asid++;\n\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = sd->min_asid;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t}\n\n\tsvm->asid_generation = sd->asid_generation;\n\tsvm->vmcb->control.asid = sd->next_asid++;\n\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pre_sev_run",
          "args": [
            "svm",
            "cpu"
          ],
          "line": 4031
        },
        "resolved": true,
        "details": {
          "function_name": "pre_sev_run",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4000-4022",
          "snippet": "static void pre_sev_run(struct vcpu_svm *svm, int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tint asid = sev_get_asid(svm->vcpu.kvm);\n\n\t/* Assign the asid allocated with this SEV guest */\n\tsvm->vmcb->control.asid = asid;\n\n\t/*\n\t * Flush guest TLB:\n\t *\n\t * 1) when different VMCB for the same ASID is to be run on the same host CPU.\n\t * 2) or this VMCB was executed on different host CPU in previous VMRUNs.\n\t */\n\tif (sd->sev_vmcbs[asid] == svm->vmcb &&\n\t    svm->last_cpu == cpu)\n\t\treturn;\n\n\tsvm->last_cpu = cpu;\n\tsd->sev_vmcbs[asid] = svm->vmcb;\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
            "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void pre_sev_run(struct vcpu_svm *svm, int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tint asid = sev_get_asid(svm->vcpu.kvm);\n\n\t/* Assign the asid allocated with this SEV guest */\n\tsvm->vmcb->control.asid = asid;\n\n\t/*\n\t * Flush guest TLB:\n\t *\n\t * 1) when different VMCB for the same ASID is to be run on the same host CPU.\n\t * 2) or this VMCB was executed on different host CPU in previous VMRUNs.\n\t */\n\tif (sd->sev_vmcbs[asid] == svm->vmcb &&\n\t    svm->last_cpu == cpu)\n\t\treturn;\n\n\tsvm->last_cpu = cpu;\n\tsd->sev_vmcbs[asid] = svm->vmcb;\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "svm->vcpu.kvm"
          ],
          "line": 4030
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "cpu"
          ],
          "line": 4028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 4026
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void pre_svm_run(struct vcpu_svm *svm)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\n\tif (sev_guest(svm->vcpu.kvm))\n\t\treturn pre_sev_run(svm, cpu);\n\n\t/* FIXME: handle wraparound of asid_generation */\n\tif (svm->asid_generation != sd->asid_generation)\n\t\tnew_asid(svm, sd);\n}"
  },
  {
    "function_name": "pre_sev_run",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "4000-4022",
    "snippet": "static void pre_sev_run(struct vcpu_svm *svm, int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tint asid = sev_get_asid(svm->vcpu.kvm);\n\n\t/* Assign the asid allocated with this SEV guest */\n\tsvm->vmcb->control.asid = asid;\n\n\t/*\n\t * Flush guest TLB:\n\t *\n\t * 1) when different VMCB for the same ASID is to be run on the same host CPU.\n\t * 2) or this VMCB was executed on different host CPU in previous VMRUNs.\n\t */\n\tif (sd->sev_vmcbs[asid] == svm->vmcb &&\n\t    svm->last_cpu == cpu)\n\t\treturn;\n\n\tsvm->last_cpu = cpu;\n\tsd->sev_vmcbs[asid] = svm->vmcb;\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_ASID"
          ],
          "line": 4021
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_get_asid",
          "args": [
            "svm->vcpu.kvm"
          ],
          "line": 4003
        },
        "resolved": true,
        "details": {
          "function_name": "sev_get_asid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "306-311",
          "snippet": "static inline int sev_get_asid(struct kvm *kvm)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->asid;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline int sev_get_asid(struct kvm *kvm)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->asid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "cpu"
          ],
          "line": 4002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void pre_sev_run(struct vcpu_svm *svm, int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tint asid = sev_get_asid(svm->vcpu.kvm);\n\n\t/* Assign the asid allocated with this SEV guest */\n\tsvm->vmcb->control.asid = asid;\n\n\t/*\n\t * Flush guest TLB:\n\t *\n\t * 1) when different VMCB for the same ASID is to be run on the same host CPU.\n\t * 2) or this VMCB was executed on different host CPU in previous VMRUNs.\n\t */\n\tif (sd->sev_vmcbs[asid] == svm->vmcb &&\n\t    svm->last_cpu == cpu)\n\t\treturn;\n\n\tsvm->last_cpu = cpu;\n\tsd->sev_vmcbs[asid] = svm->vmcb;\n\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ASID;\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}"
  },
  {
    "function_name": "reload_tss",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3991-3998",
    "snippet": "static void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "load_TR_desc",
          "args": [],
          "line": 3997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "cpu"
          ],
          "line": 3995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 3993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void reload_tss(struct kvm_vcpu *vcpu)\n{\n\tint cpu = raw_smp_processor_id();\n\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tsd->tss_desc->type = 9; /* available 32/64-bit TSS */\n\tload_TR_desc();\n}"
  },
  {
    "function_name": "handle_exit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3902-3989",
    "snippet": "static int handle_exit(struct kvm_vcpu *vcpu,\n\tenum exit_fastpath_completion exit_fastpath)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\ttrace_kvm_exit(exit_code, vcpu, KVM_ISA_SVM);\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR0_WRITE))\n\t\tvcpu->arch.cr0 = svm->vmcb->save.cr0;\n\tif (npt_enabled)\n\t\tvcpu->arch.cr3 = svm->vmcb->save.cr3;\n\n\tif (unlikely(svm->nested.exit_required)) {\n\t\tnested_svm_vmexit(svm);\n\t\tsvm->nested.exit_required = false;\n\n\t\treturn 1;\n\t}\n\n\tif (is_guest_mode(vcpu)) {\n\t\tint vmexit;\n\n\t\ttrace_kvm_nested_vmexit(svm->vmcb->save.rip, exit_code,\n\t\t\t\t\tsvm->vmcb->control.exit_info_1,\n\t\t\t\t\tsvm->vmcb->control.exit_info_2,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info_err,\n\t\t\t\t\tKVM_ISA_SVM);\n\n\t\tvmexit = nested_svm_exit_special(svm);\n\n\t\tif (vmexit == NESTED_EXIT_CONTINUE)\n\t\t\tvmexit = nested_svm_exit_handled(svm);\n\n\t\tif (vmexit == NESTED_EXIT_DONE)\n\t\t\treturn 1;\n\t}\n\n\tsvm_complete_interrupts(svm);\n\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_ERR) {\n\t\tkvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tkvm_run->fail_entry.hardware_entry_failure_reason\n\t\t\t= svm->vmcb->control.exit_code;\n\t\tdump_vmcb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_external_interrupt(svm->vmcb->control.exit_int_info) &&\n\t    exit_code != SVM_EXIT_EXCP_BASE + PF_VECTOR &&\n\t    exit_code != SVM_EXIT_NPF && exit_code != SVM_EXIT_TASK_SWITCH &&\n\t    exit_code != SVM_EXIT_INTR && exit_code != SVM_EXIT_NMI)\n\t\tprintk(KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\",\n\t\t       __func__, svm->vmcb->control.exit_int_info,\n\t\t       exit_code);\n\n\tif (exit_fastpath == EXIT_FASTPATH_SKIP_EMUL_INS) {\n\t\tkvm_skip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t} else if (exit_code >= ARRAY_SIZE(svm_exit_handlers)\n\t    || !svm_exit_handlers[exit_code]) {\n\t\tvcpu_unimpl(vcpu, \"svm: unexpected exit reason 0x%x\\n\", exit_code);\n\t\tdump_vmcb(vcpu);\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror =\n\t\t\tKVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;\n\t\tvcpu->run->internal.ndata = 1;\n\t\tvcpu->run->internal.data[0] = exit_code;\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_RETPOLINE\n\tif (exit_code == SVM_EXIT_MSR)\n\t\treturn msr_interception(svm);\n\telse if (exit_code == SVM_EXIT_VINTR)\n\t\treturn interrupt_window_interception(svm);\n\telse if (exit_code == SVM_EXIT_INTR)\n\t\treturn intr_interception(svm);\n\telse if (exit_code == SVM_EXIT_HLT)\n\t\treturn halt_interception(svm);\n\telse if (exit_code == SVM_EXIT_NPF)\n\t\treturn npf_interception(svm);\n#endif\n\treturn svm_exit_handlers[exit_code](svm);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
      "static int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {\n\t[SVM_EXIT_READ_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR8]\t\t\t= cr_interception,\n\t[SVM_EXIT_CR0_SEL_WRITE]\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR8]\t\t\t= cr8_write_interception,\n\t[SVM_EXIT_READ_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_EXCP_BASE + DB_VECTOR]\t= db_interception,\n\t[SVM_EXIT_EXCP_BASE + BP_VECTOR]\t= bp_interception,\n\t[SVM_EXIT_EXCP_BASE + UD_VECTOR]\t= ud_interception,\n\t[SVM_EXIT_EXCP_BASE + PF_VECTOR]\t= pf_interception,\n\t[SVM_EXIT_EXCP_BASE + MC_VECTOR]\t= mc_interception,\n\t[SVM_EXIT_EXCP_BASE + AC_VECTOR]\t= ac_interception,\n\t[SVM_EXIT_EXCP_BASE + GP_VECTOR]\t= gp_interception,\n\t[SVM_EXIT_INTR]\t\t\t\t= intr_interception,\n\t[SVM_EXIT_NMI]\t\t\t\t= nmi_interception,\n\t[SVM_EXIT_SMI]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_INIT]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_VINTR]\t\t\t= interrupt_window_interception,\n\t[SVM_EXIT_RDPMC]\t\t\t= rdpmc_interception,\n\t[SVM_EXIT_CPUID]\t\t\t= cpuid_interception,\n\t[SVM_EXIT_IRET]                         = iret_interception,\n\t[SVM_EXIT_INVD]                         = emulate_on_interception,\n\t[SVM_EXIT_PAUSE]\t\t\t= pause_interception,\n\t[SVM_EXIT_HLT]\t\t\t\t= halt_interception,\n\t[SVM_EXIT_INVLPG]\t\t\t= invlpg_interception,\n\t[SVM_EXIT_INVLPGA]\t\t\t= invlpga_interception,\n\t[SVM_EXIT_IOIO]\t\t\t\t= io_interception,\n\t[SVM_EXIT_MSR]\t\t\t\t= msr_interception,\n\t[SVM_EXIT_TASK_SWITCH]\t\t\t= task_switch_interception,\n\t[SVM_EXIT_SHUTDOWN]\t\t\t= shutdown_interception,\n\t[SVM_EXIT_VMRUN]\t\t\t= vmrun_interception,\n\t[SVM_EXIT_VMMCALL]\t\t\t= vmmcall_interception,\n\t[SVM_EXIT_VMLOAD]\t\t\t= vmload_interception,\n\t[SVM_EXIT_VMSAVE]\t\t\t= vmsave_interception,\n\t[SVM_EXIT_STGI]\t\t\t\t= stgi_interception,\n\t[SVM_EXIT_CLGI]\t\t\t\t= clgi_interception,\n\t[SVM_EXIT_SKINIT]\t\t\t= skinit_interception,\n\t[SVM_EXIT_WBINVD]                       = wbinvd_interception,\n\t[SVM_EXIT_MONITOR]\t\t\t= monitor_interception,\n\t[SVM_EXIT_MWAIT]\t\t\t= mwait_interception,\n\t[SVM_EXIT_XSETBV]\t\t\t= xsetbv_interception,\n\t[SVM_EXIT_RDPRU]\t\t\t= rdpru_interception,\n\t[SVM_EXIT_NPF]\t\t\t\t= npf_interception,\n\t[SVM_EXIT_RSM]                          = rsm_interception,\n\t[SVM_EXIT_AVIC_INCOMPLETE_IPI]\t\t= avic_incomplete_ipi_interception,\n\t[SVM_EXIT_AVIC_UNACCELERATED_ACCESS]\t= avic_unaccelerated_access_interception,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_exit_handlers[exit_code]",
          "args": [
            "svm"
          ],
          "line": 3988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "npf_interception",
          "args": [
            "svm"
          ],
          "line": 3986
        },
        "resolved": true,
        "details": {
          "function_name": "npf_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2456-2466",
          "snippet": "static int npf_interception(struct vcpu_svm *svm)\n{\n\tu64 fault_address = __sme_clr(svm->vmcb->control.exit_info_2);\n\tu64 error_code = svm->vmcb->control.exit_info_1;\n\n\ttrace_kvm_page_fault(fault_address, error_code);\n\treturn kvm_mmu_page_fault(&svm->vcpu, fault_address, error_code,\n\t\t\tstatic_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL,\n\t\t\tsvm->vmcb->control.insn_len);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int npf_interception(struct vcpu_svm *svm)\n{\n\tu64 fault_address = __sme_clr(svm->vmcb->control.exit_info_2);\n\tu64 error_code = svm->vmcb->control.exit_info_1;\n\n\ttrace_kvm_page_fault(fault_address, error_code);\n\treturn kvm_mmu_page_fault(&svm->vcpu, fault_address, error_code,\n\t\t\tstatic_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL,\n\t\t\tsvm->vmcb->control.insn_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "halt_interception",
          "args": [
            "svm"
          ],
          "line": 3984
        },
        "resolved": true,
        "details": {
          "function_name": "halt_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2657-2660",
          "snippet": "static int halt_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_halt(&svm->vcpu);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int halt_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_halt(&svm->vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "intr_interception",
          "args": [
            "svm"
          ],
          "line": 3982
        },
        "resolved": true,
        "details": {
          "function_name": "intr_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2646-2650",
          "snippet": "static int intr_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.irq_exits;\n\treturn 1;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int intr_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.irq_exits;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "interrupt_window_interception",
          "args": [
            "svm"
          ],
          "line": 3980
        },
        "resolved": true,
        "details": {
          "function_name": "interrupt_window_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3393-3409",
          "snippet": "static int interrupt_window_interception(struct vcpu_svm *svm)\n{\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\tsvm_clear_vintr(svm);\n\n\t/*\n\t * For AVIC, the only reason to end up here is ExtINTs.\n\t * In this case AVIC was temporarily disabled for\n\t * requesting the IRQ window and we have to re-enable it.\n\t */\n\tsvm_toggle_avic_for_irq_window(&svm->vcpu, true);\n\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\t++svm->vcpu.stat.irq_window_exits;\n\treturn 1;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int interrupt_window_interception(struct vcpu_svm *svm)\n{\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\tsvm_clear_vintr(svm);\n\n\t/*\n\t * For AVIC, the only reason to end up here is ExtINTs.\n\t * In this case AVIC was temporarily disabled for\n\t * requesting the IRQ window and we have to re-enable it.\n\t */\n\tsvm_toggle_avic_for_irq_window(&svm->vcpu, true);\n\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\t++svm->vcpu.stat.irq_window_exits;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msr_interception",
          "args": [
            "svm"
          ],
          "line": 3978
        },
        "resolved": true,
        "details": {
          "function_name": "msr_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3385-3391",
          "snippet": "static int msr_interception(struct vcpu_svm *svm)\n{\n\tif (svm->vmcb->control.exit_info_1)\n\t\treturn wrmsr_interception(svm);\n\telse\n\t\treturn rdmsr_interception(svm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic int msr_interception(struct vcpu_svm *svm)\n{\n\tif (svm->vmcb->control.exit_info_1)\n\t\treturn wrmsr_interception(svm);\n\telse\n\t\treturn rdmsr_interception(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_vmcb",
          "args": [
            "vcpu"
          ],
          "line": 3967
        },
        "resolved": true,
        "details": {
          "function_name": "dump_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3778-3892",
          "snippet": "static void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tif (!dump_invalid_vmcb) {\n\t\tpr_warn_ratelimited(\"set kvm_amd.dump_invalid_vmcb=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercept_cr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercept_cr >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercept_dr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercept_dr >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercept_exceptions);\n\tpr_err(\"%-20s%016llx\\n\", \"intercepts:\", control->intercept);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%d\\n\", \"pause filter threshold:\",\n\t       control->pause_filter_thresh);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_vapic_bar:\", control->avic_vapic_bar);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"virt_ext:\", control->virt_ext);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_backing_page:\", control->avic_backing_page);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_logical_id:\", control->avic_logical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_physical_id:\", control->avic_physical_id);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save->fs.selector, save->fs.attrib,\n\t       save->fs.limit, save->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save->gs.selector, save->gs.attrib,\n\t       save->gs.limit, save->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save->ldtr.selector, save->ldtr.attrib,\n\t       save->ldtr.limit, save->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save->tr.selector, save->tr.attrib,\n\t       save->tr.limit, save->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save->star, \"lstar:\", save->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save->cstar, \"sfmask:\", save->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save->kernel_gs_base,\n\t       \"sysenter_cs:\", save->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save->sysenter_esp,\n\t       \"sysenter_eip:\", save->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;",
            "static unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tif (!dump_invalid_vmcb) {\n\t\tpr_warn_ratelimited(\"set kvm_amd.dump_invalid_vmcb=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercept_cr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercept_cr >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercept_dr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercept_dr >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercept_exceptions);\n\tpr_err(\"%-20s%016llx\\n\", \"intercepts:\", control->intercept);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%d\\n\", \"pause filter threshold:\",\n\t       control->pause_filter_thresh);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_vapic_bar:\", control->avic_vapic_bar);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"virt_ext:\", control->virt_ext);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_backing_page:\", control->avic_backing_page);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_logical_id:\", control->avic_logical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_physical_id:\", control->avic_physical_id);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save->fs.selector, save->fs.attrib,\n\t       save->fs.limit, save->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save->gs.selector, save->gs.attrib,\n\t       save->gs.limit, save->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save->ldtr.selector, save->ldtr.attrib,\n\t       save->ldtr.limit, save->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save->tr.selector, save->tr.attrib,\n\t       save->tr.limit, save->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save->star, \"lstar:\", save->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save->cstar, \"sfmask:\", save->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save->kernel_gs_base,\n\t       \"sysenter_cs:\", save->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save->sysenter_esp,\n\t       \"sysenter_eip:\", save->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"svm: unexpected exit reason 0x%x\\n\"",
            "exit_code"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "svm_exit_handlers"
          ],
          "line": 3964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "vcpu"
          ],
          "line": 3962
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\"",
            "__func__",
            "svm->vmcb->control.exit_int_info",
            "exit_code"
          ],
          "line": 3956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_external_interrupt",
          "args": [
            "svm->vmcb->control.exit_int_info"
          ],
          "line": 3952
        },
        "resolved": true,
        "details": {
          "function_name": "is_external_interrupt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "428-432",
          "snippet": "static int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_complete_interrupts",
          "args": [
            "svm"
          ],
          "line": 3942
        },
        "resolved": true,
        "details": {
          "function_name": "svm_complete_interrupts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4550-4612",
          "snippet": "static void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm)\n{\n\tu8 vector;\n\tint type;\n\tu32 exitintinfo = svm->vmcb->control.exit_int_info;\n\tunsigned int3_injected = svm->int3_injected;\n\n\tsvm->int3_injected = 0;\n\n\t/*\n\t * If we've made progress since setting HF_IRET_MASK, we've\n\t * executed an IRET and can allow NMI injection.\n\t */\n\tif ((svm->vcpu.arch.hflags & HF_IRET_MASK)\n\t    && kvm_rip_read(&svm->vcpu) != svm->nmi_iret_rip) {\n\t\tsvm->vcpu.arch.hflags &= ~(HF_NMI_MASK | HF_IRET_MASK);\n\t\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\t}\n\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tif (!(exitintinfo & SVM_EXITINTINFO_VALID))\n\t\treturn;\n\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tvector = exitintinfo & SVM_EXITINTINFO_VEC_MASK;\n\ttype = exitintinfo & SVM_EXITINTINFO_TYPE_MASK;\n\n\tswitch (type) {\n\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\tsvm->vcpu.arch.nmi_injected = true;\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t/*\n\t\t * In case of software exceptions, do not reinject the vector,\n\t\t * but re-execute the instruction instead. Rewind RIP first\n\t\t * if we emulated INT3 before.\n\t\t */\n\t\tif (kvm_exception_is_soft(vector)) {\n\t\t\tif (vector == BP_VECTOR && int3_injected &&\n\t\t\t    kvm_is_linear_rip(&svm->vcpu, svm->int3_rip))\n\t\t\t\tkvm_rip_write(&svm->vcpu,\n\t\t\t\t\t      kvm_rip_read(&svm->vcpu) -\n\t\t\t\t\t      int3_injected);\n\t\t\tbreak;\n\t\t}\n\t\tif (exitintinfo & SVM_EXITINTINFO_VALID_ERR) {\n\t\t\tu32 err = svm->vmcb->control.exit_int_info_err;\n\t\t\tkvm_requeue_exception_e(&svm->vcpu, vector, err);\n\n\t\t} else\n\t\t\tkvm_requeue_exception(&svm->vcpu, vector);\n\t\tbreak;\n\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\tkvm_queue_interrupt(&svm->vcpu, vector, false);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_exit_handled",
          "args": [
            "svm"
          ],
          "line": 3936
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_exit_handled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "708-718",
          "snippet": "int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_exit_special",
          "args": [
            "svm"
          ],
          "line": 3933
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_exit_special",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "799-823",
          "snippet": "int nested_svm_exit_special(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_INTR:\n\tcase SVM_EXIT_NMI:\n\tcase SVM_EXIT_EXCP_BASE + MC_VECTOR:\n\t\treturn NESTED_EXIT_HOST;\n\tcase SVM_EXIT_NPF:\n\t\t/* For now we are always handling NPFs when using them */\n\t\tif (npt_enabled)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + PF_VECTOR:\n\t\t/* When we're shadowing, trap PFs, but not async PF */\n\t\tif (!npt_enabled && svm->vcpu.arch.apf.host_apf_reason == 0)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NESTED_EXIT_CONTINUE;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_exit_special(struct vcpu_svm *svm)\n{\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\tswitch (exit_code) {\n\tcase SVM_EXIT_INTR:\n\tcase SVM_EXIT_NMI:\n\tcase SVM_EXIT_EXCP_BASE + MC_VECTOR:\n\t\treturn NESTED_EXIT_HOST;\n\tcase SVM_EXIT_NPF:\n\t\t/* For now we are always handling NPFs when using them */\n\t\tif (npt_enabled)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tcase SVM_EXIT_EXCP_BASE + PF_VECTOR:\n\t\t/* When we're shadowing, trap PFs, but not async PF */\n\t\tif (!npt_enabled && svm->vcpu.arch.apf.host_apf_reason == 0)\n\t\t\treturn NESTED_EXIT_HOST;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn NESTED_EXIT_CONTINUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_nested_vmexit",
          "args": [
            "svm->vmcb->save.rip",
            "exit_code",
            "svm->vmcb->control.exit_info_1",
            "svm->vmcb->control.exit_info_2",
            "svm->vmcb->control.exit_int_info",
            "svm->vmcb->control.exit_int_info_err",
            "KVM_ISA_SVM"
          ],
          "line": 3926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 3923
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_vmexit",
          "args": [
            "svm"
          ],
          "line": 3917
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmexit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "438-579",
          "snippet": "int nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tint rc;\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_host_map map;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\trc = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(svm->nested.vmcb), &map);\n\tif (rc) {\n\t\tif (rc == -EINVAL)\n\t\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tnested_vmcb = map.hva;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\tnested_vmcb->control.pause_filter_count =\n\t\tsvm->vmcb->control.pause_filter_count;\n\tnested_vmcb->control.pause_filter_thresh =\n\t\tsvm->vmcb->control.pause_filter_thresh;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tsvm->vcpu.arch.tsc_offset = svm->vmcb->control.tsc_offset;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_rax_write(&svm->vcpu, hsave->save.rax);\n\tkvm_rsp_write(&svm->vcpu, hsave->save.rsp);\n\tkvm_rip_write(&svm->vcpu, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\t/*\n\t * Drop what we picked up for L2 via svm_complete_interrupts() so it\n\t * doesn't end up in L1.\n\t */\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_vmexit(struct vcpu_svm *svm)\n{\n\tint rc;\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_host_map map;\n\n\ttrace_kvm_nested_vmexit_inject(vmcb->control.exit_code,\n\t\t\t\t       vmcb->control.exit_info_1,\n\t\t\t\t       vmcb->control.exit_info_2,\n\t\t\t\t       vmcb->control.exit_int_info,\n\t\t\t\t       vmcb->control.exit_int_info_err,\n\t\t\t\t       KVM_ISA_SVM);\n\n\trc = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(svm->nested.vmcb), &map);\n\tif (rc) {\n\t\tif (rc == -EINVAL)\n\t\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tnested_vmcb = map.hva;\n\n\t/* Exit Guest-Mode */\n\tleave_guest_mode(&svm->vcpu);\n\tsvm->nested.vmcb = 0;\n\n\t/* Give the current vmcb to the guest */\n\tdisable_gif(svm);\n\n\tnested_vmcb->save.es     = vmcb->save.es;\n\tnested_vmcb->save.cs     = vmcb->save.cs;\n\tnested_vmcb->save.ss     = vmcb->save.ss;\n\tnested_vmcb->save.ds     = vmcb->save.ds;\n\tnested_vmcb->save.gdtr   = vmcb->save.gdtr;\n\tnested_vmcb->save.idtr   = vmcb->save.idtr;\n\tnested_vmcb->save.efer   = svm->vcpu.arch.efer;\n\tnested_vmcb->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\tnested_vmcb->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\tnested_vmcb->save.cr2    = vmcb->save.cr2;\n\tnested_vmcb->save.cr4    = svm->vcpu.arch.cr4;\n\tnested_vmcb->save.rflags = kvm_get_rflags(&svm->vcpu);\n\tnested_vmcb->save.rip    = vmcb->save.rip;\n\tnested_vmcb->save.rsp    = vmcb->save.rsp;\n\tnested_vmcb->save.rax    = vmcb->save.rax;\n\tnested_vmcb->save.dr7    = vmcb->save.dr7;\n\tnested_vmcb->save.dr6    = vmcb->save.dr6;\n\tnested_vmcb->save.cpl    = vmcb->save.cpl;\n\n\tnested_vmcb->control.int_ctl           = vmcb->control.int_ctl;\n\tnested_vmcb->control.int_vector        = vmcb->control.int_vector;\n\tnested_vmcb->control.int_state         = vmcb->control.int_state;\n\tnested_vmcb->control.exit_code         = vmcb->control.exit_code;\n\tnested_vmcb->control.exit_code_hi      = vmcb->control.exit_code_hi;\n\tnested_vmcb->control.exit_info_1       = vmcb->control.exit_info_1;\n\tnested_vmcb->control.exit_info_2       = vmcb->control.exit_info_2;\n\tnested_vmcb->control.exit_int_info     = vmcb->control.exit_int_info;\n\tnested_vmcb->control.exit_int_info_err = vmcb->control.exit_int_info_err;\n\n\tif (svm->nrips_enabled)\n\t\tnested_vmcb->control.next_rip  = vmcb->control.next_rip;\n\n\t/*\n\t * If we emulate a VMRUN/#VMEXIT in the same host #vmexit cycle we have\n\t * to make sure that we do not lose injected events. So check event_inj\n\t * here and copy it to exit_int_info if it is valid.\n\t * Exit_int_info and event_inj can't be both valid because the case\n\t * below only happens on a VMRUN instruction intercept which has\n\t * no valid exit_int_info set.\n\t */\n\tif (vmcb->control.event_inj & SVM_EVTINJ_VALID) {\n\t\tstruct vmcb_control_area *nc = &nested_vmcb->control;\n\n\t\tnc->exit_int_info     = vmcb->control.event_inj;\n\t\tnc->exit_int_info_err = vmcb->control.event_inj_err;\n\t}\n\n\tnested_vmcb->control.tlb_ctl           = 0;\n\tnested_vmcb->control.event_inj         = 0;\n\tnested_vmcb->control.event_inj_err     = 0;\n\n\tnested_vmcb->control.pause_filter_count =\n\t\tsvm->vmcb->control.pause_filter_count;\n\tnested_vmcb->control.pause_filter_thresh =\n\t\tsvm->vmcb->control.pause_filter_thresh;\n\n\t/* We always set V_INTR_MASKING and remember the old value in hflags */\n\tif (!(svm->vcpu.arch.hflags & HF_VINTR_MASK))\n\t\tnested_vmcb->control.int_ctl &= ~V_INTR_MASKING_MASK;\n\n\t/* Restore the original control entries */\n\tcopy_vmcb_control_area(vmcb, hsave);\n\n\tsvm->vcpu.arch.tsc_offset = svm->vmcb->control.tsc_offset;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\tsvm->nested.nested_cr3 = 0;\n\n\t/* Restore selected save entries */\n\tsvm->vmcb->save.es = hsave->save.es;\n\tsvm->vmcb->save.cs = hsave->save.cs;\n\tsvm->vmcb->save.ss = hsave->save.ss;\n\tsvm->vmcb->save.ds = hsave->save.ds;\n\tsvm->vmcb->save.gdtr = hsave->save.gdtr;\n\tsvm->vmcb->save.idtr = hsave->save.idtr;\n\tkvm_set_rflags(&svm->vcpu, hsave->save.rflags);\n\tsvm_set_efer(&svm->vcpu, hsave->save.efer);\n\tsvm_set_cr0(&svm->vcpu, hsave->save.cr0 | X86_CR0_PE);\n\tsvm_set_cr4(&svm->vcpu, hsave->save.cr4);\n\tif (npt_enabled) {\n\t\tsvm->vmcb->save.cr3 = hsave->save.cr3;\n\t\tsvm->vcpu.arch.cr3 = hsave->save.cr3;\n\t} else {\n\t\t(void)kvm_set_cr3(&svm->vcpu, hsave->save.cr3);\n\t}\n\tkvm_rax_write(&svm->vcpu, hsave->save.rax);\n\tkvm_rsp_write(&svm->vcpu, hsave->save.rsp);\n\tkvm_rip_write(&svm->vcpu, hsave->save.rip);\n\tsvm->vmcb->save.dr7 = 0;\n\tsvm->vmcb->save.cpl = 0;\n\tsvm->vmcb->control.exit_int_info = 0;\n\n\tmark_all_dirty(svm->vmcb);\n\n\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\tnested_svm_uninit_mmu_context(&svm->vcpu);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\tkvm_mmu_load(&svm->vcpu);\n\n\t/*\n\t * Drop what we picked up for L2 via svm_complete_interrupts() so it\n\t * doesn't end up in L1.\n\t */\n\tsvm->vcpu.arch.nmi_injected = false;\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "svm->nested.exit_required"
          ],
          "line": 3916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR0_WRITE"
          ],
          "line": 3911
        },
        "resolved": true,
        "details": {
          "function_name": "is_cr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "223-228",
          "snippet": "static inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool is_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\treturn vmcb->control.intercept_cr & (1U << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_exit",
          "args": [
            "exit_code",
            "vcpu",
            "KVM_ISA_SVM"
          ],
          "line": 3909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3905
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic int (*const svm_exit_handlers[])(struct vcpu_svm *svm) = {\n\t[SVM_EXIT_READ_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_READ_CR8]\t\t\t= cr_interception,\n\t[SVM_EXIT_CR0_SEL_WRITE]\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR0]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR3]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR4]\t\t\t= cr_interception,\n\t[SVM_EXIT_WRITE_CR8]\t\t\t= cr8_write_interception,\n\t[SVM_EXIT_READ_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_READ_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR0]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR1]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR2]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR3]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR4]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR5]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR6]\t\t\t= dr_interception,\n\t[SVM_EXIT_WRITE_DR7]\t\t\t= dr_interception,\n\t[SVM_EXIT_EXCP_BASE + DB_VECTOR]\t= db_interception,\n\t[SVM_EXIT_EXCP_BASE + BP_VECTOR]\t= bp_interception,\n\t[SVM_EXIT_EXCP_BASE + UD_VECTOR]\t= ud_interception,\n\t[SVM_EXIT_EXCP_BASE + PF_VECTOR]\t= pf_interception,\n\t[SVM_EXIT_EXCP_BASE + MC_VECTOR]\t= mc_interception,\n\t[SVM_EXIT_EXCP_BASE + AC_VECTOR]\t= ac_interception,\n\t[SVM_EXIT_EXCP_BASE + GP_VECTOR]\t= gp_interception,\n\t[SVM_EXIT_INTR]\t\t\t\t= intr_interception,\n\t[SVM_EXIT_NMI]\t\t\t\t= nmi_interception,\n\t[SVM_EXIT_SMI]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_INIT]\t\t\t\t= nop_on_interception,\n\t[SVM_EXIT_VINTR]\t\t\t= interrupt_window_interception,\n\t[SVM_EXIT_RDPMC]\t\t\t= rdpmc_interception,\n\t[SVM_EXIT_CPUID]\t\t\t= cpuid_interception,\n\t[SVM_EXIT_IRET]                         = iret_interception,\n\t[SVM_EXIT_INVD]                         = emulate_on_interception,\n\t[SVM_EXIT_PAUSE]\t\t\t= pause_interception,\n\t[SVM_EXIT_HLT]\t\t\t\t= halt_interception,\n\t[SVM_EXIT_INVLPG]\t\t\t= invlpg_interception,\n\t[SVM_EXIT_INVLPGA]\t\t\t= invlpga_interception,\n\t[SVM_EXIT_IOIO]\t\t\t\t= io_interception,\n\t[SVM_EXIT_MSR]\t\t\t\t= msr_interception,\n\t[SVM_EXIT_TASK_SWITCH]\t\t\t= task_switch_interception,\n\t[SVM_EXIT_SHUTDOWN]\t\t\t= shutdown_interception,\n\t[SVM_EXIT_VMRUN]\t\t\t= vmrun_interception,\n\t[SVM_EXIT_VMMCALL]\t\t\t= vmmcall_interception,\n\t[SVM_EXIT_VMLOAD]\t\t\t= vmload_interception,\n\t[SVM_EXIT_VMSAVE]\t\t\t= vmsave_interception,\n\t[SVM_EXIT_STGI]\t\t\t\t= stgi_interception,\n\t[SVM_EXIT_CLGI]\t\t\t\t= clgi_interception,\n\t[SVM_EXIT_SKINIT]\t\t\t= skinit_interception,\n\t[SVM_EXIT_WBINVD]                       = wbinvd_interception,\n\t[SVM_EXIT_MONITOR]\t\t\t= monitor_interception,\n\t[SVM_EXIT_MWAIT]\t\t\t= mwait_interception,\n\t[SVM_EXIT_XSETBV]\t\t\t= xsetbv_interception,\n\t[SVM_EXIT_RDPRU]\t\t\t= rdpru_interception,\n\t[SVM_EXIT_NPF]\t\t\t\t= npf_interception,\n\t[SVM_EXIT_RSM]                          = rsm_interception,\n\t[SVM_EXIT_AVIC_INCOMPLETE_IPI]\t\t= avic_incomplete_ipi_interception,\n\t[SVM_EXIT_AVIC_UNACCELERATED_ACCESS]\t= avic_unaccelerated_access_interception,\n};\n\nstatic int handle_exit(struct kvm_vcpu *vcpu,\n\tenum exit_fastpath_completion exit_fastpath)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct kvm_run *kvm_run = vcpu->run;\n\tu32 exit_code = svm->vmcb->control.exit_code;\n\n\ttrace_kvm_exit(exit_code, vcpu, KVM_ISA_SVM);\n\n\tif (!is_cr_intercept(svm, INTERCEPT_CR0_WRITE))\n\t\tvcpu->arch.cr0 = svm->vmcb->save.cr0;\n\tif (npt_enabled)\n\t\tvcpu->arch.cr3 = svm->vmcb->save.cr3;\n\n\tif (unlikely(svm->nested.exit_required)) {\n\t\tnested_svm_vmexit(svm);\n\t\tsvm->nested.exit_required = false;\n\n\t\treturn 1;\n\t}\n\n\tif (is_guest_mode(vcpu)) {\n\t\tint vmexit;\n\n\t\ttrace_kvm_nested_vmexit(svm->vmcb->save.rip, exit_code,\n\t\t\t\t\tsvm->vmcb->control.exit_info_1,\n\t\t\t\t\tsvm->vmcb->control.exit_info_2,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info,\n\t\t\t\t\tsvm->vmcb->control.exit_int_info_err,\n\t\t\t\t\tKVM_ISA_SVM);\n\n\t\tvmexit = nested_svm_exit_special(svm);\n\n\t\tif (vmexit == NESTED_EXIT_CONTINUE)\n\t\t\tvmexit = nested_svm_exit_handled(svm);\n\n\t\tif (vmexit == NESTED_EXIT_DONE)\n\t\t\treturn 1;\n\t}\n\n\tsvm_complete_interrupts(svm);\n\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_ERR) {\n\t\tkvm_run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tkvm_run->fail_entry.hardware_entry_failure_reason\n\t\t\t= svm->vmcb->control.exit_code;\n\t\tdump_vmcb(vcpu);\n\t\treturn 0;\n\t}\n\n\tif (is_external_interrupt(svm->vmcb->control.exit_int_info) &&\n\t    exit_code != SVM_EXIT_EXCP_BASE + PF_VECTOR &&\n\t    exit_code != SVM_EXIT_NPF && exit_code != SVM_EXIT_TASK_SWITCH &&\n\t    exit_code != SVM_EXIT_INTR && exit_code != SVM_EXIT_NMI)\n\t\tprintk(KERN_ERR \"%s: unexpected exit_int_info 0x%x \"\n\t\t       \"exit_code 0x%x\\n\",\n\t\t       __func__, svm->vmcb->control.exit_int_info,\n\t\t       exit_code);\n\n\tif (exit_fastpath == EXIT_FASTPATH_SKIP_EMUL_INS) {\n\t\tkvm_skip_emulated_instruction(vcpu);\n\t\treturn 1;\n\t} else if (exit_code >= ARRAY_SIZE(svm_exit_handlers)\n\t    || !svm_exit_handlers[exit_code]) {\n\t\tvcpu_unimpl(vcpu, \"svm: unexpected exit reason 0x%x\\n\", exit_code);\n\t\tdump_vmcb(vcpu);\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror =\n\t\t\tKVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;\n\t\tvcpu->run->internal.ndata = 1;\n\t\tvcpu->run->internal.data[0] = exit_code;\n\t\treturn 0;\n\t}\n\n#ifdef CONFIG_RETPOLINE\n\tif (exit_code == SVM_EXIT_MSR)\n\t\treturn msr_interception(svm);\n\telse if (exit_code == SVM_EXIT_VINTR)\n\t\treturn interrupt_window_interception(svm);\n\telse if (exit_code == SVM_EXIT_INTR)\n\t\treturn intr_interception(svm);\n\telse if (exit_code == SVM_EXIT_HLT)\n\t\treturn halt_interception(svm);\n\telse if (exit_code == SVM_EXIT_NPF)\n\t\treturn npf_interception(svm);\n#endif\n\treturn svm_exit_handlers[exit_code](svm);\n}"
  },
  {
    "function_name": "svm_get_exit_info",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3894-3900",
    "snippet": "static void svm_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\tstruct vmcb_control_area *control = &to_svm(vcpu)->vmcb->control;\n\n\t*info1 = control->exit_info_1;\n\t*info2 = control->exit_info_2;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3896
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_get_exit_info(struct kvm_vcpu *vcpu, u64 *info1, u64 *info2)\n{\n\tstruct vmcb_control_area *control = &to_svm(vcpu)->vmcb->control;\n\n\t*info1 = control->exit_info_1;\n\t*info2 = control->exit_info_2;\n}"
  },
  {
    "function_name": "dump_vmcb",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3778-3892",
    "snippet": "static void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tif (!dump_invalid_vmcb) {\n\t\tpr_warn_ratelimited(\"set kvm_amd.dump_invalid_vmcb=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercept_cr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercept_cr >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercept_dr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercept_dr >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercept_exceptions);\n\tpr_err(\"%-20s%016llx\\n\", \"intercepts:\", control->intercept);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%d\\n\", \"pause filter threshold:\",\n\t       control->pause_filter_thresh);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_vapic_bar:\", control->avic_vapic_bar);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"virt_ext:\", control->virt_ext);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_backing_page:\", control->avic_backing_page);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_logical_id:\", control->avic_logical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_physical_id:\", control->avic_physical_id);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save->fs.selector, save->fs.attrib,\n\t       save->fs.limit, save->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save->gs.selector, save->gs.attrib,\n\t       save->gs.limit, save->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save->ldtr.selector, save->ldtr.attrib,\n\t       save->ldtr.limit, save->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save->tr.selector, save->tr.attrib,\n\t       save->tr.limit, save->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save->star, \"lstar:\", save->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save->cstar, \"sfmask:\", save->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save->kernel_gs_base,\n\t       \"sysenter_cs:\", save->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save->sysenter_esp,\n\t       \"sysenter_eip:\", save->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;",
      "static unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"excp_from:\"",
            "save->last_excp_from",
            "\"excp_to:\"",
            "save->last_excp_to"
          ],
          "line": 3889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"br_from:\"",
            "save->br_from",
            "\"br_to:\"",
            "save->br_to"
          ],
          "line": 3887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"gpat:\"",
            "save->g_pat",
            "\"dbgctl:\"",
            "save->dbgctl"
          ],
          "line": 3885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"sysenter_esp:\"",
            "save->sysenter_esp",
            "\"sysenter_eip:\"",
            "save->sysenter_eip"
          ],
          "line": 3882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"kernel_gs_base:\"",
            "save->kernel_gs_base",
            "\"sysenter_cs:\"",
            "save->sysenter_cs"
          ],
          "line": 3879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"cstar:\"",
            "save->cstar",
            "\"sfmask:\"",
            "save->sfmask"
          ],
          "line": 3877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"star:\"",
            "save->star",
            "\"lstar:\"",
            "save->lstar"
          ],
          "line": 3875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"rsp:\"",
            "save->rsp",
            "\"rax:\"",
            "save->rax"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"rip:\"",
            "save->rip",
            "\"rflags:\"",
            "save->rflags"
          ],
          "line": 3871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"dr6:\"",
            "save->dr6",
            "\"dr7:\"",
            "save->dr7"
          ],
          "line": 3869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"cr3:\"",
            "save->cr3",
            "\"cr4:\"",
            "save->cr4"
          ],
          "line": 3867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-15s %016llx %-13s %016llx\\n\"",
            "\"cr0:\"",
            "save->cr0",
            "\"cr2:\"",
            "save->cr2"
          ],
          "line": 3865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cpl:            %d                efer:         %016llx\\n\"",
            "save->cpl",
            "save->efer"
          ],
          "line": 3863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"tr:\"",
            "save->tr.selector",
            "save->tr.attrib",
            "save->tr.limit",
            "save->tr.base"
          ],
          "line": 3859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"idtr:\"",
            "save->idtr.selector",
            "save->idtr.attrib",
            "save->idtr.limit",
            "save->idtr.base"
          ],
          "line": 3855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"ldtr:\"",
            "save->ldtr.selector",
            "save->ldtr.attrib",
            "save->ldtr.limit",
            "save->ldtr.base"
          ],
          "line": 3851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"gdtr:\"",
            "save->gdtr.selector",
            "save->gdtr.attrib",
            "save->gdtr.limit",
            "save->gdtr.base"
          ],
          "line": 3847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"gs:\"",
            "save->gs.selector",
            "save->gs.attrib",
            "save->gs.limit",
            "save->gs.base"
          ],
          "line": 3843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"fs:\"",
            "save->fs.selector",
            "save->fs.attrib",
            "save->fs.limit",
            "save->fs.base"
          ],
          "line": 3839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"ds:\"",
            "save->ds.selector",
            "save->ds.attrib",
            "save->ds.limit",
            "save->ds.base"
          ],
          "line": 3835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"ss:\"",
            "save->ss.selector",
            "save->ss.attrib",
            "save->ss.limit",
            "save->ss.base"
          ],
          "line": 3831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"cs:\"",
            "save->cs.selector",
            "save->cs.attrib",
            "save->cs.limit",
            "save->cs.base"
          ],
          "line": 3827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\"",
            "\"es:\"",
            "save->es.selector",
            "save->es.attrib",
            "save->es.limit",
            "save->es.base"
          ],
          "line": 3823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"VMCB State Save Area:\\n\""
          ],
          "line": 3822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"avic_physical_id:\"",
            "control->avic_physical_id"
          ],
          "line": 3821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"avic_logical_id:\"",
            "control->avic_logical_id"
          ],
          "line": 3820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"avic_backing_page:\"",
            "control->avic_backing_page"
          ],
          "line": 3819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"next_rip:\"",
            "control->next_rip"
          ],
          "line": 3818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%lld\\n\"",
            "\"virt_ext:\"",
            "control->virt_ext"
          ],
          "line": 3817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"event_inj_err:\"",
            "control->event_inj_err"
          ],
          "line": 3816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"event_inj:\"",
            "control->event_inj"
          ],
          "line": 3815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"avic_vapic_bar:\"",
            "control->avic_vapic_bar"
          ],
          "line": 3814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"nested_cr3:\"",
            "control->nested_cr3"
          ],
          "line": 3813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%lld\\n\"",
            "\"nested_ctl:\"",
            "control->nested_ctl"
          ],
          "line": 3812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"exit_int_info_err:\"",
            "control->exit_int_info_err"
          ],
          "line": 3811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"exit_int_info:\"",
            "control->exit_int_info"
          ],
          "line": 3810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"exit_info2:\"",
            "control->exit_info_2"
          ],
          "line": 3809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"exit_info1:\"",
            "control->exit_info_1"
          ],
          "line": 3808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"exit_code:\"",
            "control->exit_code"
          ],
          "line": 3807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"int_state:\"",
            "control->int_state"
          ],
          "line": 3806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"int_vector:\"",
            "control->int_vector"
          ],
          "line": 3805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"int_ctl:\"",
            "control->int_ctl"
          ],
          "line": 3804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%d\\n\"",
            "\"tlb_ctl:\"",
            "control->tlb_ctl"
          ],
          "line": 3803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%d\\n\"",
            "\"asid:\"",
            "control->asid"
          ],
          "line": 3802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"tsc_offset:\"",
            "control->tsc_offset"
          ],
          "line": 3801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"msrpm_base_pa:\"",
            "control->msrpm_base_pa"
          ],
          "line": 3800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"iopm_base_pa:\"",
            "control->iopm_base_pa"
          ],
          "line": 3799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%d\\n\"",
            "\"pause filter threshold:\"",
            "control->pause_filter_thresh"
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%d\\n\"",
            "\"pause filter count:\"",
            "control->pause_filter_count"
          ],
          "line": 3796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%016llx\\n\"",
            "\"intercepts:\"",
            "control->intercept"
          ],
          "line": 3795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%08x\\n\"",
            "\"exceptions:\"",
            "control->intercept_exceptions"
          ],
          "line": 3794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%04x\\n\"",
            "\"dr_write:\"",
            "control->intercept_dr >> 16"
          ],
          "line": 3793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%04x\\n\"",
            "\"dr_read:\"",
            "control->intercept_dr & 0xffff"
          ],
          "line": 3792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%04x\\n\"",
            "\"cr_write:\"",
            "control->intercept_cr >> 16"
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%-20s%04x\\n\"",
            "\"cr_read:\"",
            "control->intercept_cr & 0xffff"
          ],
          "line": 3790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"VMCB Control Area:\\n\""
          ],
          "line": 3789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"set kvm_amd.dump_invalid_vmcb=1 to dump internal KVM state.\\n\""
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3780
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void dump_vmcb(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tif (!dump_invalid_vmcb) {\n\t\tpr_warn_ratelimited(\"set kvm_amd.dump_invalid_vmcb=1 to dump internal KVM state.\\n\");\n\t\treturn;\n\t}\n\n\tpr_err(\"VMCB Control Area:\\n\");\n\tpr_err(\"%-20s%04x\\n\", \"cr_read:\", control->intercept_cr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"cr_write:\", control->intercept_cr >> 16);\n\tpr_err(\"%-20s%04x\\n\", \"dr_read:\", control->intercept_dr & 0xffff);\n\tpr_err(\"%-20s%04x\\n\", \"dr_write:\", control->intercept_dr >> 16);\n\tpr_err(\"%-20s%08x\\n\", \"exceptions:\", control->intercept_exceptions);\n\tpr_err(\"%-20s%016llx\\n\", \"intercepts:\", control->intercept);\n\tpr_err(\"%-20s%d\\n\", \"pause filter count:\", control->pause_filter_count);\n\tpr_err(\"%-20s%d\\n\", \"pause filter threshold:\",\n\t       control->pause_filter_thresh);\n\tpr_err(\"%-20s%016llx\\n\", \"iopm_base_pa:\", control->iopm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"msrpm_base_pa:\", control->msrpm_base_pa);\n\tpr_err(\"%-20s%016llx\\n\", \"tsc_offset:\", control->tsc_offset);\n\tpr_err(\"%-20s%d\\n\", \"asid:\", control->asid);\n\tpr_err(\"%-20s%d\\n\", \"tlb_ctl:\", control->tlb_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_ctl:\", control->int_ctl);\n\tpr_err(\"%-20s%08x\\n\", \"int_vector:\", control->int_vector);\n\tpr_err(\"%-20s%08x\\n\", \"int_state:\", control->int_state);\n\tpr_err(\"%-20s%08x\\n\", \"exit_code:\", control->exit_code);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info1:\", control->exit_info_1);\n\tpr_err(\"%-20s%016llx\\n\", \"exit_info2:\", control->exit_info_2);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info:\", control->exit_int_info);\n\tpr_err(\"%-20s%08x\\n\", \"exit_int_info_err:\", control->exit_int_info_err);\n\tpr_err(\"%-20s%lld\\n\", \"nested_ctl:\", control->nested_ctl);\n\tpr_err(\"%-20s%016llx\\n\", \"nested_cr3:\", control->nested_cr3);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_vapic_bar:\", control->avic_vapic_bar);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj:\", control->event_inj);\n\tpr_err(\"%-20s%08x\\n\", \"event_inj_err:\", control->event_inj_err);\n\tpr_err(\"%-20s%lld\\n\", \"virt_ext:\", control->virt_ext);\n\tpr_err(\"%-20s%016llx\\n\", \"next_rip:\", control->next_rip);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_backing_page:\", control->avic_backing_page);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_logical_id:\", control->avic_logical_id);\n\tpr_err(\"%-20s%016llx\\n\", \"avic_physical_id:\", control->avic_physical_id);\n\tpr_err(\"VMCB State Save Area:\\n\");\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"es:\",\n\t       save->es.selector, save->es.attrib,\n\t       save->es.limit, save->es.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"cs:\",\n\t       save->cs.selector, save->cs.attrib,\n\t       save->cs.limit, save->cs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ss:\",\n\t       save->ss.selector, save->ss.attrib,\n\t       save->ss.limit, save->ss.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ds:\",\n\t       save->ds.selector, save->ds.attrib,\n\t       save->ds.limit, save->ds.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"fs:\",\n\t       save->fs.selector, save->fs.attrib,\n\t       save->fs.limit, save->fs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gs:\",\n\t       save->gs.selector, save->gs.attrib,\n\t       save->gs.limit, save->gs.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"gdtr:\",\n\t       save->gdtr.selector, save->gdtr.attrib,\n\t       save->gdtr.limit, save->gdtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"ldtr:\",\n\t       save->ldtr.selector, save->ldtr.attrib,\n\t       save->ldtr.limit, save->ldtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"idtr:\",\n\t       save->idtr.selector, save->idtr.attrib,\n\t       save->idtr.limit, save->idtr.base);\n\tpr_err(\"%-5s s: %04x a: %04x l: %08x b: %016llx\\n\",\n\t       \"tr:\",\n\t       save->tr.selector, save->tr.attrib,\n\t       save->tr.limit, save->tr.base);\n\tpr_err(\"cpl:            %d                efer:         %016llx\\n\",\n\t\tsave->cpl, save->efer);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr0:\", save->cr0, \"cr2:\", save->cr2);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cr3:\", save->cr3, \"cr4:\", save->cr4);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"dr6:\", save->dr6, \"dr7:\", save->dr7);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rip:\", save->rip, \"rflags:\", save->rflags);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"rsp:\", save->rsp, \"rax:\", save->rax);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"star:\", save->star, \"lstar:\", save->lstar);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"cstar:\", save->cstar, \"sfmask:\", save->sfmask);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"kernel_gs_base:\", save->kernel_gs_base,\n\t       \"sysenter_cs:\", save->sysenter_cs);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"sysenter_esp:\", save->sysenter_esp,\n\t       \"sysenter_eip:\", save->sysenter_eip);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"gpat:\", save->g_pat, \"dbgctl:\", save->dbgctl);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"br_from:\", save->br_from, \"br_to:\", save->br_to);\n\tpr_err(\"%-15s %016llx %-13s %016llx\\n\",\n\t       \"excp_from:\", save->last_excp_from,\n\t       \"excp_to:\", save->last_excp_to);\n}"
  },
  {
    "function_name": "avic_unaccelerated_access_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3685-3708",
    "snippet": "static int avic_unaccelerated_access_interception(struct vcpu_svm *svm)\n{\n\tint ret = 0;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t     AVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\tu32 vector = svm->vmcb->control.exit_info_2 &\n\t\t     AVIC_UNACCEL_ACCESS_VECTOR_MASK;\n\tbool write = (svm->vmcb->control.exit_info_1 >> 32) &\n\t\t     AVIC_UNACCEL_ACCESS_WRITE_MASK;\n\tbool trap = is_avic_unaccelerated_access_trap(offset);\n\n\ttrace_kvm_avic_unaccelerated_access(svm->vcpu.vcpu_id, offset,\n\t\t\t\t\t    trap, write, vector);\n\tif (trap) {\n\t\t/* Handling Trap */\n\t\tWARN_ONCE(!write, \"svm: Handling trap read.\\n\");\n\t\tret = avic_unaccel_trap_write(svm);\n\t} else {\n\t\t/* Handling Fault */\n\t\tret = kvm_emulate_instruction(&svm->vcpu, 0);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_UNACCEL_ACCESS_VECTOR_MASK\t\t0xFFFFFFFF",
      "#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0",
      "#define AVIC_UNACCEL_ACCESS_WRITE_MASK\t\t1"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 3704
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_unaccel_trap_write",
          "args": [
            "svm"
          ],
          "line": 3701
        },
        "resolved": true,
        "details": {
          "function_name": "avic_unaccel_trap_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3629-3654",
          "snippet": "static int avic_unaccel_trap_write(struct vcpu_svm *svm)\n{\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t\t\tAVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (avic_handle_apic_id_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_LDR:\n\t\tif (avic_handle_ldr_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_DFR:\n\t\tavic_handle_dfr_update(&svm->vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));\n\n\treturn 1;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_unaccel_trap_write(struct vcpu_svm *svm)\n{\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t\t\tAVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (avic_handle_apic_id_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_LDR:\n\t\tif (avic_handle_ldr_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_DFR:\n\t\tavic_handle_dfr_update(&svm->vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "!write",
            "\"svm: Handling trap read.\\n\""
          ],
          "line": 3700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_avic_unaccelerated_access",
          "args": [
            "svm->vcpu.vcpu_id",
            "offset",
            "trap",
            "write",
            "vector"
          ],
          "line": 3696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_avic_unaccelerated_access_trap",
          "args": [
            "offset"
          ],
          "line": 3694
        },
        "resolved": true,
        "details": {
          "function_name": "is_avic_unaccelerated_access_trap",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3656-3683",
          "snippet": "static bool is_avic_unaccelerated_access_trap(u32 offset)\n{\n\tbool ret = false;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\tcase APIC_EOI:\n\tcase APIC_RRR:\n\tcase APIC_LDR:\n\tcase APIC_DFR:\n\tcase APIC_SPIV:\n\tcase APIC_ESR:\n\tcase APIC_ICR:\n\tcase APIC_LVTT:\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT0:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\tcase APIC_TMICT:\n\tcase APIC_TDCR:\n\t\tret = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool is_avic_unaccelerated_access_trap(u32 offset)\n{\n\tbool ret = false;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\tcase APIC_EOI:\n\tcase APIC_RRR:\n\tcase APIC_LDR:\n\tcase APIC_DFR:\n\tcase APIC_SPIV:\n\tcase APIC_ESR:\n\tcase APIC_ICR:\n\tcase APIC_LVTT:\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT0:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\tcase APIC_TMICT:\n\tcase APIC_TDCR:\n\t\tret = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_UNACCEL_ACCESS_VECTOR_MASK\t\t0xFFFFFFFF\n#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0\n#define AVIC_UNACCEL_ACCESS_WRITE_MASK\t\t1\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_unaccelerated_access_interception(struct vcpu_svm *svm)\n{\n\tint ret = 0;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t     AVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\tu32 vector = svm->vmcb->control.exit_info_2 &\n\t\t     AVIC_UNACCEL_ACCESS_VECTOR_MASK;\n\tbool write = (svm->vmcb->control.exit_info_1 >> 32) &\n\t\t     AVIC_UNACCEL_ACCESS_WRITE_MASK;\n\tbool trap = is_avic_unaccelerated_access_trap(offset);\n\n\ttrace_kvm_avic_unaccelerated_access(svm->vcpu.vcpu_id, offset,\n\t\t\t\t\t    trap, write, vector);\n\tif (trap) {\n\t\t/* Handling Trap */\n\t\tWARN_ONCE(!write, \"svm: Handling trap read.\\n\");\n\t\tret = avic_unaccel_trap_write(svm);\n\t} else {\n\t\t/* Handling Fault */\n\t\tret = kvm_emulate_instruction(&svm->vcpu, 0);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "is_avic_unaccelerated_access_trap",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3656-3683",
    "snippet": "static bool is_avic_unaccelerated_access_trap(u32 offset)\n{\n\tbool ret = false;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\tcase APIC_EOI:\n\tcase APIC_RRR:\n\tcase APIC_LDR:\n\tcase APIC_DFR:\n\tcase APIC_SPIV:\n\tcase APIC_ESR:\n\tcase APIC_ICR:\n\tcase APIC_LVTT:\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT0:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\tcase APIC_TMICT:\n\tcase APIC_TDCR:\n\t\tret = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool is_avic_unaccelerated_access_trap(u32 offset)\n{\n\tbool ret = false;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\tcase APIC_EOI:\n\tcase APIC_RRR:\n\tcase APIC_LDR:\n\tcase APIC_DFR:\n\tcase APIC_SPIV:\n\tcase APIC_ESR:\n\tcase APIC_ICR:\n\tcase APIC_LVTT:\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT0:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR:\n\tcase APIC_TMICT:\n\tcase APIC_TDCR:\n\t\tret = true;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "avic_unaccel_trap_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3629-3654",
    "snippet": "static int avic_unaccel_trap_write(struct vcpu_svm *svm)\n{\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t\t\tAVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (avic_handle_apic_id_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_LDR:\n\t\tif (avic_handle_ldr_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_DFR:\n\t\tavic_handle_dfr_update(&svm->vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));\n\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "offset",
            "kvm_lapic_get_reg(apic, offset)"
          ],
          "line": 3651
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1902-2044",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "offset"
          ],
          "line": 3651
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_handle_dfr_update",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3645
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_dfr_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3617-3627",
          "snippet": "static void avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\n\tif (svm->dfr_reg == dfr)\n\t\treturn;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\tsvm->dfr_reg = dfr;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\n\tif (svm->dfr_reg == dfr)\n\t\treturn;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\tsvm->dfr_reg = dfr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_handle_ldr_update",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3641
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_ldr_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3567-3586",
          "snippet": "static int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret = 0;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (ldr == svm->ldr_reg)\n\t\treturn 0;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\n\tif (ldr)\n\t\tret = avic_ldr_write(vcpu, id, ldr);\n\n\tif (!ret)\n\t\tsvm->ldr_reg = ldr;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret = 0;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (ldr == svm->ldr_reg)\n\t\treturn 0;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\n\tif (ldr)\n\t\tret = avic_ldr_write(vcpu, id, ldr);\n\n\tif (!ret)\n\t\tsvm->ldr_reg = ldr;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_handle_apic_id_update",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3637
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_apic_id_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3588-3615",
          "snippet": "static int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_UNACCEL_ACCESS_OFFSET_MASK\t\t0xFF0\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_unaccel_trap_write(struct vcpu_svm *svm)\n{\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\tu32 offset = svm->vmcb->control.exit_info_1 &\n\t\t\t\tAVIC_UNACCEL_ACCESS_OFFSET_MASK;\n\n\tswitch (offset) {\n\tcase APIC_ID:\n\t\tif (avic_handle_apic_id_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_LDR:\n\t\tif (avic_handle_ldr_update(&svm->vcpu))\n\t\t\treturn 0;\n\t\tbreak;\n\tcase APIC_DFR:\n\t\tavic_handle_dfr_update(&svm->vcpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tkvm_lapic_reg_write(apic, offset, kvm_lapic_get_reg(apic, offset));\n\n\treturn 1;\n}"
  },
  {
    "function_name": "avic_handle_dfr_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3617-3627",
    "snippet": "static void avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\n\tif (svm->dfr_reg == dfr)\n\t\treturn;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\tsvm->dfr_reg = dfr;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_invalidate_logical_id_entry",
          "args": [
            "vcpu"
          ],
          "line": 3625
        },
        "resolved": true,
        "details": {
          "function_name": "avic_invalidate_logical_id_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3557-3565",
          "snippet": "static void avic_invalidate_logical_id_entry(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tbool flat = svm->dfr_reg == APIC_DFR_FLAT;\n\tu32 *entry = avic_get_logical_id_entry(vcpu, svm->ldr_reg, flat);\n\n\tif (entry)\n\t\tclear_bit(AVIC_LOGICAL_ID_ENTRY_VALID_BIT, (unsigned long *)entry);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_LOGICAL_ID_ENTRY_VALID_BIT\t\t\t31"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_LOGICAL_ID_ENTRY_VALID_BIT\t\t\t31\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_invalidate_logical_id_entry(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tbool flat = svm->dfr_reg == APIC_DFR_FLAT;\n\tu32 *entry = avic_get_logical_id_entry(vcpu, svm->ldr_reg, flat);\n\n\tif (entry)\n\t\tclear_bit(AVIC_LOGICAL_ID_ENTRY_VALID_BIT, (unsigned long *)entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "vcpu->arch.apic",
            "APIC_DFR"
          ],
          "line": 3620
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3619
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_handle_dfr_update(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dfr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR);\n\n\tif (svm->dfr_reg == dfr)\n\t\treturn;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\tsvm->dfr_reg = dfr;\n}"
  },
  {
    "function_name": "avic_handle_apic_id_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3588-3615",
    "snippet": "static int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_handle_ldr_update",
          "args": [
            "vcpu"
          ],
          "line": 3612
        },
        "resolved": true,
        "details": {
          "function_name": "avic_handle_ldr_update",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3567-3586",
          "snippet": "static int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret = 0;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (ldr == svm->ldr_reg)\n\t\treturn 0;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\n\tif (ldr)\n\t\tret = avic_ldr_write(vcpu, id, ldr);\n\n\tif (!ret)\n\t\tsvm->ldr_reg = ldr;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret = 0;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (ldr == svm->ldr_reg)\n\t\treturn 0;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\n\tif (ldr)\n\t\tret = avic_ldr_write(vcpu, id, ldr);\n\n\tif (!ret)\n\t\tsvm->ldr_reg = ldr;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3605
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_get_physical_id_entry",
          "args": [
            "vcpu",
            "id"
          ],
          "line": 3598
        },
        "resolved": true,
        "details": {
          "function_name": "avic_get_physical_id_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1407-1419",
          "snippet": "static u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t       unsigned int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(kvm_svm->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
          ],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t       unsigned int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(kvm_svm->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_xapic_id",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 3592
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_xapic_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "252-255",
          "snippet": "static inline u8 kvm_xapic_id(struct kvm_lapic *apic)\n{\n\treturn kvm_lapic_get_reg(apic, APIC_ID) >> 24;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u8 kvm_xapic_id(struct kvm_lapic *apic)\n{\n\treturn kvm_lapic_get_reg(apic, APIC_ID) >> 24;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_handle_apic_id_update(struct kvm_vcpu *vcpu)\n{\n\tu64 *old, *new;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (vcpu->vcpu_id == id)\n\t\treturn 0;\n\n\told = avic_get_physical_id_entry(vcpu, vcpu->vcpu_id);\n\tnew = avic_get_physical_id_entry(vcpu, id);\n\tif (!new || !old)\n\t\treturn 1;\n\n\t/* We need to move physical_id_entry to new offset */\n\t*new = *old;\n\t*old = 0ULL;\n\tto_svm(vcpu)->avic_physical_id_cache = new;\n\n\t/*\n\t * Also update the guest physical APIC ID in the logical\n\t * APIC ID table entry if already setup the LDR.\n\t */\n\tif (svm->ldr_reg)\n\t\tavic_handle_ldr_update(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "avic_handle_ldr_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3567-3586",
    "snippet": "static int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret = 0;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (ldr == svm->ldr_reg)\n\t\treturn 0;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\n\tif (ldr)\n\t\tret = avic_ldr_write(vcpu, id, ldr);\n\n\tif (!ret)\n\t\tsvm->ldr_reg = ldr;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_ldr_write",
          "args": [
            "vcpu",
            "id",
            "ldr"
          ],
          "line": 3580
        },
        "resolved": true,
        "details": {
          "function_name": "avic_ldr_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3538-3555",
          "snippet": "static int avic_ldr_write(struct kvm_vcpu *vcpu, u8 g_physical_id, u32 ldr)\n{\n\tbool flat;\n\tu32 *entry, new_entry;\n\n\tflat = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR) == APIC_DFR_FLAT;\n\tentry = avic_get_logical_id_entry(vcpu, ldr, flat);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK;\n\tnew_entry |= (g_physical_id & AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK);\n\tnew_entry |= AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_LOGICAL_ID_ENTRY_VALID_MASK\t\t(1 << 31)",
            "#define AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK\t(0xFF)"
          ],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_LOGICAL_ID_ENTRY_VALID_MASK\t\t(1 << 31)\n#define AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK\t(0xFF)\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_ldr_write(struct kvm_vcpu *vcpu, u8 g_physical_id, u32 ldr)\n{\n\tbool flat;\n\tu32 *entry, new_entry;\n\n\tflat = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR) == APIC_DFR_FLAT;\n\tentry = avic_get_logical_id_entry(vcpu, ldr, flat);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK;\n\tnew_entry |= (g_physical_id & AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK);\n\tnew_entry |= AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_invalidate_logical_id_entry",
          "args": [
            "vcpu"
          ],
          "line": 3577
        },
        "resolved": true,
        "details": {
          "function_name": "avic_invalidate_logical_id_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3557-3565",
          "snippet": "static void avic_invalidate_logical_id_entry(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tbool flat = svm->dfr_reg == APIC_DFR_FLAT;\n\tu32 *entry = avic_get_logical_id_entry(vcpu, svm->ldr_reg, flat);\n\n\tif (entry)\n\t\tclear_bit(AVIC_LOGICAL_ID_ENTRY_VALID_BIT, (unsigned long *)entry);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_LOGICAL_ID_ENTRY_VALID_BIT\t\t\t31"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_LOGICAL_ID_ENTRY_VALID_BIT\t\t\t31\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_invalidate_logical_id_entry(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tbool flat = svm->dfr_reg == APIC_DFR_FLAT;\n\tu32 *entry = avic_get_logical_id_entry(vcpu, svm->ldr_reg, flat);\n\n\tif (entry)\n\t\tclear_bit(AVIC_LOGICAL_ID_ENTRY_VALID_BIT, (unsigned long *)entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_xapic_id",
          "args": [
            "vcpu->arch.apic"
          ],
          "line": 3572
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_xapic_id",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "252-255",
          "snippet": "static inline u8 kvm_xapic_id(struct kvm_lapic *apic)\n{\n\treturn kvm_lapic_get_reg(apic, APIC_ID) >> 24;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u8 kvm_xapic_id(struct kvm_lapic *apic)\n{\n\treturn kvm_lapic_get_reg(apic, APIC_ID) >> 24;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "vcpu->arch.apic",
            "APIC_LDR"
          ],
          "line": 3571
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3570
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_handle_ldr_update(struct kvm_vcpu *vcpu)\n{\n\tint ret = 0;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ldr = kvm_lapic_get_reg(vcpu->arch.apic, APIC_LDR);\n\tu32 id = kvm_xapic_id(vcpu->arch.apic);\n\n\tif (ldr == svm->ldr_reg)\n\t\treturn 0;\n\n\tavic_invalidate_logical_id_entry(vcpu);\n\n\tif (ldr)\n\t\tret = avic_ldr_write(vcpu, id, ldr);\n\n\tif (!ret)\n\t\tsvm->ldr_reg = ldr;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "avic_invalidate_logical_id_entry",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3557-3565",
    "snippet": "static void avic_invalidate_logical_id_entry(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tbool flat = svm->dfr_reg == APIC_DFR_FLAT;\n\tu32 *entry = avic_get_logical_id_entry(vcpu, svm->ldr_reg, flat);\n\n\tif (entry)\n\t\tclear_bit(AVIC_LOGICAL_ID_ENTRY_VALID_BIT, (unsigned long *)entry);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_LOGICAL_ID_ENTRY_VALID_BIT\t\t\t31"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "AVIC_LOGICAL_ID_ENTRY_VALID_BIT",
            "(unsigned long *)entry"
          ],
          "line": 3564
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "214-222",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_get_logical_id_entry",
          "args": [
            "vcpu",
            "svm->ldr_reg",
            "flat"
          ],
          "line": 3561
        },
        "resolved": true,
        "details": {
          "function_name": "avic_get_logical_id_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3509-3536",
          "snippet": "static u32 *avic_get_logical_id_entry(struct kvm_vcpu *vcpu, u32 ldr, bool flat)\n{\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\tint index;\n\tu32 *logical_apic_id_table;\n\tint dlid = GET_APIC_LOGICAL_ID(ldr);\n\n\tif (!dlid)\n\t\treturn NULL;\n\n\tif (flat) { /* flat */\n\t\tindex = ffs(dlid) - 1;\n\t\tif (index > 7)\n\t\t\treturn NULL;\n\t} else { /* cluster */\n\t\tint cluster = (dlid & 0xf0) >> 4;\n\t\tint apic = ffs(dlid & 0x0f) - 1;\n\n\t\tif ((apic < 0) || (apic > 7) ||\n\t\t    (cluster >= 0xf))\n\t\t\treturn NULL;\n\t\tindex = (cluster << 2) + apic;\n\t}\n\n\tlogical_apic_id_table = (u32 *) page_address(kvm_svm->avic_logical_id_table_page);\n\n\treturn &logical_apic_id_table[index];\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u32 *avic_get_logical_id_entry(struct kvm_vcpu *vcpu, u32 ldr, bool flat)\n{\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\tint index;\n\tu32 *logical_apic_id_table;\n\tint dlid = GET_APIC_LOGICAL_ID(ldr);\n\n\tif (!dlid)\n\t\treturn NULL;\n\n\tif (flat) { /* flat */\n\t\tindex = ffs(dlid) - 1;\n\t\tif (index > 7)\n\t\t\treturn NULL;\n\t} else { /* cluster */\n\t\tint cluster = (dlid & 0xf0) >> 4;\n\t\tint apic = ffs(dlid & 0x0f) - 1;\n\n\t\tif ((apic < 0) || (apic > 7) ||\n\t\t    (cluster >= 0xf))\n\t\t\treturn NULL;\n\t\tindex = (cluster << 2) + apic;\n\t}\n\n\tlogical_apic_id_table = (u32 *) page_address(kvm_svm->avic_logical_id_table_page);\n\n\treturn &logical_apic_id_table[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3559
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_LOGICAL_ID_ENTRY_VALID_BIT\t\t\t31\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_invalidate_logical_id_entry(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tbool flat = svm->dfr_reg == APIC_DFR_FLAT;\n\tu32 *entry = avic_get_logical_id_entry(vcpu, svm->ldr_reg, flat);\n\n\tif (entry)\n\t\tclear_bit(AVIC_LOGICAL_ID_ENTRY_VALID_BIT, (unsigned long *)entry);\n}"
  },
  {
    "function_name": "avic_ldr_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3538-3555",
    "snippet": "static int avic_ldr_write(struct kvm_vcpu *vcpu, u8 g_physical_id, u32 ldr)\n{\n\tbool flat;\n\tu32 *entry, new_entry;\n\n\tflat = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR) == APIC_DFR_FLAT;\n\tentry = avic_get_logical_id_entry(vcpu, ldr, flat);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK;\n\tnew_entry |= (g_physical_id & AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK);\n\tnew_entry |= AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_LOGICAL_ID_ENTRY_VALID_MASK\t\t(1 << 31)",
      "#define AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK\t(0xFF)"
    ],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*entry",
            "new_entry"
          ],
          "line": 3552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*entry"
          ],
          "line": 3548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_get_logical_id_entry",
          "args": [
            "vcpu",
            "ldr",
            "flat"
          ],
          "line": 3544
        },
        "resolved": true,
        "details": {
          "function_name": "avic_get_logical_id_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3509-3536",
          "snippet": "static u32 *avic_get_logical_id_entry(struct kvm_vcpu *vcpu, u32 ldr, bool flat)\n{\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\tint index;\n\tu32 *logical_apic_id_table;\n\tint dlid = GET_APIC_LOGICAL_ID(ldr);\n\n\tif (!dlid)\n\t\treturn NULL;\n\n\tif (flat) { /* flat */\n\t\tindex = ffs(dlid) - 1;\n\t\tif (index > 7)\n\t\t\treturn NULL;\n\t} else { /* cluster */\n\t\tint cluster = (dlid & 0xf0) >> 4;\n\t\tint apic = ffs(dlid & 0x0f) - 1;\n\n\t\tif ((apic < 0) || (apic > 7) ||\n\t\t    (cluster >= 0xf))\n\t\t\treturn NULL;\n\t\tindex = (cluster << 2) + apic;\n\t}\n\n\tlogical_apic_id_table = (u32 *) page_address(kvm_svm->avic_logical_id_table_page);\n\n\treturn &logical_apic_id_table[index];\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u32 *avic_get_logical_id_entry(struct kvm_vcpu *vcpu, u32 ldr, bool flat)\n{\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\tint index;\n\tu32 *logical_apic_id_table;\n\tint dlid = GET_APIC_LOGICAL_ID(ldr);\n\n\tif (!dlid)\n\t\treturn NULL;\n\n\tif (flat) { /* flat */\n\t\tindex = ffs(dlid) - 1;\n\t\tif (index > 7)\n\t\t\treturn NULL;\n\t} else { /* cluster */\n\t\tint cluster = (dlid & 0xf0) >> 4;\n\t\tint apic = ffs(dlid & 0x0f) - 1;\n\n\t\tif ((apic < 0) || (apic > 7) ||\n\t\t    (cluster >= 0xf))\n\t\t\treturn NULL;\n\t\tindex = (cluster << 2) + apic;\n\t}\n\n\tlogical_apic_id_table = (u32 *) page_address(kvm_svm->avic_logical_id_table_page);\n\n\treturn &logical_apic_id_table[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "vcpu->arch.apic",
            "APIC_DFR"
          ],
          "line": 3543
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_LOGICAL_ID_ENTRY_VALID_MASK\t\t(1 << 31)\n#define AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK\t(0xFF)\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_ldr_write(struct kvm_vcpu *vcpu, u8 g_physical_id, u32 ldr)\n{\n\tbool flat;\n\tu32 *entry, new_entry;\n\n\tflat = kvm_lapic_get_reg(vcpu->arch.apic, APIC_DFR) == APIC_DFR_FLAT;\n\tentry = avic_get_logical_id_entry(vcpu, ldr, flat);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = READ_ONCE(*entry);\n\tnew_entry &= ~AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK;\n\tnew_entry |= (g_physical_id & AVIC_LOGICAL_ID_ENTRY_GUEST_PHYSICAL_ID_MASK);\n\tnew_entry |= AVIC_LOGICAL_ID_ENTRY_VALID_MASK;\n\tWRITE_ONCE(*entry, new_entry);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "avic_get_logical_id_entry",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3509-3536",
    "snippet": "static u32 *avic_get_logical_id_entry(struct kvm_vcpu *vcpu, u32 ldr, bool flat)\n{\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\tint index;\n\tu32 *logical_apic_id_table;\n\tint dlid = GET_APIC_LOGICAL_ID(ldr);\n\n\tif (!dlid)\n\t\treturn NULL;\n\n\tif (flat) { /* flat */\n\t\tindex = ffs(dlid) - 1;\n\t\tif (index > 7)\n\t\t\treturn NULL;\n\t} else { /* cluster */\n\t\tint cluster = (dlid & 0xf0) >> 4;\n\t\tint apic = ffs(dlid & 0x0f) - 1;\n\n\t\tif ((apic < 0) || (apic > 7) ||\n\t\t    (cluster >= 0xf))\n\t\t\treturn NULL;\n\t\tindex = (cluster << 2) + apic;\n\t}\n\n\tlogical_apic_id_table = (u32 *) page_address(kvm_svm->avic_logical_id_table_page);\n\n\treturn &logical_apic_id_table[index];\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "kvm_svm->avic_logical_id_table_page"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffs",
          "args": [
            "dlid & 0x0f"
          ],
          "line": 3525
        },
        "resolved": true,
        "details": {
          "function_name": "svm_read_l1_tsc_offset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1198-1206",
          "snippet": "static u64 svm_read_l1_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn svm->nested.hsave->control.tsc_offset;\n\n\treturn vcpu->arch.tsc_offset;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_read_l1_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn svm->nested.hsave->control.tsc_offset;\n\n\treturn vcpu->arch.tsc_offset;\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_APIC_LOGICAL_ID",
          "args": [
            "ldr"
          ],
          "line": 3514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "vcpu->kvm"
          ],
          "line": 3511
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u32 *avic_get_logical_id_entry(struct kvm_vcpu *vcpu, u32 ldr, bool flat)\n{\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\tint index;\n\tu32 *logical_apic_id_table;\n\tint dlid = GET_APIC_LOGICAL_ID(ldr);\n\n\tif (!dlid)\n\t\treturn NULL;\n\n\tif (flat) { /* flat */\n\t\tindex = ffs(dlid) - 1;\n\t\tif (index > 7)\n\t\t\treturn NULL;\n\t} else { /* cluster */\n\t\tint cluster = (dlid & 0xf0) >> 4;\n\t\tint apic = ffs(dlid & 0x0f) - 1;\n\n\t\tif ((apic < 0) || (apic > 7) ||\n\t\t    (cluster >= 0xf))\n\t\t\treturn NULL;\n\t\tindex = (cluster << 2) + apic;\n\t}\n\n\tlogical_apic_id_table = (u32 *) page_address(kvm_svm->avic_logical_id_table_page);\n\n\treturn &logical_apic_id_table[index];\n}"
  },
  {
    "function_name": "avic_incomplete_ipi_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3447-3507",
    "snippet": "static int avic_incomplete_ipi_interception(struct vcpu_svm *svm)\n{\n\tu32 icrh = svm->vmcb->control.exit_info_1 >> 32;\n\tu32 icrl = svm->vmcb->control.exit_info_1;\n\tu32 id = svm->vmcb->control.exit_info_2 >> 32;\n\tu32 index = svm->vmcb->control.exit_info_2 & 0xFF;\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\n\ttrace_kvm_avic_incomplete_ipi(svm->vcpu.vcpu_id, icrh, icrl, id, index);\n\n\tswitch (id) {\n\tcase AVIC_IPI_FAILURE_INVALID_INT_TYPE:\n\t\t/*\n\t\t * AVIC hardware handles the generation of\n\t\t * IPIs when the specified Message Type is Fixed\n\t\t * (also known as fixed delivery mode) and\n\t\t * the Trigger Mode is edge-triggered. The hardware\n\t\t * also supports self and broadcast delivery modes\n\t\t * specified via the Destination Shorthand(DSH)\n\t\t * field of the ICRL. Logical and physical APIC ID\n\t\t * formats are supported. All other IPI types cause\n\t\t * a #VMEXIT, which needs to emulated.\n\t\t */\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, icrh);\n\t\tkvm_lapic_reg_write(apic, APIC_ICR, icrl);\n\t\tbreak;\n\tcase AVIC_IPI_FAILURE_TARGET_NOT_RUNNING: {\n\t\tint i;\n\t\tstruct kvm_vcpu *vcpu;\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\n\t\t/*\n\t\t * At this point, we expect that the AVIC HW has already\n\t\t * set the appropriate IRR bits on the valid target\n\t\t * vcpus. So, we just need to kick the appropriate vcpu.\n\t\t */\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tbool m = kvm_apic_match_dest(vcpu, apic,\n\t\t\t\t\t\t     icrl & APIC_SHORT_MASK,\n\t\t\t\t\t\t     GET_APIC_DEST_FIELD(icrh),\n\t\t\t\t\t\t     icrl & APIC_DEST_MASK);\n\n\t\t\tif (m && !avic_vcpu_is_running(vcpu))\n\t\t\t\tkvm_vcpu_wake_up(vcpu);\n\t\t}\n\t\tbreak;\n\t}\n\tcase AVIC_IPI_FAILURE_INVALID_TARGET:\n\t\tWARN_ONCE(1, \"Invalid IPI target: index=%u, vcpu=%d, icr=%#0x:%#0x\\n\",\n\t\t\t  index, svm->vcpu.vcpu_id, icrh, icrl);\n\t\tbreak;\n\tcase AVIC_IPI_FAILURE_INVALID_BACKING_PAGE:\n\t\tWARN_ONCE(1, \"Invalid backing page\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown IPI interception\\n\");\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unknown IPI interception\\n\""
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Invalid backing page\\n\""
          ],
          "line": 3500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"Invalid IPI target: index=%u, vcpu=%d, icr=%#0x:%#0x\\n\"",
            "index",
            "svm->vcpu.vcpu_id",
            "icrh",
            "icrl"
          ],
          "line": 3496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_wake_up",
          "args": [
            "vcpu"
          ],
          "line": 3491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_vcpu_is_running",
          "args": [
            "vcpu"
          ],
          "line": 3490
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vcpu_is_running",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "319-328",
          "snippet": "static inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "apic",
            "icrl & APIC_SHORT_MASK",
            "GET_APIC_DEST_FIELD(icrh)",
            "icrl & APIC_DEST_MASK"
          ],
          "line": 3485
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "808-830",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "GET_APIC_DEST_FIELD",
          "args": [
            "icrh"
          ],
          "line": 3487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "kvm"
          ],
          "line": 3484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_reg_write",
          "args": [
            "apic",
            "APIC_ICR",
            "icrl"
          ],
          "line": 3471
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_reg_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1902-2044",
          "snippet": "int kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};",
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic const unsigned int apic_lvt_mask[KVM_APIC_LVT_NUM] = {\n\tLVT_MASK ,      /* part LVTT mask, timer mode mask added at runtime */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTTHMR */\n\tLVT_MASK | APIC_MODE_MASK,\t/* LVTPC */\n\tLINT_MASK, LINT_MASK,\t/* LVT0-1 */\n\tLVT_MASK\t\t/* LVTERR */\n};\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nint kvm_lapic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)\n{\n\tint ret = 0;\n\n\ttrace_kvm_apic_write(reg, val);\n\n\tswitch (reg) {\n\tcase APIC_ID:\t\t/* Local APIC ID */\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_xapic_id(apic, val >> 24);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_TASKPRI:\n\t\treport_tpr_access(apic, true);\n\t\tapic_set_tpr(apic, val & 0xff);\n\t\tbreak;\n\n\tcase APIC_EOI:\n\t\tapic_set_eoi(apic);\n\t\tbreak;\n\n\tcase APIC_LDR:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tkvm_apic_set_ldr(apic, val & APIC_LDR_MASK);\n\t\telse\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_DFR:\n\t\tif (!apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_set_reg(apic, APIC_DFR, val | 0x0FFFFFFF);\n\t\t\tapic->vcpu->kvm->arch.apic_map_dirty = true;\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SPIV: {\n\t\tu32 mask = 0x3ff;\n\t\tif (kvm_lapic_get_reg(apic, APIC_LVR) & APIC_LVR_DIRECTED_EOI)\n\t\t\tmask |= APIC_SPIV_DIRECTED_EOI;\n\t\tapic_set_spiv(apic, val & mask);\n\t\tif (!(val & APIC_SPIV_APIC_ENABLED)) {\n\t\t\tint i;\n\t\t\tu32 lvt_val;\n\n\t\t\tfor (i = 0; i < KVM_APIC_LVT_NUM; i++) {\n\t\t\t\tlvt_val = kvm_lapic_get_reg(apic,\n\t\t\t\t\t\t       APIC_LVTT + 0x10 * i);\n\t\t\t\tkvm_lapic_set_reg(apic, APIC_LVTT + 0x10 * i,\n\t\t\t\t\t     lvt_val | APIC_LVT_MASKED);\n\t\t\t}\n\t\t\tapic_update_lvtt(apic);\n\t\t\tatomic_set(&apic->lapic_timer.pending, 0);\n\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ICR:\n\t\t/* No delay here, so we always clear the pending bit */\n\t\tval &= ~(1 << 12);\n\t\tkvm_apic_send_ipi(apic, val, kvm_lapic_get_reg(apic, APIC_ICR2));\n\t\tkvm_lapic_set_reg(apic, APIC_ICR, val);\n\t\tbreak;\n\n\tcase APIC_ICR2:\n\t\tif (!apic_x2apic_mode(apic))\n\t\t\tval &= 0xff000000;\n\t\tkvm_lapic_set_reg(apic, APIC_ICR2, val);\n\t\tbreak;\n\n\tcase APIC_LVT0:\n\t\tapic_manage_nmi_watchdog(apic, val);\n\t\t/* fall through */\n\tcase APIC_LVTTHMR:\n\tcase APIC_LVTPC:\n\tcase APIC_LVT1:\n\tcase APIC_LVTERR: {\n\t\t/* TODO: Check vector */\n\t\tsize_t size;\n\t\tu32 index;\n\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tsize = ARRAY_SIZE(apic_lvt_mask);\n\t\tindex = array_index_nospec(\n\t\t\t\t(reg - APIC_LVTT) >> 4, size);\n\t\tval &= apic_lvt_mask[index];\n\t\tkvm_lapic_set_reg(apic, reg, val);\n\t\tbreak;\n\t}\n\n\tcase APIC_LVTT:\n\t\tif (!kvm_apic_sw_enabled(apic))\n\t\t\tval |= APIC_LVT_MASKED;\n\t\tval &= (apic_lvt_mask[0] | apic->lapic_timer.timer_mode_mask);\n\t\tkvm_lapic_set_reg(apic, APIC_LVTT, val);\n\t\tapic_update_lvtt(apic);\n\t\tbreak;\n\n\tcase APIC_TMICT:\n\t\tif (apic_lvtt_tscdeadline(apic))\n\t\t\tbreak;\n\n\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\tkvm_lapic_set_reg(apic, APIC_TMICT, val);\n\t\tstart_apic_timer(apic);\n\t\tbreak;\n\n\tcase APIC_TDCR: {\n\t\tuint32_t old_divisor = apic->divide_count;\n\n\t\tkvm_lapic_set_reg(apic, APIC_TDCR, val);\n\t\tupdate_divide_count(apic);\n\t\tif (apic->divide_count != old_divisor &&\n\t\t\t\tapic->lapic_timer.period) {\n\t\t\thrtimer_cancel(&apic->lapic_timer.timer);\n\t\t\tupdate_target_expiration(apic, old_divisor);\n\t\t\trestart_apic_timer(apic);\n\t\t}\n\t\tbreak;\n\t}\n\tcase APIC_ESR:\n\t\tif (apic_x2apic_mode(apic) && val != 0)\n\t\t\tret = 1;\n\t\tbreak;\n\n\tcase APIC_SELF_IPI:\n\t\tif (apic_x2apic_mode(apic)) {\n\t\t\tkvm_lapic_reg_write(apic, APIC_ICR, 0x40000 | (val & 0xff));\n\t\t} else\n\t\t\tret = 1;\n\t\tbreak;\n\tdefault:\n\t\tret = 1;\n\t\tbreak;\n\t}\n\n\tkvm_recalculate_apic_map(apic->vcpu->kvm);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_avic_incomplete_ipi",
          "args": [
            "svm->vcpu.vcpu_id",
            "icrh",
            "icrl",
            "id",
            "index"
          ],
          "line": 3455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_incomplete_ipi_interception(struct vcpu_svm *svm)\n{\n\tu32 icrh = svm->vmcb->control.exit_info_1 >> 32;\n\tu32 icrl = svm->vmcb->control.exit_info_1;\n\tu32 id = svm->vmcb->control.exit_info_2 >> 32;\n\tu32 index = svm->vmcb->control.exit_info_2 & 0xFF;\n\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\n\ttrace_kvm_avic_incomplete_ipi(svm->vcpu.vcpu_id, icrh, icrl, id, index);\n\n\tswitch (id) {\n\tcase AVIC_IPI_FAILURE_INVALID_INT_TYPE:\n\t\t/*\n\t\t * AVIC hardware handles the generation of\n\t\t * IPIs when the specified Message Type is Fixed\n\t\t * (also known as fixed delivery mode) and\n\t\t * the Trigger Mode is edge-triggered. The hardware\n\t\t * also supports self and broadcast delivery modes\n\t\t * specified via the Destination Shorthand(DSH)\n\t\t * field of the ICRL. Logical and physical APIC ID\n\t\t * formats are supported. All other IPI types cause\n\t\t * a #VMEXIT, which needs to emulated.\n\t\t */\n\t\tkvm_lapic_reg_write(apic, APIC_ICR2, icrh);\n\t\tkvm_lapic_reg_write(apic, APIC_ICR, icrl);\n\t\tbreak;\n\tcase AVIC_IPI_FAILURE_TARGET_NOT_RUNNING: {\n\t\tint i;\n\t\tstruct kvm_vcpu *vcpu;\n\t\tstruct kvm *kvm = svm->vcpu.kvm;\n\t\tstruct kvm_lapic *apic = svm->vcpu.arch.apic;\n\n\t\t/*\n\t\t * At this point, we expect that the AVIC HW has already\n\t\t * set the appropriate IRR bits on the valid target\n\t\t * vcpus. So, we just need to kick the appropriate vcpu.\n\t\t */\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tbool m = kvm_apic_match_dest(vcpu, apic,\n\t\t\t\t\t\t     icrl & APIC_SHORT_MASK,\n\t\t\t\t\t\t     GET_APIC_DEST_FIELD(icrh),\n\t\t\t\t\t\t     icrl & APIC_DEST_MASK);\n\n\t\t\tif (m && !avic_vcpu_is_running(vcpu))\n\t\t\t\tkvm_vcpu_wake_up(vcpu);\n\t\t}\n\t\tbreak;\n\t}\n\tcase AVIC_IPI_FAILURE_INVALID_TARGET:\n\t\tWARN_ONCE(1, \"Invalid IPI target: index=%u, vcpu=%d, icr=%#0x:%#0x\\n\",\n\t\t\t  index, svm->vcpu.vcpu_id, icrh, icrl);\n\t\tbreak;\n\tcase AVIC_IPI_FAILURE_INVALID_BACKING_PAGE:\n\t\tWARN_ONCE(1, \"Invalid backing page\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_err(\"Unknown IPI interception\\n\");\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "mwait_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3434-3438",
    "snippet": "static int mwait_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nop_interception",
          "args": [
            "svm"
          ],
          "line": 3437
        },
        "resolved": true,
        "details": {
          "function_name": "nop_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3423-3426",
          "snippet": "static int nop_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_skip_emulated_instruction(&(svm->vcpu));\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int nop_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_skip_emulated_instruction(&(svm->vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\""
          ],
          "line": 3436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic int mwait_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MWAIT instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}"
  },
  {
    "function_name": "monitor_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3428-3432",
    "snippet": "static int monitor_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nop_interception",
          "args": [
            "svm"
          ],
          "line": 3431
        },
        "resolved": true,
        "details": {
          "function_name": "nop_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3423-3426",
          "snippet": "static int nop_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_skip_emulated_instruction(&(svm->vcpu));\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int nop_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_skip_emulated_instruction(&(svm->vcpu));\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_once",
          "args": [
            "KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\""
          ],
          "line": 3430
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic int monitor_interception(struct vcpu_svm *svm)\n{\n\tprintk_once(KERN_WARNING \"kvm: MONITOR instruction emulated as NOP!\\n\");\n\treturn nop_interception(svm);\n}"
  },
  {
    "function_name": "nop_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3423-3426",
    "snippet": "static int nop_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_skip_emulated_instruction(&(svm->vcpu));\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "&(svm->vcpu)"
          ],
          "line": 3425
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int nop_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_skip_emulated_instruction(&(svm->vcpu));\n}"
  },
  {
    "function_name": "pause_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3411-3421",
    "snippet": "static int pause_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tbool in_kernel = (svm_get_cpl(vcpu) == 0);\n\n\tif (pause_filter_thresh)\n\t\tgrow_ple_window(vcpu);\n\n\tkvm_vcpu_on_spin(vcpu, in_kernel);\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_on_spin",
          "args": [
            "vcpu",
            "in_kernel"
          ],
          "line": 3419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grow_ple_window",
          "args": [
            "vcpu"
          ],
          "line": 3417
        },
        "resolved": true,
        "details": {
          "function_name": "grow_ple_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "947-963",
          "snippet": "static void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tcontrol->pause_filter_count = __grow_ple_window(old,\n\t\t\t\t\t\t\tpause_filter_count,\n\t\t\t\t\t\t\tpause_filter_count_grow,\n\t\t\t\t\t\t\tpause_filter_count_max);\n\n\tif (control->pause_filter_count != old) {\n\t\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;",
            "static unsigned short pause_filter_count_grow = KVM_DEFAULT_PLE_WINDOW_GROW;",
            "static unsigned short pause_filter_count_max = KVM_SVM_DEFAULT_PLE_WINDOW_MAX;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nstatic unsigned short pause_filter_count_grow = KVM_DEFAULT_PLE_WINDOW_GROW;\nstatic unsigned short pause_filter_count_max = KVM_SVM_DEFAULT_PLE_WINDOW_MAX;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tcontrol->pause_filter_count = __grow_ple_window(old,\n\t\t\t\t\t\t\tpause_filter_count,\n\t\t\t\t\t\t\tpause_filter_count_grow,\n\t\t\t\t\t\t\tpause_filter_count_max);\n\n\tif (control->pause_filter_count != old) {\n\t\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_get_cpl",
          "args": [
            "vcpu"
          ],
          "line": 3414
        },
        "resolved": true,
        "details": {
          "function_name": "svm_get_cpl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2229-2234",
          "snippet": "static int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int pause_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tbool in_kernel = (svm_get_cpl(vcpu) == 0);\n\n\tif (pause_filter_thresh)\n\t\tgrow_ple_window(vcpu);\n\n\tkvm_vcpu_on_spin(vcpu, in_kernel);\n\treturn 1;\n}"
  },
  {
    "function_name": "interrupt_window_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3393-3409",
    "snippet": "static int interrupt_window_interception(struct vcpu_svm *svm)\n{\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\tsvm_clear_vintr(svm);\n\n\t/*\n\t * For AVIC, the only reason to end up here is ExtINTs.\n\t * In this case AVIC was temporarily disabled for\n\t * requesting the IRQ window and we have to re-enable it.\n\t */\n\tsvm_toggle_avic_for_irq_window(&svm->vcpu, true);\n\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\t++svm->vcpu.stat.irq_window_exits;\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTR"
          ],
          "line": 3406
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_toggle_avic_for_irq_window",
          "args": [
            "&svm->vcpu",
            "true"
          ],
          "line": 3403
        },
        "resolved": true,
        "details": {
          "function_name": "svm_toggle_avic_for_irq_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4090-4099",
          "snippet": "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate)\n{\n\tif (!avic || !lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tkvm_request_apicv_update(vcpu->kvm, activate,\n\t\t\t\t APICV_INHIBIT_REASON_IRQWIN);\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int avic;",
            "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate)\n{\n\tif (!avic || !lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tkvm_request_apicv_update(vcpu->kvm, activate,\n\t\t\t\t APICV_INHIBIT_REASON_IRQWIN);\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_clear_vintr",
          "args": [
            "svm"
          ],
          "line": 3396
        },
        "resolved": true,
        "details": {
          "function_name": "svm_clear_vintr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2127-2133",
          "snippet": "static void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "&svm->vcpu"
          ],
          "line": 3395
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int interrupt_window_interception(struct vcpu_svm *svm)\n{\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\tsvm_clear_vintr(svm);\n\n\t/*\n\t * For AVIC, the only reason to end up here is ExtINTs.\n\t * In this case AVIC was temporarily disabled for\n\t * requesting the IRQ window and we have to re-enable it.\n\t */\n\tsvm_toggle_avic_for_irq_window(&svm->vcpu, true);\n\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n\t++svm->vcpu.stat.irq_window_exits;\n\treturn 1;\n}"
  },
  {
    "function_name": "msr_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3385-3391",
    "snippet": "static int msr_interception(struct vcpu_svm *svm)\n{\n\tif (svm->vmcb->control.exit_info_1)\n\t\treturn wrmsr_interception(svm);\n\telse\n\t\treturn rdmsr_interception(svm);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rdmsr_interception",
          "args": [
            "svm"
          ],
          "line": 3390
        },
        "resolved": true,
        "details": {
          "function_name": "rdmsr_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3191-3194",
          "snippet": "static int rdmsr_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_rdmsr(&svm->vcpu);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int rdmsr_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_rdmsr(&svm->vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrmsr_interception",
          "args": [
            "svm"
          ],
          "line": 3388
        },
        "resolved": true,
        "details": {
          "function_name": "wrmsr_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3380-3383",
          "snippet": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_wrmsr(&svm->vcpu);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int wrmsr_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_wrmsr(&svm->vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic int msr_interception(struct vcpu_svm *svm)\n{\n\tif (svm->vmcb->control.exit_info_1)\n\t\treturn wrmsr_interception(svm);\n\telse\n\t\treturn rdmsr_interception(svm);\n}"
  },
  {
    "function_name": "wrmsr_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3380-3383",
    "snippet": "static int wrmsr_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_wrmsr(&svm->vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_wrmsr",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3382
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_wrmsr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1559-1572",
          "snippet": "int kvm_emulate_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data = kvm_read_edx_eax(vcpu);\n\n\tif (kvm_set_msr(vcpu, ecx, data)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_write(ecx, data);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_wrmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data = kvm_read_edx_eax(vcpu);\n\n\tif (kvm_set_msr(vcpu, ecx, data)) {\n\t\ttrace_kvm_msr_write_ex(ecx, data);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_write(ecx, data);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int wrmsr_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_wrmsr(&svm->vcpu);\n}"
  },
  {
    "function_name": "svm_set_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3221-3378",
    "snippet": "static int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tu32 ecx = msr->index;\n\tu64 data = msr->data;\n\tswitch (ecx) {\n\tcase MSR_IA32_CR_PAT:\n\t\tif (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))\n\t\t\treturn 1;\n\t\tvcpu->arch.pat = data;\n\t\tsvm->vmcb->save.g_pat = data;\n\t\tmark_dirty(svm->vmcb, VMCB_NPT);\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_STIBP) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBRS) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_SSBD))\n\t\t\treturn 1;\n\n\t\tif (data & ~kvm_spec_ctrl_valid_bits(vcpu))\n\t\t\treturn 1;\n\n\t\tsvm->spec_ctrl = data;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_svm_vmrun_msrpm.\n\t\t * We update the L1 MSR bit as well since it will end up\n\t\t * touching the MSR anyway now.\n\t\t */\n\t\tset_msr_interception(svm->msrpm, MSR_IA32_SPEC_CTRL, 1, 1);\n\t\tbreak;\n\tcase MSR_IA32_PRED_CMD:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBPB))\n\t\t\treturn 1;\n\n\t\tif (data & ~PRED_CMD_IBPB)\n\t\t\treturn 1;\n\t\tif (!boot_cpu_has(X86_FEATURE_AMD_IBPB))\n\t\t\treturn 1;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\twrmsrl(MSR_IA32_PRED_CMD, PRED_CMD_IBPB);\n\t\tset_msr_interception(svm->msrpm, MSR_IA32_PRED_CMD, 0, 1);\n\t\tbreak;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_VIRT_SSBD))\n\t\t\treturn 1;\n\n\t\tif (data & ~SPEC_CTRL_SSBD)\n\t\t\treturn 1;\n\n\t\tsvm->virt_spec_ctrl = data;\n\t\tbreak;\n\tcase MSR_STAR:\n\t\tsvm->vmcb->save.star = data;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tsvm->vmcb->save.lstar = data;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tsvm->vmcb->save.cstar = data;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tsvm->vmcb->save.kernel_gs_base = data;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tsvm->vmcb->save.sfmask = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tsvm->vmcb->save.sysenter_cs = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tsvm->sysenter_eip = data;\n\t\tsvm->vmcb->save.sysenter_eip = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tsvm->sysenter_esp = data;\n\t\tsvm->vmcb->save.sysenter_esp = data;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!boot_cpu_has(X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * This is rare, so we update the MSR here instead of using\n\t\t * direct_access_msrs.  Doing that would require a rdmsr in\n\t\t * svm_vcpu_put.\n\t\t */\n\t\tsvm->tsc_aux = data;\n\t\twrmsrl(MSR_TSC_AUX, svm->tsc_aux);\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!boot_cpu_has(X86_FEATURE_LBRV)) {\n\t\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTL 0x%llx, nop\\n\",\n\t\t\t\t    __func__, data);\n\t\t\tbreak;\n\t\t}\n\t\tif (data & DEBUGCTL_RESERVED_BITS)\n\t\t\treturn 1;\n\n\t\tsvm->vmcb->save.dbgctl = data;\n\t\tmark_dirty(svm->vmcb, VMCB_LBR);\n\t\tif (data & (1ULL<<0))\n\t\t\tsvm_enable_lbrv(svm);\n\t\telse\n\t\t\tsvm_disable_lbrv(svm);\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tsvm->nested.hsave_msr = data;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\treturn svm_set_vm_cr(vcpu, data);\n\tcase MSR_VM_IGNNE:\n\t\tvcpu_unimpl(vcpu, \"unimplemented wrmsr: 0x%x data 0x%llx\\n\", ecx, data);\n\t\tbreak;\n\tcase MSR_F10H_DECFG: {\n\t\tstruct kvm_msr_entry msr_entry;\n\n\t\tmsr_entry.index = msr->index;\n\t\tif (svm_get_msr_feature(&msr_entry))\n\t\t\treturn 1;\n\n\t\t/* Check the supported bits */\n\t\tif (data & ~msr_entry.data)\n\t\t\treturn 1;\n\n\t\t/* Don't allow the guest to change a bit, #GP */\n\t\tif (!msr->host_initiated && (data ^ msr_entry.data))\n\t\t\treturn 1;\n\n\t\tsvm->msr_decfg = data;\n\t\tbreak;\n\t}\n\tcase MSR_IA32_APICBASE:\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tavic_update_vapic_bar(to_svm(vcpu), data);\n\t\t/* Fall through */\n\tdefault:\n\t\treturn kvm_set_msr_common(vcpu, msr);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define DEBUGCTL_RESERVED_BITS (~(0x3fULL))"
    ],
    "globals_used": [
      "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};",
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_set_msr_common",
          "args": [
            "vcpu",
            "msr"
          ],
          "line": 3375
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_msr_common",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "2730-3000",
          "snippet": "int kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t\tbreak;\n\n\tcase MSR_IA32_UCODE_REV:\n\t\tif (msr_info->host_initiated)\n\t\t\tvcpu->arch.microcode_version = data;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.arch_capabilities = data;\n\t\tbreak;\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, msr_info);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\n\t\t/* Handle McStatusWrEn */\n\t\tif (data == BIT_ULL(18)) {\n\t\t\tvcpu->arch.msr_hwcr = data;\n\t\t} else if (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_TSC_ADJUST)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tif (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT) &&\n\t\t    ((vcpu->arch.ia32_misc_enable_msr ^ data) & MSR_IA32_MISC_ENABLE_MWAIT)) {\n\t\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_XMM3))\n\t\t\t\treturn 1;\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t\tkvm_update_cpuid(vcpu);\n\t\t} else {\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tvcpu->arch.msr_ia32_power_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\t/*\n\t\t * KVM supports exposing PT to the guest, but does not support\n\t\t * IA32_XSS[bit 8]. Guests have to use RDMSR/WRMSR rather than\n\t\t * XSAVES/XRSTORS to save/restore PT MSRs.\n\t\t */\n\t\tif (data & ~supported_xss)\n\t\t\treturn 1;\n\t\tvcpu->arch.ia32_xss = data;\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smi_count = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tvcpu->arch.pv_time_enabled = false;\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tif (!kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data, sizeof(u8)))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_KVM_POLL_CONTROL:\n\t\t/* only enable bit supported */\n\t\tif (data & (-1ULL << 1))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.msr_kvm_poll_control = data;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr_info);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tif (report_ignored_msrs)\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\tmsr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated ||\n\t\t    (!(data & MSR_PLATFORM_INFO_CPUID_FAULT) &&\n\t\t     cpuid_fault_enabled(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_platform_info = data;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tif (data & ~MSR_MISC_FEATURES_ENABLES_CPUID_FAULT ||\n\t\t    (data & MSR_MISC_FEATURES_ENABLES_CPUID_FAULT &&\n\t\t     !supports_cpuid_fault(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_misc_features_enables = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_debug_ratelimited(vcpu, \"unhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (report_ignored_msrs)\n\t\t\t\tvcpu_unimpl(vcpu,\n\t\t\t\t\t\"ignored wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\t\tmsr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tbool pr = false;\n\tu32 msr = msr_info->index;\n\tu64 data = msr_info->data;\n\n\tswitch (msr) {\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_IA32_UCODE_WRITE:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_AMD64_PATCH_LOADER:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t\tbreak;\n\n\tcase MSR_IA32_UCODE_REV:\n\t\tif (msr_info->host_initiated)\n\t\t\tvcpu->arch.microcode_version = data;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.arch_capabilities = data;\n\t\tbreak;\n\tcase MSR_EFER:\n\t\treturn set_efer(vcpu, msr_info);\n\tcase MSR_K7_HWCR:\n\t\tdata &= ~(u64)0x40;\t/* ignore flush filter disable */\n\t\tdata &= ~(u64)0x100;\t/* ignore ignne emulation enable */\n\t\tdata &= ~(u64)0x8;\t/* ignore TLB cache disable */\n\n\t\t/* Handle McStatusWrEn */\n\t\tif (data == BIT_ULL(18)) {\n\t\t\tvcpu->arch.msr_hwcr = data;\n\t\t} else if (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented HWCR wrmsr: 0x%llx\\n\",\n\t\t\t\t    data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\t\tif (data != 0) {\n\t\t\tvcpu_unimpl(vcpu, \"unimplemented MMIO_CONF_BASE wrmsr: \"\n\t\t\t\t    \"0x%llx\\n\", data);\n\t\t\treturn 1;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!data) {\n\t\t\t/* We support the non-activated case already */\n\t\t\tbreak;\n\t\t} else if (data & ~(DEBUGCTLMSR_LBR | DEBUGCTLMSR_BTF)) {\n\t\t\t/* Values other than LBR and BTF are vendor-specific,\n\t\t\t   thus reserved and should throw a #GP */\n\t\t\treturn 1;\n\t\t}\n\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTLMSR 0x%llx, nop\\n\",\n\t\t\t    __func__, data);\n\t\tbreak;\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_set_msr(vcpu, msr, data);\n\tcase MSR_IA32_APICBASE:\n\t\treturn kvm_set_apic_base(vcpu, msr_info);\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_write(vcpu, msr, data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tkvm_set_lapic_tscdeadline_msr(vcpu, data);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tif (guest_cpuid_has(vcpu, X86_FEATURE_TSC_ADJUST)) {\n\t\t\tif (!msr_info->host_initiated) {\n\t\t\t\ts64 adj = data - vcpu->arch.ia32_tsc_adjust_msr;\n\t\t\t\tadjust_tsc_offset_guest(vcpu, adj);\n\t\t\t}\n\t\t\tvcpu->arch.ia32_tsc_adjust_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tif (!kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_MISC_ENABLE_NO_MWAIT) &&\n\t\t    ((vcpu->arch.ia32_misc_enable_msr ^ data) & MSR_IA32_MISC_ENABLE_MWAIT)) {\n\t\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_XMM3))\n\t\t\t\treturn 1;\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t\tkvm_update_cpuid(vcpu);\n\t\t} else {\n\t\t\tvcpu->arch.ia32_misc_enable_msr = data;\n\t\t}\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smbase = data;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tvcpu->arch.msr_ia32_power_ctl = data;\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tkvm_write_tsc(vcpu, msr_info);\n\t\tbreak;\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\t/*\n\t\t * KVM supports exposing PT to the guest, but does not support\n\t\t * IA32_XSS[bit 8]. Guests have to use RDMSR/WRMSR rather than\n\t\t * XSAVES/XRSTORS to save/restore PT MSRs.\n\t\t */\n\t\tif (data & ~supported_xss)\n\t\t\treturn 1;\n\t\tvcpu->arch.ia32_xss = data;\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tvcpu->arch.smi_count = data;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\tcase MSR_KVM_WALL_CLOCK:\n\t\tvcpu->kvm->arch.wall_clock = data;\n\t\tkvm_write_wall_clock(vcpu->kvm, data);\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\tcase MSR_KVM_SYSTEM_TIME: {\n\t\tstruct kvm_arch *ka = &vcpu->kvm->arch;\n\n\t\tif (vcpu->vcpu_id == 0 && !msr_info->host_initiated) {\n\t\t\tbool tmp = (msr == MSR_KVM_SYSTEM_TIME);\n\n\t\t\tif (ka->boot_vcpu_runs_old_kvmclock != tmp)\n\t\t\t\tkvm_make_request(KVM_REQ_MASTERCLOCK_UPDATE, vcpu);\n\n\t\t\tka->boot_vcpu_runs_old_kvmclock = tmp;\n\t\t}\n\n\t\tvcpu->arch.time = data;\n\t\tkvm_make_request(KVM_REQ_GLOBAL_CLOCK_UPDATE, vcpu);\n\n\t\t/* we verify if the enable bit is set... */\n\t\tvcpu->arch.pv_time_enabled = false;\n\t\tif (!(data & 1))\n\t\t\tbreak;\n\n\t\tif (!kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t     &vcpu->arch.pv_time, data & ~1ULL,\n\t\t     sizeof(struct pvclock_vcpu_time_info)))\n\t\t\tvcpu->arch.pv_time_enabled = true;\n\n\t\tbreak;\n\t}\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tif (kvm_pv_enable_async_pf(vcpu, data))\n\t\t\treturn 1;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\n\t\tif (unlikely(!sched_info_on()))\n\t\t\treturn 1;\n\n\t\tif (data & KVM_STEAL_RESERVED_MASK)\n\t\t\treturn 1;\n\n\t\tvcpu->arch.st.msr_val = data;\n\n\t\tif (!(data & KVM_MSR_ENABLED))\n\t\t\tbreak;\n\n\t\tkvm_make_request(KVM_REQ_STEAL_UPDATE, vcpu);\n\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tif (kvm_lapic_enable_pv_eoi(vcpu, data, sizeof(u8)))\n\t\t\treturn 1;\n\t\tbreak;\n\n\tcase MSR_KVM_POLL_CONTROL:\n\t\t/* only enable bit supported */\n\t\tif (data & (-1ULL << 1))\n\t\t\treturn 1;\n\n\t\tvcpu->arch.msr_kvm_poll_control = data;\n\t\tbreak;\n\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn set_msr_mce(vcpu, msr_info);\n\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\t\tpr = true; /* fall through */\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\n\t\tif (pr || data != 0)\n\t\t\tvcpu_unimpl(vcpu, \"disabled perfctr wrmsr: \"\n\t\t\t\t    \"0x%x data 0x%llx\\n\", msr, data);\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Ignore all writes to this no longer documented MSR.\n\t\t * Writes are only relevant for old K7 processors,\n\t\t * all pre-dating SVM, but a recommended workaround from\n\t\t * AMD for these chips. It is possible to specify the\n\t\t * affected processor models on the command line, hence\n\t\t * the need to ignore the workaround.\n\t\t */\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_set_msr_common(vcpu, msr, data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* Drop writes to this legacy MSR -- see rdmsr\n\t\t * counterpart for further detail.\n\t\t */\n\t\tif (report_ignored_msrs)\n\t\t\tvcpu_unimpl(vcpu, \"ignored wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\tmsr, data);\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.length = data;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tvcpu->arch.osvw.status = data;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated ||\n\t\t    (!(data & MSR_PLATFORM_INFO_CPUID_FAULT) &&\n\t\t     cpuid_fault_enabled(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_platform_info = data;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tif (data & ~MSR_MISC_FEATURES_ENABLES_CPUID_FAULT ||\n\t\t    (data & MSR_MISC_FEATURES_ENABLES_CPUID_FAULT &&\n\t\t     !supports_cpuid_fault(vcpu)))\n\t\t\treturn 1;\n\t\tvcpu->arch.msr_misc_features_enables = data;\n\t\tbreak;\n\tdefault:\n\t\tif (msr && (msr == vcpu->kvm->arch.xen_hvm_config.msr))\n\t\t\treturn xen_hvm_config(vcpu, data);\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr))\n\t\t\treturn kvm_pmu_set_msr(vcpu, msr_info);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_debug_ratelimited(vcpu, \"unhandled wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\t    msr, data);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (report_ignored_msrs)\n\t\t\t\tvcpu_unimpl(vcpu,\n\t\t\t\t\t\"ignored wrmsr: 0x%x data 0x%llx\\n\",\n\t\t\t\t\tmsr, data);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_update_vapic_bar",
          "args": [
            "to_svm(vcpu)",
            "data"
          ],
          "line": 3372
        },
        "resolved": true,
        "details": {
          "function_name": "avic_update_vapic_bar",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "313-317",
          "snippet": "static inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3372
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 3371
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_get_msr_feature",
          "args": [
            "&msr_entry"
          ],
          "line": 3356
        },
        "resolved": true,
        "details": {
          "function_name": "svm_get_msr_feature",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3070-3084",
          "snippet": "static int svm_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tmsr->data = 0;\n\n\tswitch (msr->index) {\n\tcase MSR_F10H_DECFG:\n\t\tif (boot_cpu_has(X86_FEATURE_LFENCE_RDTSC))\n\t\t\tmsr->data |= MSR_F10H_DECFG_LFENCE_SERIALIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int svm_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tmsr->data = 0;\n\n\tswitch (msr->index) {\n\tcase MSR_F10H_DECFG:\n\t\tif (boot_cpu_has(X86_FEATURE_LFENCE_RDTSC))\n\t\t\tmsr->data |= MSR_F10H_DECFG_LFENCE_SERIALIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"unimplemented wrmsr: 0x%x data 0x%llx\\n\"",
            "ecx",
            "data"
          ],
          "line": 3350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_set_vm_cr",
          "args": [
            "vcpu",
            "data"
          ],
          "line": 3348
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_vm_cr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "3196-3219",
          "snippet": "static int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_disable_lbrv",
          "args": [
            "svm"
          ],
          "line": 3342
        },
        "resolved": true,
        "details": {
          "function_name": "svm_disable_lbrv",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "832-841",
          "snippet": "static void svm_disable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.virt_ext &= ~LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_disable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.virt_ext &= ~LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_enable_lbrv",
          "args": [
            "svm"
          ],
          "line": 3340
        },
        "resolved": true,
        "details": {
          "function_name": "svm_enable_lbrv",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "821-830",
          "snippet": "static void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_LBR"
          ],
          "line": 3338
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vcpu_unimpl",
          "args": [
            "vcpu",
            "\"%s: MSR_IA32_DEBUGCTL 0x%llx, nop\\n\"",
            "__func__",
            "data"
          ],
          "line": 3330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_LBRV"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_TSC_AUX",
            "svm->tsc_aux"
          ],
          "line": 3326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_RDTSCP"
          ],
          "line": 3317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_VIRT_SSBD"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_msr_interception",
          "args": [
            "svm->msrpm",
            "MSR_IA32_PRED_CMD",
            "0",
            "1"
          ],
          "line": 3276
        },
        "resolved": true,
        "details": {
          "function_name": "set_msr_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "738-762",
          "snippet": "static void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_IA32_PRED_CMD",
            "PRED_CMD_IBPB"
          ],
          "line": 3275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_AMD_IBPB"
          ],
          "line": 3270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_spec_ctrl_valid_bits",
          "args": [
            "vcpu"
          ],
          "line": 3243
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_spec_ctrl_valid_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10540-10560",
          "snippet": "u64 kvm_spec_ctrl_valid_bits(struct kvm_vcpu *vcpu)\n{\n\tuint64_t bits = SPEC_CTRL_IBRS | SPEC_CTRL_STIBP | SPEC_CTRL_SSBD;\n\n\t/* The STIBP bit doesn't fault even if it's not advertised */\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) &&\n\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBRS))\n\t\tbits &= ~(SPEC_CTRL_IBRS | SPEC_CTRL_STIBP);\n\tif (!boot_cpu_has(X86_FEATURE_SPEC_CTRL) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_IBRS))\n\t\tbits &= ~(SPEC_CTRL_IBRS | SPEC_CTRL_STIBP);\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL_SSBD) &&\n\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_SSBD))\n\t\tbits &= ~SPEC_CTRL_SSBD;\n\tif (!boot_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tbits &= ~SPEC_CTRL_SSBD;\n\n\treturn bits;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nu64 kvm_spec_ctrl_valid_bits(struct kvm_vcpu *vcpu)\n{\n\tuint64_t bits = SPEC_CTRL_IBRS | SPEC_CTRL_STIBP | SPEC_CTRL_SSBD;\n\n\t/* The STIBP bit doesn't fault even if it's not advertised */\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) &&\n\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBRS))\n\t\tbits &= ~(SPEC_CTRL_IBRS | SPEC_CTRL_STIBP);\n\tif (!boot_cpu_has(X86_FEATURE_SPEC_CTRL) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_IBRS))\n\t\tbits &= ~(SPEC_CTRL_IBRS | SPEC_CTRL_STIBP);\n\n\tif (!guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL_SSBD) &&\n\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_SSBD))\n\t\tbits &= ~SPEC_CTRL_SSBD;\n\tif (!boot_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tbits &= ~SPEC_CTRL_SSBD;\n\n\treturn bits;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mtrr_valid",
          "args": [
            "vcpu",
            "MSR_IA32_CR_PAT",
            "data"
          ],
          "line": 3229
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mtrr_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mtrr.c",
          "lines": "54-93",
          "snippet": "bool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint i;\n\tu64 mask;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn false;\n\n\tif (msr == MSR_IA32_CR_PAT) {\n\t\treturn kvm_pat_valid(data);\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tif (data & ~0xcff)\n\t\t\treturn false;\n\t\treturn valid_mtrr_type(data & 0xff);\n\t} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\n\t\tfor (i = 0; i < 8 ; i++)\n\t\t\tif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/* variable MTRRs */\n\tWARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));\n\n\tmask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\tif ((msr & 1) == 0) {\n\t\t/* MTRR base */\n\t\tif (!valid_mtrr_type(data & 0xff))\n\t\t\treturn false;\n\t\tmask |= 0xf00;\n\t} else\n\t\t/* MTRR mask */\n\t\tmask |= 0x7ff;\n\tif (data & mask) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"mmu.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mtrr.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"mmu.h\"\n#include \"cpuid.h\"\n#include <asm/mtrr.h>\n#include <linux/kvm_host.h>\n\nbool kvm_mtrr_valid(struct kvm_vcpu *vcpu, u32 msr, u64 data)\n{\n\tint i;\n\tu64 mask;\n\n\tif (!msr_mtrr_valid(msr))\n\t\treturn false;\n\n\tif (msr == MSR_IA32_CR_PAT) {\n\t\treturn kvm_pat_valid(data);\n\t} else if (msr == MSR_MTRRdefType) {\n\t\tif (data & ~0xcff)\n\t\t\treturn false;\n\t\treturn valid_mtrr_type(data & 0xff);\n\t} else if (msr >= MSR_MTRRfix64K_00000 && msr <= MSR_MTRRfix4K_F8000) {\n\t\tfor (i = 0; i < 8 ; i++)\n\t\t\tif (!valid_mtrr_type((data >> (i * 8)) & 0xff))\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t/* variable MTRRs */\n\tWARN_ON(!(msr >= 0x200 && msr < 0x200 + 2 * KVM_NR_VAR_MTRR));\n\n\tmask = (~0ULL) << cpuid_maxphyaddr(vcpu);\n\tif ((msr & 1) == 0) {\n\t\t/* MTRR base */\n\t\tif (!valid_mtrr_type(data & 0xff))\n\t\t\treturn false;\n\t\tmask |= 0xf00;\n\t} else\n\t\t/* MTRR mask */\n\t\tmask |= 0x7ff;\n\tif (data & mask) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define DEBUGCTL_RESERVED_BITS (~(0x3fULL))\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tu32 ecx = msr->index;\n\tu64 data = msr->data;\n\tswitch (ecx) {\n\tcase MSR_IA32_CR_PAT:\n\t\tif (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))\n\t\t\treturn 1;\n\t\tvcpu->arch.pat = data;\n\t\tsvm->vmcb->save.g_pat = data;\n\t\tmark_dirty(svm->vmcb, VMCB_NPT);\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_STIBP) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBRS) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_SSBD))\n\t\t\treturn 1;\n\n\t\tif (data & ~kvm_spec_ctrl_valid_bits(vcpu))\n\t\t\treturn 1;\n\n\t\tsvm->spec_ctrl = data;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * For non-nested:\n\t\t * When it's written (to non-zero) for the first time, pass\n\t\t * it through.\n\t\t *\n\t\t * For nested:\n\t\t * The handling of the MSR bitmap for L2 guests is done in\n\t\t * nested_svm_vmrun_msrpm.\n\t\t * We update the L1 MSR bit as well since it will end up\n\t\t * touching the MSR anyway now.\n\t\t */\n\t\tset_msr_interception(svm->msrpm, MSR_IA32_SPEC_CTRL, 1, 1);\n\t\tbreak;\n\tcase MSR_IA32_PRED_CMD:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBPB))\n\t\t\treturn 1;\n\n\t\tif (data & ~PRED_CMD_IBPB)\n\t\t\treturn 1;\n\t\tif (!boot_cpu_has(X86_FEATURE_AMD_IBPB))\n\t\t\treturn 1;\n\t\tif (!data)\n\t\t\tbreak;\n\n\t\twrmsrl(MSR_IA32_PRED_CMD, PRED_CMD_IBPB);\n\t\tset_msr_interception(svm->msrpm, MSR_IA32_PRED_CMD, 0, 1);\n\t\tbreak;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\t\tif (!msr->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_VIRT_SSBD))\n\t\t\treturn 1;\n\n\t\tif (data & ~SPEC_CTRL_SSBD)\n\t\t\treturn 1;\n\n\t\tsvm->virt_spec_ctrl = data;\n\t\tbreak;\n\tcase MSR_STAR:\n\t\tsvm->vmcb->save.star = data;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tsvm->vmcb->save.lstar = data;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tsvm->vmcb->save.cstar = data;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tsvm->vmcb->save.kernel_gs_base = data;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tsvm->vmcb->save.sfmask = data;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tsvm->vmcb->save.sysenter_cs = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tsvm->sysenter_eip = data;\n\t\tsvm->vmcb->save.sysenter_eip = data;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tsvm->sysenter_esp = data;\n\t\tsvm->vmcb->save.sysenter_esp = data;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!boot_cpu_has(X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * This is rare, so we update the MSR here instead of using\n\t\t * direct_access_msrs.  Doing that would require a rdmsr in\n\t\t * svm_vcpu_put.\n\t\t */\n\t\tsvm->tsc_aux = data;\n\t\twrmsrl(MSR_TSC_AUX, svm->tsc_aux);\n\t\tbreak;\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tif (!boot_cpu_has(X86_FEATURE_LBRV)) {\n\t\t\tvcpu_unimpl(vcpu, \"%s: MSR_IA32_DEBUGCTL 0x%llx, nop\\n\",\n\t\t\t\t    __func__, data);\n\t\t\tbreak;\n\t\t}\n\t\tif (data & DEBUGCTL_RESERVED_BITS)\n\t\t\treturn 1;\n\n\t\tsvm->vmcb->save.dbgctl = data;\n\t\tmark_dirty(svm->vmcb, VMCB_LBR);\n\t\tif (data & (1ULL<<0))\n\t\t\tsvm_enable_lbrv(svm);\n\t\telse\n\t\t\tsvm_disable_lbrv(svm);\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tsvm->nested.hsave_msr = data;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\treturn svm_set_vm_cr(vcpu, data);\n\tcase MSR_VM_IGNNE:\n\t\tvcpu_unimpl(vcpu, \"unimplemented wrmsr: 0x%x data 0x%llx\\n\", ecx, data);\n\t\tbreak;\n\tcase MSR_F10H_DECFG: {\n\t\tstruct kvm_msr_entry msr_entry;\n\n\t\tmsr_entry.index = msr->index;\n\t\tif (svm_get_msr_feature(&msr_entry))\n\t\t\treturn 1;\n\n\t\t/* Check the supported bits */\n\t\tif (data & ~msr_entry.data)\n\t\t\treturn 1;\n\n\t\t/* Don't allow the guest to change a bit, #GP */\n\t\tif (!msr->host_initiated && (data ^ msr_entry.data))\n\t\t\treturn 1;\n\n\t\tsvm->msr_decfg = data;\n\t\tbreak;\n\t}\n\tcase MSR_IA32_APICBASE:\n\t\tif (kvm_vcpu_apicv_active(vcpu))\n\t\t\tavic_update_vapic_bar(to_svm(vcpu), data);\n\t\t/* Fall through */\n\tdefault:\n\t\treturn kvm_set_msr_common(vcpu, msr);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_set_vm_cr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3196-3219",
    "snippet": "static int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3198
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_set_vm_cr(struct kvm_vcpu *vcpu, u64 data)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint svm_dis, chg_mask;\n\n\tif (data & ~SVM_VM_CR_VALID_MASK)\n\t\treturn 1;\n\n\tchg_mask = SVM_VM_CR_VALID_MASK;\n\n\tif (svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK)\n\t\tchg_mask &= ~(SVM_VM_CR_SVM_LOCK_MASK | SVM_VM_CR_SVM_DIS_MASK);\n\n\tsvm->nested.vm_cr_msr &= ~chg_mask;\n\tsvm->nested.vm_cr_msr |= (data & chg_mask);\n\n\tsvm_dis = svm->nested.vm_cr_msr & SVM_VM_CR_SVM_DIS_MASK;\n\n\t/* check for svm_disable while efer.svme is set */\n\tif (svm_dis && (vcpu->arch.efer & EFER_SVME))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rdmsr_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3191-3194",
    "snippet": "static int rdmsr_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_rdmsr(&svm->vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_rdmsr",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3193
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_rdmsr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1540-1556",
          "snippet": "int kvm_emulate_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data;\n\n\tif (kvm_get_msr(vcpu, ecx, &data)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_read(ecx, data);\n\n\tkvm_rax_write(vcpu, data & -1u);\n\tkvm_rdx_write(vcpu, (data >> 32) & -1u);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_rdmsr(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data;\n\n\tif (kvm_get_msr(vcpu, ecx, &data)) {\n\t\ttrace_kvm_msr_read_ex(ecx);\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\n\ttrace_kvm_msr_read(ecx, data);\n\n\tkvm_rax_write(vcpu, data & -1u);\n\tkvm_rdx_write(vcpu, (data >> 32) & -1u);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int rdmsr_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_rdmsr(&svm->vcpu);\n}"
  },
  {
    "function_name": "svm_get_msr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3086-3189",
    "snippet": "static int svm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tswitch (msr_info->index) {\n\tcase MSR_STAR:\n\t\tmsr_info->data = svm->vmcb->save.star;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tmsr_info->data = svm->vmcb->save.lstar;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tmsr_info->data = svm->vmcb->save.cstar;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = svm->vmcb->save.kernel_gs_base;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tmsr_info->data = svm->vmcb->save.sfmask;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = svm->vmcb->save.sysenter_cs;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = svm->sysenter_eip;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = svm->sysenter_esp;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!boot_cpu_has(X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\t\tmsr_info->data = svm->tsc_aux;\n\t\tbreak;\n\t/*\n\t * Nobody will change the following 5 values in the VMCB so we can\n\t * safely return them on rdmsr. They will always be 0 until LBRV is\n\t * implemented.\n\t */\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tmsr_info->data = svm->vmcb->save.dbgctl;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.br_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\t\tmsr_info->data = svm->vmcb->save.br_to;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTTOIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_to;\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tmsr_info->data = svm->nested.hsave_msr;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\tmsr_info->data = svm->nested.vm_cr_msr;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_STIBP) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBRS) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_SSBD))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = svm->spec_ctrl;\n\t\tbreak;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_VIRT_SSBD))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = svm->virt_spec_ctrl;\n\t\tbreak;\n\tcase MSR_F15H_IC_CFG: {\n\n\t\tint family, model;\n\n\t\tfamily = guest_cpuid_family(vcpu);\n\t\tmodel  = guest_cpuid_model(vcpu);\n\n\t\tif (family < 0 || model < 0)\n\t\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\n\t\tmsr_info->data = 0;\n\n\t\tif (family == 0x15 &&\n\t\t    (model >= 0x2 && model < 0x20))\n\t\t\tmsr_info->data = 0x1E;\n\t\t}\n\t\tbreak;\n\tcase MSR_F10H_DECFG:\n\t\tmsr_info->data = svm->msr_decfg;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_msr_common",
          "args": [
            "vcpu",
            "msr_info"
          ],
          "line": 3186
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_msr_common",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "3041-3246",
          "snippet": "int kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_IA32_PERF_CTL:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = vcpu->arch.microcode_version;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.arch_capabilities;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tmsr_info->data = vcpu->arch.msr_ia32_power_ctl;\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tmsr_info->data = kvm_scale_tsc(vcpu, rdtsc()) + vcpu->arch.tsc_offset;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tmsr_info->data = vcpu->arch.smi_count;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_POLL_CONTROL:\n\t\tmsr_info->data = vcpu->arch.msr_kvm_poll_control;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data,\n\t\t\t\t   msr_info->host_initiated);\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.ia32_xss;\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !vcpu->kvm->arch.guest_can_read_msr_platform_info)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.msr_platform_info;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tmsr_info->data = vcpu->arch.msr_misc_features_enables;\n\t\tbreak;\n\tcase MSR_K7_HWCR:\n\t\tmsr_info->data = vcpu->arch.msr_hwcr;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_debug_ratelimited(vcpu, \"unhandled rdmsr: 0x%x\\n\",\n\t\t\t\t\t       msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (report_ignored_msrs)\n\t\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\",\n\t\t\t\t\tmsr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define KVM_MAX_MCE_BANKS 32"
          ],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define KVM_MAX_MCE_BANKS 32\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_get_msr_common(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tswitch (msr_info->index) {\n\tcase MSR_IA32_PLATFORM_ID:\n\tcase MSR_IA32_EBL_CR_POWERON:\n\tcase MSR_IA32_DEBUGCTLMSR:\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\tcase MSR_IA32_LASTINTFROMIP:\n\tcase MSR_IA32_LASTINTTOIP:\n\tcase MSR_K8_SYSCFG:\n\tcase MSR_K8_TSEG_ADDR:\n\tcase MSR_K8_TSEG_MASK:\n\tcase MSR_VM_HSAVE_PA:\n\tcase MSR_K8_INT_PENDING_MSG:\n\tcase MSR_AMD64_NB_CFG:\n\tcase MSR_FAM10H_MMIO_CONF_BASE:\n\tcase MSR_AMD64_BU_CFG2:\n\tcase MSR_IA32_PERF_CTL:\n\tcase MSR_AMD64_DC_CFG:\n\tcase MSR_F15H_EX_CFG:\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_F15H_PERF_CTL0 ... MSR_F15H_PERF_CTR5:\n\tcase MSR_K7_EVNTSEL0 ... MSR_K7_EVNTSEL3:\n\tcase MSR_K7_PERFCTR0 ... MSR_K7_PERFCTR3:\n\tcase MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR1:\n\tcase MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL1:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tmsr_info->data = 0;\n\t\tbreak;\n\tcase MSR_IA32_UCODE_REV:\n\t\tmsr_info->data = vcpu->arch.microcode_version;\n\t\tbreak;\n\tcase MSR_IA32_ARCH_CAPABILITIES:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_ARCH_CAPABILITIES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.arch_capabilities;\n\t\tbreak;\n\tcase MSR_IA32_POWER_CTL:\n\t\tmsr_info->data = vcpu->arch.msr_ia32_power_ctl;\n\t\tbreak;\n\tcase MSR_IA32_TSC:\n\t\tmsr_info->data = kvm_scale_tsc(vcpu, rdtsc()) + vcpu->arch.tsc_offset;\n\t\tbreak;\n\tcase MSR_MTRRcap:\n\tcase 0x200 ... 0x2ff:\n\t\treturn kvm_mtrr_get_msr(vcpu, msr_info->index, &msr_info->data);\n\tcase 0xcd: /* fsb frequency */\n\t\tmsr_info->data = 3;\n\t\tbreak;\n\t\t/*\n\t\t * MSR_EBC_FREQUENCY_ID\n\t\t * Conservative value valid for even the basic CPU models.\n\t\t * Models 0,1: 000 in bits 23:21 indicating a bus speed of\n\t\t * 100MHz, model 2 000 in bits 18:16 indicating 100MHz,\n\t\t * and 266MHz for model 3, or 4. Set Core Clock\n\t\t * Frequency to System Bus Frequency Ratio to 1 (bits\n\t\t * 31:24) even though these are only valid for CPU\n\t\t * models > 2, however guests may end up dividing or\n\t\t * multiplying by zero otherwise.\n\t\t */\n\tcase MSR_EBC_FREQUENCY_ID:\n\t\tmsr_info->data = 1 << 24;\n\t\tbreak;\n\tcase MSR_IA32_APICBASE:\n\t\tmsr_info->data = kvm_get_apic_base(vcpu);\n\t\tbreak;\n\tcase APIC_BASE_MSR ... APIC_BASE_MSR + 0x3ff:\n\t\treturn kvm_x2apic_msr_read(vcpu, msr_info->index, &msr_info->data);\n\tcase MSR_IA32_TSCDEADLINE:\n\t\tmsr_info->data = kvm_get_lapic_tscdeadline_msr(vcpu);\n\t\tbreak;\n\tcase MSR_IA32_TSC_ADJUST:\n\t\tmsr_info->data = (u64)vcpu->arch.ia32_tsc_adjust_msr;\n\t\tbreak;\n\tcase MSR_IA32_MISC_ENABLE:\n\t\tmsr_info->data = vcpu->arch.ia32_misc_enable_msr;\n\t\tbreak;\n\tcase MSR_IA32_SMBASE:\n\t\tif (!msr_info->host_initiated)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.smbase;\n\t\tbreak;\n\tcase MSR_SMI_COUNT:\n\t\tmsr_info->data = vcpu->arch.smi_count;\n\t\tbreak;\n\tcase MSR_IA32_PERF_STATUS:\n\t\t/* TSC increment by tick */\n\t\tmsr_info->data = 1000ULL;\n\t\t/* CPU multiplier */\n\t\tmsr_info->data |= (((uint64_t)4ULL) << 40);\n\t\tbreak;\n\tcase MSR_EFER:\n\t\tmsr_info->data = vcpu->arch.efer;\n\t\tbreak;\n\tcase MSR_KVM_WALL_CLOCK:\n\tcase MSR_KVM_WALL_CLOCK_NEW:\n\t\tmsr_info->data = vcpu->kvm->arch.wall_clock;\n\t\tbreak;\n\tcase MSR_KVM_SYSTEM_TIME:\n\tcase MSR_KVM_SYSTEM_TIME_NEW:\n\t\tmsr_info->data = vcpu->arch.time;\n\t\tbreak;\n\tcase MSR_KVM_ASYNC_PF_EN:\n\t\tmsr_info->data = vcpu->arch.apf.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_STEAL_TIME:\n\t\tmsr_info->data = vcpu->arch.st.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_PV_EOI_EN:\n\t\tmsr_info->data = vcpu->arch.pv_eoi.msr_val;\n\t\tbreak;\n\tcase MSR_KVM_POLL_CONTROL:\n\t\tmsr_info->data = vcpu->arch.msr_kvm_poll_control;\n\t\tbreak;\n\tcase MSR_IA32_P5_MC_ADDR:\n\tcase MSR_IA32_P5_MC_TYPE:\n\tcase MSR_IA32_MCG_CAP:\n\tcase MSR_IA32_MCG_CTL:\n\tcase MSR_IA32_MCG_STATUS:\n\tcase MSR_IA32_MC0_CTL ... MSR_IA32_MCx_CTL(KVM_MAX_MCE_BANKS) - 1:\n\t\treturn get_msr_mce(vcpu, msr_info->index, &msr_info->data,\n\t\t\t\t   msr_info->host_initiated);\n\tcase MSR_IA32_XSS:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_XSAVES))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.ia32_xss;\n\t\tbreak;\n\tcase MSR_K7_CLK_CTL:\n\t\t/*\n\t\t * Provide expected ramp-up count for K7. All other\n\t\t * are set to zero, indicating minimum divisors for\n\t\t * every field.\n\t\t *\n\t\t * This prevents guest kernels on AMD host with CPU\n\t\t * type 6, model 8 and higher from exploding due to\n\t\t * the rdmsr failing.\n\t\t */\n\t\tmsr_info->data = 0x20000000;\n\t\tbreak;\n\tcase HV_X64_MSR_GUEST_OS_ID ... HV_X64_MSR_SINT15:\n\tcase HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4:\n\tcase HV_X64_MSR_CRASH_CTL:\n\tcase HV_X64_MSR_STIMER0_CONFIG ... HV_X64_MSR_STIMER3_COUNT:\n\tcase HV_X64_MSR_REENLIGHTENMENT_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_CONTROL:\n\tcase HV_X64_MSR_TSC_EMULATION_STATUS:\n\t\treturn kvm_hv_get_msr_common(vcpu,\n\t\t\t\t\t     msr_info->index, &msr_info->data,\n\t\t\t\t\t     msr_info->host_initiated);\n\tcase MSR_IA32_BBL_CR_CTL3:\n\t\t/* This legacy MSR exists but isn't fully documented in current\n\t\t * silicon.  It is however accessed by winxp in very narrow\n\t\t * scenarios where it sets bit #19, itself documented as\n\t\t * a \"reserved\" bit.  Best effort attempt to source coherent\n\t\t * read data here should the balance of the register be\n\t\t * interpreted by the guest:\n\t\t *\n\t\t * L2 cache control register 3: 64GB range, 256KB size,\n\t\t * enabled, latency 0x1, configured\n\t\t */\n\t\tmsr_info->data = 0xbe702111;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_ID_LENGTH:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.length;\n\t\tbreak;\n\tcase MSR_AMD64_OSVW_STATUS:\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_OSVW))\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.osvw.status;\n\t\tbreak;\n\tcase MSR_PLATFORM_INFO:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !vcpu->kvm->arch.guest_can_read_msr_platform_info)\n\t\t\treturn 1;\n\t\tmsr_info->data = vcpu->arch.msr_platform_info;\n\t\tbreak;\n\tcase MSR_MISC_FEATURES_ENABLES:\n\t\tmsr_info->data = vcpu->arch.msr_misc_features_enables;\n\t\tbreak;\n\tcase MSR_K7_HWCR:\n\t\tmsr_info->data = vcpu->arch.msr_hwcr;\n\t\tbreak;\n\tdefault:\n\t\tif (kvm_pmu_is_valid_msr(vcpu, msr_info->index))\n\t\t\treturn kvm_pmu_get_msr(vcpu, msr_info->index, &msr_info->data);\n\t\tif (!ignore_msrs) {\n\t\t\tvcpu_debug_ratelimited(vcpu, \"unhandled rdmsr: 0x%x\\n\",\n\t\t\t\t\t       msr_info->index);\n\t\t\treturn 1;\n\t\t} else {\n\t\t\tif (report_ignored_msrs)\n\t\t\t\tvcpu_unimpl(vcpu, \"ignored rdmsr: 0x%x\\n\",\n\t\t\t\t\tmsr_info->index);\n\t\t\tmsr_info->data = 0;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_model",
          "args": [
            "vcpu"
          ],
          "line": 3170
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_model",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "238-247",
          "snippet": "static inline int guest_cpuid_model(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tif (!best)\n\t\treturn -1;\n\n\treturn x86_model(best->eax);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int guest_cpuid_model(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tif (!best)\n\t\treturn -1;\n\n\treturn x86_model(best->eax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_family",
          "args": [
            "vcpu"
          ],
          "line": 3169
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_family",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "227-236",
          "snippet": "static inline int guest_cpuid_family(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tif (!best)\n\t\treturn -1;\n\n\treturn x86_family(best->eax);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic inline int guest_cpuid_family(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_cpuid_entry2 *best;\n\n\tbest = kvm_find_cpuid_entry(vcpu, 0x1, 0);\n\tif (!best)\n\t\treturn -1;\n\n\treturn x86_family(best->eax);\n}"
        }
      },
      {
        "call_info": {
          "callee": "guest_cpuid_has",
          "args": [
            "vcpu",
            "X86_FEATURE_VIRT_SSBD"
          ],
          "line": 3160
        },
        "resolved": true,
        "details": {
          "function_name": "guest_cpuid_has",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "195-205",
          "snippet": "static __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline bool guest_cpuid_has(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    unsigned int x86_feature)\n{\n\tu32 *reg;\n\n\treg = guest_cpuid_get_register(vcpu, x86_feature);\n\tif (!reg)\n\t\treturn false;\n\n\treturn *reg & __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_RDTSCP"
          ],
          "line": 3118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 3088
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_get_msr(struct kvm_vcpu *vcpu, struct msr_data *msr_info)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tswitch (msr_info->index) {\n\tcase MSR_STAR:\n\t\tmsr_info->data = svm->vmcb->save.star;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase MSR_LSTAR:\n\t\tmsr_info->data = svm->vmcb->save.lstar;\n\t\tbreak;\n\tcase MSR_CSTAR:\n\t\tmsr_info->data = svm->vmcb->save.cstar;\n\t\tbreak;\n\tcase MSR_KERNEL_GS_BASE:\n\t\tmsr_info->data = svm->vmcb->save.kernel_gs_base;\n\t\tbreak;\n\tcase MSR_SYSCALL_MASK:\n\t\tmsr_info->data = svm->vmcb->save.sfmask;\n\t\tbreak;\n#endif\n\tcase MSR_IA32_SYSENTER_CS:\n\t\tmsr_info->data = svm->vmcb->save.sysenter_cs;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_EIP:\n\t\tmsr_info->data = svm->sysenter_eip;\n\t\tbreak;\n\tcase MSR_IA32_SYSENTER_ESP:\n\t\tmsr_info->data = svm->sysenter_esp;\n\t\tbreak;\n\tcase MSR_TSC_AUX:\n\t\tif (!boot_cpu_has(X86_FEATURE_RDTSCP))\n\t\t\treturn 1;\n\t\tmsr_info->data = svm->tsc_aux;\n\t\tbreak;\n\t/*\n\t * Nobody will change the following 5 values in the VMCB so we can\n\t * safely return them on rdmsr. They will always be 0 until LBRV is\n\t * implemented.\n\t */\n\tcase MSR_IA32_DEBUGCTLMSR:\n\t\tmsr_info->data = svm->vmcb->save.dbgctl;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.br_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTBRANCHTOIP:\n\t\tmsr_info->data = svm->vmcb->save.br_to;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTFROMIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_from;\n\t\tbreak;\n\tcase MSR_IA32_LASTINTTOIP:\n\t\tmsr_info->data = svm->vmcb->save.last_excp_to;\n\t\tbreak;\n\tcase MSR_VM_HSAVE_PA:\n\t\tmsr_info->data = svm->nested.hsave_msr;\n\t\tbreak;\n\tcase MSR_VM_CR:\n\t\tmsr_info->data = svm->nested.vm_cr_msr;\n\t\tbreak;\n\tcase MSR_IA32_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_SPEC_CTRL) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_STIBP) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_IBRS) &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_AMD_SSBD))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = svm->spec_ctrl;\n\t\tbreak;\n\tcase MSR_AMD64_VIRT_SPEC_CTRL:\n\t\tif (!msr_info->host_initiated &&\n\t\t    !guest_cpuid_has(vcpu, X86_FEATURE_VIRT_SSBD))\n\t\t\treturn 1;\n\n\t\tmsr_info->data = svm->virt_spec_ctrl;\n\t\tbreak;\n\tcase MSR_F15H_IC_CFG: {\n\n\t\tint family, model;\n\n\t\tfamily = guest_cpuid_family(vcpu);\n\t\tmodel  = guest_cpuid_model(vcpu);\n\n\t\tif (family < 0 || model < 0)\n\t\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\n\t\tmsr_info->data = 0;\n\n\t\tif (family == 0x15 &&\n\t\t    (model >= 0x2 && model < 0x20))\n\t\t\tmsr_info->data = 0x1E;\n\t\t}\n\t\tbreak;\n\tcase MSR_F10H_DECFG:\n\t\tmsr_info->data = svm->msr_decfg;\n\t\tbreak;\n\tdefault:\n\t\treturn kvm_get_msr_common(vcpu, msr_info);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_get_msr_feature",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3070-3084",
    "snippet": "static int svm_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tmsr->data = 0;\n\n\tswitch (msr->index) {\n\tcase MSR_F10H_DECFG:\n\t\tif (boot_cpu_has(X86_FEATURE_LFENCE_RDTSC))\n\t\t\tmsr->data |= MSR_F10H_DECFG_LFENCE_SERIALIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_LFENCE_RDTSC"
          ],
          "line": 3076
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int svm_get_msr_feature(struct kvm_msr_entry *msr)\n{\n\tmsr->data = 0;\n\n\tswitch (msr->index) {\n\tcase MSR_F10H_DECFG:\n\t\tif (boot_cpu_has(X86_FEATURE_LFENCE_RDTSC))\n\t\t\tmsr->data |= MSR_F10H_DECFG_LFENCE_SERIALIZE;\n\t\tbreak;\n\tdefault:\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cr8_write_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3054-3068",
    "snippet": "static int cr8_write_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tint r;\n\n\tu8 cr8_prev = kvm_get_cr8(&svm->vcpu);\n\t/* instruction emulation calls kvm_set_cr8() */\n\tr = cr_interception(svm);\n\tif (lapic_in_kernel(&svm->vcpu))\n\t\treturn r;\n\tif (cr8_prev <= kvm_get_cr8(&svm->vcpu))\n\t\treturn r;\n\tkvm_run->exit_reason = KVM_EXIT_SET_TPR;\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_get_cr8",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3064
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_cr8",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1041-1047",
          "snippet": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lapic_in_kernel",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3062
        },
        "resolved": true,
        "details": {
          "function_name": "lapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "168-173",
          "snippet": "static inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool lapic_in_kernel(struct kvm_vcpu *vcpu)\n{\n\tif (static_key_false(&kvm_no_apic_vcpu))\n\t\treturn vcpu->arch.apic;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cr_interception",
          "args": [
            "svm"
          ],
          "line": 3061
        },
        "resolved": true,
        "details": {
          "function_name": "cr_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2946-3015",
          "snippet": "static int cr_interception(struct vcpu_svm *svm)\n{\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_CR0_SEL_WRITE)\n\t\tcr = SVM_EXIT_WRITE_CR0 - SVM_EXIT_READ_CR0;\n\telse\n\t\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(svm, val))\n\t\t\t\terr = kvm_set_cr0(&svm->vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = svm->vcpu.arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\treturn kvm_complete_insn_gp(&svm->vcpu, err);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define CR_VALID (1ULL << 63)"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define CR_VALID (1ULL << 63)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int cr_interception(struct vcpu_svm *svm)\n{\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_CR0_SEL_WRITE)\n\t\tcr = SVM_EXIT_WRITE_CR0 - SVM_EXIT_READ_CR0;\n\telse\n\t\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(svm, val))\n\t\t\t\terr = kvm_set_cr0(&svm->vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = svm->vcpu.arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\treturn kvm_complete_insn_gp(&svm->vcpu, err);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int cr8_write_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tint r;\n\n\tu8 cr8_prev = kvm_get_cr8(&svm->vcpu);\n\t/* instruction emulation calls kvm_set_cr8() */\n\tr = cr_interception(svm);\n\tif (lapic_in_kernel(&svm->vcpu))\n\t\treturn r;\n\tif (cr8_prev <= kvm_get_cr8(&svm->vcpu))\n\t\treturn r;\n\tkvm_run->exit_reason = KVM_EXIT_SET_TPR;\n\treturn 0;\n}"
  },
  {
    "function_name": "dr_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "3017-3052",
    "snippet": "static int dr_interception(struct vcpu_svm *svm)\n{\n\tint reg, dr;\n\tunsigned long val;\n\n\tif (svm->vcpu.guest_debug == 0) {\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tclr_dr_intercepts(svm);\n\t\tsvm->vcpu.arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tdr = svm->vmcb->control.exit_code - SVM_EXIT_READ_DR0;\n\n\tif (dr >= 16) { /* mov to DRn */\n\t\tif (!kvm_require_dr(&svm->vcpu, dr - 16))\n\t\t\treturn 1;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tkvm_set_dr(&svm->vcpu, dr - 16, val);\n\t} else {\n\t\tif (!kvm_require_dr(&svm->vcpu, dr))\n\t\t\treturn 1;\n\t\tkvm_get_dr(&svm->vcpu, dr, &val);\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\n\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3051
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "&svm->vcpu",
            "reg",
            "val"
          ],
          "line": 3048
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-84",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu, int reg,\n\t\t\t\t      unsigned long val)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn;\n\n\tvcpu->arch.regs[reg] = val;\n\tkvm_register_mark_dirty(vcpu, reg);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_write(struct kvm_vcpu *vcpu, int reg,\n\t\t\t\t      unsigned long val)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn;\n\n\tvcpu->arch.regs[reg] = val;\n\tkvm_register_mark_dirty(vcpu, reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_get_dr",
          "args": [
            "&svm->vcpu",
            "dr",
            "&val"
          ],
          "line": 3047
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_dr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1131-1154",
          "snippet": "int kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tsize_t size = ARRAY_SIZE(vcpu->arch.db);\n\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[array_index_nospec(dr, size)];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops.get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_get_dr(struct kvm_vcpu *vcpu, int dr, unsigned long *val)\n{\n\tsize_t size = ARRAY_SIZE(vcpu->arch.db);\n\n\tswitch (dr) {\n\tcase 0 ... 3:\n\t\t*val = vcpu->arch.db[array_index_nospec(dr, size)];\n\t\tbreak;\n\tcase 4:\n\t\t/* fall through */\n\tcase 6:\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_HW_BP)\n\t\t\t*val = vcpu->arch.dr6;\n\t\telse\n\t\t\t*val = kvm_x86_ops.get_dr6(vcpu);\n\t\tbreak;\n\tcase 5:\n\t\t/* fall through */\n\tdefault: /* 7 */\n\t\t*val = vcpu->arch.dr7;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_require_dr",
          "args": [
            "&svm->vcpu",
            "dr"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_require_dr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "656-663",
          "snippet": "bool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)\n{\n\tif ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\treturn true;\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_require_dr(struct kvm_vcpu *vcpu, int dr)\n{\n\tif ((dr != 4 && dr != 5) || !kvm_read_cr4_bits(vcpu, X86_CR4_DE))\n\t\treturn true;\n\n\tkvm_queue_exception(vcpu, UD_VECTOR);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_dr",
          "args": [
            "&svm->vcpu",
            "dr - 16",
            "val"
          ],
          "line": 3043
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_dr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1121-1128",
          "snippet": "int kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tif (__kvm_set_dr(vcpu, dr, val)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_dr(struct kvm_vcpu *vcpu, int dr, unsigned long val)\n{\n\tif (__kvm_set_dr(vcpu, dr, val)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "&svm->vcpu",
            "reg"
          ],
          "line": 3042
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "65-74",
          "snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu, int reg)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn 0;\n\n\tif (!kvm_register_is_available(vcpu, reg))\n\t\tkvm_x86_ops.cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu, int reg)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn 0;\n\n\tif (!kvm_register_is_available(vcpu, reg))\n\t\tkvm_x86_ops.cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_on_interception",
          "args": [
            "svm"
          ],
          "line": 3034
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_on_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2899-2902",
          "snippet": "static int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_instruction(&svm->vcpu, 0);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_instruction(&svm->vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_DECODEASSISTS"
          ],
          "line": 3033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clr_dr_intercepts",
          "args": [
            "svm"
          ],
          "line": 3028
        },
        "resolved": true,
        "details": {
          "function_name": "clr_dr_intercepts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "254-261",
          "snippet": "static inline void clr_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = 0;\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = 0;\n\n\trecalc_intercepts(svm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int dr_interception(struct vcpu_svm *svm)\n{\n\tint reg, dr;\n\tunsigned long val;\n\n\tif (svm->vcpu.guest_debug == 0) {\n\t\t/*\n\t\t * No more DR vmexits; force a reload of the debug registers\n\t\t * and reenter on this instruction.  The next vmexit will\n\t\t * retrieve the full state of the debug registers.\n\t\t */\n\t\tclr_dr_intercepts(svm);\n\t\tsvm->vcpu.arch.switch_db_regs |= KVM_DEBUGREG_WONT_EXIT;\n\t\treturn 1;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tdr = svm->vmcb->control.exit_code - SVM_EXIT_READ_DR0;\n\n\tif (dr >= 16) { /* mov to DRn */\n\t\tif (!kvm_require_dr(&svm->vcpu, dr - 16))\n\t\t\treturn 1;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tkvm_set_dr(&svm->vcpu, dr - 16, val);\n\t} else {\n\t\tif (!kvm_require_dr(&svm->vcpu, dr))\n\t\t\treturn 1;\n\t\tkvm_get_dr(&svm->vcpu, dr, &val);\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\n\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n}"
  },
  {
    "function_name": "cr_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2946-3015",
    "snippet": "static int cr_interception(struct vcpu_svm *svm)\n{\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_CR0_SEL_WRITE)\n\t\tcr = SVM_EXIT_WRITE_CR0 - SVM_EXIT_READ_CR0;\n\telse\n\t\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(svm, val))\n\t\t\t\terr = kvm_set_cr0(&svm->vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = svm->vcpu.arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\treturn kvm_complete_insn_gp(&svm->vcpu, err);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define CR_VALID (1ULL << 63)"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_complete_insn_gp",
          "args": [
            "&svm->vcpu",
            "err"
          ],
          "line": 3014
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_complete_insn_gp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "588-596",
          "snippet": "int kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_write",
          "args": [
            "&svm->vcpu",
            "reg",
            "val"
          ],
          "line": 3012
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "76-84",
          "snippet": "static inline void kvm_register_write(struct kvm_vcpu *vcpu, int reg,\n\t\t\t\t      unsigned long val)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn;\n\n\tvcpu->arch.regs[reg] = val;\n\tkvm_register_mark_dirty(vcpu, reg);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_register_write(struct kvm_vcpu *vcpu, int reg,\n\t\t\t\t      unsigned long val)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn;\n\n\tvcpu->arch.regs[reg] = val;\n\tkvm_register_mark_dirty(vcpu, reg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "&svm->vcpu",
            "UD_VECTOR"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"unhandled read from CR%d\"",
            "cr"
          ],
          "line": 3008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_cr8",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3005
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_get_cr8",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1041-1047",
          "snippet": "unsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nunsigned long kvm_get_cr8(struct kvm_vcpu *vcpu)\n{\n\tif (lapic_in_kernel(vcpu))\n\t\treturn kvm_lapic_get_cr8(vcpu);\n\telse\n\t\treturn vcpu->arch.cr8;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr4",
          "args": [
            "&svm->vcpu"
          ],
          "line": 3002
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr4",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "144-147",
          "snippet": "static inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline ulong kvm_read_cr4(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr4_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2999
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "137-142",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tkvm_x86_ops.cache_reg(vcpu, VCPU_EXREG_CR3);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tkvm_x86_ops.cache_reg(vcpu, VCPU_EXREG_CR3);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr0",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2993
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr0",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "124-127",
          "snippet": "static inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline ulong kvm_read_cr0(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_read_cr0_bits(vcpu, ~0UL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"unhandled write to CR%d\"",
            "cr"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_cr8",
          "args": [
            "&svm->vcpu",
            "val"
          ],
          "line": 2983
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr8",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1029-1038",
          "snippet": "int kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr8(struct kvm_vcpu *vcpu, unsigned long cr8)\n{\n\tif (cr8 & CR8_RESERVED_BITS)\n\t\treturn 1;\n\tif (lapic_in_kernel(vcpu))\n\t\tkvm_lapic_set_tpr(vcpu, cr8);\n\telse\n\t\tvcpu->arch.cr8 = cr8;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr4",
          "args": [
            "&svm->vcpu",
            "val"
          ],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr4",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "953-991",
          "snippet": "int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |\n\t\t\t\t   X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE;\n\n\tif (kvm_valid_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_PCID))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops.set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long old_cr4 = kvm_read_cr4(vcpu);\n\tunsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |\n\t\t\t\t   X86_CR4_SMEP | X86_CR4_SMAP | X86_CR4_PKE;\n\n\tif (kvm_valid_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (is_long_mode(vcpu)) {\n\t\tif (!(cr4 & X86_CR4_PAE))\n\t\t\treturn 1;\n\t} else if (is_paging(vcpu) && (cr4 & X86_CR4_PAE)\n\t\t   && ((cr4 ^ old_cr4) & pdptr_bits)\n\t\t   && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t   kvm_read_cr3(vcpu)))\n\t\treturn 1;\n\n\tif ((cr4 & X86_CR4_PCIDE) && !(old_cr4 & X86_CR4_PCIDE)) {\n\t\tif (!guest_cpuid_has(vcpu, X86_FEATURE_PCID))\n\t\t\treturn 1;\n\n\t\t/* PCID can not be enabled when cr3[11:0]!=000H or EFER.LMA=0 */\n\t\tif ((kvm_read_cr3(vcpu) & X86_CR3_PCID_MASK) || !is_long_mode(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (kvm_x86_ops.set_cr4(vcpu, cr4))\n\t\treturn 1;\n\n\tif (((cr4 ^ old_cr4) & pdptr_bits) ||\n\t    (!(cr4 & X86_CR4_PCIDE) && (old_cr4 & X86_CR4_PCIDE)))\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif ((cr4 ^ old_cr4) & (X86_CR4_OSXSAVE | X86_CR4_PKE))\n\t\tkvm_update_cpuid(vcpu);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr3",
          "args": [
            "&svm->vcpu",
            "val"
          ],
          "line": 2977
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr3",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "994-1026",
          "snippet": "int kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tbool skip_tlb_flush = false;\n#ifdef CONFIG_X86_64\n\tbool pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);\n\n\tif (pcid_enabled) {\n\t\tskip_tlb_flush = cr3 & X86_CR3_PCID_NOFLUSH;\n\t\tcr3 &= ~X86_CR3_PCID_NOFLUSH;\n\t}\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tif (!skip_tlb_flush) {\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu) &&\n\t    (cr3 & rsvd_bits(cpuid_maxphyaddr(vcpu), 63)))\n\t\treturn 1;\n\telse if (is_pae_paging(vcpu) &&\n\t\t !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tkvm_mmu_new_cr3(vcpu, cr3, skip_tlb_flush);\n\tvcpu->arch.cr3 = cr3;\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_CR3);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr3(struct kvm_vcpu *vcpu, unsigned long cr3)\n{\n\tbool skip_tlb_flush = false;\n#ifdef CONFIG_X86_64\n\tbool pcid_enabled = kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE);\n\n\tif (pcid_enabled) {\n\t\tskip_tlb_flush = cr3 & X86_CR3_PCID_NOFLUSH;\n\t\tcr3 &= ~X86_CR3_PCID_NOFLUSH;\n\t}\n#endif\n\n\tif (cr3 == kvm_read_cr3(vcpu) && !pdptrs_changed(vcpu)) {\n\t\tif (!skip_tlb_flush) {\n\t\t\tkvm_mmu_sync_roots(vcpu);\n\t\t\tkvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tif (is_long_mode(vcpu) &&\n\t    (cr3 & rsvd_bits(cpuid_maxphyaddr(vcpu), 63)))\n\t\treturn 1;\n\telse if (is_pae_paging(vcpu) &&\n\t\t !load_pdptrs(vcpu, vcpu->arch.walk_mmu, cr3))\n\t\treturn 1;\n\n\tkvm_mmu_new_cr3(vcpu, cr3, skip_tlb_flush);\n\tvcpu->arch.cr3 = cr3;\n\tkvm_register_mark_available(vcpu, VCPU_EXREG_CR3);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_cr0",
          "args": [
            "&svm->vcpu",
            "val"
          ],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cr0",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "763-819",
          "snippet": "int kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops.set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tunsigned long old_cr0 = kvm_read_cr0(vcpu);\n\tunsigned long update_bits = X86_CR0_PG | X86_CR0_WP;\n\n\tcr0 |= X86_CR0_ET;\n\n#ifdef CONFIG_X86_64\n\tif (cr0 & 0xffffffff00000000UL)\n\t\treturn 1;\n#endif\n\n\tcr0 &= ~CR0_RESERVED_BITS;\n\n\tif ((cr0 & X86_CR0_NW) && !(cr0 & X86_CR0_CD))\n\t\treturn 1;\n\n\tif ((cr0 & X86_CR0_PG) && !(cr0 & X86_CR0_PE))\n\t\treturn 1;\n\n\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n#ifdef CONFIG_X86_64\n\t\tif ((vcpu->arch.efer & EFER_LME)) {\n\t\t\tint cs_db, cs_l;\n\n\t\t\tif (!is_pae(vcpu))\n\t\t\t\treturn 1;\n\t\t\tkvm_x86_ops.get_cs_db_l_bits(vcpu, &cs_db, &cs_l);\n\t\t\tif (cs_l)\n\t\t\t\treturn 1;\n\t\t} else\n#endif\n\t\tif (is_pae(vcpu) && !load_pdptrs(vcpu, vcpu->arch.walk_mmu,\n\t\t\t\t\t\t kvm_read_cr3(vcpu)))\n\t\t\treturn 1;\n\t}\n\n\tif (!(cr0 & X86_CR0_PG) && kvm_read_cr4_bits(vcpu, X86_CR4_PCIDE))\n\t\treturn 1;\n\n\tkvm_x86_ops.set_cr0(vcpu, cr0);\n\n\tif ((cr0 ^ old_cr0) & X86_CR0_PG) {\n\t\tkvm_clear_async_pf_completion_queue(vcpu);\n\t\tkvm_async_pf_hash_reset(vcpu);\n\t}\n\n\tif ((cr0 ^ old_cr0) & update_bits)\n\t\tkvm_mmu_reset_context(vcpu);\n\n\tif (((cr0 ^ old_cr0) & X86_CR0_CD) &&\n\t    kvm_arch_has_noncoherent_dma(vcpu->kvm) &&\n\t    !kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tkvm_zap_gfn_range(vcpu->kvm, 0, ~0ULL);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_selective_cr0_intercepted",
          "args": [
            "svm",
            "val"
          ],
          "line": 2970
        },
        "resolved": true,
        "details": {
          "function_name": "check_selective_cr0_intercepted",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2920-2942",
          "snippet": "static bool check_selective_cr0_intercepted(struct vcpu_svm *svm,\n\t\t\t\t\t    unsigned long val)\n{\n\tunsigned long cr0 = svm->vcpu.arch.cr0;\n\tbool ret = false;\n\tu64 intercept;\n\n\tintercept = svm->nested.intercept;\n\n\tif (!is_guest_mode(&svm->vcpu) ||\n\t    (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic bool check_selective_cr0_intercepted(struct vcpu_svm *svm,\n\t\t\t\t\t    unsigned long val)\n{\n\tunsigned long cr0 = svm->vcpu.arch.cr0;\n\tbool ret = false;\n\tu64 intercept;\n\n\tintercept = svm->nested.intercept;\n\n\tif (!is_guest_mode(&svm->vcpu) ||\n\t    (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_register_read",
          "args": [
            "&svm->vcpu",
            "reg"
          ],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_register_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "65-74",
          "snippet": "static inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu, int reg)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn 0;\n\n\tif (!kvm_register_is_available(vcpu, reg))\n\t\tkvm_x86_ops.cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_register_read(struct kvm_vcpu *vcpu, int reg)\n{\n\tif (WARN_ON_ONCE((unsigned int)reg >= NR_VCPU_REGS))\n\t\treturn 0;\n\n\tif (!kvm_register_is_available(vcpu, reg))\n\t\tkvm_x86_ops.cache_reg(vcpu, reg);\n\n\treturn vcpu->arch.regs[reg];\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_on_interception",
          "args": [
            "svm"
          ],
          "line": 2956
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_on_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2899-2902",
          "snippet": "static int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_instruction(&svm->vcpu, 0);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_instruction(&svm->vcpu, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(svm->vmcb->control.exit_info_1 & CR_VALID) == 0"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_DECODEASSISTS"
          ],
          "line": 2952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define CR_VALID (1ULL << 63)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int cr_interception(struct vcpu_svm *svm)\n{\n\tint reg, cr;\n\tunsigned long val;\n\tint err;\n\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn emulate_on_interception(svm);\n\n\tif (unlikely((svm->vmcb->control.exit_info_1 & CR_VALID) == 0))\n\t\treturn emulate_on_interception(svm);\n\n\treg = svm->vmcb->control.exit_info_1 & SVM_EXITINFO_REG_MASK;\n\tif (svm->vmcb->control.exit_code == SVM_EXIT_CR0_SEL_WRITE)\n\t\tcr = SVM_EXIT_WRITE_CR0 - SVM_EXIT_READ_CR0;\n\telse\n\t\tcr = svm->vmcb->control.exit_code - SVM_EXIT_READ_CR0;\n\n\terr = 0;\n\tif (cr >= 16) { /* mov to cr */\n\t\tcr -= 16;\n\t\tval = kvm_register_read(&svm->vcpu, reg);\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tif (!check_selective_cr0_intercepted(svm, val))\n\t\t\t\terr = kvm_set_cr0(&svm->vcpu, val);\n\t\t\telse\n\t\t\t\treturn 1;\n\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\terr = kvm_set_cr3(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\terr = kvm_set_cr4(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\terr = kvm_set_cr8(&svm->vcpu, val);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled write to CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t} else { /* mov from cr */\n\t\tswitch (cr) {\n\t\tcase 0:\n\t\t\tval = kvm_read_cr0(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tval = svm->vcpu.arch.cr2;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tval = kvm_read_cr3(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tval = kvm_read_cr4(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tval = kvm_get_cr8(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tWARN(1, \"unhandled read from CR%d\", cr);\n\t\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\t\treturn 1;\n\t\t}\n\t\tkvm_register_write(&svm->vcpu, reg, val);\n\t}\n\treturn kvm_complete_insn_gp(&svm->vcpu, err);\n}"
  },
  {
    "function_name": "check_selective_cr0_intercepted",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2920-2942",
    "snippet": "static bool check_selective_cr0_intercepted(struct vcpu_svm *svm,\n\t\t\t\t\t    unsigned long val)\n{\n\tunsigned long cr0 = svm->vcpu.arch.cr0;\n\tbool ret = false;\n\tu64 intercept;\n\n\tintercept = svm->nested.intercept;\n\n\tif (!is_guest_mode(&svm->vcpu) ||\n\t    (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_exit_handled",
          "args": [
            "svm"
          ],
          "line": 2938
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_exit_handled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "708-718",
          "snippet": "int nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_exit_handled(struct vcpu_svm *svm)\n{\n\tint vmexit;\n\n\tvmexit = nested_svm_intercept(svm);\n\n\tif (vmexit == NESTED_EXIT_DONE)\n\t\tnested_svm_vmexit(svm);\n\n\treturn vmexit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2929
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic bool check_selective_cr0_intercepted(struct vcpu_svm *svm,\n\t\t\t\t\t    unsigned long val)\n{\n\tunsigned long cr0 = svm->vcpu.arch.cr0;\n\tbool ret = false;\n\tu64 intercept;\n\n\tintercept = svm->nested.intercept;\n\n\tif (!is_guest_mode(&svm->vcpu) ||\n\t    (!(intercept & (1ULL << INTERCEPT_SELECTIVE_CR0))))\n\t\treturn false;\n\n\tcr0 &= ~SVM_CR0_SELECTIVE_MASK;\n\tval &= ~SVM_CR0_SELECTIVE_MASK;\n\n\tif (cr0 ^ val) {\n\t\tsvm->vmcb->control.exit_code = SVM_EXIT_CR0_SEL_WRITE;\n\t\tret = (nested_svm_exit_handled(svm) == NESTED_EXIT_DONE);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rdpmc_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2909-2918",
    "snippet": "static int rdpmc_interception(struct vcpu_svm *svm)\n{\n\tint err;\n\n\tif (!nrips)\n\t\treturn emulate_on_interception(svm);\n\n\terr = kvm_rdpmc(&svm->vcpu);\n\treturn kvm_complete_insn_gp(&svm->vcpu, err);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nrips = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_complete_insn_gp",
          "args": [
            "&svm->vcpu",
            "err"
          ],
          "line": 2917
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_complete_insn_gp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "588-596",
          "snippet": "int kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_complete_insn_gp(struct kvm_vcpu *vcpu, int err)\n{\n\tif (err)\n\t\tkvm_inject_gp(vcpu, 0);\n\telse\n\t\treturn kvm_skip_emulated_instruction(vcpu);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rdpmc",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2916
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rdpmc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1157-1169",
          "snippet": "bool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_rdpmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_rax_write(vcpu, (u32)data);\n\tkvm_rdx_write(vcpu, data >> 32);\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_rdpmc(struct kvm_vcpu *vcpu)\n{\n\tu32 ecx = kvm_rcx_read(vcpu);\n\tu64 data;\n\tint err;\n\n\terr = kvm_pmu_rdpmc(vcpu, ecx, &data);\n\tif (err)\n\t\treturn err;\n\tkvm_rax_write(vcpu, (u32)data);\n\tkvm_rdx_write(vcpu, data >> 32);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emulate_on_interception",
          "args": [
            "svm"
          ],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "emulate_on_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2899-2902",
          "snippet": "static int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_instruction(&svm->vcpu, 0);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_instruction(&svm->vcpu, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nrips = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int rdpmc_interception(struct vcpu_svm *svm)\n{\n\tint err;\n\n\tif (!nrips)\n\t\treturn emulate_on_interception(svm);\n\n\terr = kvm_rdpmc(&svm->vcpu);\n\treturn kvm_complete_insn_gp(&svm->vcpu, err);\n}"
  },
  {
    "function_name": "rsm_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2904-2907",
    "snippet": "static int rsm_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_instruction_from_buffer(&svm->vcpu, rsm_ins_bytes, 2);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u8 rsm_ins_bytes[] = \"\\x0f\\xaa\";",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_instruction_from_buffer",
          "args": [
            "&svm->vcpu",
            "rsm_ins_bytes",
            "2"
          ],
          "line": 2906
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction_from_buffer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6928-6932",
          "snippet": "int kvm_emulate_instruction_from_buffer(struct kvm_vcpu *vcpu,\n\t\t\t\t\tvoid *insn, int insn_len)\n{\n\treturn x86_emulate_instruction(vcpu, 0, 0, insn, insn_len);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction_from_buffer(struct kvm_vcpu *vcpu,\n\t\t\t\t\tvoid *insn, int insn_len)\n{\n\treturn x86_emulate_instruction(vcpu, 0, 0, insn, insn_len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic u8 rsm_ins_bytes[] = \"\\x0f\\xaa\";\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int rsm_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_instruction_from_buffer(&svm->vcpu, rsm_ins_bytes, 2);\n}"
  },
  {
    "function_name": "emulate_on_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2899-2902",
    "snippet": "static int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_instruction(&svm->vcpu, 0);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 2901
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int emulate_on_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_instruction(&svm->vcpu, 0);\n}"
  },
  {
    "function_name": "invlpg_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2890-2897",
    "snippet": "static int invlpg_interception(struct vcpu_svm *svm)\n{\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn kvm_emulate_instruction(&svm->vcpu, 0);\n\n\tkvm_mmu_invlpg(&svm->vcpu, svm->vmcb->control.exit_info_1);\n\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2896
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_invlpg",
          "args": [
            "&svm->vcpu",
            "svm->vmcb->control.exit_info_1"
          ],
          "line": 2895
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_invlpg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5500-5528",
          "snippet": "void kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tint i;\n\n\t/* INVLPG on a * non-canonical address is a NOP according to the SDM.  */\n\tif (is_noncanonical_address(gva, vcpu))\n\t\treturn;\n\n\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\n\t/*\n\t * INVLPG is required to invalidate any global mappings for the VA,\n\t * irrespective of PCID. Since it would take us roughly similar amount\n\t * of work to determine whether any of the prev_root mappings of the VA\n\t * is marked global, or to just sync it blindly, so we might as well\n\t * just always sync it.\n\t *\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\n\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tint i;\n\n\t/* INVLPG on a * non-canonical address is a NOP according to the SDM.  */\n\tif (is_noncanonical_address(gva, vcpu))\n\t\treturn;\n\n\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\n\t/*\n\t * INVLPG is required to invalidate any global mappings for the VA,\n\t * irrespective of PCID. Since it would take us roughly similar amount\n\t * of work to determine whether any of the prev_root mappings of the VA\n\t * is marked global, or to just sync it blindly, so we might as well\n\t * just always sync it.\n\t *\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\n\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 2893
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_DECODEASSISTS"
          ],
          "line": 2892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int invlpg_interception(struct vcpu_svm *svm)\n{\n\tif (!static_cpu_has(X86_FEATURE_DECODEASSISTS))\n\t\treturn kvm_emulate_instruction(&svm->vcpu, 0);\n\n\tkvm_mmu_invlpg(&svm->vcpu, svm->vmcb->control.exit_info_1);\n\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n}"
  },
  {
    "function_name": "iret_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2880-2888",
    "snippet": "static int iret_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.nmi_window_exits;\n\tclr_intercept(svm, INTERCEPT_IRET);\n\tsvm->vcpu.arch.hflags |= HF_IRET_MASK;\n\tsvm->nmi_iret_rip = kvm_rip_read(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "&svm->vcpu"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2885
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "86-89",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_intercept",
          "args": [
            "svm",
            "INTERCEPT_IRET"
          ],
          "line": 2883
        },
        "resolved": true,
        "details": {
          "function_name": "clr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "290-297",
          "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int iret_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.nmi_window_exits;\n\tclr_intercept(svm, INTERCEPT_IRET);\n\tsvm->vcpu.arch.hflags |= HF_IRET_MASK;\n\tsvm->nmi_iret_rip = kvm_rip_read(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\treturn 1;\n}"
  },
  {
    "function_name": "cpuid_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2875-2878",
    "snippet": "static int cpuid_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_cpuid(&svm->vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_cpuid",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2877
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_cpuid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.c",
          "lines": "1037-1052",
          "snippet": "int kvm_emulate_cpuid(struct kvm_vcpu *vcpu)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\tif (cpuid_fault_enabled(vcpu) && !kvm_require_cpl(vcpu, 0))\n\t\treturn 1;\n\n\teax = kvm_rax_read(vcpu);\n\tecx = kvm_rcx_read(vcpu);\n\tkvm_cpuid(vcpu, &eax, &ebx, &ecx, &edx, false);\n\tkvm_rax_write(vcpu, eax);\n\tkvm_rbx_write(vcpu, ebx);\n\tkvm_rcx_write(vcpu, ecx);\n\tkvm_rdx_write(vcpu, edx);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/processor.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/processor.h>\n#include <linux/sched/stat.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/kvm_host.h>\n\nint kvm_emulate_cpuid(struct kvm_vcpu *vcpu)\n{\n\tu32 eax, ebx, ecx, edx;\n\n\tif (cpuid_fault_enabled(vcpu) && !kvm_require_cpl(vcpu, 0))\n\t\treturn 1;\n\n\teax = kvm_rax_read(vcpu);\n\tecx = kvm_rcx_read(vcpu);\n\tkvm_cpuid(vcpu, &eax, &ebx, &ecx, &edx, false);\n\tkvm_rax_write(vcpu, eax);\n\tkvm_rbx_write(vcpu, ebx);\n\tkvm_rcx_write(vcpu, ecx);\n\tkvm_rdx_write(vcpu, edx);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int cpuid_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_cpuid(&svm->vcpu);\n}"
  },
  {
    "function_name": "task_switch_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2811-2873",
    "snippet": "static int task_switch_interception(struct vcpu_svm *svm)\n{\n\tu16 tss_selector;\n\tint reason;\n\tint int_type = svm->vmcb->control.exit_int_info &\n\t\tSVM_EXITINTINFO_TYPE_MASK;\n\tint int_vec = svm->vmcb->control.exit_int_info & SVM_EVTINJ_VEC_MASK;\n\tuint32_t type =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_TYPE_MASK;\n\tuint32_t idt_v =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_VALID;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\n\ttss_selector = (u16)svm->vmcb->control.exit_info_1;\n\n\tif (svm->vmcb->control.exit_info_2 &\n\t    (1ULL << SVM_EXITINFOSHIFT_TS_REASON_IRET))\n\t\treason = TASK_SWITCH_IRET;\n\telse if (svm->vmcb->control.exit_info_2 &\n\t\t (1ULL << SVM_EXITINFOSHIFT_TS_REASON_JMP))\n\t\treason = TASK_SWITCH_JMP;\n\telse if (idt_v)\n\t\treason = TASK_SWITCH_GATE;\n\telse\n\t\treason = TASK_SWITCH_CALL;\n\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tswitch (type) {\n\t\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\t\tsvm->vcpu.arch.nmi_injected = false;\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t\tif (svm->vmcb->control.exit_info_2 &\n\t\t\t    (1ULL << SVM_EXITINFOSHIFT_TS_HAS_ERROR_CODE)) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\t(u32)svm->vmcb->control.exit_info_2;\n\t\t\t}\n\t\t\tkvm_clear_exception_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\t\tkvm_clear_interrupt_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (reason != TASK_SWITCH_GATE ||\n\t    int_type == SVM_EXITINTINFO_TYPE_SOFT ||\n\t    (int_type == SVM_EXITINTINFO_TYPE_EXEPT &&\n\t     (int_vec == OF_VECTOR || int_vec == BP_VECTOR))) {\n\t\tif (!skip_emulated_instruction(&svm->vcpu))\n\t\t\treturn 0;\n\t}\n\n\tif (int_type != SVM_EXITINTINFO_TYPE_SOFT)\n\t\tint_vec = -1;\n\n\treturn kvm_task_switch(&svm->vcpu, tss_selector, int_vec, reason,\n\t\t\t       has_error_code, error_code);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_task_switch",
          "args": [
            "&svm->vcpu",
            "tss_selector",
            "int_vec",
            "reason",
            "has_error_code",
            "error_code"
          ],
          "line": 2871
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_task_switch",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8961-8981",
          "snippet": "int kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\tif (ret) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\treturn 1;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_task_switch(struct kvm_vcpu *vcpu, u16 tss_selector, int idt_index,\n\t\t    int reason, bool has_error_code, u32 error_code)\n{\n\tstruct x86_emulate_ctxt *ctxt = vcpu->arch.emulate_ctxt;\n\tint ret;\n\n\tinit_emulate_ctxt(vcpu);\n\n\tret = emulator_task_switch(ctxt, tss_selector, idt_index, reason,\n\t\t\t\t   has_error_code, error_code);\n\tif (ret) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_EMULATION;\n\t\tvcpu->run->internal.ndata = 0;\n\t\treturn 0;\n\t}\n\n\tkvm_rip_write(vcpu, ctxt->eip);\n\tkvm_set_rflags(vcpu, ctxt->eflags);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2864
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "455-476",
          "snippet": "static int skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (nrips && svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t} else {\n\t\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\t\tpr_err(\"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\t\tkvm_rip_write(vcpu, svm->next_rip);\n\t}\n\tsvm_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static int nrips = true;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic int nrips = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (nrips && svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t} else {\n\t\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\t\tpr_err(\"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\t\tkvm_rip_write(vcpu, svm->next_rip);\n\t}\n\tsvm_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_interrupt_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2853
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_interrupt_queue",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "64-67",
          "snippet": "static inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.injected = false;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_interrupt_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.interrupt.injected = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_clear_exception_queue",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2850
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_clear_exception_queue",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "50-54",
          "snippet": "static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n\tvcpu->arch.exception.injected = false;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)\n{\n\tvcpu->arch.exception.pending = false;\n\tvcpu->arch.exception.injected = false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int task_switch_interception(struct vcpu_svm *svm)\n{\n\tu16 tss_selector;\n\tint reason;\n\tint int_type = svm->vmcb->control.exit_int_info &\n\t\tSVM_EXITINTINFO_TYPE_MASK;\n\tint int_vec = svm->vmcb->control.exit_int_info & SVM_EVTINJ_VEC_MASK;\n\tuint32_t type =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_TYPE_MASK;\n\tuint32_t idt_v =\n\t\tsvm->vmcb->control.exit_int_info & SVM_EXITINTINFO_VALID;\n\tbool has_error_code = false;\n\tu32 error_code = 0;\n\n\ttss_selector = (u16)svm->vmcb->control.exit_info_1;\n\n\tif (svm->vmcb->control.exit_info_2 &\n\t    (1ULL << SVM_EXITINFOSHIFT_TS_REASON_IRET))\n\t\treason = TASK_SWITCH_IRET;\n\telse if (svm->vmcb->control.exit_info_2 &\n\t\t (1ULL << SVM_EXITINFOSHIFT_TS_REASON_JMP))\n\t\treason = TASK_SWITCH_JMP;\n\telse if (idt_v)\n\t\treason = TASK_SWITCH_GATE;\n\telse\n\t\treason = TASK_SWITCH_CALL;\n\n\tif (reason == TASK_SWITCH_GATE) {\n\t\tswitch (type) {\n\t\tcase SVM_EXITINTINFO_TYPE_NMI:\n\t\t\tsvm->vcpu.arch.nmi_injected = false;\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_EXEPT:\n\t\t\tif (svm->vmcb->control.exit_info_2 &\n\t\t\t    (1ULL << SVM_EXITINFOSHIFT_TS_HAS_ERROR_CODE)) {\n\t\t\t\thas_error_code = true;\n\t\t\t\terror_code =\n\t\t\t\t\t(u32)svm->vmcb->control.exit_info_2;\n\t\t\t}\n\t\t\tkvm_clear_exception_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tcase SVM_EXITINTINFO_TYPE_INTR:\n\t\t\tkvm_clear_interrupt_queue(&svm->vcpu);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (reason != TASK_SWITCH_GATE ||\n\t    int_type == SVM_EXITINTINFO_TYPE_SOFT ||\n\t    (int_type == SVM_EXITINTINFO_TYPE_EXEPT &&\n\t     (int_vec == OF_VECTOR || int_vec == BP_VECTOR))) {\n\t\tif (!skip_emulated_instruction(&svm->vcpu))\n\t\t\treturn 0;\n\t}\n\n\tif (int_type != SVM_EXITINTINFO_TYPE_SOFT)\n\t\tint_vec = -1;\n\n\treturn kvm_task_switch(&svm->vcpu, tss_selector, int_vec, reason,\n\t\t\t       has_error_code, error_code);\n}"
  },
  {
    "function_name": "rdpru_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2805-2809",
    "snippet": "static int rdpru_interception(struct vcpu_svm *svm)\n{\n\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "&svm->vcpu",
            "UD_VECTOR"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int rdpru_interception(struct vcpu_svm *svm)\n{\n\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}"
  },
  {
    "function_name": "xsetbv_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2793-2803",
    "snippet": "static int xsetbv_interception(struct vcpu_svm *svm)\n{\n\tu64 new_bv = kvm_read_edx_eax(&svm->vcpu);\n\tu32 index = kvm_rcx_read(&svm->vcpu);\n\n\tif (kvm_set_xcr(&svm->vcpu, index, new_bv) == 0) {\n\t\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_xcr",
          "args": [
            "&svm->vcpu",
            "index",
            "new_bv"
          ],
          "line": 2798
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_xcr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "897-905",
          "snippet": "int kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops.get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_set_xcr(struct kvm_vcpu *vcpu, u32 index, u64 xcr)\n{\n\tif (kvm_x86_ops.get_cpl(vcpu) != 0 ||\n\t    __kvm_set_xcr(vcpu, index, xcr)) {\n\t\tkvm_inject_gp(vcpu, 0);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rcx_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_edx_eax",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2795
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_edx_eax",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "149-153",
          "snippet": "static inline u64 kvm_read_edx_eax(struct kvm_vcpu *vcpu)\n{\n\treturn (kvm_rax_read(vcpu) & -1u)\n\t\t| ((u64)(kvm_rdx_read(vcpu) & -1u) << 32);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline u64 kvm_read_edx_eax(struct kvm_vcpu *vcpu)\n{\n\treturn (kvm_rax_read(vcpu) & -1u)\n\t\t| ((u64)(kvm_rdx_read(vcpu) & -1u) << 32);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int xsetbv_interception(struct vcpu_svm *svm)\n{\n\tu64 new_bv = kvm_read_edx_eax(&svm->vcpu);\n\tu32 index = kvm_rcx_read(&svm->vcpu);\n\n\tif (kvm_set_xcr(&svm->vcpu, index, new_bv) == 0) {\n\t\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "wbinvd_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2788-2791",
    "snippet": "static int wbinvd_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_wbinvd(&svm->vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_wbinvd",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2790
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_wbinvd",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6012-6016",
          "snippet": "int kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tkvm_emulate_wbinvd_noskip(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_wbinvd(struct kvm_vcpu *vcpu)\n{\n\tkvm_emulate_wbinvd_noskip(vcpu);\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int wbinvd_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_wbinvd(&svm->vcpu);\n}"
  },
  {
    "function_name": "skinit_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2780-2786",
    "snippet": "static int skinit_interception(struct vcpu_svm *svm)\n{\n\ttrace_kvm_skinit(svm->vmcb->save.rip, kvm_rax_read(&svm->vcpu));\n\n\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "&svm->vcpu",
            "UD_VECTOR"
          ],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_skinit",
          "args": [
            "svm->vmcb->save.rip",
            "kvm_rax_read(&svm->vcpu)"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rax_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2782
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int skinit_interception(struct vcpu_svm *svm)\n{\n\ttrace_kvm_skinit(svm->vmcb->save.rip, kvm_rax_read(&svm->vcpu));\n\n\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\treturn 1;\n}"
  },
  {
    "function_name": "invlpga_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2767-2778",
    "snippet": "static int invlpga_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\ttrace_kvm_invlpga(svm->vmcb->save.rip, kvm_rcx_read(&svm->vcpu),\n\t\t\t  kvm_rax_read(&svm->vcpu));\n\n\t/* Let's treat INVLPGA the same as INVLPG (can be optimized!) */\n\tkvm_mmu_invlpg(vcpu, kvm_rax_read(&svm->vcpu));\n\n\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_invlpg",
          "args": [
            "vcpu",
            "kvm_rax_read(&svm->vcpu)"
          ],
          "line": 2775
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_invlpg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5500-5528",
          "snippet": "void kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tint i;\n\n\t/* INVLPG on a * non-canonical address is a NOP according to the SDM.  */\n\tif (is_noncanonical_address(gva, vcpu))\n\t\treturn;\n\n\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\n\t/*\n\t * INVLPG is required to invalidate any global mappings for the VA,\n\t * irrespective of PCID. Since it would take us roughly similar amount\n\t * of work to determine whether any of the prev_root mappings of the VA\n\t * is marked global, or to just sync it blindly, so we might as well\n\t * just always sync it.\n\t *\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\n\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_invlpg(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct kvm_mmu *mmu = vcpu->arch.mmu;\n\tint i;\n\n\t/* INVLPG on a * non-canonical address is a NOP according to the SDM.  */\n\tif (is_noncanonical_address(gva, vcpu))\n\t\treturn;\n\n\tmmu->invlpg(vcpu, gva, mmu->root_hpa);\n\n\t/*\n\t * INVLPG is required to invalidate any global mappings for the VA,\n\t * irrespective of PCID. Since it would take us roughly similar amount\n\t * of work to determine whether any of the prev_root mappings of the VA\n\t * is marked global, or to just sync it blindly, so we might as well\n\t * just always sync it.\n\t *\n\t * Mappings not reachable via the current cr3 or the prev_roots will be\n\t * synced when switching to that cr3, so nothing needs to be done here\n\t * for them.\n\t */\n\tfor (i = 0; i < KVM_MMU_NUM_PREV_ROOTS; i++)\n\t\tif (VALID_PAGE(mmu->prev_roots[i].hpa))\n\t\t\tmmu->invlpg(vcpu, gva, mmu->prev_roots[i].hpa);\n\n\tkvm_x86_ops.tlb_flush_gva(vcpu, gva);\n\t++vcpu->stat.invlpg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rax_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_invlpga",
          "args": [
            "svm->vmcb->save.rip",
            "kvm_rcx_read(&svm->vcpu)",
            "kvm_rax_read(&svm->vcpu)"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rax_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rcx_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2771
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int invlpga_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\ttrace_kvm_invlpga(svm->vmcb->save.rip, kvm_rcx_read(&svm->vcpu),\n\t\t\t  kvm_rax_read(&svm->vcpu));\n\n\t/* Let's treat INVLPGA the same as INVLPG (can be optimized!) */\n\tkvm_mmu_invlpg(vcpu, kvm_rax_read(&svm->vcpu));\n\n\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n}"
  },
  {
    "function_name": "clgi_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2749-2765",
    "snippet": "static int clgi_interception(struct vcpu_svm *svm)\n{\n\tint ret;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\n\tdisable_gif(svm);\n\n\t/* After a CLGI no interrupts should come */\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tsvm_clear_vintr(svm);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_clear_vintr",
          "args": [
            "svm"
          ],
          "line": 2762
        },
        "resolved": true,
        "details": {
          "function_name": "svm_clear_vintr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2127-2133",
          "snippet": "static void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2761
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_gif",
          "args": [
            "svm"
          ],
          "line": 2758
        },
        "resolved": true,
        "details": {
          "function_name": "disable_gif",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "317-323",
          "snippet": "static inline void disable_gif(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\tsvm->vmcb->control.int_ctl &= ~V_GIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void disable_gif(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\tsvm->vmcb->control.int_ctl &= ~V_GIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags &= ~HF_GIF_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_check_permissions",
          "args": [
            "svm"
          ],
          "line": 2753
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_permissions",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "720-734",
          "snippet": "int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME) ||\n\t    !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME) ||\n\t    !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int clgi_interception(struct vcpu_svm *svm)\n{\n\tint ret;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\n\tdisable_gif(svm);\n\n\t/* After a CLGI no interrupts should come */\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tsvm_clear_vintr(svm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "stgi_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2727-2747",
    "snippet": "static int stgi_interception(struct vcpu_svm *svm)\n{\n\tint ret;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\t/*\n\t * If VGIF is enabled, the STGI intercept is only added to\n\t * detect the opening of the SMI/NMI window; remove it now.\n\t */\n\tif (vgif_enabled(svm))\n\t\tclr_intercept(svm, INTERCEPT_STGI);\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tenable_gif(svm);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_gif",
          "args": [
            "svm"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "enable_gif",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "309-315",
          "snippet": "static inline void enable_gif(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void enable_gif(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "&svm->vcpu"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_intercept",
          "args": [
            "svm",
            "INTERCEPT_STGI"
          ],
          "line": 2739
        },
        "resolved": true,
        "details": {
          "function_name": "clr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "290-297",
          "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vgif_enabled",
          "args": [
            "svm"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "vgif_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "304-307",
          "snippet": "static inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool vgif_enabled(struct vcpu_svm *svm)\n{\n\treturn !!(svm->vmcb->control.int_ctl & V_GIF_ENABLE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_check_permissions",
          "args": [
            "svm"
          ],
          "line": 2731
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_permissions",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "720-734",
          "snippet": "int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME) ||\n\t    !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME) ||\n\t    !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int stgi_interception(struct vcpu_svm *svm)\n{\n\tint ret;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\t/*\n\t * If VGIF is enabled, the STGI intercept is only added to\n\t * detect the opening of the SMI/NMI window; remove it now.\n\t */\n\tif (vgif_enabled(svm))\n\t\tclr_intercept(svm, INTERCEPT_STGI);\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\tkvm_make_request(KVM_REQ_EVENT, &svm->vcpu);\n\n\tenable_gif(svm);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vmrun_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2719-2725",
    "snippet": "static int vmrun_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\treturn nested_svm_vmrun(svm);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_svm_vmrun",
          "args": [
            "svm"
          ],
          "line": 2724
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmrun",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "335-420",
          "snippet": "int nested_svm_vmrun(struct vcpu_svm *svm)\n{\n\tint ret;\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_host_map map;\n\tu64 vmcb_gpa;\n\n\tvmcb_gpa = svm->vmcb->save.rax;\n\n\tret = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(vmcb_gpa), &map);\n\tif (ret == -EINVAL) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t} else if (ret) {\n\t\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n\t}\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\n\tnested_vmcb = map.hva;\n\n\tif (!nested_vmcb_checks(nested_vmcb)) {\n\t\tnested_vmcb->control.exit_code    = SVM_EXIT_ERR;\n\t\tnested_vmcb->control.exit_code_hi = 0;\n\t\tnested_vmcb->control.exit_info_1  = 0;\n\t\tnested_vmcb->control.exit_info_2  = 0;\n\n\t\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\t\treturn ret;\n\t}\n\n\ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb_gpa,\n\t\t\t       nested_vmcb->save.rip,\n\t\t\t       nested_vmcb->control.int_ctl,\n\t\t\t       nested_vmcb->control.event_inj,\n\t\t\t       nested_vmcb->control.nested_ctl);\n\n\ttrace_kvm_nested_intercepts(nested_vmcb->control.intercept_cr & 0xffff,\n\t\t\t\t    nested_vmcb->control.intercept_cr >> 16,\n\t\t\t\t    nested_vmcb->control.intercept_exceptions,\n\t\t\t\t    nested_vmcb->control.intercept);\n\n\t/* Clear internal status */\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\t/*\n\t * Save the old vmcb, so we don't need to pick what we save, but can\n\t * restore everything when a VMEXIT occurs\n\t */\n\thsave->save.es     = vmcb->save.es;\n\thsave->save.cs     = vmcb->save.cs;\n\thsave->save.ss     = vmcb->save.ss;\n\thsave->save.ds     = vmcb->save.ds;\n\thsave->save.gdtr   = vmcb->save.gdtr;\n\thsave->save.idtr   = vmcb->save.idtr;\n\thsave->save.efer   = svm->vcpu.arch.efer;\n\thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\thsave->save.cr4    = svm->vcpu.arch.cr4;\n\thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n\thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n\thsave->save.rsp    = vmcb->save.rsp;\n\thsave->save.rax    = vmcb->save.rax;\n\tif (npt_enabled)\n\t\thsave->save.cr3    = vmcb->save.cr3;\n\telse\n\t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\n\tcopy_vmcb_control_area(hsave, vmcb);\n\n\tenter_svm_guest_mode(svm, vmcb_gpa, nested_vmcb, &map);\n\n\tif (!nested_svm_vmrun_msrpm(svm)) {\n\t\tsvm->vmcb->control.exit_code    = SVM_EXIT_ERR;\n\t\tsvm->vmcb->control.exit_code_hi = 0;\n\t\tsvm->vmcb->control.exit_info_1  = 0;\n\t\tsvm->vmcb->control.exit_info_2  = 0;\n\n\t\tnested_svm_vmexit(svm);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_vmrun(struct vcpu_svm *svm)\n{\n\tint ret;\n\tstruct vmcb *nested_vmcb;\n\tstruct vmcb *hsave = svm->nested.hsave;\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_host_map map;\n\tu64 vmcb_gpa;\n\n\tvmcb_gpa = svm->vmcb->save.rax;\n\n\tret = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(vmcb_gpa), &map);\n\tif (ret == -EINVAL) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t} else if (ret) {\n\t\treturn kvm_skip_emulated_instruction(&svm->vcpu);\n\t}\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\n\tnested_vmcb = map.hva;\n\n\tif (!nested_vmcb_checks(nested_vmcb)) {\n\t\tnested_vmcb->control.exit_code    = SVM_EXIT_ERR;\n\t\tnested_vmcb->control.exit_code_hi = 0;\n\t\tnested_vmcb->control.exit_info_1  = 0;\n\t\tnested_vmcb->control.exit_info_2  = 0;\n\n\t\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\t\treturn ret;\n\t}\n\n\ttrace_kvm_nested_vmrun(svm->vmcb->save.rip, vmcb_gpa,\n\t\t\t       nested_vmcb->save.rip,\n\t\t\t       nested_vmcb->control.int_ctl,\n\t\t\t       nested_vmcb->control.event_inj,\n\t\t\t       nested_vmcb->control.nested_ctl);\n\n\ttrace_kvm_nested_intercepts(nested_vmcb->control.intercept_cr & 0xffff,\n\t\t\t\t    nested_vmcb->control.intercept_cr >> 16,\n\t\t\t\t    nested_vmcb->control.intercept_exceptions,\n\t\t\t\t    nested_vmcb->control.intercept);\n\n\t/* Clear internal status */\n\tkvm_clear_exception_queue(&svm->vcpu);\n\tkvm_clear_interrupt_queue(&svm->vcpu);\n\n\t/*\n\t * Save the old vmcb, so we don't need to pick what we save, but can\n\t * restore everything when a VMEXIT occurs\n\t */\n\thsave->save.es     = vmcb->save.es;\n\thsave->save.cs     = vmcb->save.cs;\n\thsave->save.ss     = vmcb->save.ss;\n\thsave->save.ds     = vmcb->save.ds;\n\thsave->save.gdtr   = vmcb->save.gdtr;\n\thsave->save.idtr   = vmcb->save.idtr;\n\thsave->save.efer   = svm->vcpu.arch.efer;\n\thsave->save.cr0    = kvm_read_cr0(&svm->vcpu);\n\thsave->save.cr4    = svm->vcpu.arch.cr4;\n\thsave->save.rflags = kvm_get_rflags(&svm->vcpu);\n\thsave->save.rip    = kvm_rip_read(&svm->vcpu);\n\thsave->save.rsp    = vmcb->save.rsp;\n\thsave->save.rax    = vmcb->save.rax;\n\tif (npt_enabled)\n\t\thsave->save.cr3    = vmcb->save.cr3;\n\telse\n\t\thsave->save.cr3    = kvm_read_cr3(&svm->vcpu);\n\n\tcopy_vmcb_control_area(hsave, vmcb);\n\n\tenter_svm_guest_mode(svm, vmcb_gpa, nested_vmcb, &map);\n\n\tif (!nested_svm_vmrun_msrpm(svm)) {\n\t\tsvm->vmcb->control.exit_code    = SVM_EXIT_ERR;\n\t\tsvm->vmcb->control.exit_code_hi = 0;\n\t\tsvm->vmcb->control.exit_info_1  = 0;\n\t\tsvm->vmcb->control.exit_info_2  = 0;\n\n\t\tnested_svm_vmexit(svm);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_check_permissions",
          "args": [
            "svm"
          ],
          "line": 2721
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_permissions",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "720-734",
          "snippet": "int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME) ||\n\t    !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME) ||\n\t    !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic int vmrun_interception(struct vcpu_svm *svm)\n{\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\treturn nested_svm_vmrun(svm);\n}"
  },
  {
    "function_name": "vmsave_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2693-2717",
    "snippet": "static int vmsave_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct kvm_host_map map;\n\tint ret;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tret = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(svm->vmcb->save.rax), &map);\n\tif (ret) {\n\t\tif (ret == -EINVAL)\n\t\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tnested_vmcb = map.hva;\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(svm->vmcb, nested_vmcb);\n\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_unmap",
          "args": [
            "&svm->vcpu",
            "&map",
            "true"
          ],
          "line": 2714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_svm_vmloadsave",
          "args": [
            "svm->vmcb",
            "nested_vmcb"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmloadsave",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "422-436",
          "snippet": "void nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2711
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 2705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_map",
          "args": [
            "&svm->vcpu",
            "gpa_to_gfn(svm->vmcb->save.rax)",
            "&map"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "svm->vmcb->save.rax"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_svm_check_permissions",
          "args": [
            "svm"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_permissions",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "720-734",
          "snippet": "int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME) ||\n\t    !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME) ||\n\t    !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int vmsave_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct kvm_host_map map;\n\tint ret;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tret = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(svm->vmcb->save.rax), &map);\n\tif (ret) {\n\t\tif (ret == -EINVAL)\n\t\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tnested_vmcb = map.hva;\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(svm->vmcb, nested_vmcb);\n\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vmload_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2667-2691",
    "snippet": "static int vmload_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct kvm_host_map map;\n\tint ret;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tret = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(svm->vmcb->save.rax), &map);\n\tif (ret) {\n\t\tif (ret == -EINVAL)\n\t\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tnested_vmcb = map.hva;\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(nested_vmcb, svm->vmcb);\n\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_unmap",
          "args": [
            "&svm->vcpu",
            "&map",
            "true"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_svm_vmloadsave",
          "args": [
            "nested_vmcb",
            "svm->vmcb"
          ],
          "line": 2687
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_vmloadsave",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "422-436",
          "snippet": "void nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nvoid nested_svm_vmloadsave(struct vmcb *from_vmcb, struct vmcb *to_vmcb)\n{\n\tto_vmcb->save.fs = from_vmcb->save.fs;\n\tto_vmcb->save.gs = from_vmcb->save.gs;\n\tto_vmcb->save.tr = from_vmcb->save.tr;\n\tto_vmcb->save.ldtr = from_vmcb->save.ldtr;\n\tto_vmcb->save.kernel_gs_base = from_vmcb->save.kernel_gs_base;\n\tto_vmcb->save.star = from_vmcb->save.star;\n\tto_vmcb->save.lstar = from_vmcb->save.lstar;\n\tto_vmcb->save.cstar = from_vmcb->save.cstar;\n\tto_vmcb->save.sfmask = from_vmcb->save.sfmask;\n\tto_vmcb->save.sysenter_cs = from_vmcb->save.sysenter_cs;\n\tto_vmcb->save.sysenter_esp = from_vmcb->save.sysenter_esp;\n\tto_vmcb->save.sysenter_eip = from_vmcb->save.sysenter_eip;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6655-6675",
          "snippet": "int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tunsigned long rflags = kvm_x86_ops.get_rflags(vcpu);\n\tint r;\n\n\tr = kvm_x86_ops.skip_emulated_instruction(vcpu);\n\tif (unlikely(!r))\n\t\treturn 0;\n\n\t/*\n\t * rflags is the old, \"raw\" value of the flags.  The new value has\n\t * not been saved yet.\n\t *\n\t * This is correct even for TF set by the guest, because \"the\n\t * processor will not generate this exception after the instruction\n\t * that sets the TF flag\".\n\t */\n\tif (unlikely(rflags & X86_EFLAGS_TF))\n\t\tr = kvm_vcpu_do_singlestep(vcpu);\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_inject_gp",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 2679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_map",
          "args": [
            "&svm->vcpu",
            "gpa_to_gfn(svm->vmcb->save.rax)",
            "&map"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gpa_to_gfn",
          "args": [
            "svm->vmcb->save.rax"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nested_svm_check_permissions",
          "args": [
            "svm"
          ],
          "line": 2673
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_permissions",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "720-734",
          "snippet": "int nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME) ||\n\t    !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_check_permissions(struct vcpu_svm *svm)\n{\n\tif (!(svm->vcpu.arch.efer & EFER_SVME) ||\n\t    !is_paging(&svm->vcpu)) {\n\t\tkvm_queue_exception(&svm->vcpu, UD_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->vmcb->save.cpl) {\n\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int vmload_interception(struct vcpu_svm *svm)\n{\n\tstruct vmcb *nested_vmcb;\n\tstruct kvm_host_map map;\n\tint ret;\n\n\tif (nested_svm_check_permissions(svm))\n\t\treturn 1;\n\n\tret = kvm_vcpu_map(&svm->vcpu, gpa_to_gfn(svm->vmcb->save.rax), &map);\n\tif (ret) {\n\t\tif (ret == -EINVAL)\n\t\t\tkvm_inject_gp(&svm->vcpu, 0);\n\t\treturn 1;\n\t}\n\n\tnested_vmcb = map.hva;\n\n\tret = kvm_skip_emulated_instruction(&svm->vcpu);\n\n\tnested_svm_vmloadsave(nested_vmcb, svm->vmcb);\n\tkvm_vcpu_unmap(&svm->vcpu, &map, true);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "vmmcall_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2662-2665",
    "snippet": "static int vmmcall_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_hypercall(&svm->vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_hypercall",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2664
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_hypercall",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7529-7591",
          "snippet": "int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit;\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_rax_read(vcpu);\n\ta0 = kvm_rbx_read(vcpu);\n\ta1 = kvm_rcx_read(vcpu);\n\ta2 = kvm_rdx_read(vcpu);\n\ta3 = kvm_rsi_read(vcpu);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_mode(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops.get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tkvm_sched_yield(vcpu->kvm, a1);\n\t\tret = 0;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase KVM_HC_CLOCK_PAIRING:\n\t\tret = kvm_pv_clock_pairing(vcpu, a0, a1);\n\t\tbreak;\n#endif\n\tcase KVM_HC_SEND_IPI:\n\t\tret = kvm_pv_send_ipi(vcpu->kvm, a0, a1, a2, a3, op_64_bit);\n\t\tbreak;\n\tcase KVM_HC_SCHED_YIELD:\n\t\tkvm_sched_yield(vcpu->kvm, a0);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_rax_write(vcpu, ret);\n\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_hypercall(struct kvm_vcpu *vcpu)\n{\n\tunsigned long nr, a0, a1, a2, a3, ret;\n\tint op_64_bit;\n\n\tif (kvm_hv_hypercall_enabled(vcpu->kvm))\n\t\treturn kvm_hv_hypercall(vcpu);\n\n\tnr = kvm_rax_read(vcpu);\n\ta0 = kvm_rbx_read(vcpu);\n\ta1 = kvm_rcx_read(vcpu);\n\ta2 = kvm_rdx_read(vcpu);\n\ta3 = kvm_rsi_read(vcpu);\n\n\ttrace_kvm_hypercall(nr, a0, a1, a2, a3);\n\n\top_64_bit = is_64_bit_mode(vcpu);\n\tif (!op_64_bit) {\n\t\tnr &= 0xFFFFFFFF;\n\t\ta0 &= 0xFFFFFFFF;\n\t\ta1 &= 0xFFFFFFFF;\n\t\ta2 &= 0xFFFFFFFF;\n\t\ta3 &= 0xFFFFFFFF;\n\t}\n\n\tif (kvm_x86_ops.get_cpl(vcpu) != 0) {\n\t\tret = -KVM_EPERM;\n\t\tgoto out;\n\t}\n\n\tswitch (nr) {\n\tcase KVM_HC_VAPIC_POLL_IRQ:\n\t\tret = 0;\n\t\tbreak;\n\tcase KVM_HC_KICK_CPU:\n\t\tkvm_pv_kick_cpu_op(vcpu->kvm, a0, a1);\n\t\tkvm_sched_yield(vcpu->kvm, a1);\n\t\tret = 0;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase KVM_HC_CLOCK_PAIRING:\n\t\tret = kvm_pv_clock_pairing(vcpu, a0, a1);\n\t\tbreak;\n#endif\n\tcase KVM_HC_SEND_IPI:\n\t\tret = kvm_pv_send_ipi(vcpu->kvm, a0, a1, a2, a3, op_64_bit);\n\t\tbreak;\n\tcase KVM_HC_SCHED_YIELD:\n\t\tkvm_sched_yield(vcpu->kvm, a0);\n\t\tret = 0;\n\t\tbreak;\n\tdefault:\n\t\tret = -KVM_ENOSYS;\n\t\tbreak;\n\t}\nout:\n\tif (!op_64_bit)\n\t\tret = (u32)ret;\n\tkvm_rax_write(vcpu, ret);\n\n\t++vcpu->stat.hypercalls;\n\treturn kvm_skip_emulated_instruction(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int vmmcall_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_hypercall(&svm->vcpu);\n}"
  },
  {
    "function_name": "halt_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2657-2660",
    "snippet": "static int halt_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_halt(&svm->vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_halt",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2659
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_halt",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7435-7443",
          "snippet": "int kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\tint ret = kvm_skip_emulated_instruction(vcpu);\n\t/*\n\t * TODO: we might be squashing a GUESTDBG_SINGLESTEP-triggered\n\t * KVM_EXIT_DEBUG here.\n\t */\n\treturn kvm_vcpu_halt(vcpu) && ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_halt(struct kvm_vcpu *vcpu)\n{\n\tint ret = kvm_skip_emulated_instruction(vcpu);\n\t/*\n\t * TODO: we might be squashing a GUESTDBG_SINGLESTEP-triggered\n\t * KVM_EXIT_DEBUG here.\n\t */\n\treturn kvm_vcpu_halt(vcpu) && ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int halt_interception(struct vcpu_svm *svm)\n{\n\treturn kvm_emulate_halt(&svm->vcpu);\n}"
  },
  {
    "function_name": "nop_on_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2652-2655",
    "snippet": "static int nop_on_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic int nop_on_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "intr_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2646-2650",
    "snippet": "static int intr_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.irq_exits;\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int intr_interception(struct vcpu_svm *svm)\n{\n\t++svm->vcpu.stat.irq_exits;\n\treturn 1;\n}"
  },
  {
    "function_name": "nmi_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2641-2644",
    "snippet": "static int nmi_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic int nmi_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "io_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2621-2639",
    "snippet": "static int io_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 io_info = svm->vmcb->control.exit_info_1; /* address size bug? */\n\tint size, in, string;\n\tunsigned port;\n\n\t++svm->vcpu.stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tif (string)\n\t\treturn kvm_emulate_instruction(vcpu, 0);\n\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\n\treturn kvm_fast_pio(&svm->vcpu, size, port, in);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_fast_pio",
          "args": [
            "&svm->vcpu",
            "size",
            "port",
            "in"
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_fast_pio",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7022-7031",
          "snippet": "int kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in)\n{\n\tint ret;\n\n\tif (in)\n\t\tret = kvm_fast_pio_in(vcpu, size, port);\n\telse\n\t\tret = kvm_fast_pio_out(vcpu, size, port);\n\treturn ret && kvm_skip_emulated_instruction(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_fast_pio(struct kvm_vcpu *vcpu, int size, unsigned short port, int in)\n{\n\tint ret;\n\n\tif (in)\n\t\tret = kvm_fast_pio_in(vcpu, size, port);\n\telse\n\t\tret = kvm_fast_pio_out(vcpu, size, port);\n\treturn ret && kvm_skip_emulated_instruction(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 2632
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int io_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 io_info = svm->vmcb->control.exit_info_1; /* address size bug? */\n\tint size, in, string;\n\tunsigned port;\n\n\t++svm->vcpu.stat.io_exits;\n\tstring = (io_info & SVM_IOIO_STR_MASK) != 0;\n\tin = (io_info & SVM_IOIO_TYPE_MASK) != 0;\n\tif (string)\n\t\treturn kvm_emulate_instruction(vcpu, 0);\n\n\tport = io_info >> 16;\n\tsize = (io_info & SVM_IOIO_SIZE_MASK) >> SVM_IOIO_SIZE_SHIFT;\n\tsvm->next_rip = svm->vmcb->control.exit_info_2;\n\n\treturn kvm_fast_pio(&svm->vcpu, size, port, in);\n}"
  },
  {
    "function_name": "shutdown_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2606-2619",
    "snippet": "static int shutdown_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\t/*\n\t * VMCB is undefined after a SHUTDOWN intercept\n\t * so reinitialize it.\n\t */\n\tclear_page(svm->vmcb);\n\tinit_vmcb(svm);\n\n\tkvm_run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_vmcb",
          "args": [
            "svm"
          ],
          "line": 2615
        },
        "resolved": true,
        "details": {
          "function_name": "init_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1248-1405",
          "snippet": "static void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\tset_exception_intercept(svm, GP_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\tset_intercept(svm, INTERCEPT_RDPRU);\n\tset_intercept(svm, INTERCEPT_RSM);\n\n\tif (!kvm_mwait_in_guest(svm->vcpu.kvm)) {\n\t\tset_intercept(svm, INTERCEPT_MONITOR);\n\t\tset_intercept(svm, INTERCEPT_MWAIT);\n\t}\n\n\tif (!kvm_hlt_in_guest(svm->vcpu.kvm))\n\t\tset_intercept(svm, INTERCEPT_HLT);\n\n\tcontrol->iopm_base_pa = __sme_set(iopm_base);\n\tcontrol->msrpm_base_pa = __sme_set(__pa(svm->msrpm));\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl |= SVM_NESTED_CTL_NP_ENABLE;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (pause_filter_count) {\n\t\tcontrol->pause_filter_count = pause_filter_count;\n\t\tif (pause_filter_thresh)\n\t\t\tcontrol->pause_filter_thresh = pause_filter_thresh;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t} else {\n\t\tclr_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tavic_init_vmcb(svm);\n\n\t/*\n\t * If hardware supports Virtual VMLOAD VMSAVE then enable it\n\t * in VMCB and clear intercepts to avoid #VMEXIT.\n\t */\n\tif (vls) {\n\t\tclr_intercept(svm, INTERCEPT_VMLOAD);\n\t\tclr_intercept(svm, INTERCEPT_VMSAVE);\n\t\tsvm->vmcb->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\t}\n\n\tif (vgif) {\n\t\tclr_intercept(svm, INTERCEPT_STGI);\n\t\tclr_intercept(svm, INTERCEPT_CLGI);\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_ENABLE_MASK;\n\t}\n\n\tif (sev_guest(svm->vcpu.kvm)) {\n\t\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ENABLE;\n\t\tclr_exception_intercept(svm, UD_VECTOR);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define SEG_TYPE_BUSY_TSS16 3",
            "#define SEG_TYPE_LDT 2"
          ],
          "globals_used": [
            "static unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;",
            "static unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;",
            "static int nested = true;",
            "static int vls = true;",
            "static int vgif = true;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
            "static unsigned long iopm_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define SEG_TYPE_BUSY_TSS16 3\n#define SEG_TYPE_LDT 2\n\nstatic unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nstatic int nested = true;\nstatic int vls = true;\nstatic int vgif = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic unsigned long iopm_base;\n\nstatic void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\tset_exception_intercept(svm, GP_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\tset_intercept(svm, INTERCEPT_RDPRU);\n\tset_intercept(svm, INTERCEPT_RSM);\n\n\tif (!kvm_mwait_in_guest(svm->vcpu.kvm)) {\n\t\tset_intercept(svm, INTERCEPT_MONITOR);\n\t\tset_intercept(svm, INTERCEPT_MWAIT);\n\t}\n\n\tif (!kvm_hlt_in_guest(svm->vcpu.kvm))\n\t\tset_intercept(svm, INTERCEPT_HLT);\n\n\tcontrol->iopm_base_pa = __sme_set(iopm_base);\n\tcontrol->msrpm_base_pa = __sme_set(__pa(svm->msrpm));\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl |= SVM_NESTED_CTL_NP_ENABLE;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (pause_filter_count) {\n\t\tcontrol->pause_filter_count = pause_filter_count;\n\t\tif (pause_filter_thresh)\n\t\t\tcontrol->pause_filter_thresh = pause_filter_thresh;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t} else {\n\t\tclr_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tavic_init_vmcb(svm);\n\n\t/*\n\t * If hardware supports Virtual VMLOAD VMSAVE then enable it\n\t * in VMCB and clear intercepts to avoid #VMEXIT.\n\t */\n\tif (vls) {\n\t\tclr_intercept(svm, INTERCEPT_VMLOAD);\n\t\tclr_intercept(svm, INTERCEPT_VMSAVE);\n\t\tsvm->vmcb->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\t}\n\n\tif (vgif) {\n\t\tclr_intercept(svm, INTERCEPT_STGI);\n\t\tclr_intercept(svm, INTERCEPT_CLGI);\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_ENABLE_MASK;\n\t}\n\n\tif (sev_guest(svm->vcpu.kvm)) {\n\t\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ENABLE;\n\t\tclr_exception_intercept(svm, UD_VECTOR);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "svm->vmcb"
          ],
          "line": 2614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int shutdown_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\t/*\n\t * VMCB is undefined after a SHUTDOWN intercept\n\t * so reinitialize it.\n\t */\n\tclear_page(svm->vmcb);\n\tinit_vmcb(svm);\n\n\tkvm_run->exit_reason = KVM_EXIT_SHUTDOWN;\n\treturn 0;\n}"
  },
  {
    "function_name": "mc_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2601-2604",
    "snippet": "static int mc_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic int mc_interception(struct vcpu_svm *svm)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "svm_handle_mce",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2576-2599",
    "snippet": "static void svm_handle_mce(struct vcpu_svm *svm)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, &svm->vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tasm volatile (\n\t\t\"int $0x12\\n\");\n\t/* not sure if we ever come back to this point */\n\n\treturn;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_TRIPLE_FAULT",
            "&svm->vcpu"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"KVM: Guest triggered AMD Erratum 383\\n\""
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_erratum_383",
          "args": [],
          "line": 2578
        },
        "resolved": true,
        "details": {
          "function_name": "is_erratum_383",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2537-2574",
          "snippet": "static bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool erratum_383_found"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool erratum_383_found;\n\nstatic bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_handle_mce(struct vcpu_svm *svm)\n{\n\tif (is_erratum_383()) {\n\t\t/*\n\t\t * Erratum 383 triggered. Guest state is corrupt so kill the\n\t\t * guest.\n\t\t */\n\t\tpr_err(\"KVM: Guest triggered AMD Erratum 383\\n\");\n\n\t\tkvm_make_request(KVM_REQ_TRIPLE_FAULT, &svm->vcpu);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * On an #MC intercept the MCE handler is not called automatically in\n\t * the host. So do it by hand here.\n\t */\n\tasm volatile (\n\t\t\"int $0x12\\n\");\n\t/* not sure if we ever come back to this point */\n\n\treturn;\n}"
  },
  {
    "function_name": "is_erratum_383",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2537-2574",
    "snippet": "static bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool erratum_383_found"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__flush_tlb_all",
          "args": [],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_write_msr_safe",
          "args": [
            "MSR_IA32_MCG_STATUS",
            "low",
            "high"
          ],
          "line": 2567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upper_32_bits",
          "args": [
            "value"
          ],
          "line": 2565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_32_bits",
          "args": [
            "value"
          ],
          "line": 2564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_read_msr_safe",
          "args": [
            "MSR_IA32_MCG_STATUS",
            "&err"
          ],
          "line": 2559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_write_msr_safe",
          "args": [
            "MSR_IA32_MCx_STATUS(i)",
            "0",
            "0"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MSR_IA32_MCx_STATUS",
          "args": [
            "i"
          ],
          "line": 2557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_read_msr_safe",
          "args": [
            "MSR_IA32_MC0_STATUS",
            "&err"
          ],
          "line": 2545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool erratum_383_found;\n\nstatic bool is_erratum_383(void)\n{\n\tint err, i;\n\tu64 value;\n\n\tif (!erratum_383_found)\n\t\treturn false;\n\n\tvalue = native_read_msr_safe(MSR_IA32_MC0_STATUS, &err);\n\tif (err)\n\t\treturn false;\n\n\t/* Bit 62 may or may not be set for this mce */\n\tvalue &= ~(1ULL << 62);\n\n\tif (value != 0xb600000000010015ULL)\n\t\treturn false;\n\n\t/* Clear MCi_STATUS registers */\n\tfor (i = 0; i < 6; ++i)\n\t\tnative_write_msr_safe(MSR_IA32_MCx_STATUS(i), 0, 0);\n\n\tvalue = native_read_msr_safe(MSR_IA32_MCG_STATUS, &err);\n\tif (!err) {\n\t\tu32 low, high;\n\n\t\tvalue &= ~(1ULL << 2);\n\t\tlow    = lower_32_bits(value);\n\t\thigh   = upper_32_bits(value);\n\n\t\tnative_write_msr_safe(MSR_IA32_MCG_STATUS, low, high);\n\t}\n\n\t/* Flush tlb to evict multi-match entries */\n\t__flush_tlb_all();\n\n\treturn true;\n}"
  },
  {
    "function_name": "gp_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2519-2535",
    "snippet": "static int gp_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 error_code = svm->vmcb->control.exit_info_1;\n\n\tWARN_ON_ONCE(!enable_vmware_backdoor);\n\n\t/*\n\t * VMware backdoor emulation on #GP interception only handles IN{S},\n\t * OUT{S}, and RDPMC, none of which generate a non-zero error code.\n\t */\n\tif (error_code) {\n\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n\t\treturn 1;\n\t}\n\treturn kvm_emulate_instruction(vcpu, EMULTYPE_VMWARE_GP);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "vcpu",
            "EMULTYPE_VMWARE_GP"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception_e",
          "args": [
            "vcpu",
            "GP_VECTOR",
            "error_code"
          ],
          "line": 2531
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception_e",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "631-634",
          "snippet": "void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!enable_vmware_backdoor"
          ],
          "line": 2524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int gp_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\tu32 error_code = svm->vmcb->control.exit_info_1;\n\n\tWARN_ON_ONCE(!enable_vmware_backdoor);\n\n\t/*\n\t * VMware backdoor emulation on #GP interception only handles IN{S},\n\t * OUT{S}, and RDPMC, none of which generate a non-zero error code.\n\t */\n\tif (error_code) {\n\t\tkvm_queue_exception_e(vcpu, GP_VECTOR, error_code);\n\t\treturn 1;\n\t}\n\treturn kvm_emulate_instruction(vcpu, EMULTYPE_VMWARE_GP);\n}"
  },
  {
    "function_name": "ac_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2513-2517",
    "snippet": "static int ac_interception(struct vcpu_svm *svm)\n{\n\tkvm_queue_exception_e(&svm->vcpu, AC_VECTOR, 0);\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_queue_exception_e",
          "args": [
            "&svm->vcpu",
            "AC_VECTOR",
            "0"
          ],
          "line": 2515
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception_e",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "631-634",
          "snippet": "void kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception_e(struct kvm_vcpu *vcpu, unsigned nr, u32 error_code)\n{\n\tkvm_multiple_exception(vcpu, nr, true, error_code, false, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int ac_interception(struct vcpu_svm *svm)\n{\n\tkvm_queue_exception_e(&svm->vcpu, AC_VECTOR, 0);\n\treturn 1;\n}"
  },
  {
    "function_name": "ud_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2508-2511",
    "snippet": "static int ud_interception(struct vcpu_svm *svm)\n{\n\treturn handle_ud(&svm->vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "handle_ud",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2510
        },
        "resolved": true,
        "details": {
          "function_name": "handle_ud",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "5550-5566",
          "snippet": "int handle_ud(struct kvm_vcpu *vcpu)\n{\n\tstatic const char kvm_emulate_prefix[] = { __KVM_EMULATE_PREFIX };\n\tint emul_type = EMULTYPE_TRAP_UD;\n\tchar sig[5]; /* ud2; .ascii \"kvm\" */\n\tstruct x86_exception e;\n\n\tif (force_emulation_prefix &&\n\t    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),\n\t\t\t\tsig, sizeof(sig), &e) == 0 &&\n\t    memcmp(sig, kvm_emulate_prefix, sizeof(sig)) == 0) {\n\t\tkvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig));\n\t\temul_type = EMULTYPE_TRAP_UD_FORCED;\n\t}\n\n\treturn kvm_emulate_instruction(vcpu, emul_type);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint handle_ud(struct kvm_vcpu *vcpu)\n{\n\tstatic const char kvm_emulate_prefix[] = { __KVM_EMULATE_PREFIX };\n\tint emul_type = EMULTYPE_TRAP_UD;\n\tchar sig[5]; /* ud2; .ascii \"kvm\" */\n\tstruct x86_exception e;\n\n\tif (force_emulation_prefix &&\n\t    kvm_read_guest_virt(vcpu, kvm_get_linear_rip(vcpu),\n\t\t\t\tsig, sizeof(sig), &e) == 0 &&\n\t    memcmp(sig, kvm_emulate_prefix, sizeof(sig)) == 0) {\n\t\tkvm_rip_write(vcpu, kvm_rip_read(vcpu) + sizeof(sig));\n\t\temul_type = EMULTYPE_TRAP_UD_FORCED;\n\t}\n\n\treturn kvm_emulate_instruction(vcpu, emul_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int ud_interception(struct vcpu_svm *svm)\n{\n\treturn handle_ud(&svm->vcpu);\n}"
  },
  {
    "function_name": "bp_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2498-2506",
    "snippet": "static int bp_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\tkvm_run->debug.arch.pc = svm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\tkvm_run->debug.arch.exception = BP_VECTOR;\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int bp_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\n\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\tkvm_run->debug.arch.pc = svm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\tkvm_run->debug.arch.exception = BP_VECTOR;\n\treturn 0;\n}"
  },
  {
    "function_name": "db_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2468-2496",
    "snippet": "static int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->nmi_singlestep) {\n\t\tdisable_nmi_singlestep(svm);\n\t\t/* Make sure we check for pending NMIs upon entry */\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_request",
          "args": [
            "KVM_REQ_EVENT",
            "vcpu"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "disable_nmi_singlestep",
          "args": [
            "svm"
          ],
          "line": 2481
        },
        "resolved": true,
        "details": {
          "function_name": "disable_nmi_singlestep",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "843-854",
          "snippet": "void disable_nmi_singlestep(struct vcpu_svm *svm)\n{\n\tsvm->nmi_singlestep = false;\n\n\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP)) {\n\t\t/* Clear our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_RF;\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nvoid disable_nmi_singlestep(struct vcpu_svm *svm)\n{\n\tsvm->nmi_singlestep = false;\n\n\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP)) {\n\t\t/* Clear our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_RF;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_queue_exception",
          "args": [
            "&svm->vcpu",
            "DB_VECTOR"
          ],
          "line": 2476
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_queue_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "563-566",
          "snippet": "void kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_queue_exception(struct kvm_vcpu *vcpu, unsigned nr)\n{\n\tkvm_multiple_exception(vcpu, nr, false, 0, false, 0, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int db_interception(struct vcpu_svm *svm)\n{\n\tstruct kvm_run *kvm_run = svm->vcpu.run;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\tif (!(svm->vcpu.guest_debug &\n\t      (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) &&\n\t\t!svm->nmi_singlestep) {\n\t\tkvm_queue_exception(&svm->vcpu, DB_VECTOR);\n\t\treturn 1;\n\t}\n\n\tif (svm->nmi_singlestep) {\n\t\tdisable_nmi_singlestep(svm);\n\t\t/* Make sure we check for pending NMIs upon entry */\n\t\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n\t}\n\n\tif (svm->vcpu.guest_debug &\n\t    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP)) {\n\t\tkvm_run->exit_reason = KVM_EXIT_DEBUG;\n\t\tkvm_run->debug.arch.pc =\n\t\t\tsvm->vmcb->save.cs.base + svm->vmcb->save.rip;\n\t\tkvm_run->debug.arch.exception = DB_VECTOR;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "npf_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2456-2466",
    "snippet": "static int npf_interception(struct vcpu_svm *svm)\n{\n\tu64 fault_address = __sme_clr(svm->vmcb->control.exit_info_2);\n\tu64 error_code = svm->vmcb->control.exit_info_1;\n\n\ttrace_kvm_page_fault(fault_address, error_code);\n\treturn kvm_mmu_page_fault(&svm->vcpu, fault_address, error_code,\n\t\t\tstatic_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL,\n\t\t\tsvm->vmcb->control.insn_len);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_page_fault",
          "args": [
            "&svm->vcpu",
            "fault_address",
            "error_code",
            "static_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL",
            "svm->vmcb->control.insn_len"
          ],
          "line": 2462
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5429-5497",
          "snippet": "int kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_PF;\n\tbool direct = vcpu->arch.mmu->direct_map;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tr = RET_PF_INVALID;\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);\n\t\tif (r == RET_PF_EMULATE)\n\t\t\tgoto emulate;\n\t}\n\n\tif (r == RET_PF_INVALID) {\n\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,\n\t\t\t\t\t  lower_32_bits(error_code), false);\n\t\tWARN_ON(r == RET_PF_INVALID);\n\t}\n\n\tif (r == RET_PF_RETRY)\n\t\treturn 1;\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * Before emulating the instruction, check if the error code\n\t * was due to a RO violation while translating the guest page.\n\t * This can occur when using nested virtualization with nested\n\t * paging in both guests. If true, we simply unprotect the page\n\t * and resume the guest.\n\t */\n\tif (vcpu->arch.mmu->direct_map &&\n\t    (error_code & PFERR_NESTED_GUEST_PAGE) == PFERR_NESTED_GUEST_PAGE) {\n\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(cr2_or_gpa));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * vcpu->arch.mmu.page_fault returned RET_PF_EMULATE, but we can still\n\t * optimistically try to just unprotect the page and let the processor\n\t * re-execute the instruction that caused the page fault.  Do not allow\n\t * retrying MMIO emulation, as it's not only pointless but could also\n\t * cause us to enter an infinite loop because the processor will keep\n\t * faulting on the non-existent MMIO address.  Retrying an instruction\n\t * from a nested guest is also pointless and dangerous as we are only\n\t * explicitly shadowing L1's page tables, i.e. unprotecting something\n\t * for L1 isn't going to magically fix whatever issue cause L2 to fail.\n\t */\n\tif (!mmio_info_in_cache(vcpu, cr2_or_gpa, direct) && !is_guest_mode(vcpu))\n\t\temulation_type |= EMULTYPE_ALLOW_RETRY_PF;\nemulate:\n\t/*\n\t * On AMD platforms, under certain conditions insn_len may be zero on #NPF.\n\t * This can happen if a guest gets a page-fault on data access but the HW\n\t * table walker is not able to read the instruction page (e.g instruction\n\t * page is not present in memory). In those cases we simply restart the\n\t * guest, with the exception of AMD Erratum 1096 which is unrecoverable.\n\t */\n\tif (unlikely(insn && !insn_len)) {\n\t\tif (!kvm_x86_ops.need_emulation_on_page_fault(vcpu))\n\t\t\treturn 1;\n\t}\n\n\treturn x86_emulate_instruction(vcpu, cr2_or_gpa, emulation_type, insn,\n\t\t\t\t       insn_len);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_mmu_page_fault(struct kvm_vcpu *vcpu, gpa_t cr2_or_gpa, u64 error_code,\n\t\t       void *insn, int insn_len)\n{\n\tint r, emulation_type = EMULTYPE_PF;\n\tbool direct = vcpu->arch.mmu->direct_map;\n\n\tif (WARN_ON(!VALID_PAGE(vcpu->arch.mmu->root_hpa)))\n\t\treturn RET_PF_RETRY;\n\n\tr = RET_PF_INVALID;\n\tif (unlikely(error_code & PFERR_RSVD_MASK)) {\n\t\tr = handle_mmio_page_fault(vcpu, cr2_or_gpa, direct);\n\t\tif (r == RET_PF_EMULATE)\n\t\t\tgoto emulate;\n\t}\n\n\tif (r == RET_PF_INVALID) {\n\t\tr = kvm_mmu_do_page_fault(vcpu, cr2_or_gpa,\n\t\t\t\t\t  lower_32_bits(error_code), false);\n\t\tWARN_ON(r == RET_PF_INVALID);\n\t}\n\n\tif (r == RET_PF_RETRY)\n\t\treturn 1;\n\tif (r < 0)\n\t\treturn r;\n\n\t/*\n\t * Before emulating the instruction, check if the error code\n\t * was due to a RO violation while translating the guest page.\n\t * This can occur when using nested virtualization with nested\n\t * paging in both guests. If true, we simply unprotect the page\n\t * and resume the guest.\n\t */\n\tif (vcpu->arch.mmu->direct_map &&\n\t    (error_code & PFERR_NESTED_GUEST_PAGE) == PFERR_NESTED_GUEST_PAGE) {\n\t\tkvm_mmu_unprotect_page(vcpu->kvm, gpa_to_gfn(cr2_or_gpa));\n\t\treturn 1;\n\t}\n\n\t/*\n\t * vcpu->arch.mmu.page_fault returned RET_PF_EMULATE, but we can still\n\t * optimistically try to just unprotect the page and let the processor\n\t * re-execute the instruction that caused the page fault.  Do not allow\n\t * retrying MMIO emulation, as it's not only pointless but could also\n\t * cause us to enter an infinite loop because the processor will keep\n\t * faulting on the non-existent MMIO address.  Retrying an instruction\n\t * from a nested guest is also pointless and dangerous as we are only\n\t * explicitly shadowing L1's page tables, i.e. unprotecting something\n\t * for L1 isn't going to magically fix whatever issue cause L2 to fail.\n\t */\n\tif (!mmio_info_in_cache(vcpu, cr2_or_gpa, direct) && !is_guest_mode(vcpu))\n\t\temulation_type |= EMULTYPE_ALLOW_RETRY_PF;\nemulate:\n\t/*\n\t * On AMD platforms, under certain conditions insn_len may be zero on #NPF.\n\t * This can happen if a guest gets a page-fault on data access but the HW\n\t * table walker is not able to read the instruction page (e.g instruction\n\t * page is not present in memory). In those cases we simply restart the\n\t * guest, with the exception of AMD Erratum 1096 which is unrecoverable.\n\t */\n\tif (unlikely(insn && !insn_len)) {\n\t\tif (!kvm_x86_ops.need_emulation_on_page_fault(vcpu))\n\t\t\treturn 1;\n\t}\n\n\treturn x86_emulate_instruction(vcpu, cr2_or_gpa, emulation_type, insn,\n\t\t\t\t       insn_len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_DECODEASSISTS"
          ],
          "line": 2463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_page_fault",
          "args": [
            "fault_address",
            "error_code"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_clr",
          "args": [
            "svm->vmcb->control.exit_info_2"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int npf_interception(struct vcpu_svm *svm)\n{\n\tu64 fault_address = __sme_clr(svm->vmcb->control.exit_info_2);\n\tu64 error_code = svm->vmcb->control.exit_info_1;\n\n\ttrace_kvm_page_fault(fault_address, error_code);\n\treturn kvm_mmu_page_fault(&svm->vcpu, fault_address, error_code,\n\t\t\tstatic_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL,\n\t\t\tsvm->vmcb->control.insn_len);\n}"
  },
  {
    "function_name": "pf_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2445-2454",
    "snippet": "static int pf_interception(struct vcpu_svm *svm)\n{\n\tu64 fault_address = __sme_clr(svm->vmcb->control.exit_info_2);\n\tu64 error_code = svm->vmcb->control.exit_info_1;\n\n\treturn kvm_handle_page_fault(&svm->vcpu, error_code, fault_address,\n\t\t\tstatic_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL,\n\t\t\tsvm->vmcb->control.insn_len);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_handle_page_fault",
          "args": [
            "&svm->vcpu",
            "error_code",
            "fault_address",
            "static_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL",
            "svm->vmcb->control.insn_len"
          ],
          "line": 2450
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_handle_page_fault",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "4177-4212",
          "snippet": "int kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code,\n\t\t\t\tu64 fault_address, char *insn, int insn_len)\n{\n\tint r = 1;\n\n#ifndef CONFIG_X86_64\n\t/* A 64-bit CR2 should be impossible on 32-bit KVM. */\n\tif (WARN_ON_ONCE(fault_address >> 32))\n\t\treturn -EFAULT;\n#endif\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tswitch (vcpu->arch.apf.host_apf_reason) {\n\tdefault:\n\t\ttrace_kvm_page_fault(fault_address, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, fault_address);\n\t\tr = kvm_mmu_page_fault(vcpu, fault_address, error_code, insn,\n\t\t\t\tinsn_len);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_NOT_PRESENT:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wait(fault_address, 0);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_READY:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wake(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\t}\n\treturn r;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nint kvm_handle_page_fault(struct kvm_vcpu *vcpu, u64 error_code,\n\t\t\t\tu64 fault_address, char *insn, int insn_len)\n{\n\tint r = 1;\n\n#ifndef CONFIG_X86_64\n\t/* A 64-bit CR2 should be impossible on 32-bit KVM. */\n\tif (WARN_ON_ONCE(fault_address >> 32))\n\t\treturn -EFAULT;\n#endif\n\n\tvcpu->arch.l1tf_flush_l1d = true;\n\tswitch (vcpu->arch.apf.host_apf_reason) {\n\tdefault:\n\t\ttrace_kvm_page_fault(fault_address, error_code);\n\n\t\tif (kvm_event_needs_reinjection(vcpu))\n\t\t\tkvm_mmu_unprotect_page_virt(vcpu, fault_address);\n\t\tr = kvm_mmu_page_fault(vcpu, fault_address, error_code, insn,\n\t\t\t\tinsn_len);\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_NOT_PRESENT:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wait(fault_address, 0);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tcase KVM_PV_REASON_PAGE_READY:\n\t\tvcpu->arch.apf.host_apf_reason = 0;\n\t\tlocal_irq_disable();\n\t\tkvm_async_pf_task_wake(fault_address);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\t}\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_DECODEASSISTS"
          ],
          "line": 2451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_clr",
          "args": [
            "svm->vmcb->control.exit_info_2"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int pf_interception(struct vcpu_svm *svm)\n{\n\tu64 fault_address = __sme_clr(svm->vmcb->control.exit_info_2);\n\tu64 error_code = svm->vmcb->control.exit_info_1;\n\n\treturn kvm_handle_page_fault(&svm->vcpu, error_code, fault_address,\n\t\t\tstatic_cpu_has(X86_FEATURE_DECODEASSISTS) ?\n\t\t\tsvm->vmcb->control.insn_bytes : NULL,\n\t\t\tsvm->vmcb->control.insn_len);\n}"
  },
  {
    "function_name": "svm_set_dr7",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2437-2443",
    "snippet": "static void svm_set_dr7(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr7 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_DR"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2439
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_dr7(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr7 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}"
  },
  {
    "function_name": "svm_sync_dirty_debug_regs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2422-2435",
    "snippet": "static void svm_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tvcpu->arch.dr6 = svm_get_dr6(vcpu);\n\tvcpu->arch.dr7 = svm->vmcb->save.dr7;\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tset_dr_intercepts(svm);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_dr_intercepts",
          "args": [
            "svm"
          ],
          "line": 2434
        },
        "resolved": true,
        "details": {
          "function_name": "set_dr_intercepts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "230-252",
          "snippet": "static inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_get_dr6",
          "args": [
            "vcpu"
          ],
          "line": 2430
        },
        "resolved": true,
        "details": {
          "function_name": "svm_get_dr6",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2409-2412",
          "snippet": "static u64 svm_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.dr6;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.dr6;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_debugreg",
          "args": [
            "vcpu->arch.db[3]",
            "3"
          ],
          "line": 2429
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_ioctl_x86_get_debugregs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "3985-3996",
          "snippet": "static void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nstatic void kvm_vcpu_ioctl_x86_get_debugregs(struct kvm_vcpu *vcpu,\n\t\t\t\t\t     struct kvm_debugregs *dbgregs)\n{\n\tunsigned long val;\n\n\tmemcpy(dbgregs->db, vcpu->arch.db, sizeof(vcpu->arch.db));\n\tkvm_get_dr(vcpu, 6, &val);\n\tdbgregs->dr6 = val;\n\tdbgregs->dr7 = vcpu->arch.dr7;\n\tdbgregs->flags = 0;\n\tmemset(&dbgregs->reserved, 0, sizeof(dbgregs->reserved));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2424
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_sync_dirty_debug_regs(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tget_debugreg(vcpu->arch.db[0], 0);\n\tget_debugreg(vcpu->arch.db[1], 1);\n\tget_debugreg(vcpu->arch.db[2], 2);\n\tget_debugreg(vcpu->arch.db[3], 3);\n\tvcpu->arch.dr6 = svm_get_dr6(vcpu);\n\tvcpu->arch.dr7 = svm->vmcb->save.dr7;\n\n\tvcpu->arch.switch_db_regs &= ~KVM_DEBUGREG_WONT_EXIT;\n\tset_dr_intercepts(svm);\n}"
  },
  {
    "function_name": "svm_set_dr6",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2414-2420",
    "snippet": "static void svm_set_dr6(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr6 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_DR"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_dr6(struct kvm_vcpu *vcpu, unsigned long value)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.dr6 = value;\n\tmark_dirty(svm->vmcb, VMCB_DR);\n}"
  },
  {
    "function_name": "svm_get_dr6",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2409-2412",
    "snippet": "static u64 svm_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.dr6;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_get_dr6(struct kvm_vcpu *vcpu)\n{\n\treturn to_svm(vcpu)->vmcb->save.dr6;\n}"
  },
  {
    "function_name": "new_asid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2395-2407",
    "snippet": "static void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = sd->min_asid;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t}\n\n\tsvm->asid_generation = sd->asid_generation;\n\tsvm->vmcb->control.asid = sd->next_asid++;\n\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_ASID"
          ],
          "line": 2406
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void new_asid(struct vcpu_svm *svm, struct svm_cpu_data *sd)\n{\n\tif (sd->next_asid > sd->max_asid) {\n\t\t++sd->asid_generation;\n\t\tsd->next_asid = sd->min_asid;\n\t\tsvm->vmcb->control.tlb_ctl = TLB_CONTROL_FLUSH_ALL_ASID;\n\t}\n\n\tsvm->asid_generation = sd->asid_generation;\n\tsvm->vmcb->control.asid = sd->next_asid++;\n\n\tmark_dirty(svm->vmcb, VMCB_ASID);\n}"
  },
  {
    "function_name": "update_bp_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2382-2393",
    "snippet": "static void update_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_exception_intercept",
          "args": [
            "svm",
            "BP_VECTOR"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "set_exception_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "263-270",
          "snippet": "static inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_exception_intercept",
          "args": [
            "svm",
            "BP_VECTOR"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "clr_exception_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "272-279",
          "snippet": "static inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2384
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void update_bp_intercept(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tclr_exception_intercept(svm, BP_VECTOR);\n\n\tif (vcpu->guest_debug & KVM_GUESTDBG_ENABLE) {\n\t\tif (vcpu->guest_debug & KVM_GUESTDBG_USE_SW_BP)\n\t\t\tset_exception_intercept(svm, BP_VECTOR);\n\t} else\n\t\tvcpu->guest_debug = 0;\n}"
  },
  {
    "function_name": "svm_set_segment",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2351-2380",
    "snippet": "static void svm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\ts->base = var->base;\n\ts->limit = var->limit;\n\ts->selector = var->selector;\n\ts->attrib = (var->type & SVM_SELECTOR_TYPE_MASK);\n\ts->attrib |= (var->s & 1) << SVM_SELECTOR_S_SHIFT;\n\ts->attrib |= (var->dpl & 3) << SVM_SELECTOR_DPL_SHIFT;\n\ts->attrib |= ((var->present & 1) && !var->unusable) << SVM_SELECTOR_P_SHIFT;\n\ts->attrib |= (var->avl & 1) << SVM_SELECTOR_AVL_SHIFT;\n\ts->attrib |= (var->l & 1) << SVM_SELECTOR_L_SHIFT;\n\ts->attrib |= (var->db & 1) << SVM_SELECTOR_DB_SHIFT;\n\ts->attrib |= (var->g & 1) << SVM_SELECTOR_G_SHIFT;\n\n\t/*\n\t * This is always accurate, except if SYSRET returned to a segment\n\t * with SS.DPL != 3.  Intel does not have this quirk, and always\n\t * forces SS.DPL to 3 on sysret, so we ignore that case; fixing it\n\t * would entail passing the CPL to userspace and back.\n\t */\n\tif (seg == VCPU_SREG_SS)\n\t\t/* This is symmetric with svm_get_segment() */\n\t\tsvm->vmcb->save.cpl = (var->dpl & 3);\n\n\tmark_dirty(svm->vmcb, VMCB_SEG);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_SEG"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_seg",
          "args": [
            "vcpu",
            "seg"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "svm_seg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2135-2151",
          "snippet": "static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2354
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\ts->base = var->base;\n\ts->limit = var->limit;\n\ts->selector = var->selector;\n\ts->attrib = (var->type & SVM_SELECTOR_TYPE_MASK);\n\ts->attrib |= (var->s & 1) << SVM_SELECTOR_S_SHIFT;\n\ts->attrib |= (var->dpl & 3) << SVM_SELECTOR_DPL_SHIFT;\n\ts->attrib |= ((var->present & 1) && !var->unusable) << SVM_SELECTOR_P_SHIFT;\n\ts->attrib |= (var->avl & 1) << SVM_SELECTOR_AVL_SHIFT;\n\ts->attrib |= (var->l & 1) << SVM_SELECTOR_L_SHIFT;\n\ts->attrib |= (var->db & 1) << SVM_SELECTOR_DB_SHIFT;\n\ts->attrib |= (var->g & 1) << SVM_SELECTOR_G_SHIFT;\n\n\t/*\n\t * This is always accurate, except if SYSRET returned to a segment\n\t * with SS.DPL != 3.  Intel does not have this quirk, and always\n\t * forces SS.DPL to 3 on sysret, so we ignore that case; fixing it\n\t * would entail passing the CPL to userspace and back.\n\t */\n\tif (seg == VCPU_SREG_SS)\n\t\t/* This is symmetric with svm_get_segment() */\n\t\tsvm->vmcb->save.cpl = (var->dpl & 3);\n\n\tmark_dirty(svm->vmcb, VMCB_SEG);\n}"
  },
  {
    "function_name": "svm_set_cr4",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2331-2349",
    "snippet": "int svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = cr4_read_shadow() & X86_CR4_MCE;\n\tunsigned long old_cr4 = to_svm(vcpu)->vmcb->save.cr4;\n\n\tif (cr4 & X86_CR4_VMXE)\n\t\treturn 1;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb(vcpu, true);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled)\n\t\tcr4 |= X86_CR4_PAE;\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "to_svm(vcpu)->vmcb",
            "VMCB_CR"
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_flush_tlb",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "svm_flush_tlb_gva",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "4512-4517",
          "snippet": "static void svm_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tinvlpga(gva, svm->vmcb->control.asid);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_flush_tlb_gva(struct kvm_vcpu *vcpu, gva_t gva)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tinvlpga(gva, svm->vmcb->control.asid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cr4_read_shadow",
          "args": [],
          "line": 2333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nint svm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)\n{\n\tunsigned long host_cr4_mce = cr4_read_shadow() & X86_CR4_MCE;\n\tunsigned long old_cr4 = to_svm(vcpu)->vmcb->save.cr4;\n\n\tif (cr4 & X86_CR4_VMXE)\n\t\treturn 1;\n\n\tif (npt_enabled && ((old_cr4 ^ cr4) & X86_CR4_PGE))\n\t\tsvm_flush_tlb(vcpu, true);\n\n\tvcpu->arch.cr4 = cr4;\n\tif (!npt_enabled)\n\t\tcr4 |= X86_CR4_PAE;\n\tcr4 |= host_cr4_mce;\n\tto_svm(vcpu)->vmcb->save.cr4 = cr4;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_set_cr0",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2297-2329",
    "snippet": "void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cr0_intercept",
          "args": [
            "svm"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "update_cr0_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2278-2295",
          "snippet": "static void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_CR"
          ],
          "line": 2327
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_has_quirk",
          "args": [
            "vcpu->kvm",
            "KVM_X86_QUIRK_CD_NW_CLEARED"
          ],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_check_has_quirk",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "233-236",
          "snippet": "static inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_check_has_quirk(struct kvm *kvm, u64 quirk)\n{\n\treturn !(kvm->arch.disabled_quirks & quirk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_paging",
          "args": [
            "vcpu"
          ],
          "line": 2308
        },
        "resolved": true,
        "details": {
          "function_name": "is_paging",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "138-141",
          "snippet": "static inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline int is_paging(struct kvm_vcpu *vcpu)\n{\n\treturn likely(kvm_read_cr0_bits(vcpu, X86_CR0_PG));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2299
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nvoid svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}"
  },
  {
    "function_name": "update_cr0_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2278-2295",
    "snippet": "static void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR0_WRITE"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "set_cr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "205-212",
          "snippet": "static inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR0_WRITE"
          ],
          "line": 2290
        },
        "resolved": true,
        "details": {
          "function_name": "clr_cr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "214-221",
          "snippet": "static inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_CR"
          ],
          "line": 2286
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void update_cr0_intercept(struct vcpu_svm *svm)\n{\n\tulong gcr0 = svm->vcpu.arch.cr0;\n\tu64 *hcr0 = &svm->vmcb->save.cr0;\n\n\t*hcr0 = (*hcr0 & ~SVM_CR0_SELECTIVE_MASK)\n\t\t| (gcr0 & SVM_CR0_SELECTIVE_MASK);\n\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\n\tif (gcr0 == *hcr0) {\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t} else {\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\t\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\t}\n}"
  },
  {
    "function_name": "svm_decache_cr4_guest_bits",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2274-2276",
    "snippet": "static void svm_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_decache_cr4_guest_bits(struct kvm_vcpu *vcpu)\n{\n}"
  },
  {
    "function_name": "svm_decache_cr0_guest_bits",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2270-2272",
    "snippet": "static void svm_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)\n{\n}"
  },
  {
    "function_name": "svm_set_gdt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2261-2268",
    "snippet": "static void svm_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.gdtr.limit = dt->size;\n\tsvm->vmcb->save.gdtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_DT"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.gdtr.limit = dt->size;\n\tsvm->vmcb->save.gdtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}"
  },
  {
    "function_name": "svm_get_gdt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2253-2259",
    "snippet": "static void svm_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.gdtr.limit;\n\tdt->address = svm->vmcb->save.gdtr.base;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_get_gdt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.gdtr.limit;\n\tdt->address = svm->vmcb->save.gdtr.base;\n}"
  },
  {
    "function_name": "svm_set_idt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2244-2251",
    "snippet": "static void svm_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.idtr.limit = dt->size;\n\tsvm->vmcb->save.idtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_DT"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->vmcb->save.idtr.limit = dt->size;\n\tsvm->vmcb->save.idtr.base = dt->address ;\n\tmark_dirty(svm->vmcb, VMCB_DT);\n}"
  },
  {
    "function_name": "svm_get_idt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2236-2242",
    "snippet": "static void svm_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.idtr.limit;\n\tdt->address = svm->vmcb->save.idtr.base;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_get_idt(struct kvm_vcpu *vcpu, struct desc_ptr *dt)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tdt->size = svm->vmcb->save.idtr.limit;\n\tdt->address = svm->vmcb->save.idtr.base;\n}"
  },
  {
    "function_name": "svm_get_cpl",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2229-2234",
    "snippet": "static int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_get_cpl(struct kvm_vcpu *vcpu)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\treturn save->cpl;\n}"
  },
  {
    "function_name": "svm_get_segment",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2160-2227",
    "snippet": "static void svm_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\tvar->base = s->base;\n\tvar->limit = s->limit;\n\tvar->selector = s->selector;\n\tvar->type = s->attrib & SVM_SELECTOR_TYPE_MASK;\n\tvar->s = (s->attrib >> SVM_SELECTOR_S_SHIFT) & 1;\n\tvar->dpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\tvar->present = (s->attrib >> SVM_SELECTOR_P_SHIFT) & 1;\n\tvar->avl = (s->attrib >> SVM_SELECTOR_AVL_SHIFT) & 1;\n\tvar->l = (s->attrib >> SVM_SELECTOR_L_SHIFT) & 1;\n\tvar->db = (s->attrib >> SVM_SELECTOR_DB_SHIFT) & 1;\n\n\t/*\n\t * AMD CPUs circa 2014 track the G bit for all segments except CS.\n\t * However, the SVM spec states that the G bit is not observed by the\n\t * CPU, and some VMware virtual CPUs drop the G bit for all segments.\n\t * So let's synthesize a legal G bit for all segments, this helps\n\t * running KVM nested. It also helps cross-vendor migration, because\n\t * Intel's vmentry has a check on the 'G' bit.\n\t */\n\tvar->g = s->limit > 0xfffff;\n\n\t/*\n\t * AMD's VMCB does not have an explicit unusable field, so emulate it\n\t * for cross vendor migration purposes by \"not present\"\n\t */\n\tvar->unusable = !var->present;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_TR:\n\t\t/*\n\t\t * Work around a bug where the busy flag in the tr selector\n\t\t * isn't exposed\n\t\t */\n\t\tvar->type |= 0x2;\n\t\tbreak;\n\tcase VCPU_SREG_DS:\n\tcase VCPU_SREG_ES:\n\tcase VCPU_SREG_FS:\n\tcase VCPU_SREG_GS:\n\t\t/*\n\t\t * The accessed bit must always be set in the segment\n\t\t * descriptor cache, although it can be cleared in the\n\t\t * descriptor, the cached bit always remains at 1. Since\n\t\t * Intel has a check on this, set it here to support\n\t\t * cross-vendor migration.\n\t\t */\n\t\tif (!var->unusable)\n\t\t\tvar->type |= 0x1;\n\t\tbreak;\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * On AMD CPUs sometimes the DB bit in the segment\n\t\t * descriptor is left as 1, although the whole segment has\n\t\t * been made unusable. Clear it here to pass an Intel VMX\n\t\t * entry check when cross vendor migrating.\n\t\t */\n\t\tif (var->unusable)\n\t\t\tvar->db = 0;\n\t\t/* This is symmetric with svm_set_segment() */\n\t\tvar->dpl = to_svm(vcpu)->vmcb->save.cpl;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_seg",
          "args": [
            "vcpu",
            "seg"
          ],
          "line": 2163
        },
        "resolved": true,
        "details": {
          "function_name": "svm_seg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2135-2151",
          "snippet": "static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_get_segment(struct kvm_vcpu *vcpu,\n\t\t\t    struct kvm_segment *var, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\tvar->base = s->base;\n\tvar->limit = s->limit;\n\tvar->selector = s->selector;\n\tvar->type = s->attrib & SVM_SELECTOR_TYPE_MASK;\n\tvar->s = (s->attrib >> SVM_SELECTOR_S_SHIFT) & 1;\n\tvar->dpl = (s->attrib >> SVM_SELECTOR_DPL_SHIFT) & 3;\n\tvar->present = (s->attrib >> SVM_SELECTOR_P_SHIFT) & 1;\n\tvar->avl = (s->attrib >> SVM_SELECTOR_AVL_SHIFT) & 1;\n\tvar->l = (s->attrib >> SVM_SELECTOR_L_SHIFT) & 1;\n\tvar->db = (s->attrib >> SVM_SELECTOR_DB_SHIFT) & 1;\n\n\t/*\n\t * AMD CPUs circa 2014 track the G bit for all segments except CS.\n\t * However, the SVM spec states that the G bit is not observed by the\n\t * CPU, and some VMware virtual CPUs drop the G bit for all segments.\n\t * So let's synthesize a legal G bit for all segments, this helps\n\t * running KVM nested. It also helps cross-vendor migration, because\n\t * Intel's vmentry has a check on the 'G' bit.\n\t */\n\tvar->g = s->limit > 0xfffff;\n\n\t/*\n\t * AMD's VMCB does not have an explicit unusable field, so emulate it\n\t * for cross vendor migration purposes by \"not present\"\n\t */\n\tvar->unusable = !var->present;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_TR:\n\t\t/*\n\t\t * Work around a bug where the busy flag in the tr selector\n\t\t * isn't exposed\n\t\t */\n\t\tvar->type |= 0x2;\n\t\tbreak;\n\tcase VCPU_SREG_DS:\n\tcase VCPU_SREG_ES:\n\tcase VCPU_SREG_FS:\n\tcase VCPU_SREG_GS:\n\t\t/*\n\t\t * The accessed bit must always be set in the segment\n\t\t * descriptor cache, although it can be cleared in the\n\t\t * descriptor, the cached bit always remains at 1. Since\n\t\t * Intel has a check on this, set it here to support\n\t\t * cross-vendor migration.\n\t\t */\n\t\tif (!var->unusable)\n\t\t\tvar->type |= 0x1;\n\t\tbreak;\n\tcase VCPU_SREG_SS:\n\t\t/*\n\t\t * On AMD CPUs sometimes the DB bit in the segment\n\t\t * descriptor is left as 1, although the whole segment has\n\t\t * been made unusable. Clear it here to pass an Intel VMX\n\t\t * entry check when cross vendor migrating.\n\t\t */\n\t\tif (var->unusable)\n\t\t\tvar->db = 0;\n\t\t/* This is symmetric with svm_set_segment() */\n\t\tvar->dpl = to_svm(vcpu)->vmcb->save.cpl;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "svm_get_segment_base",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2153-2158",
    "snippet": "static u64 svm_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\treturn s->base;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_seg",
          "args": [
            "vcpu",
            "seg"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "svm_seg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2135-2151",
          "snippet": "static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_get_segment_base(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_seg *s = svm_seg(vcpu, seg);\n\n\treturn s->base;\n}"
  },
  {
    "function_name": "svm_seg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2135-2151",
    "snippet": "static struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 2149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic struct vmcb_seg *svm_seg(struct kvm_vcpu *vcpu, int seg)\n{\n\tstruct vmcb_save_area *save = &to_svm(vcpu)->vmcb->save;\n\n\tswitch (seg) {\n\tcase VCPU_SREG_CS: return &save->cs;\n\tcase VCPU_SREG_DS: return &save->ds;\n\tcase VCPU_SREG_ES: return &save->es;\n\tcase VCPU_SREG_FS: return &save->fs;\n\tcase VCPU_SREG_GS: return &save->gs;\n\tcase VCPU_SREG_SS: return &save->ss;\n\tcase VCPU_SREG_TR: return &save->tr;\n\tcase VCPU_SREG_LDTR: return &save->ldtr;\n\t}\n\tBUG();\n\treturn NULL;\n}"
  },
  {
    "function_name": "svm_clear_vintr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2127-2133",
    "snippet": "static void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTR"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_intercept",
          "args": [
            "svm",
            "INTERCEPT_VINTR"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "clr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "290-297",
          "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_clear_vintr(struct vcpu_svm *svm)\n{\n\tclr_intercept(svm, INTERCEPT_VINTR);\n\n\tsvm->vmcb->control.int_ctl &= ~V_IRQ_MASK;\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}"
  },
  {
    "function_name": "svm_set_vintr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2120-2125",
    "snippet": "static void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tset_intercept(svm, INTERCEPT_VINTR);\n\tif (is_intercept(svm, INTERCEPT_VINTR))\n\t\tsvm_enable_vintr(svm);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_enable_vintr",
          "args": [
            "svm"
          ],
          "line": 2124
        },
        "resolved": true,
        "details": {
          "function_name": "svm_enable_vintr",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2101-2118",
          "snippet": "static inline void svm_enable_vintr(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control;\n\n\t/* The following fields are ignored when AVIC is enabled */\n\tWARN_ON(kvm_vcpu_apicv_active(&svm->vcpu));\n\n\t/*\n\t * This is just a dummy VINTR to actually cause a vmexit to happen.\n\t * Actual injection of virtual interrupts happens through EVENTINJ.\n\t */\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = 0x0;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline void svm_enable_vintr(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control;\n\n\t/* The following fields are ignored when AVIC is enabled */\n\tWARN_ON(kvm_vcpu_apicv_active(&svm->vcpu));\n\n\t/*\n\t * This is just a dummy VINTR to actually cause a vmexit to happen.\n\t * Actual injection of virtual interrupts happens through EVENTINJ.\n\t */\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = 0x0;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_intercept",
          "args": [
            "svm",
            "INTERCEPT_VINTR"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "is_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "299-302",
          "snippet": "static inline bool is_intercept(struct vcpu_svm *svm, int bit)\n{\n\treturn (svm->vmcb->control.intercept & (1ULL << bit)) != 0;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline bool is_intercept(struct vcpu_svm *svm, int bit)\n{\n\treturn (svm->vmcb->control.intercept & (1ULL << bit)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_intercept",
          "args": [
            "svm",
            "INTERCEPT_VINTR"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "set_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "281-288",
          "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_set_vintr(struct vcpu_svm *svm)\n{\n\tset_intercept(svm, INTERCEPT_VINTR);\n\tif (is_intercept(svm, INTERCEPT_VINTR))\n\t\tsvm_enable_vintr(svm);\n}"
  },
  {
    "function_name": "svm_enable_vintr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2101-2118",
    "snippet": "static inline void svm_enable_vintr(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control;\n\n\t/* The following fields are ignored when AVIC is enabled */\n\tWARN_ON(kvm_vcpu_apicv_active(&svm->vcpu));\n\n\t/*\n\t * This is just a dummy VINTR to actually cause a vmexit to happen.\n\t * Actual injection of virtual interrupts happens through EVENTINJ.\n\t */\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = 0x0;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTR"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "kvm_vcpu_apicv_active(&svm->vcpu)"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "&svm->vcpu"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline void svm_enable_vintr(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control;\n\n\t/* The following fields are ignored when AVIC is enabled */\n\tWARN_ON(kvm_vcpu_apicv_active(&svm->vcpu));\n\n\t/*\n\t * This is just a dummy VINTR to actually cause a vmexit to happen.\n\t * Actual injection of virtual interrupts happens through EVENTINJ.\n\t */\n\tcontrol = &svm->vmcb->control;\n\tcontrol->int_vector = 0x0;\n\tcontrol->int_ctl &= ~V_INTR_PRIO_MASK;\n\tcontrol->int_ctl |= V_IRQ_MASK |\n\t\t((/*control->int_vector >> 4*/ 0xf) << V_INTR_PRIO_SHIFT);\n\tmark_dirty(svm->vmcb, VMCB_INTR);\n}"
  },
  {
    "function_name": "svm_cache_reg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2089-2099",
    "snippet": "static void svm_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tswitch (reg) {\n\tcase VCPU_EXREG_PDPTR:\n\t\tBUG_ON(!npt_enabled);\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "1"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_pdptrs",
          "args": [
            "vcpu",
            "vcpu->arch.walk_mmu",
            "kvm_read_cr3(vcpu)"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "load_pdptrs",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "706-736",
          "snippet": "int load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif ((pdpte[i] & PT_PRESENT_MASK) &&\n\t\t    (pdpte[i] & pdptr_rsvd_bits(vcpu))) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);\n\nout:\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint load_pdptrs(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu, unsigned long cr3)\n{\n\tgfn_t pdpt_gfn = cr3 >> PAGE_SHIFT;\n\tunsigned offset = ((cr3 & (PAGE_SIZE-1)) >> 5) << 2;\n\tint i;\n\tint ret;\n\tu64 pdpte[ARRAY_SIZE(mmu->pdptrs)];\n\n\tret = kvm_read_guest_page_mmu(vcpu, mmu, pdpt_gfn, pdpte,\n\t\t\t\t      offset * sizeof(u64), sizeof(pdpte),\n\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\tif (ret < 0) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tfor (i = 0; i < ARRAY_SIZE(pdpte); ++i) {\n\t\tif ((pdpte[i] & PT_PRESENT_MASK) &&\n\t\t    (pdpte[i] & pdptr_rsvd_bits(vcpu))) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tret = 1;\n\n\tmemcpy(mmu->pdptrs, pdpte, sizeof(mmu->pdptrs));\n\tkvm_register_mark_dirty(vcpu, VCPU_EXREG_PDPTR);\n\nout:\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_read_cr3",
          "args": [
            "vcpu"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_read_cr3",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "137-142",
          "snippet": "static inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tkvm_x86_ops.cache_reg(vcpu, VCPU_EXREG_CR3);\n\treturn vcpu->arch.cr3;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline ulong kvm_read_cr3(struct kvm_vcpu *vcpu)\n{\n\tif (!kvm_register_is_available(vcpu, VCPU_EXREG_CR3))\n\t\tkvm_x86_ops.cache_reg(vcpu, VCPU_EXREG_CR3);\n\treturn vcpu->arch.cr3;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!npt_enabled"
          ],
          "line": 2093
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_cache_reg(struct kvm_vcpu *vcpu, enum kvm_reg reg)\n{\n\tswitch (reg) {\n\tcase VCPU_EXREG_PDPTR:\n\t\tBUG_ON(!npt_enabled);\n\t\tload_pdptrs(vcpu, vcpu->arch.walk_mmu, kvm_read_cr3(vcpu));\n\t\tbreak;\n\tdefault:\n\t\tWARN_ON_ONCE(1);\n\t}\n}"
  },
  {
    "function_name": "svm_set_rflags",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2076-2087",
    "snippet": "static void svm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (to_svm(vcpu)->nmi_singlestep)\n\t\trflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\n       /*\n        * Any change of EFLAGS.VM is accompanied by a reload of SS\n        * (caused by either a task switch or an inter-privilege IRET),\n        * so we do not need to update the CPL here.\n        */\n\tto_svm(vcpu)->vmcb->save.rflags = rflags;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2086
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\tif (to_svm(vcpu)->nmi_singlestep)\n\t\trflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);\n\n       /*\n        * Any change of EFLAGS.VM is accompanied by a reload of SS\n        * (caused by either a task switch or an inter-privilege IRET),\n        * so we do not need to update the CPL here.\n        */\n\tto_svm(vcpu)->vmcb->save.rflags = rflags;\n}"
  },
  {
    "function_name": "svm_get_rflags",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2061-2074",
    "snippet": "static unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long rflags = svm->vmcb->save.rflags;\n\n\tif (svm->nmi_singlestep) {\n\t\t/* Hide our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\trflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\trflags &= ~X86_EFLAGS_RF;\n\t}\n\treturn rflags;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2063
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic unsigned long svm_get_rflags(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned long rflags = svm->vmcb->save.rflags;\n\n\tif (svm->nmi_singlestep) {\n\t\t/* Hide our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\trflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\trflags &= ~X86_EFLAGS_RF;\n\t}\n\treturn rflags;\n}"
  },
  {
    "function_name": "svm_vcpu_unblocking",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2054-2059",
    "snippet": "static void svm_vcpu_unblocking(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))\n\t\tkvm_vcpu_update_apicv(vcpu);\n\tavic_set_running(vcpu, true);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_set_running",
          "args": [
            "vcpu",
            "true"
          ],
          "line": 2058
        },
        "resolved": true,
        "details": {
          "function_name": "avic_set_running",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1839-1848",
          "snippet": "static void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->avic_is_running = is_run;\n\tif (is_run)\n\t\tavic_vcpu_load(vcpu, vcpu->cpu);\n\telse\n\t\tavic_vcpu_put(vcpu);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->avic_is_running = is_run;\n\tif (is_run)\n\t\tavic_vcpu_load(vcpu, vcpu->cpu);\n\telse\n\t\tavic_vcpu_put(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_update_apicv",
          "args": [
            "vcpu"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_update_apicv",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8039-8047",
          "snippet": "void kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)\n{\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tvcpu->arch.apicv_active = kvm_apicv_activated(vcpu->kvm);\n\tkvm_apic_update_apicv(vcpu);\n\tkvm_x86_ops.refresh_apicv_exec_ctrl(vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "struct kvm_x86_ops kvm_x86_ops",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstruct kvm_x86_ops kvm_x86_ops;\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_vcpu_update_apicv(struct kvm_vcpu *vcpu)\n{\n\tif (!lapic_in_kernel(vcpu))\n\t\treturn;\n\n\tvcpu->arch.apicv_active = kvm_apicv_activated(vcpu->kvm);\n\tkvm_apic_update_apicv(vcpu);\n\tkvm_x86_ops.refresh_apicv_exec_ctrl(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_check_request",
          "args": [
            "KVM_REQ_APICV_UPDATE",
            "vcpu"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_vcpu_unblocking(struct kvm_vcpu *vcpu)\n{\n\tif (kvm_check_request(KVM_REQ_APICV_UPDATE, vcpu))\n\t\tkvm_vcpu_update_apicv(vcpu);\n\tavic_set_running(vcpu, true);\n}"
  },
  {
    "function_name": "svm_vcpu_blocking",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2049-2052",
    "snippet": "static void svm_vcpu_blocking(struct kvm_vcpu *vcpu)\n{\n\tavic_set_running(vcpu, false);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_set_running",
          "args": [
            "vcpu",
            "false"
          ],
          "line": 2051
        },
        "resolved": true,
        "details": {
          "function_name": "avic_set_running",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1839-1848",
          "snippet": "static void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->avic_is_running = is_run;\n\tif (is_run)\n\t\tavic_vcpu_load(vcpu, vcpu->cpu);\n\telse\n\t\tavic_vcpu_put(vcpu);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->avic_is_running = is_run;\n\tif (is_run)\n\t\tavic_vcpu_load(vcpu, vcpu->cpu);\n\telse\n\t\tavic_vcpu_put(vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_vcpu_blocking(struct kvm_vcpu *vcpu)\n{\n\tavic_set_running(vcpu, false);\n}"
  },
  {
    "function_name": "svm_vcpu_put",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "2027-2047",
    "snippet": "static void svm_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint i;\n\n\tavic_vcpu_put(vcpu);\n\n\t++vcpu->stat.host_state_reload;\n\tkvm_load_ldt(svm->host.ldt);\n#ifdef CONFIG_X86_64\n\tloadsegment(fs, svm->host.fs);\n\twrmsrl(MSR_KERNEL_GS_BASE, current->thread.gsbase);\n\tload_gs_index(svm->host.gs);\n#else\n#ifdef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\twrmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "host_save_user_msrs[i]",
            "svm->host_user_msrs[i]"
          ],
          "line": 2046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "gs",
            "svm->host.gs"
          ],
          "line": 2042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_gs_index",
          "args": [
            "svm->host.gs"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_KERNEL_GS_BASE",
            "current->thread.gsbase"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "loadsegment",
          "args": [
            "fs",
            "svm->host.fs"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_load_ldt",
          "args": [
            "svm->host.ldt"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_vcpu_put",
          "args": [
            "vcpu"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vcpu_put",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1820-1834",
          "snippet": "static void avic_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tu64 entry;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tif (entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK)\n\t\tavic_update_iommu_vcpu_affinity(vcpu, -1, 0);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tu64 entry;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tif (entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK)\n\t\tavic_update_iommu_vcpu_affinity(vcpu, -1, 0);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2029
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tint i;\n\n\tavic_vcpu_put(vcpu);\n\n\t++vcpu->stat.host_state_reload;\n\tkvm_load_ldt(svm->host.ldt);\n#ifdef CONFIG_X86_64\n\tloadsegment(fs, svm->host.fs);\n\twrmsrl(MSR_KERNEL_GS_BASE, current->thread.gsbase);\n\tload_gs_index(svm->host.gs);\n#else\n#ifdef CONFIG_X86_32_LAZY_GS\n\tloadsegment(gs, svm->host.gs);\n#endif\n#endif\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\twrmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n}"
  },
  {
    "function_name": "svm_vcpu_load",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1988-2025",
    "snippet": "static void svm_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tint i;\n\n\tif (unlikely(cpu != vcpu->cpu)) {\n\t\tsvm->asid_generation = 0;\n\t\tmark_all_dirty(svm->vmcb);\n\t}\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_GS_BASE, to_svm(vcpu)->host.gs_base);\n#endif\n\tsavesegment(fs, svm->host.fs);\n\tsavesegment(gs, svm->host.gs);\n\tsvm->host.ldt = kvm_read_ldt();\n\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\trdmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tu64 tsc_ratio = vcpu->arch.tsc_scaling_ratio;\n\t\tif (tsc_ratio != __this_cpu_read(current_tsc_ratio)) {\n\t\t\t__this_cpu_write(current_tsc_ratio, tsc_ratio);\n\t\t\twrmsrl(MSR_AMD64_TSC_RATIO, tsc_ratio);\n\t\t}\n\t}\n\t/* This assumes that the kernel never uses MSR_TSC_AUX */\n\tif (static_cpu_has(X86_FEATURE_RDTSCP))\n\t\twrmsrl(MSR_TSC_AUX, svm->tsc_aux);\n\n\tif (sd->current_vmcb != svm->vmcb) {\n\t\tsd->current_vmcb = svm->vmcb;\n\t\tindirect_branch_prediction_barrier();\n\t}\n\tavic_vcpu_load(vcpu, cpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(u64, current_tsc_ratio);",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_vcpu_load",
          "args": [
            "vcpu",
            "cpu"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vcpu_load",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1788-1818",
          "snippet": "static void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tu64 entry;\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tint h_physical_id = kvm_cpu_get_apicid(cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/*\n\t * Since the host physical APIC id is 8 bits,\n\t * we can support host APIC ID upto 255.\n\t */\n\tif (WARN_ON(h_physical_id > AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK;\n\tentry |= (h_physical_id & AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (svm->avic_is_running)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n\tavic_update_iommu_vcpu_affinity(vcpu, h_physical_id,\n\t\t\t\t\tsvm->avic_is_running);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)",
            "#define AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK\t(0xFFULL)"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n#define AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK\t(0xFFULL)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tu64 entry;\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tint h_physical_id = kvm_cpu_get_apicid(cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/*\n\t * Since the host physical APIC id is 8 bits,\n\t * we can support host APIC ID upto 255.\n\t */\n\tif (WARN_ON(h_physical_id > AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK;\n\tentry |= (h_physical_id & AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (svm->avic_is_running)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n\tavic_update_iommu_vcpu_affinity(vcpu, h_physical_id,\n\t\t\t\t\tsvm->avic_is_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "indirect_branch_prediction_barrier",
          "args": [],
          "line": 2022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_TSC_AUX",
            "svm->tsc_aux"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_RDTSCP"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_AMD64_TSC_RATIO",
            "tsc_ratio"
          ],
          "line": 2013
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_tsc_ratio",
            "tsc_ratio"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_read",
          "args": [
            "current_tsc_ratio"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_TSCRATEMSR"
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "host_save_user_msrs[i]",
            "svm->host_user_msrs[i]"
          ],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_read_ldt",
          "args": [],
          "line": 2004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "savesegment",
          "args": [
            "gs",
            "svm->host.gs"
          ],
          "line": 2003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "savesegment",
          "args": [
            "fs",
            "svm->host.fs"
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_GS_BASE",
            "to_svm(vcpu)->host.gs_base"
          ],
          "line": 2000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 2000
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_all_dirty",
          "args": [
            "svm->vmcb"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "mark_all_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "176-179",
          "snippet": "static inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "cpu != vcpu->cpu"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "cpu"
          ],
          "line": 1991
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_PER_CPU(u64, current_tsc_ratio);\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void svm_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, cpu);\n\tint i;\n\n\tif (unlikely(cpu != vcpu->cpu)) {\n\t\tsvm->asid_generation = 0;\n\t\tmark_all_dirty(svm->vmcb);\n\t}\n\n#ifdef CONFIG_X86_64\n\trdmsrl(MSR_GS_BASE, to_svm(vcpu)->host.gs_base);\n#endif\n\tsavesegment(fs, svm->host.fs);\n\tsavesegment(gs, svm->host.gs);\n\tsvm->host.ldt = kvm_read_ldt();\n\n\tfor (i = 0; i < NR_HOST_SAVE_USER_MSRS; i++)\n\t\trdmsrl(host_save_user_msrs[i], svm->host_user_msrs[i]);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tu64 tsc_ratio = vcpu->arch.tsc_scaling_ratio;\n\t\tif (tsc_ratio != __this_cpu_read(current_tsc_ratio)) {\n\t\t\t__this_cpu_write(current_tsc_ratio, tsc_ratio);\n\t\t\twrmsrl(MSR_AMD64_TSC_RATIO, tsc_ratio);\n\t\t}\n\t}\n\t/* This assumes that the kernel never uses MSR_TSC_AUX */\n\tif (static_cpu_has(X86_FEATURE_RDTSCP))\n\t\twrmsrl(MSR_TSC_AUX, svm->tsc_aux);\n\n\tif (sd->current_vmcb != svm->vmcb) {\n\t\tsd->current_vmcb = svm->vmcb;\n\t\tindirect_branch_prediction_barrier();\n\t}\n\tavic_vcpu_load(vcpu, cpu);\n}"
  },
  {
    "function_name": "svm_free_vcpu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1971-1986",
    "snippet": "static void svm_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * The vmcb page can be recycled, causing a false negative in\n\t * svm_vcpu_load(). So, ensure that no logical CPU has this\n\t * vmcb page recorded as its current vmcb.\n\t */\n\tsvm_clear_current_vmcb(svm->vmcb);\n\n\t__free_page(pfn_to_page(__sme_clr(svm->vmcb_pa) >> PAGE_SHIFT));\n\t__free_pages(virt_to_page(svm->msrpm), MSRPM_ALLOC_ORDER);\n\t__free_page(virt_to_page(svm->nested.hsave));\n\t__free_pages(virt_to_page(svm->nested.msrpm), MSRPM_ALLOC_ORDER);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSRPM_ALLOC_ORDER 1"
    ],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "virt_to_page(svm->nested.msrpm)",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "svm->nested.msrpm"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "virt_to_page(svm->nested.hsave)"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "svm->nested.hsave"
          ],
          "line": 1984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "virt_to_page(svm->msrpm)",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "svm->msrpm"
          ],
          "line": 1983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "pfn_to_page(__sme_clr(svm->vmcb_pa) >> PAGE_SHIFT)"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "__sme_clr(svm->vmcb_pa) >> PAGE_SHIFT"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_clr",
          "args": [
            "svm->vmcb_pa"
          ],
          "line": 1982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_clear_current_vmcb",
          "args": [
            "svm->vmcb"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "svm_clear_current_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1963-1969",
          "snippet": "static void svm_clear_current_vmcb(struct vmcb *vmcb)\n{\n\tint i;\n\n\tfor_each_online_cpu(i)\n\t\tcmpxchg(&per_cpu(svm_data, i)->current_vmcb, vmcb, NULL);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void svm_clear_current_vmcb(struct vmcb *vmcb)\n{\n\tint i;\n\n\tfor_each_online_cpu(i)\n\t\tcmpxchg(&per_cpu(svm_data, i)->current_vmcb, vmcb, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1973
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRPM_ALLOC_ORDER 1\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_free_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\t/*\n\t * The vmcb page can be recycled, causing a false negative in\n\t * svm_vcpu_load(). So, ensure that no logical CPU has this\n\t * vmcb page recorded as its current vmcb.\n\t */\n\tsvm_clear_current_vmcb(svm->vmcb);\n\n\t__free_page(pfn_to_page(__sme_clr(svm->vmcb_pa) >> PAGE_SHIFT));\n\t__free_pages(virt_to_page(svm->msrpm), MSRPM_ALLOC_ORDER);\n\t__free_page(virt_to_page(svm->nested.hsave));\n\t__free_pages(virt_to_page(svm->nested.msrpm), MSRPM_ALLOC_ORDER);\n}"
  },
  {
    "function_name": "svm_clear_current_vmcb",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1963-1969",
    "snippet": "static void svm_clear_current_vmcb(struct vmcb *vmcb)\n{\n\tint i;\n\n\tfor_each_online_cpu(i)\n\t\tcmpxchg(&per_cpu(svm_data, i)->current_vmcb, vmcb, NULL);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void svm_clear_current_vmcb(struct vmcb *vmcb)\n{\n\tint i;\n\n\tfor_each_online_cpu(i)\n\t\tcmpxchg(&per_cpu(svm_data, i)->current_vmcb, vmcb, NULL);\n}"
  },
  {
    "function_name": "svm_create_vcpu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1893-1961",
    "snippet": "static int svm_create_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm;\n\tstruct page *page;\n\tstruct page *msrpm_pages;\n\tstruct page *hsave_page;\n\tstruct page *nested_msrpm_pages;\n\tint err;\n\n\tBUILD_BUG_ON(offsetof(struct vcpu_svm, vcpu) != 0);\n\tsvm = to_svm(vcpu);\n\n\terr = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!page)\n\t\tgoto out;\n\n\tmsrpm_pages = alloc_pages(GFP_KERNEL_ACCOUNT, MSRPM_ALLOC_ORDER);\n\tif (!msrpm_pages)\n\t\tgoto free_page1;\n\n\tnested_msrpm_pages = alloc_pages(GFP_KERNEL_ACCOUNT, MSRPM_ALLOC_ORDER);\n\tif (!nested_msrpm_pages)\n\t\tgoto free_page2;\n\n\thsave_page = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!hsave_page)\n\t\tgoto free_page3;\n\n\terr = avic_init_vcpu(svm);\n\tif (err)\n\t\tgoto free_page4;\n\n\t/* We initialize this flag to true to make sure that the is_running\n\t * bit would be set the first time the vcpu is loaded.\n\t */\n\tif (irqchip_in_kernel(vcpu->kvm) && kvm_apicv_activated(vcpu->kvm))\n\t\tsvm->avic_is_running = true;\n\n\tsvm->nested.hsave = page_address(hsave_page);\n\n\tsvm->msrpm = page_address(msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->msrpm);\n\n\tsvm->nested.msrpm = page_address(nested_msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->nested.msrpm);\n\n\tsvm->vmcb = page_address(page);\n\tclear_page(svm->vmcb);\n\tsvm->vmcb_pa = __sme_set(page_to_pfn(page) << PAGE_SHIFT);\n\tsvm->asid_generation = 0;\n\tinit_vmcb(svm);\n\n\tsvm_init_osvw(vcpu);\n\tvcpu->arch.microcode_version = 0x01000065;\n\n\treturn 0;\n\nfree_page4:\n\t__free_page(hsave_page);\nfree_page3:\n\t__free_pages(nested_msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page2:\n\t__free_pages(msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page1:\n\t__free_page(page);\nout:\n\treturn err;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSRPM_ALLOC_ORDER 1"
    ],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "page"
          ],
          "line": 1958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "msrpm_pages",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "nested_msrpm_pages",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "hsave_page"
          ],
          "line": 1952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_init_osvw",
          "args": [
            "vcpu"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "svm_init_osvw",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "543-562",
          "snippet": "static void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static uint64_t osvw_len = 4, osvw_status;",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic uint64_t osvw_len = 4, osvw_status;\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_vmcb",
          "args": [
            "svm"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "init_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1248-1405",
          "snippet": "static void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\tset_exception_intercept(svm, GP_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\tset_intercept(svm, INTERCEPT_RDPRU);\n\tset_intercept(svm, INTERCEPT_RSM);\n\n\tif (!kvm_mwait_in_guest(svm->vcpu.kvm)) {\n\t\tset_intercept(svm, INTERCEPT_MONITOR);\n\t\tset_intercept(svm, INTERCEPT_MWAIT);\n\t}\n\n\tif (!kvm_hlt_in_guest(svm->vcpu.kvm))\n\t\tset_intercept(svm, INTERCEPT_HLT);\n\n\tcontrol->iopm_base_pa = __sme_set(iopm_base);\n\tcontrol->msrpm_base_pa = __sme_set(__pa(svm->msrpm));\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl |= SVM_NESTED_CTL_NP_ENABLE;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (pause_filter_count) {\n\t\tcontrol->pause_filter_count = pause_filter_count;\n\t\tif (pause_filter_thresh)\n\t\t\tcontrol->pause_filter_thresh = pause_filter_thresh;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t} else {\n\t\tclr_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tavic_init_vmcb(svm);\n\n\t/*\n\t * If hardware supports Virtual VMLOAD VMSAVE then enable it\n\t * in VMCB and clear intercepts to avoid #VMEXIT.\n\t */\n\tif (vls) {\n\t\tclr_intercept(svm, INTERCEPT_VMLOAD);\n\t\tclr_intercept(svm, INTERCEPT_VMSAVE);\n\t\tsvm->vmcb->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\t}\n\n\tif (vgif) {\n\t\tclr_intercept(svm, INTERCEPT_STGI);\n\t\tclr_intercept(svm, INTERCEPT_CLGI);\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_ENABLE_MASK;\n\t}\n\n\tif (sev_guest(svm->vcpu.kvm)) {\n\t\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ENABLE;\n\t\tclr_exception_intercept(svm, UD_VECTOR);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define SEG_TYPE_BUSY_TSS16 3",
            "#define SEG_TYPE_LDT 2"
          ],
          "globals_used": [
            "static unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;",
            "static unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;",
            "static int nested = true;",
            "static int vls = true;",
            "static int vgif = true;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
            "static unsigned long iopm_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define SEG_TYPE_BUSY_TSS16 3\n#define SEG_TYPE_LDT 2\n\nstatic unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nstatic int nested = true;\nstatic int vls = true;\nstatic int vgif = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic unsigned long iopm_base;\n\nstatic void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\tset_exception_intercept(svm, GP_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\tset_intercept(svm, INTERCEPT_RDPRU);\n\tset_intercept(svm, INTERCEPT_RSM);\n\n\tif (!kvm_mwait_in_guest(svm->vcpu.kvm)) {\n\t\tset_intercept(svm, INTERCEPT_MONITOR);\n\t\tset_intercept(svm, INTERCEPT_MWAIT);\n\t}\n\n\tif (!kvm_hlt_in_guest(svm->vcpu.kvm))\n\t\tset_intercept(svm, INTERCEPT_HLT);\n\n\tcontrol->iopm_base_pa = __sme_set(iopm_base);\n\tcontrol->msrpm_base_pa = __sme_set(__pa(svm->msrpm));\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl |= SVM_NESTED_CTL_NP_ENABLE;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (pause_filter_count) {\n\t\tcontrol->pause_filter_count = pause_filter_count;\n\t\tif (pause_filter_thresh)\n\t\t\tcontrol->pause_filter_thresh = pause_filter_thresh;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t} else {\n\t\tclr_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tavic_init_vmcb(svm);\n\n\t/*\n\t * If hardware supports Virtual VMLOAD VMSAVE then enable it\n\t * in VMCB and clear intercepts to avoid #VMEXIT.\n\t */\n\tif (vls) {\n\t\tclr_intercept(svm, INTERCEPT_VMLOAD);\n\t\tclr_intercept(svm, INTERCEPT_VMSAVE);\n\t\tsvm->vmcb->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\t}\n\n\tif (vgif) {\n\t\tclr_intercept(svm, INTERCEPT_STGI);\n\t\tclr_intercept(svm, INTERCEPT_CLGI);\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_ENABLE_MASK;\n\t}\n\n\tif (sev_guest(svm->vcpu.kvm)) {\n\t\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ENABLE;\n\t\tclr_exception_intercept(svm, UD_VECTOR);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "page_to_pfn(page) << PAGE_SHIFT"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "page"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "svm->vmcb"
          ],
          "line": 1941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "page"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_vcpu_init_msrpm",
          "args": [
            "svm->nested.msrpm"
          ],
          "line": 1938
        },
        "resolved": true,
        "details": {
          "function_name": "svm_vcpu_init_msrpm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "764-776",
          "snippet": "static void svm_vcpu_init_msrpm(u32 *msrpm)\n{\n\tint i;\n\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\n\t\tset_msr_interception(msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSRPM_ALLOC_ORDER 1"
          ],
          "globals_used": [
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRPM_ALLOC_ORDER 1\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void svm_vcpu_init_msrpm(u32 *msrpm)\n{\n\tint i;\n\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\n\t\tset_msr_interception(msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "nested_msrpm_pages"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "msrpm_pages"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "hsave_page"
          ],
          "line": 1932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apicv_activated",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apicv_activated",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7495-7498",
          "snippet": "bool kvm_apicv_activated(struct kvm *kvm)\n{\n\treturn (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_apicv_activated(struct kvm *kvm)\n{\n\treturn (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.h",
          "lines": "96-103",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode != KVM_IRQCHIP_NONE;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode != KVM_IRQCHIP_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_init_vcpu",
          "args": [
            "svm"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "avic_init_vcpu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1874-1891",
          "snippet": "static int avic_init_vcpu(struct vcpu_svm *svm)\n{\n\tint ret;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\tif (!avic || !irqchip_in_kernel(vcpu->kvm))\n\t\treturn 0;\n\n\tret = avic_init_backing_page(&svm->vcpu);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_LIST_HEAD(&svm->ir_list);\n\tspin_lock_init(&svm->ir_list_lock);\n\tsvm->dfr_reg = APIC_DFR_FLAT;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int avic;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_init_vcpu(struct vcpu_svm *svm)\n{\n\tint ret;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\tif (!avic || !irqchip_in_kernel(vcpu->kvm))\n\t\treturn 0;\n\n\tret = avic_init_backing_page(&svm->vcpu);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_LIST_HEAD(&svm->ir_list);\n\tspin_lock_init(&svm->ir_list_lock);\n\tsvm->dfr_reg = APIC_DFR_FLAT;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "GFP_KERNEL_ACCOUNT",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "GFP_KERNEL_ACCOUNT",
            "MSRPM_ALLOC_ORDER"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1903
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "offsetof(struct vcpu_svm, vcpu) != 0"
          ],
          "line": 1902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRPM_ALLOC_ORDER 1\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int svm_create_vcpu(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm;\n\tstruct page *page;\n\tstruct page *msrpm_pages;\n\tstruct page *hsave_page;\n\tstruct page *nested_msrpm_pages;\n\tint err;\n\n\tBUILD_BUG_ON(offsetof(struct vcpu_svm, vcpu) != 0);\n\tsvm = to_svm(vcpu);\n\n\terr = -ENOMEM;\n\tpage = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!page)\n\t\tgoto out;\n\n\tmsrpm_pages = alloc_pages(GFP_KERNEL_ACCOUNT, MSRPM_ALLOC_ORDER);\n\tif (!msrpm_pages)\n\t\tgoto free_page1;\n\n\tnested_msrpm_pages = alloc_pages(GFP_KERNEL_ACCOUNT, MSRPM_ALLOC_ORDER);\n\tif (!nested_msrpm_pages)\n\t\tgoto free_page2;\n\n\thsave_page = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!hsave_page)\n\t\tgoto free_page3;\n\n\terr = avic_init_vcpu(svm);\n\tif (err)\n\t\tgoto free_page4;\n\n\t/* We initialize this flag to true to make sure that the is_running\n\t * bit would be set the first time the vcpu is loaded.\n\t */\n\tif (irqchip_in_kernel(vcpu->kvm) && kvm_apicv_activated(vcpu->kvm))\n\t\tsvm->avic_is_running = true;\n\n\tsvm->nested.hsave = page_address(hsave_page);\n\n\tsvm->msrpm = page_address(msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->msrpm);\n\n\tsvm->nested.msrpm = page_address(nested_msrpm_pages);\n\tsvm_vcpu_init_msrpm(svm->nested.msrpm);\n\n\tsvm->vmcb = page_address(page);\n\tclear_page(svm->vmcb);\n\tsvm->vmcb_pa = __sme_set(page_to_pfn(page) << PAGE_SHIFT);\n\tsvm->asid_generation = 0;\n\tinit_vmcb(svm);\n\n\tsvm_init_osvw(vcpu);\n\tvcpu->arch.microcode_version = 0x01000065;\n\n\treturn 0;\n\nfree_page4:\n\t__free_page(hsave_page);\nfree_page3:\n\t__free_pages(nested_msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page2:\n\t__free_pages(msrpm_pages, MSRPM_ALLOC_ORDER);\nfree_page1:\n\t__free_page(page);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "avic_init_vcpu",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1874-1891",
    "snippet": "static int avic_init_vcpu(struct vcpu_svm *svm)\n{\n\tint ret;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\tif (!avic || !irqchip_in_kernel(vcpu->kvm))\n\t\treturn 0;\n\n\tret = avic_init_backing_page(&svm->vcpu);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_LIST_HEAD(&svm->ir_list);\n\tspin_lock_init(&svm->ir_list_lock);\n\tsvm->dfr_reg = APIC_DFR_FLAT;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int avic;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&svm->ir_list_lock"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&svm->ir_list"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_init_backing_page",
          "args": [
            "&svm->vcpu"
          ],
          "line": 1882
        },
        "resolved": true,
        "details": {
          "function_name": "avic_init_backing_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1456-1491",
          "snippet": "static int avic_init_backing_page(struct kvm_vcpu *vcpu)\n{\n\tu64 *entry, new_entry;\n\tint id = vcpu->vcpu_id;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (id >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn -EINVAL;\n\n\tif (!svm->vcpu.arch.apic->regs)\n\t\treturn -EINVAL;\n\n\tif (kvm_apicv_activated(vcpu->kvm)) {\n\t\tint ret;\n\n\t\tret = avic_update_access_page(vcpu->kvm, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsvm->avic_backing_page = virt_to_page(svm->vcpu.arch.apic->regs);\n\n\t/* Setting AVIC backing page address in the phy APIC ID table */\n\tentry = avic_get_physical_id_entry(vcpu, id);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = __sme_set((page_to_phys(svm->avic_backing_page) &\n\t\t\t      AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK) |\n\t\t\t      AVIC_PHYSICAL_ID_ENTRY_VALID_MASK);\n\tWRITE_ONCE(*entry, new_entry);\n\n\tsvm->avic_physical_id_cache = entry;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_VALID_MASK\t\t(1ULL << 63)",
            "#define AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK\t(0xFFFFFFFFFFULL << 12)",
            "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_VALID_MASK\t\t(1ULL << 63)\n#define AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK\t(0xFFFFFFFFFFULL << 12)\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_init_backing_page(struct kvm_vcpu *vcpu)\n{\n\tu64 *entry, new_entry;\n\tint id = vcpu->vcpu_id;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (id >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn -EINVAL;\n\n\tif (!svm->vcpu.arch.apic->regs)\n\t\treturn -EINVAL;\n\n\tif (kvm_apicv_activated(vcpu->kvm)) {\n\t\tint ret;\n\n\t\tret = avic_update_access_page(vcpu->kvm, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsvm->avic_backing_page = virt_to_page(svm->vcpu.arch.apic->regs);\n\n\t/* Setting AVIC backing page address in the phy APIC ID table */\n\tentry = avic_get_physical_id_entry(vcpu, id);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = __sme_set((page_to_phys(svm->avic_backing_page) &\n\t\t\t      AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK) |\n\t\t\t      AVIC_PHYSICAL_ID_ENTRY_VALID_MASK);\n\tWRITE_ONCE(*entry, new_entry);\n\n\tsvm->avic_physical_id_cache = entry;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqchip_in_kernel",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "irqchip_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq.h",
          "lines": "96-103",
          "snippet": "static inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode != KVM_IRQCHIP_NONE;\n}",
          "includes": [
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <kvm/iodev.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/mm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <kvm/iodev.h>\n#include <linux/spinlock.h>\n#include <linux/kvm_host.h>\n#include <linux/hrtimer.h>\n#include <linux/mm_types.h>\n\nstatic inline int irqchip_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode != KVM_IRQCHIP_NONE;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_init_vcpu(struct vcpu_svm *svm)\n{\n\tint ret;\n\tstruct kvm_vcpu *vcpu = &svm->vcpu;\n\n\tif (!avic || !irqchip_in_kernel(vcpu->kvm))\n\t\treturn 0;\n\n\tret = avic_init_backing_page(&svm->vcpu);\n\tif (ret)\n\t\treturn ret;\n\n\tINIT_LIST_HEAD(&svm->ir_list);\n\tspin_lock_init(&svm->ir_list_lock);\n\tsvm->dfr_reg = APIC_DFR_FLAT;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "svm_vcpu_reset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1850-1872",
    "snippet": "static void svm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dummy;\n\tu32 eax = 1;\n\n\tsvm->spec_ctrl = 0;\n\tsvm->virt_spec_ctrl = 0;\n\n\tif (!init_event) {\n\t\tsvm->vcpu.arch.apic_base = APIC_DEFAULT_PHYS_BASE |\n\t\t\t\t\t   MSR_IA32_APICBASE_ENABLE;\n\t\tif (kvm_vcpu_is_reset_bsp(&svm->vcpu))\n\t\t\tsvm->vcpu.arch.apic_base |= MSR_IA32_APICBASE_BSP;\n\t}\n\tinit_vmcb(svm);\n\n\tkvm_cpuid(vcpu, &eax, &dummy, &dummy, &dummy, false);\n\tkvm_rdx_write(vcpu, eax);\n\n\tif (kvm_vcpu_apicv_active(vcpu) && !init_event)\n\t\tavic_update_vapic_bar(svm, APIC_DEFAULT_PHYS_BASE);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_update_vapic_bar",
          "args": [
            "svm",
            "APIC_DEFAULT_PHYS_BASE"
          ],
          "line": 1871
        },
        "resolved": true,
        "details": {
          "function_name": "avic_update_vapic_bar",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "313-317",
          "snippet": "static inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rdx_write",
          "args": [
            "vcpu",
            "eax"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_cpuid",
          "args": [
            "vcpu",
            "&eax",
            "&dummy",
            "&dummy",
            "&dummy",
            "false"
          ],
          "line": 1867
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpuid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.c",
          "lines": "988-1034",
          "snippet": "bool kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx,\n\t       u32 *ecx, u32 *edx, bool exact_only)\n{\n\tu32 orig_function = *eax, function = *eax, index = *ecx;\n\tstruct kvm_cpuid_entry2 *entry;\n\tbool exact, used_max_basic = false;\n\n\tentry = kvm_find_cpuid_entry(vcpu, function, index);\n\texact = !!entry;\n\n\tif (!entry && !exact_only) {\n\t\tentry = get_out_of_range_cpuid_entry(vcpu, &function, index);\n\t\tused_max_basic = !!entry;\n\t}\n\n\tif (entry) {\n\t\t*eax = entry->eax;\n\t\t*ebx = entry->ebx;\n\t\t*ecx = entry->ecx;\n\t\t*edx = entry->edx;\n\t\tif (function == 7 && index == 0) {\n\t\t\tu64 data;\n\t\t        if (!__kvm_get_msr(vcpu, MSR_IA32_TSX_CTRL, &data, true) &&\n\t\t\t    (data & TSX_CTRL_CPUID_CLEAR))\n\t\t\t\t*ebx &= ~(F(RTM) | F(HLE));\n\t\t}\n\t} else {\n\t\t*eax = *ebx = *ecx = *edx = 0;\n\t\t/*\n\t\t * When leaf 0BH or 1FH is defined, CL is pass-through\n\t\t * and EDX is always the x2APIC ID, even for undefined\n\t\t * subleaves. Index 1 will exist iff the leaf is\n\t\t * implemented, so we pass through CL iff leaf 1\n\t\t * exists. EDX can be copied from any existing index.\n\t\t */\n\t\tif (function == 0xb || function == 0x1f) {\n\t\t\tentry = kvm_find_cpuid_entry(vcpu, function, 1);\n\t\t\tif (entry) {\n\t\t\t\t*ecx = index & 0xff;\n\t\t\t\t*edx = entry->edx;\n\t\t\t}\n\t\t}\n\t}\n\ttrace_kvm_cpuid(orig_function, index, *eax, *ebx, *ecx, *edx, exact,\n\t\t\tused_max_basic);\n\treturn exact;\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/processor.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define F feature_bit"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/processor.h>\n#include <linux/sched/stat.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/kvm_host.h>\n\n#define F feature_bit\n\nbool kvm_cpuid(struct kvm_vcpu *vcpu, u32 *eax, u32 *ebx,\n\t       u32 *ecx, u32 *edx, bool exact_only)\n{\n\tu32 orig_function = *eax, function = *eax, index = *ecx;\n\tstruct kvm_cpuid_entry2 *entry;\n\tbool exact, used_max_basic = false;\n\n\tentry = kvm_find_cpuid_entry(vcpu, function, index);\n\texact = !!entry;\n\n\tif (!entry && !exact_only) {\n\t\tentry = get_out_of_range_cpuid_entry(vcpu, &function, index);\n\t\tused_max_basic = !!entry;\n\t}\n\n\tif (entry) {\n\t\t*eax = entry->eax;\n\t\t*ebx = entry->ebx;\n\t\t*ecx = entry->ecx;\n\t\t*edx = entry->edx;\n\t\tif (function == 7 && index == 0) {\n\t\t\tu64 data;\n\t\t        if (!__kvm_get_msr(vcpu, MSR_IA32_TSX_CTRL, &data, true) &&\n\t\t\t    (data & TSX_CTRL_CPUID_CLEAR))\n\t\t\t\t*ebx &= ~(F(RTM) | F(HLE));\n\t\t}\n\t} else {\n\t\t*eax = *ebx = *ecx = *edx = 0;\n\t\t/*\n\t\t * When leaf 0BH or 1FH is defined, CL is pass-through\n\t\t * and EDX is always the x2APIC ID, even for undefined\n\t\t * subleaves. Index 1 will exist iff the leaf is\n\t\t * implemented, so we pass through CL iff leaf 1\n\t\t * exists. EDX can be copied from any existing index.\n\t\t */\n\t\tif (function == 0xb || function == 0x1f) {\n\t\t\tentry = kvm_find_cpuid_entry(vcpu, function, 1);\n\t\t\tif (entry) {\n\t\t\t\t*ecx = index & 0xff;\n\t\t\t\t*edx = entry->edx;\n\t\t\t}\n\t\t}\n\t}\n\ttrace_kvm_cpuid(orig_function, index, *eax, *ebx, *ecx, *edx, exact,\n\t\t\tused_max_basic);\n\treturn exact;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_vmcb",
          "args": [
            "svm"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "init_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1248-1405",
          "snippet": "static void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\tset_exception_intercept(svm, GP_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\tset_intercept(svm, INTERCEPT_RDPRU);\n\tset_intercept(svm, INTERCEPT_RSM);\n\n\tif (!kvm_mwait_in_guest(svm->vcpu.kvm)) {\n\t\tset_intercept(svm, INTERCEPT_MONITOR);\n\t\tset_intercept(svm, INTERCEPT_MWAIT);\n\t}\n\n\tif (!kvm_hlt_in_guest(svm->vcpu.kvm))\n\t\tset_intercept(svm, INTERCEPT_HLT);\n\n\tcontrol->iopm_base_pa = __sme_set(iopm_base);\n\tcontrol->msrpm_base_pa = __sme_set(__pa(svm->msrpm));\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl |= SVM_NESTED_CTL_NP_ENABLE;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (pause_filter_count) {\n\t\tcontrol->pause_filter_count = pause_filter_count;\n\t\tif (pause_filter_thresh)\n\t\t\tcontrol->pause_filter_thresh = pause_filter_thresh;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t} else {\n\t\tclr_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tavic_init_vmcb(svm);\n\n\t/*\n\t * If hardware supports Virtual VMLOAD VMSAVE then enable it\n\t * in VMCB and clear intercepts to avoid #VMEXIT.\n\t */\n\tif (vls) {\n\t\tclr_intercept(svm, INTERCEPT_VMLOAD);\n\t\tclr_intercept(svm, INTERCEPT_VMSAVE);\n\t\tsvm->vmcb->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\t}\n\n\tif (vgif) {\n\t\tclr_intercept(svm, INTERCEPT_STGI);\n\t\tclr_intercept(svm, INTERCEPT_CLGI);\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_ENABLE_MASK;\n\t}\n\n\tif (sev_guest(svm->vcpu.kvm)) {\n\t\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ENABLE;\n\t\tclr_exception_intercept(svm, UD_VECTOR);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define SEG_TYPE_BUSY_TSS16 3",
            "#define SEG_TYPE_LDT 2"
          ],
          "globals_used": [
            "static unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;",
            "static unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;",
            "static int nested = true;",
            "static int vls = true;",
            "static int vgif = true;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
            "static unsigned long iopm_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define SEG_TYPE_BUSY_TSS16 3\n#define SEG_TYPE_LDT 2\n\nstatic unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nstatic int nested = true;\nstatic int vls = true;\nstatic int vgif = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic unsigned long iopm_base;\n\nstatic void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\tset_exception_intercept(svm, GP_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\tset_intercept(svm, INTERCEPT_RDPRU);\n\tset_intercept(svm, INTERCEPT_RSM);\n\n\tif (!kvm_mwait_in_guest(svm->vcpu.kvm)) {\n\t\tset_intercept(svm, INTERCEPT_MONITOR);\n\t\tset_intercept(svm, INTERCEPT_MWAIT);\n\t}\n\n\tif (!kvm_hlt_in_guest(svm->vcpu.kvm))\n\t\tset_intercept(svm, INTERCEPT_HLT);\n\n\tcontrol->iopm_base_pa = __sme_set(iopm_base);\n\tcontrol->msrpm_base_pa = __sme_set(__pa(svm->msrpm));\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl |= SVM_NESTED_CTL_NP_ENABLE;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (pause_filter_count) {\n\t\tcontrol->pause_filter_count = pause_filter_count;\n\t\tif (pause_filter_thresh)\n\t\t\tcontrol->pause_filter_thresh = pause_filter_thresh;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t} else {\n\t\tclr_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tavic_init_vmcb(svm);\n\n\t/*\n\t * If hardware supports Virtual VMLOAD VMSAVE then enable it\n\t * in VMCB and clear intercepts to avoid #VMEXIT.\n\t */\n\tif (vls) {\n\t\tclr_intercept(svm, INTERCEPT_VMLOAD);\n\t\tclr_intercept(svm, INTERCEPT_VMSAVE);\n\t\tsvm->vmcb->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\t}\n\n\tif (vgif) {\n\t\tclr_intercept(svm, INTERCEPT_STGI);\n\t\tclr_intercept(svm, INTERCEPT_CLGI);\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_ENABLE_MASK;\n\t}\n\n\tif (sev_guest(svm->vcpu.kvm)) {\n\t\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ENABLE;\n\t\tclr_exception_intercept(svm, UD_VECTOR);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_is_reset_bsp",
          "args": [
            "&svm->vcpu"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_is_reset_bsp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9688-9691",
          "snippet": "bool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nbool kvm_vcpu_is_reset_bsp(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->kvm->arch.bsp_vcpu_id == vcpu->vcpu_id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 dummy;\n\tu32 eax = 1;\n\n\tsvm->spec_ctrl = 0;\n\tsvm->virt_spec_ctrl = 0;\n\n\tif (!init_event) {\n\t\tsvm->vcpu.arch.apic_base = APIC_DEFAULT_PHYS_BASE |\n\t\t\t\t\t   MSR_IA32_APICBASE_ENABLE;\n\t\tif (kvm_vcpu_is_reset_bsp(&svm->vcpu))\n\t\t\tsvm->vcpu.arch.apic_base |= MSR_IA32_APICBASE_BSP;\n\t}\n\tinit_vmcb(svm);\n\n\tkvm_cpuid(vcpu, &eax, &dummy, &dummy, &dummy, false);\n\tkvm_rdx_write(vcpu, eax);\n\n\tif (kvm_vcpu_apicv_active(vcpu) && !init_event)\n\t\tavic_update_vapic_bar(svm, APIC_DEFAULT_PHYS_BASE);\n}"
  },
  {
    "function_name": "avic_set_running",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1839-1848",
    "snippet": "static void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->avic_is_running = is_run;\n\tif (is_run)\n\t\tavic_vcpu_load(vcpu, vcpu->cpu);\n\telse\n\t\tavic_vcpu_put(vcpu);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_vcpu_put",
          "args": [
            "vcpu"
          ],
          "line": 1847
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vcpu_put",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1820-1834",
          "snippet": "static void avic_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tu64 entry;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tif (entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK)\n\t\tavic_update_iommu_vcpu_affinity(vcpu, -1, 0);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tu64 entry;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tif (entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK)\n\t\tavic_update_iommu_vcpu_affinity(vcpu, -1, 0);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_vcpu_load",
          "args": [
            "vcpu",
            "vcpu->cpu"
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vcpu_load",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1788-1818",
          "snippet": "static void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tu64 entry;\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tint h_physical_id = kvm_cpu_get_apicid(cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/*\n\t * Since the host physical APIC id is 8 bits,\n\t * we can support host APIC ID upto 255.\n\t */\n\tif (WARN_ON(h_physical_id > AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK;\n\tentry |= (h_physical_id & AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (svm->avic_is_running)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n\tavic_update_iommu_vcpu_affinity(vcpu, h_physical_id,\n\t\t\t\t\tsvm->avic_is_running);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)",
            "#define AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK\t(0xFFULL)"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n#define AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK\t(0xFFULL)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tu64 entry;\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tint h_physical_id = kvm_cpu_get_apicid(cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/*\n\t * Since the host physical APIC id is 8 bits,\n\t * we can support host APIC ID upto 255.\n\t */\n\tif (WARN_ON(h_physical_id > AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK;\n\tentry |= (h_physical_id & AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (svm->avic_is_running)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n\tavic_update_iommu_vcpu_affinity(vcpu, h_physical_id,\n\t\t\t\t\tsvm->avic_is_running);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_set_running(struct kvm_vcpu *vcpu, bool is_run)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tsvm->avic_is_running = is_run;\n\tif (is_run)\n\t\tavic_vcpu_load(vcpu, vcpu->cpu);\n\telse\n\t\tavic_vcpu_put(vcpu);\n}"
  },
  {
    "function_name": "avic_vcpu_put",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1820-1834",
    "snippet": "static void avic_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tu64 entry;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tif (entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK)\n\t\tavic_update_iommu_vcpu_affinity(vcpu, -1, 0);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*(svm->avic_physical_id_cache)",
            "entry"
          ],
          "line": 1833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_update_iommu_vcpu_affinity",
          "args": [
            "vcpu",
            "-1",
            "0"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "avic_update_iommu_vcpu_affinity",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1758-1786",
          "snippet": "static inline int\navic_update_iommu_vcpu_affinity(struct kvm_vcpu *vcpu, int cpu, bool r)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm))\n\t\treturn 0;\n\n\t/*\n\t * Here, we go through the per-vcpu ir_list to update all existing\n\t * interrupt remapping table entry targeting this vcpu.\n\t */\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\n\tif (list_empty(&svm->ir_list))\n\t\tgoto out;\n\n\tlist_for_each_entry(ir, &svm->ir_list, node) {\n\t\tret = amd_iommu_update_ga(cpu, r, ir->data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline int\navic_update_iommu_vcpu_affinity(struct kvm_vcpu *vcpu, int cpu, bool r)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm))\n\t\treturn 0;\n\n\t/*\n\t * Here, we go through the per-vcpu ir_list to update all existing\n\t * interrupt remapping table entry targeting this vcpu.\n\t */\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\n\tif (list_empty(&svm->ir_list))\n\t\tgoto out;\n\n\tlist_for_each_entry(ir, &svm->ir_list, node) {\n\t\tret = amd_iommu_update_ga(cpu, r, ir->data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*(svm->avic_physical_id_cache)"
          ],
          "line": 1828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_vcpu_put(struct kvm_vcpu *vcpu)\n{\n\tu64 entry;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tif (entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK)\n\t\tavic_update_iommu_vcpu_affinity(vcpu, -1, 0);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n}"
  },
  {
    "function_name": "avic_vcpu_load",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1788-1818",
    "snippet": "static void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tu64 entry;\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tint h_physical_id = kvm_cpu_get_apicid(cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/*\n\t * Since the host physical APIC id is 8 bits,\n\t * we can support host APIC ID upto 255.\n\t */\n\tif (WARN_ON(h_physical_id > AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK;\n\tentry |= (h_physical_id & AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (svm->avic_is_running)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n\tavic_update_iommu_vcpu_affinity(vcpu, h_physical_id,\n\t\t\t\t\tsvm->avic_is_running);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)",
      "#define AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK\t(0xFFULL)"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_update_iommu_vcpu_affinity",
          "args": [
            "vcpu",
            "h_physical_id",
            "svm->avic_is_running"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "avic_update_iommu_vcpu_affinity",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1758-1786",
          "snippet": "static inline int\navic_update_iommu_vcpu_affinity(struct kvm_vcpu *vcpu, int cpu, bool r)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm))\n\t\treturn 0;\n\n\t/*\n\t * Here, we go through the per-vcpu ir_list to update all existing\n\t * interrupt remapping table entry targeting this vcpu.\n\t */\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\n\tif (list_empty(&svm->ir_list))\n\t\tgoto out;\n\n\tlist_for_each_entry(ir, &svm->ir_list, node) {\n\t\tret = amd_iommu_update_ga(cpu, r, ir->data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline int\navic_update_iommu_vcpu_affinity(struct kvm_vcpu *vcpu, int cpu, bool r)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm))\n\t\treturn 0;\n\n\t/*\n\t * Here, we go through the per-vcpu ir_list to update all existing\n\t * interrupt remapping table entry targeting this vcpu.\n\t */\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\n\tif (list_empty(&svm->ir_list))\n\t\tgoto out;\n\n\tlist_for_each_entry(ir, &svm->ir_list, node) {\n\t\tret = amd_iommu_update_ga(cpu, r, ir->data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*(svm->avic_physical_id_cache)",
            "entry"
          ],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*(svm->avic_physical_id_cache)"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "h_physical_id > AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "vcpu"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_cpu_get_apicid",
          "args": [
            "cpu"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n#define AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK\t(0xFFULL)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_vcpu_load(struct kvm_vcpu *vcpu, int cpu)\n{\n\tu64 entry;\n\t/* ID = 0xff (broadcast), ID > 0xff (reserved) */\n\tint h_physical_id = kvm_cpu_get_apicid(cpu);\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_vcpu_apicv_active(vcpu))\n\t\treturn;\n\n\t/*\n\t * Since the host physical APIC id is 8 bits,\n\t * we can support host APIC ID upto 255.\n\t */\n\tif (WARN_ON(h_physical_id > AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK))\n\t\treturn;\n\n\tentry = READ_ONCE(*(svm->avic_physical_id_cache));\n\tWARN_ON(entry & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK;\n\tentry |= (h_physical_id & AVIC_PHYSICAL_ID_ENTRY_HOST_PHYSICAL_ID_MASK);\n\n\tentry &= ~AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\tif (svm->avic_is_running)\n\t\tentry |= AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK;\n\n\tWRITE_ONCE(*(svm->avic_physical_id_cache), entry);\n\tavic_update_iommu_vcpu_affinity(vcpu, h_physical_id,\n\t\t\t\t\tsvm->avic_is_running);\n}"
  },
  {
    "function_name": "avic_update_iommu_vcpu_affinity",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1758-1786",
    "snippet": "static inline int\navic_update_iommu_vcpu_affinity(struct kvm_vcpu *vcpu, int cpu, bool r)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm))\n\t\treturn 0;\n\n\t/*\n\t * Here, we go through the per-vcpu ir_list to update all existing\n\t * interrupt remapping table entry targeting this vcpu.\n\t */\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\n\tif (list_empty(&svm->ir_list))\n\t\tgoto out;\n\n\tlist_for_each_entry(ir, &svm->ir_list, node) {\n\t\tret = amd_iommu_update_ga(cpu, r, ir->data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&svm->ir_list_lock",
            "flags"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "amd_iommu_update_ga",
          "args": [
            "cpu",
            "r",
            "ir->data"
          ],
          "line": 1779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ir",
            "&svm->ir_list",
            "node"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&svm->ir_list"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&svm->ir_list_lock",
            "flags"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_arch_has_assigned_device",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1766
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_arch_has_assigned_device",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10460-10463",
          "snippet": "bool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_arch_has_assigned_device(struct kvm *kvm)\n{\n\treturn atomic_read(&kvm->arch.assigned_device_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline int\navic_update_iommu_vcpu_affinity(struct kvm_vcpu *vcpu, int cpu, bool r)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct amd_svm_iommu_ir *ir;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (!kvm_arch_has_assigned_device(vcpu->kvm))\n\t\treturn 0;\n\n\t/*\n\t * Here, we go through the per-vcpu ir_list to update all existing\n\t * interrupt remapping table entry targeting this vcpu.\n\t */\n\tspin_lock_irqsave(&svm->ir_list_lock, flags);\n\n\tif (list_empty(&svm->ir_list))\n\t\tgoto out;\n\n\tlist_for_each_entry(ir, &svm->ir_list, node) {\n\t\tret = amd_iommu_update_ga(cpu, r, ir->data);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\nout:\n\tspin_unlock_irqrestore(&svm->ir_list_lock, flags);\n\treturn ret;\n}"
  },
  {
    "function_name": "svm_vm_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1746-1756",
    "snippet": "static int svm_vm_init(struct kvm *kvm)\n{\n\tif (avic) {\n\t\tint ret = avic_vm_init(kvm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tkvm_apicv_init(kvm, avic);\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int avic;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apicv_init",
          "args": [
            "kvm",
            "avic"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apicv_init",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7501-7509",
          "snippet": "void kvm_apicv_init(struct kvm *kvm, bool enable)\n{\n\tif (enable)\n\t\tclear_bit(APICV_INHIBIT_REASON_DISABLE,\n\t\t\t  &kvm->arch.apicv_inhibit_reasons);\n\telse\n\t\tset_bit(APICV_INHIBIT_REASON_DISABLE,\n\t\t\t&kvm->arch.apicv_inhibit_reasons);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_apicv_init(struct kvm *kvm, bool enable)\n{\n\tif (enable)\n\t\tclear_bit(APICV_INHIBIT_REASON_DISABLE,\n\t\t\t  &kvm->arch.apicv_inhibit_reasons);\n\telse\n\t\tset_bit(APICV_INHIBIT_REASON_DISABLE,\n\t\t\t&kvm->arch.apicv_inhibit_reasons);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_vm_init",
          "args": [
            "kvm"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vm_init",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1692-1744",
          "snippet": "static int avic_vm_init(struct kvm *kvm)\n{\n\tunsigned long flags;\n\tint err = -ENOMEM;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(kvm);\n\tstruct kvm_svm *k2;\n\tstruct page *p_page;\n\tstruct page *l_page;\n\tu32 vm_id;\n\n\tif (!avic)\n\t\treturn 0;\n\n\t/* Allocating physical APIC ID table (4KB) */\n\tp_page = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!p_page)\n\t\tgoto free_avic;\n\n\tkvm_svm->avic_physical_id_table_page = p_page;\n\tclear_page(page_address(p_page));\n\n\t/* Allocating logical APIC ID table (4KB) */\n\tl_page = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!l_page)\n\t\tgoto free_avic;\n\n\tkvm_svm->avic_logical_id_table_page = l_page;\n\tclear_page(page_address(l_page));\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n again:\n\tvm_id = next_vm_id = (next_vm_id + 1) & AVIC_VM_ID_MASK;\n\tif (vm_id == 0) { /* id is 1-based, zero is not okay */\n\t\tnext_vm_id_wrapped = 1;\n\t\tgoto again;\n\t}\n\t/* Is it still in use? Only possible if wrapped at least once */\n\tif (next_vm_id_wrapped) {\n\t\thash_for_each_possible(svm_vm_data_hash, k2, hnode, vm_id) {\n\t\t\tif (k2->avic_vm_id == vm_id)\n\t\t\t\tgoto again;\n\t\t}\n\t}\n\tkvm_svm->avic_vm_id = vm_id;\n\thash_add(svm_vm_data_hash, &kvm_svm->hnode, kvm_svm->avic_vm_id);\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n\n\treturn 0;\n\nfree_avic:\n\tavic_vm_destroy(kvm);\n\treturn err;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_VM_ID_MASK\t\t\t((1 << AVIC_VM_ID_BITS) - 1)"
          ],
          "globals_used": [
            "static int avic;",
            "static u32 next_vm_id = 0;",
            "static bool next_vm_id_wrapped = 0;",
            "static DEFINE_SPINLOCK(svm_vm_data_hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_VM_ID_MASK\t\t\t((1 << AVIC_VM_ID_BITS) - 1)\n\nstatic int avic;\nstatic u32 next_vm_id = 0;\nstatic bool next_vm_id_wrapped = 0;\nstatic DEFINE_SPINLOCK(svm_vm_data_hash_lock);\n\nstatic int avic_vm_init(struct kvm *kvm)\n{\n\tunsigned long flags;\n\tint err = -ENOMEM;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(kvm);\n\tstruct kvm_svm *k2;\n\tstruct page *p_page;\n\tstruct page *l_page;\n\tu32 vm_id;\n\n\tif (!avic)\n\t\treturn 0;\n\n\t/* Allocating physical APIC ID table (4KB) */\n\tp_page = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!p_page)\n\t\tgoto free_avic;\n\n\tkvm_svm->avic_physical_id_table_page = p_page;\n\tclear_page(page_address(p_page));\n\n\t/* Allocating logical APIC ID table (4KB) */\n\tl_page = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!l_page)\n\t\tgoto free_avic;\n\n\tkvm_svm->avic_logical_id_table_page = l_page;\n\tclear_page(page_address(l_page));\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n again:\n\tvm_id = next_vm_id = (next_vm_id + 1) & AVIC_VM_ID_MASK;\n\tif (vm_id == 0) { /* id is 1-based, zero is not okay */\n\t\tnext_vm_id_wrapped = 1;\n\t\tgoto again;\n\t}\n\t/* Is it still in use? Only possible if wrapped at least once */\n\tif (next_vm_id_wrapped) {\n\t\thash_for_each_possible(svm_vm_data_hash, k2, hnode, vm_id) {\n\t\t\tif (k2->avic_vm_id == vm_id)\n\t\t\t\tgoto again;\n\t\t}\n\t}\n\tkvm_svm->avic_vm_id = vm_id;\n\thash_add(svm_vm_data_hash, &kvm_svm->hnode, kvm_svm->avic_vm_id);\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n\n\treturn 0;\n\nfree_avic:\n\tavic_vm_destroy(kvm);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\n\nstatic int svm_vm_init(struct kvm *kvm)\n{\n\tif (avic) {\n\t\tint ret = avic_vm_init(kvm);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tkvm_apicv_init(kvm, avic);\n\treturn 0;\n}"
  },
  {
    "function_name": "avic_vm_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1692-1744",
    "snippet": "static int avic_vm_init(struct kvm *kvm)\n{\n\tunsigned long flags;\n\tint err = -ENOMEM;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(kvm);\n\tstruct kvm_svm *k2;\n\tstruct page *p_page;\n\tstruct page *l_page;\n\tu32 vm_id;\n\n\tif (!avic)\n\t\treturn 0;\n\n\t/* Allocating physical APIC ID table (4KB) */\n\tp_page = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!p_page)\n\t\tgoto free_avic;\n\n\tkvm_svm->avic_physical_id_table_page = p_page;\n\tclear_page(page_address(p_page));\n\n\t/* Allocating logical APIC ID table (4KB) */\n\tl_page = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!l_page)\n\t\tgoto free_avic;\n\n\tkvm_svm->avic_logical_id_table_page = l_page;\n\tclear_page(page_address(l_page));\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n again:\n\tvm_id = next_vm_id = (next_vm_id + 1) & AVIC_VM_ID_MASK;\n\tif (vm_id == 0) { /* id is 1-based, zero is not okay */\n\t\tnext_vm_id_wrapped = 1;\n\t\tgoto again;\n\t}\n\t/* Is it still in use? Only possible if wrapped at least once */\n\tif (next_vm_id_wrapped) {\n\t\thash_for_each_possible(svm_vm_data_hash, k2, hnode, vm_id) {\n\t\t\tif (k2->avic_vm_id == vm_id)\n\t\t\t\tgoto again;\n\t\t}\n\t}\n\tkvm_svm->avic_vm_id = vm_id;\n\thash_add(svm_vm_data_hash, &kvm_svm->hnode, kvm_svm->avic_vm_id);\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n\n\treturn 0;\n\nfree_avic:\n\tavic_vm_destroy(kvm);\n\treturn err;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_VM_ID_MASK\t\t\t((1 << AVIC_VM_ID_BITS) - 1)"
    ],
    "globals_used": [
      "static int avic;",
      "static u32 next_vm_id = 0;",
      "static bool next_vm_id_wrapped = 0;",
      "static DEFINE_SPINLOCK(svm_vm_data_hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "avic_vm_destroy",
          "args": [
            "kvm"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vm_destroy",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1668-1684",
          "snippet": "static void avic_vm_destroy(struct kvm *kvm)\n{\n\tunsigned long flags;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(kvm);\n\n\tif (!avic)\n\t\treturn;\n\n\tif (kvm_svm->avic_logical_id_table_page)\n\t\t__free_page(kvm_svm->avic_logical_id_table_page);\n\tif (kvm_svm->avic_physical_id_table_page)\n\t\t__free_page(kvm_svm->avic_physical_id_table_page);\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n\thash_del(&kvm_svm->hnode);\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int avic;",
            "static DEFINE_SPINLOCK(svm_vm_data_hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\nstatic DEFINE_SPINLOCK(svm_vm_data_hash_lock);\n\nstatic void avic_vm_destroy(struct kvm *kvm)\n{\n\tunsigned long flags;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(kvm);\n\n\tif (!avic)\n\t\treturn;\n\n\tif (kvm_svm->avic_logical_id_table_page)\n\t\t__free_page(kvm_svm->avic_logical_id_table_page);\n\tif (kvm_svm->avic_physical_id_table_page)\n\t\t__free_page(kvm_svm->avic_physical_id_table_page);\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n\thash_del(&kvm_svm->hnode);\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&svm_vm_data_hash_lock",
            "flags"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_add",
          "args": [
            "svm_vm_data_hash",
            "&kvm_svm->hnode",
            "kvm_svm->avic_vm_id"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "svm_vm_data_hash",
            "k2",
            "hnode",
            "vm_id"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&svm_vm_data_hash_lock",
            "flags"
          ],
          "line": 1721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "page_address(l_page)"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "l_page"
          ],
          "line": 1719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_page",
          "args": [
            "page_address(p_page)"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "p_page"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 1696
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_VM_ID_MASK\t\t\t((1 << AVIC_VM_ID_BITS) - 1)\n\nstatic int avic;\nstatic u32 next_vm_id = 0;\nstatic bool next_vm_id_wrapped = 0;\nstatic DEFINE_SPINLOCK(svm_vm_data_hash_lock);\n\nstatic int avic_vm_init(struct kvm *kvm)\n{\n\tunsigned long flags;\n\tint err = -ENOMEM;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(kvm);\n\tstruct kvm_svm *k2;\n\tstruct page *p_page;\n\tstruct page *l_page;\n\tu32 vm_id;\n\n\tif (!avic)\n\t\treturn 0;\n\n\t/* Allocating physical APIC ID table (4KB) */\n\tp_page = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!p_page)\n\t\tgoto free_avic;\n\n\tkvm_svm->avic_physical_id_table_page = p_page;\n\tclear_page(page_address(p_page));\n\n\t/* Allocating logical APIC ID table (4KB) */\n\tl_page = alloc_page(GFP_KERNEL_ACCOUNT);\n\tif (!l_page)\n\t\tgoto free_avic;\n\n\tkvm_svm->avic_logical_id_table_page = l_page;\n\tclear_page(page_address(l_page));\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n again:\n\tvm_id = next_vm_id = (next_vm_id + 1) & AVIC_VM_ID_MASK;\n\tif (vm_id == 0) { /* id is 1-based, zero is not okay */\n\t\tnext_vm_id_wrapped = 1;\n\t\tgoto again;\n\t}\n\t/* Is it still in use? Only possible if wrapped at least once */\n\tif (next_vm_id_wrapped) {\n\t\thash_for_each_possible(svm_vm_data_hash, k2, hnode, vm_id) {\n\t\t\tif (k2->avic_vm_id == vm_id)\n\t\t\t\tgoto again;\n\t\t}\n\t}\n\tkvm_svm->avic_vm_id = vm_id;\n\thash_add(svm_vm_data_hash, &kvm_svm->hnode, kvm_svm->avic_vm_id);\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n\n\treturn 0;\n\nfree_avic:\n\tavic_vm_destroy(kvm);\n\treturn err;\n}"
  },
  {
    "function_name": "svm_vm_destroy",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1686-1690",
    "snippet": "static void svm_vm_destroy(struct kvm *kvm)\n{\n\tavic_vm_destroy(kvm);\n\tsev_vm_destroy(kvm);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sev_vm_destroy",
          "args": [
            "kvm"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "sev_vm_destroy",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1633-1666",
          "snippet": "static void sev_vm_destroy(struct kvm *kvm)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct list_head *head = &sev->regions_list;\n\tstruct list_head *pos, *q;\n\n\tif (!sev_guest(kvm))\n\t\treturn;\n\n\tmutex_lock(&kvm->lock);\n\n\t/*\n\t * Ensure that all guest tagged cache entries are flushed before\n\t * releasing the pages back to the system for use. CLFLUSH will\n\t * not do this, so issue a WBINVD.\n\t */\n\twbinvd_on_all_cpus();\n\n\t/*\n\t * if userspace was terminated before unregistering the memory regions\n\t * then lets unpin all the registered memory.\n\t */\n\tif (!list_empty(head)) {\n\t\tlist_for_each_safe(pos, q, head) {\n\t\t\t__unregister_enc_region_locked(kvm,\n\t\t\t\tlist_entry(pos, struct enc_region, list));\n\t\t}\n\t}\n\n\tmutex_unlock(&kvm->lock);\n\n\tsev_unbind_asid(kvm, sev->handle);\n\tsev_asid_free(sev->asid);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic void sev_vm_destroy(struct kvm *kvm)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct list_head *head = &sev->regions_list;\n\tstruct list_head *pos, *q;\n\n\tif (!sev_guest(kvm))\n\t\treturn;\n\n\tmutex_lock(&kvm->lock);\n\n\t/*\n\t * Ensure that all guest tagged cache entries are flushed before\n\t * releasing the pages back to the system for use. CLFLUSH will\n\t * not do this, so issue a WBINVD.\n\t */\n\twbinvd_on_all_cpus();\n\n\t/*\n\t * if userspace was terminated before unregistering the memory regions\n\t * then lets unpin all the registered memory.\n\t */\n\tif (!list_empty(head)) {\n\t\tlist_for_each_safe(pos, q, head) {\n\t\t\t__unregister_enc_region_locked(kvm,\n\t\t\t\tlist_entry(pos, struct enc_region, list));\n\t\t}\n\t}\n\n\tmutex_unlock(&kvm->lock);\n\n\tsev_unbind_asid(kvm, sev->handle);\n\tsev_asid_free(sev->asid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_vm_destroy",
          "args": [
            "kvm"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "avic_vm_destroy",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1668-1684",
          "snippet": "static void avic_vm_destroy(struct kvm *kvm)\n{\n\tunsigned long flags;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(kvm);\n\n\tif (!avic)\n\t\treturn;\n\n\tif (kvm_svm->avic_logical_id_table_page)\n\t\t__free_page(kvm_svm->avic_logical_id_table_page);\n\tif (kvm_svm->avic_physical_id_table_page)\n\t\t__free_page(kvm_svm->avic_physical_id_table_page);\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n\thash_del(&kvm_svm->hnode);\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int avic;",
            "static DEFINE_SPINLOCK(svm_vm_data_hash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\nstatic DEFINE_SPINLOCK(svm_vm_data_hash_lock);\n\nstatic void avic_vm_destroy(struct kvm *kvm)\n{\n\tunsigned long flags;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(kvm);\n\n\tif (!avic)\n\t\treturn;\n\n\tif (kvm_svm->avic_logical_id_table_page)\n\t\t__free_page(kvm_svm->avic_logical_id_table_page);\n\tif (kvm_svm->avic_physical_id_table_page)\n\t\t__free_page(kvm_svm->avic_physical_id_table_page);\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n\thash_del(&kvm_svm->hnode);\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_vm_destroy(struct kvm *kvm)\n{\n\tavic_vm_destroy(kvm);\n\tsev_vm_destroy(kvm);\n}"
  },
  {
    "function_name": "avic_vm_destroy",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1668-1684",
    "snippet": "static void avic_vm_destroy(struct kvm *kvm)\n{\n\tunsigned long flags;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(kvm);\n\n\tif (!avic)\n\t\treturn;\n\n\tif (kvm_svm->avic_logical_id_table_page)\n\t\t__free_page(kvm_svm->avic_logical_id_table_page);\n\tif (kvm_svm->avic_physical_id_table_page)\n\t\t__free_page(kvm_svm->avic_physical_id_table_page);\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n\thash_del(&kvm_svm->hnode);\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int avic;",
      "static DEFINE_SPINLOCK(svm_vm_data_hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&svm_vm_data_hash_lock",
            "flags"
          ],
          "line": 1683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_del",
          "args": [
            "&kvm_svm->hnode"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&svm_vm_data_hash_lock",
            "flags"
          ],
          "line": 1681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "kvm_svm->avic_physical_id_table_page"
          ],
          "line": 1679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "kvm_svm->avic_logical_id_table_page"
          ],
          "line": 1677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int avic;\nstatic DEFINE_SPINLOCK(svm_vm_data_hash_lock);\n\nstatic void avic_vm_destroy(struct kvm *kvm)\n{\n\tunsigned long flags;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(kvm);\n\n\tif (!avic)\n\t\treturn;\n\n\tif (kvm_svm->avic_logical_id_table_page)\n\t\t__free_page(kvm_svm->avic_logical_id_table_page);\n\tif (kvm_svm->avic_physical_id_table_page)\n\t\t__free_page(kvm_svm->avic_physical_id_table_page);\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n\thash_del(&kvm_svm->hnode);\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n}"
  },
  {
    "function_name": "sev_vm_destroy",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1633-1666",
    "snippet": "static void sev_vm_destroy(struct kvm *kvm)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct list_head *head = &sev->regions_list;\n\tstruct list_head *pos, *q;\n\n\tif (!sev_guest(kvm))\n\t\treturn;\n\n\tmutex_lock(&kvm->lock);\n\n\t/*\n\t * Ensure that all guest tagged cache entries are flushed before\n\t * releasing the pages back to the system for use. CLFLUSH will\n\t * not do this, so issue a WBINVD.\n\t */\n\twbinvd_on_all_cpus();\n\n\t/*\n\t * if userspace was terminated before unregistering the memory regions\n\t * then lets unpin all the registered memory.\n\t */\n\tif (!list_empty(head)) {\n\t\tlist_for_each_safe(pos, q, head) {\n\t\t\t__unregister_enc_region_locked(kvm,\n\t\t\t\tlist_entry(pos, struct enc_region, list));\n\t\t}\n\t}\n\n\tmutex_unlock(&kvm->lock);\n\n\tsev_unbind_asid(kvm, sev->handle);\n\tsev_asid_free(sev->asid);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sev_asid_free",
          "args": [
            "sev->asid"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "sev_asid_free",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1493-1509",
          "snippet": "static void sev_asid_free(int asid)\n{\n\tstruct svm_cpu_data *sd;\n\tint cpu, pos;\n\n\tmutex_lock(&sev_bitmap_lock);\n\n\tpos = asid - 1;\n\t__set_bit(pos, sev_reclaim_asid_bitmap);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tsd = per_cpu(svm_data, cpu);\n\t\tsd->sev_vmcbs[pos] = NULL;\n\t}\n\n\tmutex_unlock(&sev_bitmap_lock);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(sev_bitmap_lock);",
            "static unsigned long *sev_reclaim_asid_bitmap;",
            "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_MUTEX(sev_bitmap_lock);\nstatic unsigned long *sev_reclaim_asid_bitmap;\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void sev_asid_free(int asid)\n{\n\tstruct svm_cpu_data *sd;\n\tint cpu, pos;\n\n\tmutex_lock(&sev_bitmap_lock);\n\n\tpos = asid - 1;\n\t__set_bit(pos, sev_reclaim_asid_bitmap);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tsd = per_cpu(svm_data, cpu);\n\t\tsd->sev_vmcbs[pos] = NULL;\n\t}\n\n\tmutex_unlock(&sev_bitmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_unbind_asid",
          "args": [
            "kvm",
            "sev->handle"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "sev_unbind_asid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1511-1542",
          "snippet": "static void sev_unbind_asid(struct kvm *kvm, unsigned int handle)\n{\n\tstruct sev_data_decommission *decommission;\n\tstruct sev_data_deactivate *data;\n\n\tif (!handle)\n\t\treturn;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\t/* deactivate handle */\n\tdata->handle = handle;\n\n\t/* Guard DEACTIVATE against WBINVD/DF_FLUSH used in ASID recycling */\n\tdown_read(&sev_deactivate_lock);\n\tsev_guest_deactivate(data, NULL);\n\tup_read(&sev_deactivate_lock);\n\n\tkfree(data);\n\n\tdecommission = kzalloc(sizeof(*decommission), GFP_KERNEL);\n\tif (!decommission)\n\t\treturn;\n\n\t/* decommission handle */\n\tdecommission->handle = handle;\n\tsev_guest_decommission(decommission, NULL);\n\n\tkfree(decommission);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(sev_deactivate_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DECLARE_RWSEM(sev_deactivate_lock);\n\nstatic void sev_unbind_asid(struct kvm *kvm, unsigned int handle)\n{\n\tstruct sev_data_decommission *decommission;\n\tstruct sev_data_deactivate *data;\n\n\tif (!handle)\n\t\treturn;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\t/* deactivate handle */\n\tdata->handle = handle;\n\n\t/* Guard DEACTIVATE against WBINVD/DF_FLUSH used in ASID recycling */\n\tdown_read(&sev_deactivate_lock);\n\tsev_guest_deactivate(data, NULL);\n\tup_read(&sev_deactivate_lock);\n\n\tkfree(data);\n\n\tdecommission = kzalloc(sizeof(*decommission), GFP_KERNEL);\n\tif (!decommission)\n\t\treturn;\n\n\t/* decommission handle */\n\tdecommission->handle = handle;\n\tsev_guest_decommission(decommission, NULL);\n\n\tkfree(decommission);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->lock"
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__unregister_enc_region_locked",
          "args": [
            "kvm",
            "list_entry(pos, struct enc_region, list)"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "__unregister_enc_region_locked",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1625-1631",
          "snippet": "static void __unregister_enc_region_locked(struct kvm *kvm,\n\t\t\t\t\t   struct enc_region *region)\n{\n\tsev_unpin_memory(kvm, region->pages, region->npages);\n\tlist_del(&region->list);\n\tkfree(region);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void __unregister_enc_region_locked(struct kvm *kvm,\n\t\t\t\t\t   struct enc_region *region)\n{\n\tsev_unpin_memory(kvm, region->pages, region->npages);\n\tlist_del(&region->list);\n\tkfree(region);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "pos",
            "structenc_region",
            "list"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_safe",
          "args": [
            "pos",
            "q",
            "head"
          ],
          "line": 1656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "head"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wbinvd_on_all_cpus",
          "args": [],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->lock"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "kvm"
          ],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic void sev_vm_destroy(struct kvm *kvm)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tstruct list_head *head = &sev->regions_list;\n\tstruct list_head *pos, *q;\n\n\tif (!sev_guest(kvm))\n\t\treturn;\n\n\tmutex_lock(&kvm->lock);\n\n\t/*\n\t * Ensure that all guest tagged cache entries are flushed before\n\t * releasing the pages back to the system for use. CLFLUSH will\n\t * not do this, so issue a WBINVD.\n\t */\n\twbinvd_on_all_cpus();\n\n\t/*\n\t * if userspace was terminated before unregistering the memory regions\n\t * then lets unpin all the registered memory.\n\t */\n\tif (!list_empty(head)) {\n\t\tlist_for_each_safe(pos, q, head) {\n\t\t\t__unregister_enc_region_locked(kvm,\n\t\t\t\tlist_entry(pos, struct enc_region, list));\n\t\t}\n\t}\n\n\tmutex_unlock(&kvm->lock);\n\n\tsev_unbind_asid(kvm, sev->handle);\n\tsev_asid_free(sev->asid);\n}"
  },
  {
    "function_name": "__unregister_enc_region_locked",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1625-1631",
    "snippet": "static void __unregister_enc_region_locked(struct kvm *kvm,\n\t\t\t\t\t   struct enc_region *region)\n{\n\tsev_unpin_memory(kvm, region->pages, region->npages);\n\tlist_del(&region->list);\n\tkfree(region);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "region"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&region->list"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_unpin_memory",
          "args": [
            "kvm",
            "region->pages",
            "region->npages"
          ],
          "line": 1628
        },
        "resolved": true,
        "details": {
          "function_name": "sev_unpin_memory",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1600-1608",
          "snippet": "static void sev_unpin_memory(struct kvm *kvm, struct page **pages,\n\t\t\t     unsigned long npages)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\trelease_pages(pages, npages);\n\tkvfree(pages);\n\tsev->pages_locked -= npages;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic void sev_unpin_memory(struct kvm *kvm, struct page **pages,\n\t\t\t     unsigned long npages)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\trelease_pages(pages, npages);\n\tkvfree(pages);\n\tsev->pages_locked -= npages;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void __unregister_enc_region_locked(struct kvm *kvm,\n\t\t\t\t\t   struct enc_region *region)\n{\n\tsev_unpin_memory(kvm, region->pages, region->npages);\n\tlist_del(&region->list);\n\tkfree(region);\n}"
  },
  {
    "function_name": "sev_clflush_pages",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1610-1623",
    "snippet": "static void sev_clflush_pages(struct page *pages[], unsigned long npages)\n{\n\tuint8_t *page_virtual;\n\tunsigned long i;\n\n\tif (npages == 0 || pages == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpage_virtual = kmap_atomic(pages[i]);\n\t\tclflush_cache_range(page_virtual, PAGE_SIZE);\n\t\tkunmap_atomic(page_virtual);\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "page_virtual"
          ],
          "line": 1621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clflush_cache_range",
          "args": [
            "page_virtual",
            "PAGE_SIZE"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "pages[i]"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void sev_clflush_pages(struct page *pages[], unsigned long npages)\n{\n\tuint8_t *page_virtual;\n\tunsigned long i;\n\n\tif (npages == 0 || pages == NULL)\n\t\treturn;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tpage_virtual = kmap_atomic(pages[i]);\n\t\tclflush_cache_range(page_virtual, PAGE_SIZE);\n\t\tkunmap_atomic(page_virtual);\n\t}\n}"
  },
  {
    "function_name": "sev_unpin_memory",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1600-1608",
    "snippet": "static void sev_unpin_memory(struct kvm *kvm, struct page **pages,\n\t\t\t     unsigned long npages)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\trelease_pages(pages, npages);\n\tkvfree(pages);\n\tsev->pages_locked -= npages;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "pages"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_pages",
          "args": [
            "pages",
            "npages"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic void sev_unpin_memory(struct kvm *kvm, struct page **pages,\n\t\t\t     unsigned long npages)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\trelease_pages(pages, npages);\n\tkvfree(pages);\n\tsev->pages_locked -= npages;\n}"
  },
  {
    "function_name": "sev_pin_memory",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1544-1598",
    "snippet": "static struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, npinned, size;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn NULL;\n\n\t/* Calculate number of pages. */\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn NULL;\n\t}\n\n\t/* Avoid using vmalloc for smaller buffers. */\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO,\n\t\t\t\t  PAGE_KERNEL);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\n\tif (!pages)\n\t\treturn NULL;\n\n\t/* Pin the user virtual address. */\n\tnpinned = get_user_pages_fast(uaddr, npages, FOLL_WRITE, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tgoto err;\n\t}\n\n\t*n = npages;\n\tsev->pages_locked = locked;\n\n\treturn pages;\n\nerr:\n\tif (npinned > 0)\n\t\trelease_pages(pages, npinned);\n\n\tkvfree(pages);\n\treturn NULL;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "pages"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_pages",
          "args": [
            "pages",
            "npinned"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SEV: Failure locking %lu pages.\\n\"",
            "npages"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages_fast",
          "args": [
            "uaddr",
            "npages",
            "FOLL_WRITE",
            "pages"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vmalloc",
          "args": [
            "size",
            "GFP_KERNEL_ACCOUNT | __GFP_ZERO",
            "PAGE_KERNEL"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\"",
            "locked",
            "lock_limit"
          ],
          "line": 1565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_IPC_LOCK"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MEMLOCK"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic struct page **sev_pin_memory(struct kvm *kvm, unsigned long uaddr,\n\t\t\t\t    unsigned long ulen, unsigned long *n,\n\t\t\t\t    int write)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\tunsigned long npages, npinned, size;\n\tunsigned long locked, lock_limit;\n\tstruct page **pages;\n\tunsigned long first, last;\n\n\tif (ulen == 0 || uaddr + ulen < uaddr)\n\t\treturn NULL;\n\n\t/* Calculate number of pages. */\n\tfirst = (uaddr & PAGE_MASK) >> PAGE_SHIFT;\n\tlast = ((uaddr + ulen - 1) & PAGE_MASK) >> PAGE_SHIFT;\n\tnpages = (last - first + 1);\n\n\tlocked = sev->pages_locked + npages;\n\tlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tif (locked > lock_limit && !capable(CAP_IPC_LOCK)) {\n\t\tpr_err(\"SEV: %lu locked pages exceed the lock limit of %lu.\\n\", locked, lock_limit);\n\t\treturn NULL;\n\t}\n\n\t/* Avoid using vmalloc for smaller buffers. */\n\tsize = npages * sizeof(struct page *);\n\tif (size > PAGE_SIZE)\n\t\tpages = __vmalloc(size, GFP_KERNEL_ACCOUNT | __GFP_ZERO,\n\t\t\t\t  PAGE_KERNEL);\n\telse\n\t\tpages = kmalloc(size, GFP_KERNEL_ACCOUNT);\n\n\tif (!pages)\n\t\treturn NULL;\n\n\t/* Pin the user virtual address. */\n\tnpinned = get_user_pages_fast(uaddr, npages, FOLL_WRITE, pages);\n\tif (npinned != npages) {\n\t\tpr_err(\"SEV: Failure locking %lu pages.\\n\", npages);\n\t\tgoto err;\n\t}\n\n\t*n = npages;\n\tsev->pages_locked = locked;\n\n\treturn pages;\n\nerr:\n\tif (npinned > 0)\n\t\trelease_pages(pages, npinned);\n\n\tkvfree(pages);\n\treturn NULL;\n}"
  },
  {
    "function_name": "sev_unbind_asid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1511-1542",
    "snippet": "static void sev_unbind_asid(struct kvm *kvm, unsigned int handle)\n{\n\tstruct sev_data_decommission *decommission;\n\tstruct sev_data_deactivate *data;\n\n\tif (!handle)\n\t\treturn;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\t/* deactivate handle */\n\tdata->handle = handle;\n\n\t/* Guard DEACTIVATE against WBINVD/DF_FLUSH used in ASID recycling */\n\tdown_read(&sev_deactivate_lock);\n\tsev_guest_deactivate(data, NULL);\n\tup_read(&sev_deactivate_lock);\n\n\tkfree(data);\n\n\tdecommission = kzalloc(sizeof(*decommission), GFP_KERNEL);\n\tif (!decommission)\n\t\treturn;\n\n\t/* decommission handle */\n\tdecommission->handle = handle;\n\tsev_guest_decommission(decommission, NULL);\n\n\tkfree(decommission);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_RWSEM(sev_deactivate_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "decommission"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest_decommission",
          "args": [
            "decommission",
            "NULL"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*decommission)",
            "GFP_KERNEL"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&sev_deactivate_lock"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_guest_deactivate",
          "args": [
            "data",
            "NULL"
          ],
          "line": 1528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&sev_deactivate_lock"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DECLARE_RWSEM(sev_deactivate_lock);\n\nstatic void sev_unbind_asid(struct kvm *kvm, unsigned int handle)\n{\n\tstruct sev_data_decommission *decommission;\n\tstruct sev_data_deactivate *data;\n\n\tif (!handle)\n\t\treturn;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn;\n\n\t/* deactivate handle */\n\tdata->handle = handle;\n\n\t/* Guard DEACTIVATE against WBINVD/DF_FLUSH used in ASID recycling */\n\tdown_read(&sev_deactivate_lock);\n\tsev_guest_deactivate(data, NULL);\n\tup_read(&sev_deactivate_lock);\n\n\tkfree(data);\n\n\tdecommission = kzalloc(sizeof(*decommission), GFP_KERNEL);\n\tif (!decommission)\n\t\treturn;\n\n\t/* decommission handle */\n\tdecommission->handle = handle;\n\tsev_guest_decommission(decommission, NULL);\n\n\tkfree(decommission);\n}"
  },
  {
    "function_name": "sev_asid_free",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1493-1509",
    "snippet": "static void sev_asid_free(int asid)\n{\n\tstruct svm_cpu_data *sd;\n\tint cpu, pos;\n\n\tmutex_lock(&sev_bitmap_lock);\n\n\tpos = asid - 1;\n\t__set_bit(pos, sev_reclaim_asid_bitmap);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tsd = per_cpu(svm_data, cpu);\n\t\tsd->sev_vmcbs[pos] = NULL;\n\t}\n\n\tmutex_unlock(&sev_bitmap_lock);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(sev_bitmap_lock);",
      "static unsigned long *sev_reclaim_asid_bitmap;",
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sev_bitmap_lock"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "cpu"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "pos",
            "sev_reclaim_asid_bitmap"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sev_bitmap_lock"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_MUTEX(sev_bitmap_lock);\nstatic unsigned long *sev_reclaim_asid_bitmap;\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void sev_asid_free(int asid)\n{\n\tstruct svm_cpu_data *sd;\n\tint cpu, pos;\n\n\tmutex_lock(&sev_bitmap_lock);\n\n\tpos = asid - 1;\n\t__set_bit(pos, sev_reclaim_asid_bitmap);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tsd = per_cpu(svm_data, cpu);\n\t\tsd->sev_vmcbs[pos] = NULL;\n\t}\n\n\tmutex_unlock(&sev_bitmap_lock);\n}"
  },
  {
    "function_name": "avic_init_backing_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1456-1491",
    "snippet": "static int avic_init_backing_page(struct kvm_vcpu *vcpu)\n{\n\tu64 *entry, new_entry;\n\tint id = vcpu->vcpu_id;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (id >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn -EINVAL;\n\n\tif (!svm->vcpu.arch.apic->regs)\n\t\treturn -EINVAL;\n\n\tif (kvm_apicv_activated(vcpu->kvm)) {\n\t\tint ret;\n\n\t\tret = avic_update_access_page(vcpu->kvm, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsvm->avic_backing_page = virt_to_page(svm->vcpu.arch.apic->regs);\n\n\t/* Setting AVIC backing page address in the phy APIC ID table */\n\tentry = avic_get_physical_id_entry(vcpu, id);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = __sme_set((page_to_phys(svm->avic_backing_page) &\n\t\t\t      AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK) |\n\t\t\t      AVIC_PHYSICAL_ID_ENTRY_VALID_MASK);\n\tWRITE_ONCE(*entry, new_entry);\n\n\tsvm->avic_physical_id_cache = entry;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_PHYSICAL_ID_ENTRY_VALID_MASK\t\t(1ULL << 63)",
      "#define AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK\t(0xFFFFFFFFFFULL << 12)",
      "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "*entry",
            "new_entry"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "(page_to_phys(svm->avic_backing_page) &\n\t\t\t      AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK) |\n\t\t\t      AVIC_PHYSICAL_ID_ENTRY_VALID_MASK"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "svm->avic_backing_page"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_get_physical_id_entry",
          "args": [
            "vcpu",
            "id"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "avic_get_physical_id_entry",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1407-1419",
          "snippet": "static u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t       unsigned int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(kvm_svm->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
          ],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t       unsigned int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(kvm_svm->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}"
        }
      },
      {
        "call_info": {
          "callee": "virt_to_page",
          "args": [
            "svm->vcpu.arch.apic->regs"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avic_update_access_page",
          "args": [
            "vcpu->kvm",
            "true"
          ],
          "line": 1471
        },
        "resolved": true,
        "details": {
          "function_name": "avic_update_access_page",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1429-1454",
          "snippet": "static int avic_update_access_page(struct kvm *kvm, bool activate)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\t/*\n\t * During kvm_destroy_vm(), kvm_pit_set_reinject() could trigger\n\t * APICv mode change, which update APIC_ACCESS_PAGE_PRIVATE_MEMSLOT\n\t * memory region. So, we need to ensure that kvm->mm == current->mm.\n\t */\n\tif ((kvm->arch.apic_access_page_done == activate) ||\n\t    (kvm->mm != current->mm))\n\t\tgoto out;\n\n\tret = __x86_set_memory_region(kvm,\n\t\t\t\t      APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t      APIC_DEFAULT_PHYS_BASE,\n\t\t\t\t      activate ? PAGE_SIZE : 0);\n\tif (ret)\n\t\tgoto out;\n\n\tkvm->arch.apic_access_page_done = activate;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);\n\nstatic int avic_update_access_page(struct kvm *kvm, bool activate)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\t/*\n\t * During kvm_destroy_vm(), kvm_pit_set_reinject() could trigger\n\t * APICv mode change, which update APIC_ACCESS_PAGE_PRIVATE_MEMSLOT\n\t * memory region. So, we need to ensure that kvm->mm == current->mm.\n\t */\n\tif ((kvm->arch.apic_access_page_done == activate) ||\n\t    (kvm->mm != current->mm))\n\t\tgoto out;\n\n\tret = __x86_set_memory_region(kvm,\n\t\t\t\t      APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t      APIC_DEFAULT_PHYS_BASE,\n\t\t\t\t      activate ? PAGE_SIZE : 0);\n\tif (ret)\n\t\tgoto out;\n\n\tkvm->arch.apic_access_page_done = activate;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apicv_activated",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apicv_activated",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7495-7498",
          "snippet": "bool kvm_apicv_activated(struct kvm *kvm)\n{\n\treturn (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_apicv_activated(struct kvm *kvm)\n{\n\treturn (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_VALID_MASK\t\t(1ULL << 63)\n#define AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK\t(0xFFFFFFFFFFULL << 12)\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int avic_init_backing_page(struct kvm_vcpu *vcpu)\n{\n\tu64 *entry, new_entry;\n\tint id = vcpu->vcpu_id;\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (id >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn -EINVAL;\n\n\tif (!svm->vcpu.arch.apic->regs)\n\t\treturn -EINVAL;\n\n\tif (kvm_apicv_activated(vcpu->kvm)) {\n\t\tint ret;\n\n\t\tret = avic_update_access_page(vcpu->kvm, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tsvm->avic_backing_page = virt_to_page(svm->vcpu.arch.apic->regs);\n\n\t/* Setting AVIC backing page address in the phy APIC ID table */\n\tentry = avic_get_physical_id_entry(vcpu, id);\n\tif (!entry)\n\t\treturn -EINVAL;\n\n\tnew_entry = __sme_set((page_to_phys(svm->avic_backing_page) &\n\t\t\t      AVIC_PHYSICAL_ID_ENTRY_BACKING_PAGE_MASK) |\n\t\t\t      AVIC_PHYSICAL_ID_ENTRY_VALID_MASK);\n\tWRITE_ONCE(*entry, new_entry);\n\n\tsvm->avic_physical_id_cache = entry;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "avic_update_access_page",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1429-1454",
    "snippet": "static int avic_update_access_page(struct kvm *kvm, bool activate)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\t/*\n\t * During kvm_destroy_vm(), kvm_pit_set_reinject() could trigger\n\t * APICv mode change, which update APIC_ACCESS_PAGE_PRIVATE_MEMSLOT\n\t * memory region. So, we need to ensure that kvm->mm == current->mm.\n\t */\n\tif ((kvm->arch.apic_access_page_done == activate) ||\n\t    (kvm->mm != current->mm))\n\t\tgoto out;\n\n\tret = __x86_set_memory_region(kvm,\n\t\t\t\t      APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t      APIC_DEFAULT_PHYS_BASE,\n\t\t\t\t      activate ? PAGE_SIZE : 0);\n\tif (ret)\n\t\tgoto out;\n\n\tkvm->arch.apic_access_page_done = activate;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__x86_set_memory_region",
          "args": [
            "kvm",
            "APIC_ACCESS_PAGE_PRIVATE_MEMSLOT",
            "APIC_DEFAULT_PHYS_BASE",
            "activate ? PAGE_SIZE : 0"
          ],
          "line": 1443
        },
        "resolved": true,
        "details": {
          "function_name": "__x86_set_memory_region",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "9800-9854",
          "snippet": "int __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva, uninitialized_var(old_npages);\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (slot && slot->npages)\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot || !slot->npages)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Stuff a non-canonical value to catch use-after-delete.  This\n\t\t * ends up being 0 on 32-bit KVM, but there's no better\n\t\t * alternative.\n\t\t */\n\t\thva = (unsigned long)(0xdeadull << 48);\n\t\told_npages = slot->npages;\n\t}\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size)\n\t\tvm_munmap(hva, old_npages * PAGE_SIZE);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nint __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)\n{\n\tint i, r;\n\tunsigned long hva, uninitialized_var(old_npages);\n\tstruct kvm_memslots *slots = kvm_memslots(kvm);\n\tstruct kvm_memory_slot *slot;\n\n\t/* Called with kvm->slots_lock held.  */\n\tif (WARN_ON(id >= KVM_MEM_SLOTS_NUM))\n\t\treturn -EINVAL;\n\n\tslot = id_to_memslot(slots, id);\n\tif (size) {\n\t\tif (slot && slot->npages)\n\t\t\treturn -EEXIST;\n\n\t\t/*\n\t\t * MAP_SHARED to prevent internal slot pages from being moved\n\t\t * by fork()/COW.\n\t\t */\n\t\thva = vm_mmap(NULL, 0, size, PROT_READ | PROT_WRITE,\n\t\t\t      MAP_SHARED | MAP_ANONYMOUS, 0);\n\t\tif (IS_ERR((void *)hva))\n\t\t\treturn PTR_ERR((void *)hva);\n\t} else {\n\t\tif (!slot || !slot->npages)\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * Stuff a non-canonical value to catch use-after-delete.  This\n\t\t * ends up being 0 on 32-bit KVM, but there's no better\n\t\t * alternative.\n\t\t */\n\t\thva = (unsigned long)(0xdeadull << 48);\n\t\told_npages = slot->npages;\n\t}\n\n\tfor (i = 0; i < KVM_ADDRESS_SPACE_NUM; i++) {\n\t\tstruct kvm_userspace_memory_region m;\n\n\t\tm.slot = id | (i << 16);\n\t\tm.flags = 0;\n\t\tm.guest_phys_addr = gpa;\n\t\tm.userspace_addr = hva;\n\t\tm.memory_size = size;\n\t\tr = __kvm_set_memory_region(kvm, &m);\n\t\tif (r < 0)\n\t\t\treturn r;\n\t}\n\n\tif (!size)\n\t\tvm_munmap(hva, old_npages * PAGE_SIZE);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_toggle_avic_for_irq_window(struct kvm_vcpu *vcpu, bool activate);\n\nstatic int avic_update_access_page(struct kvm *kvm, bool activate)\n{\n\tint ret = 0;\n\n\tmutex_lock(&kvm->slots_lock);\n\t/*\n\t * During kvm_destroy_vm(), kvm_pit_set_reinject() could trigger\n\t * APICv mode change, which update APIC_ACCESS_PAGE_PRIVATE_MEMSLOT\n\t * memory region. So, we need to ensure that kvm->mm == current->mm.\n\t */\n\tif ((kvm->arch.apic_access_page_done == activate) ||\n\t    (kvm->mm != current->mm))\n\t\tgoto out;\n\n\tret = __x86_set_memory_region(kvm,\n\t\t\t\t      APIC_ACCESS_PAGE_PRIVATE_MEMSLOT,\n\t\t\t\t      APIC_DEFAULT_PHYS_BASE,\n\t\t\t\t      activate ? PAGE_SIZE : 0);\n\tif (ret)\n\t\tgoto out;\n\n\tkvm->arch.apic_access_page_done = activate;\nout:\n\tmutex_unlock(&kvm->slots_lock);\n\treturn ret;\n}"
  },
  {
    "function_name": "avic_get_physical_id_entry",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1407-1419",
    "snippet": "static u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t       unsigned int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(kvm_svm->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255"
    ],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "kvm_svm->avic_physical_id_table_page"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "vcpu->kvm"
          ],
          "line": 1411
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u64 *avic_get_physical_id_entry(struct kvm_vcpu *vcpu,\n\t\t\t\t       unsigned int index)\n{\n\tu64 *avic_physical_id_table;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(vcpu->kvm);\n\n\tif (index >= AVIC_MAX_PHYSICAL_ID_COUNT)\n\t\treturn NULL;\n\n\tavic_physical_id_table = page_address(kvm_svm->avic_physical_id_table_page);\n\n\treturn &avic_physical_id_table[index];\n}"
  },
  {
    "function_name": "init_vmcb",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1248-1405",
    "snippet": "static void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\tset_exception_intercept(svm, GP_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\tset_intercept(svm, INTERCEPT_RDPRU);\n\tset_intercept(svm, INTERCEPT_RSM);\n\n\tif (!kvm_mwait_in_guest(svm->vcpu.kvm)) {\n\t\tset_intercept(svm, INTERCEPT_MONITOR);\n\t\tset_intercept(svm, INTERCEPT_MWAIT);\n\t}\n\n\tif (!kvm_hlt_in_guest(svm->vcpu.kvm))\n\t\tset_intercept(svm, INTERCEPT_HLT);\n\n\tcontrol->iopm_base_pa = __sme_set(iopm_base);\n\tcontrol->msrpm_base_pa = __sme_set(__pa(svm->msrpm));\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl |= SVM_NESTED_CTL_NP_ENABLE;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (pause_filter_count) {\n\t\tcontrol->pause_filter_count = pause_filter_count;\n\t\tif (pause_filter_thresh)\n\t\t\tcontrol->pause_filter_thresh = pause_filter_thresh;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t} else {\n\t\tclr_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tavic_init_vmcb(svm);\n\n\t/*\n\t * If hardware supports Virtual VMLOAD VMSAVE then enable it\n\t * in VMCB and clear intercepts to avoid #VMEXIT.\n\t */\n\tif (vls) {\n\t\tclr_intercept(svm, INTERCEPT_VMLOAD);\n\t\tclr_intercept(svm, INTERCEPT_VMSAVE);\n\t\tsvm->vmcb->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\t}\n\n\tif (vgif) {\n\t\tclr_intercept(svm, INTERCEPT_STGI);\n\t\tclr_intercept(svm, INTERCEPT_CLGI);\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_ENABLE_MASK;\n\t}\n\n\tif (sev_guest(svm->vcpu.kvm)) {\n\t\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ENABLE;\n\t\tclr_exception_intercept(svm, UD_VECTOR);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define SEG_TYPE_BUSY_TSS16 3",
      "#define SEG_TYPE_LDT 2"
    ],
    "globals_used": [
      "static unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;",
      "static unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;",
      "static int nested = true;",
      "static int vls = true;",
      "static int vgif = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
      "static unsigned long iopm_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enable_gif",
          "args": [
            "svm"
          ],
          "line": 1403
        },
        "resolved": true,
        "details": {
          "function_name": "enable_gif",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "309-315",
          "snippet": "static inline void enable_gif(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void enable_gif(struct vcpu_svm *svm)\n{\n\tif (vgif_enabled(svm))\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_MASK;\n\telse\n\t\tsvm->vcpu.arch.hflags |= HF_GIF_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mark_all_dirty",
          "args": [
            "svm->vmcb"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "mark_all_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "176-179",
          "snippet": "static inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_all_dirty(struct vmcb *vmcb)\n{\n\tvmcb->control.clean = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_exception_intercept",
          "args": [
            "svm",
            "UD_VECTOR"
          ],
          "line": 1398
        },
        "resolved": true,
        "details": {
          "function_name": "clr_exception_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "272-279",
          "snippet": "static inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_guest",
          "args": [
            "svm->vcpu.kvm"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "sev_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "295-304",
          "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CLGI"
          ],
          "line": 1392
        },
        "resolved": true,
        "details": {
          "function_name": "clr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "290-297",
          "snippet": "static inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept &= ~(1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avic_init_vmcb",
          "args": [
            "svm"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "avic_init_vmcb",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1230-1246",
          "snippet": "static void avic_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(svm->vcpu.kvm);\n\tphys_addr_t bpa = __sme_set(page_to_phys(svm->avic_backing_page));\n\tphys_addr_t lpa = __sme_set(page_to_phys(kvm_svm->avic_logical_id_table_page));\n\tphys_addr_t ppa = __sme_set(page_to_phys(kvm_svm->avic_physical_id_table_page));\n\n\tvmcb->control.avic_backing_page = bpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_logical_id = lpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id = ppa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id |= AVIC_MAX_PHYSICAL_ID_COUNT;\n\tif (kvm_apicv_activated(svm->vcpu.kvm))\n\t\tvmcb->control.int_ctl |= AVIC_ENABLE_MASK;\n\telse\n\t\tvmcb->control.int_ctl &= ~AVIC_ENABLE_MASK;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255",
            "#define AVIC_HPA_MASK\t~((0xFFFULL << 52) | 0xFFF)"
          ],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n#define AVIC_HPA_MASK\t~((0xFFFULL << 52) | 0xFFF)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(svm->vcpu.kvm);\n\tphys_addr_t bpa = __sme_set(page_to_phys(svm->avic_backing_page));\n\tphys_addr_t lpa = __sme_set(page_to_phys(kvm_svm->avic_logical_id_table_page));\n\tphys_addr_t ppa = __sme_set(page_to_phys(kvm_svm->avic_physical_id_table_page));\n\n\tvmcb->control.avic_backing_page = bpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_logical_id = lpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id = ppa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id |= AVIC_MAX_PHYSICAL_ID_COUNT;\n\tif (kvm_apicv_activated(svm->vcpu.kvm))\n\t\tvmcb->control.int_ctl |= AVIC_ENABLE_MASK;\n\telse\n\t\tvmcb->control.int_ctl &= ~AVIC_ENABLE_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_vcpu_apicv_active",
          "args": [
            "&svm->vcpu"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_vcpu_apicv_active",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "208-211",
          "snippet": "static inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline bool kvm_vcpu_apicv_active(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.apic && vcpu->arch.apicv_active;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_intercept",
          "args": [
            "svm",
            "INTERCEPT_PAUSE"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "set_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "281-288",
          "snippet": "static inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept |= (1ULL << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clr_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR3_WRITE"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "clr_cr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "214-221",
          "snippet": "static inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void clr_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr &= ~(1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mmu_reset_context",
          "args": [
            "&svm->vcpu"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_reset_context",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5167-5171",
          "snippet": "void kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tkvm_init_mmu(vcpu, true);\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nstatic union kvm_mmu_page_role\nkvm_mmu_calc_root_page_role(struct kvm_vcpu *vcpu);\n\nvoid kvm_mmu_reset_context(struct kvm_vcpu *vcpu)\n{\n\tkvm_mmu_unload(vcpu);\n\tkvm_init_mmu(vcpu, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_cr0",
          "args": [
            "&svm->vcpu",
            "X86_CR0_NW | X86_CR0_CD | X86_CR0_ET"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_cr0",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "2297-2329",
          "snippet": "void svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nvoid svm_set_cr0(struct kvm_vcpu *vcpu, unsigned long cr0)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n#ifdef CONFIG_X86_64\n\tif (vcpu->arch.efer & EFER_LME) {\n\t\tif (!is_paging(vcpu) && (cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer |= EFER_LMA;\n\t\t\tsvm->vmcb->save.efer |= EFER_LMA | EFER_LME;\n\t\t}\n\n\t\tif (is_paging(vcpu) && !(cr0 & X86_CR0_PG)) {\n\t\t\tvcpu->arch.efer &= ~EFER_LMA;\n\t\t\tsvm->vmcb->save.efer &= ~(EFER_LMA | EFER_LME);\n\t\t}\n\t}\n#endif\n\tvcpu->arch.cr0 = cr0;\n\n\tif (!npt_enabled)\n\t\tcr0 |= X86_CR0_PG | X86_CR0_WP;\n\n\t/*\n\t * re-enable caching here because the QEMU bios\n\t * does not do it - this results in some delay at\n\t * reboot\n\t */\n\tif (kvm_check_has_quirk(vcpu->kvm, KVM_X86_QUIRK_CD_NW_CLEARED))\n\t\tcr0 &= ~(X86_CR0_CD | X86_CR0_NW);\n\tsvm->vmcb->save.cr0 = cr0;\n\tmark_dirty(svm->vmcb, VMCB_CR);\n\tupdate_cr0_intercept(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_set_rflags",
          "args": [
            "&svm->vcpu",
            "2"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_rflags",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "10240-10244",
          "snippet": "void kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void __kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_set_rflags(struct kvm_vcpu *vcpu, unsigned long rflags)\n{\n\t__kvm_set_rflags(vcpu, rflags);\n\tkvm_make_request(KVM_REQ_EVENT, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_efer",
          "args": [
            "&svm->vcpu",
            "0"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_efer",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "412-426",
          "snippet": "void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\n\tif (!npt_enabled) {\n\t\t/* Shadow paging assumes NX to be available.  */\n\t\tefer |= EFER_NX;\n\n\t\tif (!(efer & EFER_LMA))\n\t\t\tefer &= ~EFER_LME;\n\t}\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nvoid svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\n\tif (!npt_enabled) {\n\t\t/* Shadow paging assumes NX to be available.  */\n\t\tefer |= EFER_NX;\n\n\t\tif (!(efer & EFER_LMA))\n\t\t\tefer &= ~EFER_LME;\n\t}\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_sys_seg",
          "args": [
            "&save->tr",
            "SEG_TYPE_BUSY_TSS16"
          ],
          "line": 1334
        },
        "resolved": true,
        "details": {
          "function_name": "init_sys_seg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1190-1196",
          "snippet": "static void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_seg",
          "args": [
            "&save->gs"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "init_seg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1181-1188",
          "snippet": "static void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "__pa(svm->msrpm)"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__pa",
          "args": [
            "svm->msrpm"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "iopm_base"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_hlt_in_guest",
          "args": [
            "svm->vcpu.kvm"
          ],
          "line": 1310
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_hlt_in_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "316-319",
          "snippet": "static inline bool kvm_hlt_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.hlt_in_guest;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_hlt_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.hlt_in_guest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_mwait_in_guest",
          "args": [
            "svm->vcpu.kvm"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mwait_in_guest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "311-314",
          "snippet": "static inline bool kvm_mwait_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.mwait_in_guest;\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline bool kvm_mwait_in_guest(struct kvm *kvm)\n{\n\treturn kvm->arch.mwait_in_guest;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_exception_intercept",
          "args": [
            "svm",
            "GP_VECTOR"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "set_exception_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "263-270",
          "snippet": "static inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_exception_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_exceptions |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_dr_intercepts",
          "args": [
            "svm"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "set_dr_intercepts",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "230-252",
          "snippet": "static inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_dr_intercepts(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_dr = (1 << INTERCEPT_DR0_READ)\n\t\t| (1 << INTERCEPT_DR1_READ)\n\t\t| (1 << INTERCEPT_DR2_READ)\n\t\t| (1 << INTERCEPT_DR3_READ)\n\t\t| (1 << INTERCEPT_DR4_READ)\n\t\t| (1 << INTERCEPT_DR5_READ)\n\t\t| (1 << INTERCEPT_DR6_READ)\n\t\t| (1 << INTERCEPT_DR7_READ)\n\t\t| (1 << INTERCEPT_DR0_WRITE)\n\t\t| (1 << INTERCEPT_DR1_WRITE)\n\t\t| (1 << INTERCEPT_DR2_WRITE)\n\t\t| (1 << INTERCEPT_DR3_WRITE)\n\t\t| (1 << INTERCEPT_DR4_WRITE)\n\t\t| (1 << INTERCEPT_DR5_WRITE)\n\t\t| (1 << INTERCEPT_DR6_WRITE)\n\t\t| (1 << INTERCEPT_DR7_WRITE);\n\n\trecalc_intercepts(svm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_cr_intercept",
          "args": [
            "svm",
            "INTERCEPT_CR8_WRITE"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "set_cr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "205-212",
          "snippet": "static inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void set_cr_intercept(struct vcpu_svm *svm, int bit)\n{\n\tstruct vmcb *vmcb = get_host_vmcb(svm);\n\n\tvmcb->control.intercept_cr |= (1U << bit);\n\n\trecalc_intercepts(svm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define SEG_TYPE_BUSY_TSS16 3\n#define SEG_TYPE_LDT 2\n\nstatic unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nstatic int nested = true;\nstatic int vls = true;\nstatic int vgif = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic unsigned long iopm_base;\n\nstatic void init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tstruct vmcb_save_area *save = &svm->vmcb->save;\n\n\tsvm->vcpu.arch.hflags = 0;\n\n\tset_cr_intercept(svm, INTERCEPT_CR0_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR3_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR4_READ);\n\tset_cr_intercept(svm, INTERCEPT_CR0_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\tset_cr_intercept(svm, INTERCEPT_CR4_WRITE);\n\tif (!kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tset_cr_intercept(svm, INTERCEPT_CR8_WRITE);\n\n\tset_dr_intercepts(svm);\n\n\tset_exception_intercept(svm, PF_VECTOR);\n\tset_exception_intercept(svm, UD_VECTOR);\n\tset_exception_intercept(svm, MC_VECTOR);\n\tset_exception_intercept(svm, AC_VECTOR);\n\tset_exception_intercept(svm, DB_VECTOR);\n\t/*\n\t * Guest access to VMware backdoor ports could legitimately\n\t * trigger #GP because of TSS I/O permission bitmap.\n\t * We intercept those #GP and allow access to them anyway\n\t * as VMware does.\n\t */\n\tif (enable_vmware_backdoor)\n\t\tset_exception_intercept(svm, GP_VECTOR);\n\n\tset_intercept(svm, INTERCEPT_INTR);\n\tset_intercept(svm, INTERCEPT_NMI);\n\tset_intercept(svm, INTERCEPT_SMI);\n\tset_intercept(svm, INTERCEPT_SELECTIVE_CR0);\n\tset_intercept(svm, INTERCEPT_RDPMC);\n\tset_intercept(svm, INTERCEPT_CPUID);\n\tset_intercept(svm, INTERCEPT_INVD);\n\tset_intercept(svm, INTERCEPT_INVLPG);\n\tset_intercept(svm, INTERCEPT_INVLPGA);\n\tset_intercept(svm, INTERCEPT_IOIO_PROT);\n\tset_intercept(svm, INTERCEPT_MSR_PROT);\n\tset_intercept(svm, INTERCEPT_TASK_SWITCH);\n\tset_intercept(svm, INTERCEPT_SHUTDOWN);\n\tset_intercept(svm, INTERCEPT_VMRUN);\n\tset_intercept(svm, INTERCEPT_VMMCALL);\n\tset_intercept(svm, INTERCEPT_VMLOAD);\n\tset_intercept(svm, INTERCEPT_VMSAVE);\n\tset_intercept(svm, INTERCEPT_STGI);\n\tset_intercept(svm, INTERCEPT_CLGI);\n\tset_intercept(svm, INTERCEPT_SKINIT);\n\tset_intercept(svm, INTERCEPT_WBINVD);\n\tset_intercept(svm, INTERCEPT_XSETBV);\n\tset_intercept(svm, INTERCEPT_RDPRU);\n\tset_intercept(svm, INTERCEPT_RSM);\n\n\tif (!kvm_mwait_in_guest(svm->vcpu.kvm)) {\n\t\tset_intercept(svm, INTERCEPT_MONITOR);\n\t\tset_intercept(svm, INTERCEPT_MWAIT);\n\t}\n\n\tif (!kvm_hlt_in_guest(svm->vcpu.kvm))\n\t\tset_intercept(svm, INTERCEPT_HLT);\n\n\tcontrol->iopm_base_pa = __sme_set(iopm_base);\n\tcontrol->msrpm_base_pa = __sme_set(__pa(svm->msrpm));\n\tcontrol->int_ctl = V_INTR_MASKING_MASK;\n\n\tinit_seg(&save->es);\n\tinit_seg(&save->ss);\n\tinit_seg(&save->ds);\n\tinit_seg(&save->fs);\n\tinit_seg(&save->gs);\n\n\tsave->cs.selector = 0xf000;\n\tsave->cs.base = 0xffff0000;\n\t/* Executable/Readable Code Segment */\n\tsave->cs.attrib = SVM_SELECTOR_READ_MASK | SVM_SELECTOR_P_MASK |\n\t\tSVM_SELECTOR_S_MASK | SVM_SELECTOR_CODE_MASK;\n\tsave->cs.limit = 0xffff;\n\n\tsave->gdtr.limit = 0xffff;\n\tsave->idtr.limit = 0xffff;\n\n\tinit_sys_seg(&save->ldtr, SEG_TYPE_LDT);\n\tinit_sys_seg(&save->tr, SEG_TYPE_BUSY_TSS16);\n\n\tsvm_set_efer(&svm->vcpu, 0);\n\tsave->dr6 = 0xffff0ff0;\n\tkvm_set_rflags(&svm->vcpu, 2);\n\tsave->rip = 0x0000fff0;\n\tsvm->vcpu.arch.regs[VCPU_REGS_RIP] = save->rip;\n\n\t/*\n\t * svm_set_cr0() sets PG and WP and clears NW and CD on save->cr0.\n\t * It also updates the guest-visible cr0 value.\n\t */\n\tsvm_set_cr0(&svm->vcpu, X86_CR0_NW | X86_CR0_CD | X86_CR0_ET);\n\tkvm_mmu_reset_context(&svm->vcpu);\n\n\tsave->cr4 = X86_CR4_PAE;\n\t/* rdx = ?? */\n\n\tif (npt_enabled) {\n\t\t/* Setup VMCB for Nested Paging */\n\t\tcontrol->nested_ctl |= SVM_NESTED_CTL_NP_ENABLE;\n\t\tclr_intercept(svm, INTERCEPT_INVLPG);\n\t\tclr_exception_intercept(svm, PF_VECTOR);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_READ);\n\t\tclr_cr_intercept(svm, INTERCEPT_CR3_WRITE);\n\t\tsave->g_pat = svm->vcpu.arch.pat;\n\t\tsave->cr3 = 0;\n\t\tsave->cr4 = 0;\n\t}\n\tsvm->asid_generation = 0;\n\n\tsvm->nested.vmcb = 0;\n\tsvm->vcpu.arch.hflags = 0;\n\n\tif (pause_filter_count) {\n\t\tcontrol->pause_filter_count = pause_filter_count;\n\t\tif (pause_filter_thresh)\n\t\t\tcontrol->pause_filter_thresh = pause_filter_thresh;\n\t\tset_intercept(svm, INTERCEPT_PAUSE);\n\t} else {\n\t\tclr_intercept(svm, INTERCEPT_PAUSE);\n\t}\n\n\tif (kvm_vcpu_apicv_active(&svm->vcpu))\n\t\tavic_init_vmcb(svm);\n\n\t/*\n\t * If hardware supports Virtual VMLOAD VMSAVE then enable it\n\t * in VMCB and clear intercepts to avoid #VMEXIT.\n\t */\n\tif (vls) {\n\t\tclr_intercept(svm, INTERCEPT_VMLOAD);\n\t\tclr_intercept(svm, INTERCEPT_VMSAVE);\n\t\tsvm->vmcb->control.virt_ext |= VIRTUAL_VMLOAD_VMSAVE_ENABLE_MASK;\n\t}\n\n\tif (vgif) {\n\t\tclr_intercept(svm, INTERCEPT_STGI);\n\t\tclr_intercept(svm, INTERCEPT_CLGI);\n\t\tsvm->vmcb->control.int_ctl |= V_GIF_ENABLE_MASK;\n\t}\n\n\tif (sev_guest(svm->vcpu.kvm)) {\n\t\tsvm->vmcb->control.nested_ctl |= SVM_NESTED_CTL_SEV_ENABLE;\n\t\tclr_exception_intercept(svm, UD_VECTOR);\n\t}\n\n\tmark_all_dirty(svm->vmcb);\n\n\tenable_gif(svm);\n\n}"
  },
  {
    "function_name": "avic_init_vmcb",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1230-1246",
    "snippet": "static void avic_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(svm->vcpu.kvm);\n\tphys_addr_t bpa = __sme_set(page_to_phys(svm->avic_backing_page));\n\tphys_addr_t lpa = __sme_set(page_to_phys(kvm_svm->avic_logical_id_table_page));\n\tphys_addr_t ppa = __sme_set(page_to_phys(kvm_svm->avic_physical_id_table_page));\n\n\tvmcb->control.avic_backing_page = bpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_logical_id = lpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id = ppa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id |= AVIC_MAX_PHYSICAL_ID_COUNT;\n\tif (kvm_apicv_activated(svm->vcpu.kvm))\n\t\tvmcb->control.int_ctl |= AVIC_ENABLE_MASK;\n\telse\n\t\tvmcb->control.int_ctl &= ~AVIC_ENABLE_MASK;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_MAX_PHYSICAL_ID_COUNT\t255",
      "#define AVIC_HPA_MASK\t~((0xFFFULL << 52) | 0xFFF)"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_apicv_activated",
          "args": [
            "svm->vcpu.kvm"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apicv_activated",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7495-7498",
          "snippet": "bool kvm_apicv_activated(struct kvm *kvm)\n{\n\treturn (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_apicv_activated(struct kvm *kvm)\n{\n\treturn (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "page_to_phys(kvm_svm->avic_physical_id_table_page)"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "kvm_svm->avic_physical_id_table_page"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "page_to_phys(kvm_svm->avic_logical_id_table_page)"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "kvm_svm->avic_logical_id_table_page"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sme_set",
          "args": [
            "page_to_phys(svm->avic_backing_page)"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_phys",
          "args": [
            "svm->avic_backing_page"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "svm->vcpu.kvm"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_MAX_PHYSICAL_ID_COUNT\t255\n#define AVIC_HPA_MASK\t~((0xFFFULL << 52) | 0xFFF)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void avic_init_vmcb(struct vcpu_svm *svm)\n{\n\tstruct vmcb *vmcb = svm->vmcb;\n\tstruct kvm_svm *kvm_svm = to_kvm_svm(svm->vcpu.kvm);\n\tphys_addr_t bpa = __sme_set(page_to_phys(svm->avic_backing_page));\n\tphys_addr_t lpa = __sme_set(page_to_phys(kvm_svm->avic_logical_id_table_page));\n\tphys_addr_t ppa = __sme_set(page_to_phys(kvm_svm->avic_physical_id_table_page));\n\n\tvmcb->control.avic_backing_page = bpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_logical_id = lpa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id = ppa & AVIC_HPA_MASK;\n\tvmcb->control.avic_physical_id |= AVIC_MAX_PHYSICAL_ID_COUNT;\n\tif (kvm_apicv_activated(svm->vcpu.kvm))\n\t\tvmcb->control.int_ctl |= AVIC_ENABLE_MASK;\n\telse\n\t\tvmcb->control.int_ctl &= ~AVIC_ENABLE_MASK;\n}"
  },
  {
    "function_name": "svm_write_l1_tsc_offset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1208-1228",
    "snippet": "static u64 svm_write_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 g_tsc_offset = 0;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/* Write L1's TSC offset.  */\n\t\tg_tsc_offset = svm->vmcb->control.tsc_offset -\n\t\t\t       svm->nested.hsave->control.tsc_offset;\n\t\tsvm->nested.hsave->control.tsc_offset = offset;\n\t}\n\n\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t   svm->vmcb->control.tsc_offset - g_tsc_offset,\n\t\t\t\t   offset);\n\n\tsvm->vmcb->control.tsc_offset = offset + g_tsc_offset;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\treturn svm->vmcb->control.tsc_offset;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTERCEPTS"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_write_tsc_offset",
          "args": [
            "vcpu->vcpu_id",
            "svm->vmcb->control.tsc_offset - g_tsc_offset",
            "offset"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_write_l1_tsc_offset(struct kvm_vcpu *vcpu, u64 offset)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 g_tsc_offset = 0;\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/* Write L1's TSC offset.  */\n\t\tg_tsc_offset = svm->vmcb->control.tsc_offset -\n\t\t\t       svm->nested.hsave->control.tsc_offset;\n\t\tsvm->nested.hsave->control.tsc_offset = offset;\n\t}\n\n\ttrace_kvm_write_tsc_offset(vcpu->vcpu_id,\n\t\t\t\t   svm->vmcb->control.tsc_offset - g_tsc_offset,\n\t\t\t\t   offset);\n\n\tsvm->vmcb->control.tsc_offset = offset + g_tsc_offset;\n\n\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\treturn svm->vmcb->control.tsc_offset;\n}"
  },
  {
    "function_name": "svm_read_l1_tsc_offset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1198-1206",
    "snippet": "static u64 svm_read_l1_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn svm->nested.hsave->control.tsc_offset;\n\n\treturn vcpu->arch.tsc_offset;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u64 svm_read_l1_tsc_offset(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (is_guest_mode(vcpu))\n\t\treturn svm->nested.hsave->control.tsc_offset;\n\n\treturn vcpu->arch.tsc_offset;\n}"
  },
  {
    "function_name": "init_sys_seg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1190-1196",
    "snippet": "static void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void init_sys_seg(struct vmcb_seg *seg, uint32_t type)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | type;\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}"
  },
  {
    "function_name": "init_seg",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1181-1188",
    "snippet": "static void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void init_seg(struct vmcb_seg *seg)\n{\n\tseg->selector = 0;\n\tseg->attrib = SVM_SELECTOR_P_MASK | SVM_SELECTOR_S_MASK |\n\t\t      SVM_SELECTOR_WRITE_MASK; /* Read/Write Data Segment */\n\tseg->limit = 0xffff;\n\tseg->base = 0;\n}"
  },
  {
    "function_name": "svm_hardware_setup",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1065-1179",
    "snippet": "static __init int svm_hardware_setup(void)\n{\n\tint cpu;\n\tstruct page *iopm_pages;\n\tvoid *iopm_va;\n\tint r;\n\n\tiopm_pages = alloc_pages(GFP_KERNEL, IOPM_ALLOC_ORDER);\n\n\tif (!iopm_pages)\n\t\treturn -ENOMEM;\n\n\tiopm_va = page_address(iopm_pages);\n\tmemset(iopm_va, 0xff, PAGE_SIZE * (1 << IOPM_ALLOC_ORDER));\n\tiopm_base = page_to_pfn(iopm_pages) << PAGE_SHIFT;\n\n\tinit_msrpm_offsets();\n\n\tsupported_xcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (boot_cpu_has(X86_FEATURE_FXSR_OPT))\n\t\tkvm_enable_efer_bits(EFER_FFXSR);\n\n\tif (boot_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = TSC_RATIO_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 32;\n\t}\n\n\t/* Check for pause filtering support */\n\tif (!boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tpause_filter_count = 0;\n\t\tpause_filter_thresh = 0;\n\t} else if (!boot_cpu_has(X86_FEATURE_PFTHRESHOLD)) {\n\t\tpause_filter_thresh = 0;\n\t}\n\n\tif (nested) {\n\t\tprintk(KERN_INFO \"kvm: Nested Virtualization enabled\\n\");\n\t\tkvm_enable_efer_bits(EFER_SVME | EFER_LMSLE);\n\t}\n\n\tif (sev) {\n\t\tif (boot_cpu_has(X86_FEATURE_SEV) &&\n\t\t    IS_ENABLED(CONFIG_KVM_AMD_SEV)) {\n\t\t\tr = sev_hardware_setup();\n\t\t\tif (r)\n\t\t\t\tsev = false;\n\t\t} else {\n\t\t\tsev = false;\n\t\t}\n\t}\n\n\tsvm_adjust_mmio_mask();\n\n\tfor_each_possible_cpu(cpu) {\n\t\tr = svm_cpu_init(cpu);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_NPT))\n\t\tnpt_enabled = false;\n\n\tif (npt_enabled && !npt)\n\t\tnpt_enabled = false;\n\n\tkvm_configure_mmu(npt_enabled, PT_PDPE_LEVEL);\n\tpr_info(\"kvm: Nested Paging %sabled\\n\", npt_enabled ? \"en\" : \"dis\");\n\n\tif (nrips) {\n\t\tif (!boot_cpu_has(X86_FEATURE_NRIPS))\n\t\t\tnrips = false;\n\t}\n\n\tif (avic) {\n\t\tif (!npt_enabled ||\n\t\t    !boot_cpu_has(X86_FEATURE_AVIC) ||\n\t\t    !IS_ENABLED(CONFIG_X86_LOCAL_APIC)) {\n\t\t\tavic = false;\n\t\t} else {\n\t\t\tpr_info(\"AVIC enabled\\n\");\n\n\t\t\tamd_iommu_register_ga_log_notifier(&avic_ga_log_notifier);\n\t\t}\n\t}\n\n\tif (vls) {\n\t\tif (!npt_enabled ||\n\t\t    !boot_cpu_has(X86_FEATURE_V_VMSAVE_VMLOAD) ||\n\t\t    !IS_ENABLED(CONFIG_X86_64)) {\n\t\t\tvls = false;\n\t\t} else {\n\t\t\tpr_info(\"Virtual VMLOAD VMSAVE supported\\n\");\n\t\t}\n\t}\n\n\tif (vgif) {\n\t\tif (!boot_cpu_has(X86_FEATURE_VGIF))\n\t\t\tvgif = false;\n\t\telse\n\t\t\tpr_info(\"Virtual GIF supported\\n\");\n\t}\n\n\tsvm_set_cpu_caps();\n\n\treturn 0;\n\nerr:\n\tsvm_hardware_teardown();\n\treturn r;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define TSC_RATIO_MAX\t\t0x000000ffffffffffULL",
      "#define IOPM_ALLOC_ORDER 2"
    ],
    "globals_used": [
      "static unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;",
      "static unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;",
      "static int npt = true;",
      "static int nested = true;",
      "static int avic;",
      "static int nrips = true;",
      "static int vls = true;",
      "static int vgif = true;",
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);",
      "static unsigned long iopm_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_hardware_teardown",
          "args": [],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "svm_hardware_teardown",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1024-1040",
          "snippet": "static void svm_hardware_teardown(void)\n{\n\tint cpu;\n\n\tif (svm_sev_enabled()) {\n\t\tbitmap_free(sev_asid_bitmap);\n\t\tbitmap_free(sev_reclaim_asid_bitmap);\n\n\t\tsev_flush_asids();\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\tsvm_cpu_uninit(cpu);\n\n\t__free_pages(pfn_to_page(iopm_base >> PAGE_SHIFT), IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define IOPM_ALLOC_ORDER 2"
          ],
          "globals_used": [
            "static int sev_flush_asids(void);",
            "static unsigned long *sev_asid_bitmap;",
            "static unsigned long *sev_reclaim_asid_bitmap;",
            "static unsigned long iopm_base;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define IOPM_ALLOC_ORDER 2\n\nstatic int sev_flush_asids(void);\nstatic unsigned long *sev_asid_bitmap;\nstatic unsigned long *sev_reclaim_asid_bitmap;\nstatic unsigned long iopm_base;\n\nstatic void svm_hardware_teardown(void)\n{\n\tint cpu;\n\n\tif (svm_sev_enabled()) {\n\t\tbitmap_free(sev_asid_bitmap);\n\t\tbitmap_free(sev_reclaim_asid_bitmap);\n\n\t\tsev_flush_asids();\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\tsvm_cpu_uninit(cpu);\n\n\t__free_pages(pfn_to_page(iopm_base >> PAGE_SHIFT), IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_set_cpu_caps",
          "args": [],
          "line": 1172
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_cpu_caps",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "1042-1063",
          "snippet": "static __init void svm_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\tsupported_xss = 0;\n\n\t/* CPUID 0x80000001 and 0x8000000A (SVM features) */\n\tif (nested) {\n\t\tkvm_cpu_cap_set(X86_FEATURE_SVM);\n\n\t\tif (nrips)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NRIPS);\n\n\t\tif (npt_enabled)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NPT);\n\t}\n\n\t/* CPUID 0x80000008 */\n\tif (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) ||\n\t    boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nested = true;",
            "static int nrips = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic int nrips = true;\n\nstatic __init void svm_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\tsupported_xss = 0;\n\n\t/* CPUID 0x80000001 and 0x8000000A (SVM features) */\n\tif (nested) {\n\t\tkvm_cpu_cap_set(X86_FEATURE_SVM);\n\n\t\tif (nrips)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NRIPS);\n\n\t\tif (npt_enabled)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NPT);\n\t}\n\n\t/* CPUID 0x80000008 */\n\tif (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) ||\n\t    boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Virtual GIF supported\\n\""
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_VGIF"
          ],
          "line": 1166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Virtual VMLOAD VMSAVE supported\\n\""
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_X86_64"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_V_VMSAVE_VMLOAD"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "amd_iommu_register_ga_log_notifier",
          "args": [
            "&avic_ga_log_notifier"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"AVIC enabled\\n\""
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_X86_LOCAL_APIC"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_AVIC"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_NRIPS"
          ],
          "line": 1139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"kvm: Nested Paging %sabled\\n\"",
            "npt_enabled ? \"en\" : \"dis\""
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_configure_mmu",
          "args": [
            "npt_enabled",
            "PT_PDPE_LEVEL"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_configure_mmu",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "5563-5580",
          "snippet": "void kvm_configure_mmu(bool enable_tdp, int tdp_page_level)\n{\n\ttdp_enabled = enable_tdp;\n\n\t/*\n\t * max_page_level reflects the capabilities of KVM's MMU irrespective\n\t * of kernel support, e.g. KVM may be capable of using 1GB pages when\n\t * the kernel is not.  But, KVM never creates a page size greater than\n\t * what is used by the kernel for any given HVA, i.e. the kernel's\n\t * capabilities are ultimately consulted by kvm_mmu_hugepage_adjust().\n\t */\n\tif (tdp_enabled)\n\t\tmax_page_level = tdp_page_level;\n\telse if (boot_cpu_has(X86_FEATURE_GBPAGES))\n\t\tmax_page_level = PT_PDPE_LEVEL;\n\telse\n\t\tmax_page_level = PT_DIRECTORY_LEVEL;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool tdp_enabled = false;",
            "static int max_page_level"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\nbool tdp_enabled = false;\nstatic int max_page_level;\n\nvoid kvm_configure_mmu(bool enable_tdp, int tdp_page_level)\n{\n\ttdp_enabled = enable_tdp;\n\n\t/*\n\t * max_page_level reflects the capabilities of KVM's MMU irrespective\n\t * of kernel support, e.g. KVM may be capable of using 1GB pages when\n\t * the kernel is not.  But, KVM never creates a page size greater than\n\t * what is used by the kernel for any given HVA, i.e. the kernel's\n\t * capabilities are ultimately consulted by kvm_mmu_hugepage_adjust().\n\t */\n\tif (tdp_enabled)\n\t\tmax_page_level = tdp_page_level;\n\telse if (boot_cpu_has(X86_FEATURE_GBPAGES))\n\t\tmax_page_level = PT_PDPE_LEVEL;\n\telse\n\t\tmax_page_level = PT_DIRECTORY_LEVEL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_NPT"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_cpu_init",
          "args": [
            "cpu"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "svm_cpu_init",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "676-706",
          "snippet": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto free_cpu_data;\n\n\tif (svm_sev_enabled()) {\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto free_save_area;\n\t}\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nfree_save_area:\n\t__free_page(sd->save_area);\nfree_cpu_data:\n\tkfree(sd);\n\treturn -ENOMEM;\n\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int max_sev_asid;",
            "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned int max_sev_asid;\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto free_cpu_data;\n\n\tif (svm_sev_enabled()) {\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto free_save_area;\n\t}\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nfree_save_area:\n\t__free_page(sd->save_area);\nfree_cpu_data:\n\tkfree(sd);\n\treturn -ENOMEM;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "svm_adjust_mmio_mask",
          "args": [],
          "line": 1121
        },
        "resolved": true,
        "details": {
          "function_name": "svm_adjust_mmio_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "989-1022",
          "snippet": "static __init void svm_adjust_mmio_mask(void)\n{\n\tunsigned int enc_bit, mask_bit;\n\tu64 msr, mask;\n\n\t/* If there is no memory encryption support, use existing mask */\n\tif (cpuid_eax(0x80000000) < 0x8000001f)\n\t\treturn;\n\n\t/* If memory encryption is not enabled, use existing mask */\n\trdmsrl(MSR_K8_SYSCFG, msr);\n\tif (!(msr & MSR_K8_SYSCFG_MEM_ENCRYPT))\n\t\treturn;\n\n\tenc_bit = cpuid_ebx(0x8000001f) & 0x3f;\n\tmask_bit = boot_cpu_data.x86_phys_bits;\n\n\t/* Increment the mask bit if it is the same as the encryption bit */\n\tif (enc_bit == mask_bit)\n\t\tmask_bit++;\n\n\t/*\n\t * If the mask bit location is below 52, then some bits above the\n\t * physical addressing limit will always be reserved, so use the\n\t * rsvd_bits() function to generate the mask. This mask, along with\n\t * the present bit, will be used to generate a page fault with\n\t * PFER.RSV = 1.\n\t *\n\t * If the mask bit location is 52 (or above), then clear the mask.\n\t */\n\tmask = (mask_bit < 52) ? rsvd_bits(mask_bit, 51) | PT_PRESENT_MASK : 0;\n\n\tkvm_mmu_set_mmio_spte_mask(mask, mask, PT_WRITABLE_MASK | PT_USER_MASK);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic __init void svm_adjust_mmio_mask(void)\n{\n\tunsigned int enc_bit, mask_bit;\n\tu64 msr, mask;\n\n\t/* If there is no memory encryption support, use existing mask */\n\tif (cpuid_eax(0x80000000) < 0x8000001f)\n\t\treturn;\n\n\t/* If memory encryption is not enabled, use existing mask */\n\trdmsrl(MSR_K8_SYSCFG, msr);\n\tif (!(msr & MSR_K8_SYSCFG_MEM_ENCRYPT))\n\t\treturn;\n\n\tenc_bit = cpuid_ebx(0x8000001f) & 0x3f;\n\tmask_bit = boot_cpu_data.x86_phys_bits;\n\n\t/* Increment the mask bit if it is the same as the encryption bit */\n\tif (enc_bit == mask_bit)\n\t\tmask_bit++;\n\n\t/*\n\t * If the mask bit location is below 52, then some bits above the\n\t * physical addressing limit will always be reserved, so use the\n\t * rsvd_bits() function to generate the mask. This mask, along with\n\t * the present bit, will be used to generate a page fault with\n\t * PFER.RSV = 1.\n\t *\n\t * If the mask bit location is 52 (or above), then clear the mask.\n\t */\n\tmask = (mask_bit < 52) ? rsvd_bits(mask_bit, 51) | PT_PRESENT_MASK : 0;\n\n\tkvm_mmu_set_mmio_spte_mask(mask, mask, PT_WRITABLE_MASK | PT_USER_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sev_hardware_setup",
          "args": [],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "sev_hardware_setup",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "902-945",
          "snippet": "static __init int sev_hardware_setup(void)\n{\n\tstruct sev_user_data_status *status;\n\tint rc;\n\n\t/* Maximum number of encrypted guests supported simultaneously */\n\tmax_sev_asid = cpuid_ecx(0x8000001F);\n\n\tif (!max_sev_asid)\n\t\treturn 1;\n\n\t/* Minimum ASID value that should be used for SEV guest */\n\tmin_sev_asid = cpuid_edx(0x8000001F);\n\n\t/* Initialize SEV ASID bitmaps */\n\tsev_asid_bitmap = bitmap_zalloc(max_sev_asid, GFP_KERNEL);\n\tif (!sev_asid_bitmap)\n\t\treturn 1;\n\n\tsev_reclaim_asid_bitmap = bitmap_zalloc(max_sev_asid, GFP_KERNEL);\n\tif (!sev_reclaim_asid_bitmap)\n\t\treturn 1;\n\n\tstatus = kmalloc(sizeof(*status), GFP_KERNEL);\n\tif (!status)\n\t\treturn 1;\n\n\t/*\n\t * Check SEV platform status.\n\t *\n\t * PLATFORM_STATUS can be called in any state, if we failed to query\n\t * the PLATFORM status then either PSP firmware does not support SEV\n\t * feature or SEV firmware is dead.\n\t */\n\trc = sev_platform_status(status, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\tpr_info(\"SEV supported\\n\");\n\nerr:\n\tkfree(status);\n\treturn rc;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int max_sev_asid;",
            "static unsigned int min_sev_asid;",
            "static unsigned long *sev_asid_bitmap;",
            "static unsigned long *sev_reclaim_asid_bitmap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned int max_sev_asid;\nstatic unsigned int min_sev_asid;\nstatic unsigned long *sev_asid_bitmap;\nstatic unsigned long *sev_reclaim_asid_bitmap;\n\nstatic __init int sev_hardware_setup(void)\n{\n\tstruct sev_user_data_status *status;\n\tint rc;\n\n\t/* Maximum number of encrypted guests supported simultaneously */\n\tmax_sev_asid = cpuid_ecx(0x8000001F);\n\n\tif (!max_sev_asid)\n\t\treturn 1;\n\n\t/* Minimum ASID value that should be used for SEV guest */\n\tmin_sev_asid = cpuid_edx(0x8000001F);\n\n\t/* Initialize SEV ASID bitmaps */\n\tsev_asid_bitmap = bitmap_zalloc(max_sev_asid, GFP_KERNEL);\n\tif (!sev_asid_bitmap)\n\t\treturn 1;\n\n\tsev_reclaim_asid_bitmap = bitmap_zalloc(max_sev_asid, GFP_KERNEL);\n\tif (!sev_reclaim_asid_bitmap)\n\t\treturn 1;\n\n\tstatus = kmalloc(sizeof(*status), GFP_KERNEL);\n\tif (!status)\n\t\treturn 1;\n\n\t/*\n\t * Check SEV platform status.\n\t *\n\t * PLATFORM_STATUS can be called in any state, if we failed to query\n\t * the PLATFORM status then either PSP firmware does not support SEV\n\t * feature or SEV firmware is dead.\n\t */\n\trc = sev_platform_status(status, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\tpr_info(\"SEV supported\\n\");\n\nerr:\n\tkfree(status);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KVM_AMD_SEV"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_SEV"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_enable_efer_bits",
          "args": [
            "EFER_SVME | EFER_LMSLE"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_enable_efer_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "1457-1460",
          "snippet": "void kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_enable_efer_bits(u64 mask)\n{\n       efer_reserved_bits &= ~mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"kvm: Nested Virtualization enabled\\n\""
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_PFTHRESHOLD"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_PAUSEFILTER"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_TSCRATEMSR"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_FXSR_OPT"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_NX"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_msrpm_offsets",
          "args": [],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "init_msrpm_offsets",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "805-819",
          "snippet": "static void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32 msrpm_offsets[MSRPM_OFFSETS]",
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nu32 msrpm_offsets[MSRPM_OFFSETS];\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "iopm_pages"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "iopm_va",
            "0xff",
            "PAGE_SIZE * (1 << IOPM_ALLOC_ORDER)"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "iopm_pages"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_pages",
          "args": [
            "GFP_KERNEL",
            "IOPM_ALLOC_ORDER"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define TSC_RATIO_MAX\t\t0x000000ffffffffffULL\n#define IOPM_ALLOC_ORDER 2\n\nstatic unsigned short pause_filter_thresh = KVM_DEFAULT_PLE_GAP;\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nstatic int npt = true;\nstatic int nested = true;\nstatic int avic;\nstatic int nrips = true;\nstatic int vls = true;\nstatic int vgif = true;\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\nstatic unsigned long iopm_base;\n\nstatic __init int svm_hardware_setup(void)\n{\n\tint cpu;\n\tstruct page *iopm_pages;\n\tvoid *iopm_va;\n\tint r;\n\n\tiopm_pages = alloc_pages(GFP_KERNEL, IOPM_ALLOC_ORDER);\n\n\tif (!iopm_pages)\n\t\treturn -ENOMEM;\n\n\tiopm_va = page_address(iopm_pages);\n\tmemset(iopm_va, 0xff, PAGE_SIZE * (1 << IOPM_ALLOC_ORDER));\n\tiopm_base = page_to_pfn(iopm_pages) << PAGE_SHIFT;\n\n\tinit_msrpm_offsets();\n\n\tsupported_xcr0 &= ~(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR);\n\n\tif (boot_cpu_has(X86_FEATURE_NX))\n\t\tkvm_enable_efer_bits(EFER_NX);\n\n\tif (boot_cpu_has(X86_FEATURE_FXSR_OPT))\n\t\tkvm_enable_efer_bits(EFER_FFXSR);\n\n\tif (boot_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\tkvm_has_tsc_control = true;\n\t\tkvm_max_tsc_scaling_ratio = TSC_RATIO_MAX;\n\t\tkvm_tsc_scaling_ratio_frac_bits = 32;\n\t}\n\n\t/* Check for pause filtering support */\n\tif (!boot_cpu_has(X86_FEATURE_PAUSEFILTER)) {\n\t\tpause_filter_count = 0;\n\t\tpause_filter_thresh = 0;\n\t} else if (!boot_cpu_has(X86_FEATURE_PFTHRESHOLD)) {\n\t\tpause_filter_thresh = 0;\n\t}\n\n\tif (nested) {\n\t\tprintk(KERN_INFO \"kvm: Nested Virtualization enabled\\n\");\n\t\tkvm_enable_efer_bits(EFER_SVME | EFER_LMSLE);\n\t}\n\n\tif (sev) {\n\t\tif (boot_cpu_has(X86_FEATURE_SEV) &&\n\t\t    IS_ENABLED(CONFIG_KVM_AMD_SEV)) {\n\t\t\tr = sev_hardware_setup();\n\t\t\tif (r)\n\t\t\t\tsev = false;\n\t\t} else {\n\t\t\tsev = false;\n\t\t}\n\t}\n\n\tsvm_adjust_mmio_mask();\n\n\tfor_each_possible_cpu(cpu) {\n\t\tr = svm_cpu_init(cpu);\n\t\tif (r)\n\t\t\tgoto err;\n\t}\n\n\tif (!boot_cpu_has(X86_FEATURE_NPT))\n\t\tnpt_enabled = false;\n\n\tif (npt_enabled && !npt)\n\t\tnpt_enabled = false;\n\n\tkvm_configure_mmu(npt_enabled, PT_PDPE_LEVEL);\n\tpr_info(\"kvm: Nested Paging %sabled\\n\", npt_enabled ? \"en\" : \"dis\");\n\n\tif (nrips) {\n\t\tif (!boot_cpu_has(X86_FEATURE_NRIPS))\n\t\t\tnrips = false;\n\t}\n\n\tif (avic) {\n\t\tif (!npt_enabled ||\n\t\t    !boot_cpu_has(X86_FEATURE_AVIC) ||\n\t\t    !IS_ENABLED(CONFIG_X86_LOCAL_APIC)) {\n\t\t\tavic = false;\n\t\t} else {\n\t\t\tpr_info(\"AVIC enabled\\n\");\n\n\t\t\tamd_iommu_register_ga_log_notifier(&avic_ga_log_notifier);\n\t\t}\n\t}\n\n\tif (vls) {\n\t\tif (!npt_enabled ||\n\t\t    !boot_cpu_has(X86_FEATURE_V_VMSAVE_VMLOAD) ||\n\t\t    !IS_ENABLED(CONFIG_X86_64)) {\n\t\t\tvls = false;\n\t\t} else {\n\t\t\tpr_info(\"Virtual VMLOAD VMSAVE supported\\n\");\n\t\t}\n\t}\n\n\tif (vgif) {\n\t\tif (!boot_cpu_has(X86_FEATURE_VGIF))\n\t\t\tvgif = false;\n\t\telse\n\t\t\tpr_info(\"Virtual GIF supported\\n\");\n\t}\n\n\tsvm_set_cpu_caps();\n\n\treturn 0;\n\nerr:\n\tsvm_hardware_teardown();\n\treturn r;\n}"
  },
  {
    "function_name": "svm_set_cpu_caps",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1042-1063",
    "snippet": "static __init void svm_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\tsupported_xss = 0;\n\n\t/* CPUID 0x80000001 and 0x8000000A (SVM features) */\n\tif (nested) {\n\t\tkvm_cpu_cap_set(X86_FEATURE_SVM);\n\n\t\tif (nrips)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NRIPS);\n\n\t\tif (npt_enabled)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NPT);\n\t}\n\n\t/* CPUID 0x80000008 */\n\tif (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) ||\n\t    boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static int nrips = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_cpu_cap_set",
          "args": [
            "X86_FEATURE_VIRT_SSBD"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_cpu_cap_set",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.h",
          "lines": "279-285",
          "snippet": "static __always_inline void kvm_cpu_cap_set(unsigned int x86_feature)\n{\n\tunsigned int x86_leaf = x86_feature / 32;\n\n\treverse_cpuid_check(x86_leaf);\n\tkvm_cpu_caps[x86_leaf] |= __feature_bit(x86_feature);\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <asm/cpu.h>",
            "#include \"x86.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <asm/cpu.h>\n#include \"x86.h\"\n\nstatic __always_inline void kvm_cpu_cap_set(unsigned int x86_feature)\n{\n\tunsigned int x86_leaf = x86_feature / 32;\n\n\treverse_cpuid_check(x86_leaf);\n\tkvm_cpu_caps[x86_leaf] |= __feature_bit(x86_feature);\n}"
        }
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_AMD_SSBD"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "boot_cpu_has",
          "args": [
            "X86_FEATURE_LS_CFG_SSBD"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_set_cpu_caps",
          "args": [],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_set_cpu_caps",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/cpuid.c",
          "lines": "275-425",
          "snippet": "void kvm_set_cpu_caps(void)\n{\n\tunsigned int f_nx = is_efer_nx() ? F(NX) : 0;\n#ifdef CONFIG_X86_64\n\tunsigned int f_gbpages = F(GBPAGES);\n\tunsigned int f_lm = F(LM);\n#else\n\tunsigned int f_gbpages = 0;\n\tunsigned int f_lm = 0;\n#endif\n\n\tBUILD_BUG_ON(sizeof(kvm_cpu_caps) >\n\t\t     sizeof(boot_cpu_data.x86_capability));\n\n\tmemcpy(&kvm_cpu_caps, &boot_cpu_data.x86_capability,\n\t       sizeof(kvm_cpu_caps));\n\n\tkvm_cpu_cap_mask(CPUID_1_ECX,\n\t\t/*\n\t\t * NOTE: MONITOR (and MWAIT) are emulated as NOP, but *not*\n\t\t * advertised to guests via CPUID!\n\t\t */\n\t\tF(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |\n\t\t0 /* DS-CPL, VMX, SMX, EST */ |\n\t\t0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |\n\t\tF(FMA) | F(CX16) | 0 /* xTPR Update, PDCM */ |\n\t\tF(PCID) | 0 /* Reserved, DCA */ | F(XMM4_1) |\n\t\tF(XMM4_2) | F(X2APIC) | F(MOVBE) | F(POPCNT) |\n\t\t0 /* Reserved*/ | F(AES) | F(XSAVE) | 0 /* OSXSAVE */ | F(AVX) |\n\t\tF(F16C) | F(RDRAND)\n\t);\n\t/* KVM emulates x2apic in software irrespective of host support. */\n\tkvm_cpu_cap_set(X86_FEATURE_X2APIC);\n\n\tkvm_cpu_cap_mask(CPUID_1_EDX,\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SEP) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* PSN */ | F(CLFLUSH) |\n\t\t0 /* Reserved, DS, ACPI */ | F(MMX) |\n\t\tF(FXSR) | F(XMM) | F(XMM2) | F(SELFSNOOP) |\n\t\t0 /* HTT, TM, Reserved, PBE */\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_7_0_EBX,\n\t\tF(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |\n\t\tF(BMI2) | F(ERMS) | 0 /*INVPCID*/ | F(RTM) | 0 /*MPX*/ | F(RDSEED) |\n\t\tF(ADX) | F(SMAP) | F(AVX512IFMA) | F(AVX512F) | F(AVX512PF) |\n\t\tF(AVX512ER) | F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(AVX512DQ) |\n\t\tF(SHA_NI) | F(AVX512BW) | F(AVX512VL) | 0 /*INTEL_PT*/\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_7_ECX,\n\t\tF(AVX512VBMI) | F(LA57) | 0 /*PKU*/ | 0 /*OSPKE*/ | F(RDPID) |\n\t\tF(AVX512_VPOPCNTDQ) | F(UMIP) | F(AVX512_VBMI2) | F(GFNI) |\n\t\tF(VAES) | F(VPCLMULQDQ) | F(AVX512_VNNI) | F(AVX512_BITALG) |\n\t\tF(CLDEMOTE) | F(MOVDIRI) | F(MOVDIR64B) | 0 /*WAITPKG*/\n\t);\n\t/* Set LA57 based on hardware capability. */\n\tif (cpuid_ecx(7) & F(LA57))\n\t\tkvm_cpu_cap_set(X86_FEATURE_LA57);\n\n\tkvm_cpu_cap_mask(CPUID_7_EDX,\n\t\tF(AVX512_4VNNIW) | F(AVX512_4FMAPS) | F(SPEC_CTRL) |\n\t\tF(SPEC_CTRL_SSBD) | F(ARCH_CAPABILITIES) | F(INTEL_STIBP) |\n\t\tF(MD_CLEAR) | F(AVX512_VP2INTERSECT) | F(FSRM)\n\t);\n\n\t/* TSC_ADJUST and ARCH_CAPABILITIES are emulated in software. */\n\tkvm_cpu_cap_set(X86_FEATURE_TSC_ADJUST);\n\tkvm_cpu_cap_set(X86_FEATURE_ARCH_CAPABILITIES);\n\n\tif (boot_cpu_has(X86_FEATURE_IBPB) && boot_cpu_has(X86_FEATURE_IBRS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_SPEC_CTRL);\n\tif (boot_cpu_has(X86_FEATURE_STIBP))\n\t\tkvm_cpu_cap_set(X86_FEATURE_INTEL_STIBP);\n\tif (boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_SPEC_CTRL_SSBD);\n\n\tkvm_cpu_cap_mask(CPUID_7_1_EAX,\n\t\tF(AVX512_BF16)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_D_1_EAX,\n\t\tF(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | F(XSAVES)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0001_ECX,\n\t\tF(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |\n\t\tF(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |\n\t\tF(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |\n\t\t0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM) |\n\t\tF(TOPOEXT) | F(PERFCTR_CORE)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0001_EDX,\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SYSCALL) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* Reserved */ |\n\t\tf_nx | 0 /* Reserved */ | F(MMXEXT) | F(MMX) |\n\t\tF(FXSR) | F(FXSR_OPT) | f_gbpages | F(RDTSCP) |\n\t\t0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW)\n\t);\n\n\tif (!tdp_enabled && IS_ENABLED(CONFIG_X86_64))\n\t\tkvm_cpu_cap_set(X86_FEATURE_GBPAGES);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0008_EBX,\n\t\tF(CLZERO) | F(XSAVEERPTR) |\n\t\tF(WBNOINVD) | F(AMD_IBPB) | F(AMD_IBRS) | F(AMD_SSBD) | F(VIRT_SSBD) |\n\t\tF(AMD_SSB_NO) | F(AMD_STIBP) | F(AMD_STIBP_ALWAYS_ON)\n\t);\n\n\t/*\n\t * AMD has separate bits for each SPEC_CTRL bit.\n\t * arch/x86/kernel/cpu/bugs.c is kind enough to\n\t * record that in cpufeatures so use them.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_IBPB))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_IBPB);\n\tif (boot_cpu_has(X86_FEATURE_IBRS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_IBRS);\n\tif (boot_cpu_has(X86_FEATURE_STIBP))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_STIBP);\n\tif (boot_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_SSBD);\n\tif (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_SSB_NO);\n\t/*\n\t * The preference is to use SPEC CTRL MSR instead of the\n\t * VIRT_SPEC MSR.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);\n\n\t/*\n\t * Hide all SVM features by default, SVM will set the cap bits for\n\t * features it emulates and/or exposes for L1.\n\t */\n\tkvm_cpu_cap_mask(CPUID_8000_000A_EDX, 0);\n\n\tkvm_cpu_cap_mask(CPUID_C000_0001_EDX,\n\t\tF(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |\n\t\tF(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |\n\t\tF(PMM) | F(PMM_EN)\n\t);\n}",
          "includes": [
            "#include \"pmu.h\"",
            "#include \"trace.h\"",
            "#include \"mmu.h\"",
            "#include \"lapic.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/fpu/xstate.h>",
            "#include <asm/user.h>",
            "#include <asm/processor.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define F feature_bit"
          ],
          "globals_used": [
            "u32 kvm_cpu_caps[NCAPINTS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pmu.h\"\n#include \"trace.h\"\n#include \"mmu.h\"\n#include \"lapic.h\"\n#include \"cpuid.h\"\n#include <asm/fpu/xstate.h>\n#include <asm/user.h>\n#include <asm/processor.h>\n#include <linux/sched/stat.h>\n#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/kvm_host.h>\n\n#define F feature_bit\n\nu32 kvm_cpu_caps[NCAPINTS];\n\nvoid kvm_set_cpu_caps(void)\n{\n\tunsigned int f_nx = is_efer_nx() ? F(NX) : 0;\n#ifdef CONFIG_X86_64\n\tunsigned int f_gbpages = F(GBPAGES);\n\tunsigned int f_lm = F(LM);\n#else\n\tunsigned int f_gbpages = 0;\n\tunsigned int f_lm = 0;\n#endif\n\n\tBUILD_BUG_ON(sizeof(kvm_cpu_caps) >\n\t\t     sizeof(boot_cpu_data.x86_capability));\n\n\tmemcpy(&kvm_cpu_caps, &boot_cpu_data.x86_capability,\n\t       sizeof(kvm_cpu_caps));\n\n\tkvm_cpu_cap_mask(CPUID_1_ECX,\n\t\t/*\n\t\t * NOTE: MONITOR (and MWAIT) are emulated as NOP, but *not*\n\t\t * advertised to guests via CPUID!\n\t\t */\n\t\tF(XMM3) | F(PCLMULQDQ) | 0 /* DTES64, MONITOR */ |\n\t\t0 /* DS-CPL, VMX, SMX, EST */ |\n\t\t0 /* TM2 */ | F(SSSE3) | 0 /* CNXT-ID */ | 0 /* Reserved */ |\n\t\tF(FMA) | F(CX16) | 0 /* xTPR Update, PDCM */ |\n\t\tF(PCID) | 0 /* Reserved, DCA */ | F(XMM4_1) |\n\t\tF(XMM4_2) | F(X2APIC) | F(MOVBE) | F(POPCNT) |\n\t\t0 /* Reserved*/ | F(AES) | F(XSAVE) | 0 /* OSXSAVE */ | F(AVX) |\n\t\tF(F16C) | F(RDRAND)\n\t);\n\t/* KVM emulates x2apic in software irrespective of host support. */\n\tkvm_cpu_cap_set(X86_FEATURE_X2APIC);\n\n\tkvm_cpu_cap_mask(CPUID_1_EDX,\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SEP) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* PSN */ | F(CLFLUSH) |\n\t\t0 /* Reserved, DS, ACPI */ | F(MMX) |\n\t\tF(FXSR) | F(XMM) | F(XMM2) | F(SELFSNOOP) |\n\t\t0 /* HTT, TM, Reserved, PBE */\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_7_0_EBX,\n\t\tF(FSGSBASE) | F(BMI1) | F(HLE) | F(AVX2) | F(SMEP) |\n\t\tF(BMI2) | F(ERMS) | 0 /*INVPCID*/ | F(RTM) | 0 /*MPX*/ | F(RDSEED) |\n\t\tF(ADX) | F(SMAP) | F(AVX512IFMA) | F(AVX512F) | F(AVX512PF) |\n\t\tF(AVX512ER) | F(AVX512CD) | F(CLFLUSHOPT) | F(CLWB) | F(AVX512DQ) |\n\t\tF(SHA_NI) | F(AVX512BW) | F(AVX512VL) | 0 /*INTEL_PT*/\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_7_ECX,\n\t\tF(AVX512VBMI) | F(LA57) | 0 /*PKU*/ | 0 /*OSPKE*/ | F(RDPID) |\n\t\tF(AVX512_VPOPCNTDQ) | F(UMIP) | F(AVX512_VBMI2) | F(GFNI) |\n\t\tF(VAES) | F(VPCLMULQDQ) | F(AVX512_VNNI) | F(AVX512_BITALG) |\n\t\tF(CLDEMOTE) | F(MOVDIRI) | F(MOVDIR64B) | 0 /*WAITPKG*/\n\t);\n\t/* Set LA57 based on hardware capability. */\n\tif (cpuid_ecx(7) & F(LA57))\n\t\tkvm_cpu_cap_set(X86_FEATURE_LA57);\n\n\tkvm_cpu_cap_mask(CPUID_7_EDX,\n\t\tF(AVX512_4VNNIW) | F(AVX512_4FMAPS) | F(SPEC_CTRL) |\n\t\tF(SPEC_CTRL_SSBD) | F(ARCH_CAPABILITIES) | F(INTEL_STIBP) |\n\t\tF(MD_CLEAR) | F(AVX512_VP2INTERSECT) | F(FSRM)\n\t);\n\n\t/* TSC_ADJUST and ARCH_CAPABILITIES are emulated in software. */\n\tkvm_cpu_cap_set(X86_FEATURE_TSC_ADJUST);\n\tkvm_cpu_cap_set(X86_FEATURE_ARCH_CAPABILITIES);\n\n\tif (boot_cpu_has(X86_FEATURE_IBPB) && boot_cpu_has(X86_FEATURE_IBRS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_SPEC_CTRL);\n\tif (boot_cpu_has(X86_FEATURE_STIBP))\n\t\tkvm_cpu_cap_set(X86_FEATURE_INTEL_STIBP);\n\tif (boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_SPEC_CTRL_SSBD);\n\n\tkvm_cpu_cap_mask(CPUID_7_1_EAX,\n\t\tF(AVX512_BF16)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_D_1_EAX,\n\t\tF(XSAVEOPT) | F(XSAVEC) | F(XGETBV1) | F(XSAVES)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0001_ECX,\n\t\tF(LAHF_LM) | F(CMP_LEGACY) | 0 /*SVM*/ | 0 /* ExtApicSpace */ |\n\t\tF(CR8_LEGACY) | F(ABM) | F(SSE4A) | F(MISALIGNSSE) |\n\t\tF(3DNOWPREFETCH) | F(OSVW) | 0 /* IBS */ | F(XOP) |\n\t\t0 /* SKINIT, WDT, LWP */ | F(FMA4) | F(TBM) |\n\t\tF(TOPOEXT) | F(PERFCTR_CORE)\n\t);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0001_EDX,\n\t\tF(FPU) | F(VME) | F(DE) | F(PSE) |\n\t\tF(TSC) | F(MSR) | F(PAE) | F(MCE) |\n\t\tF(CX8) | F(APIC) | 0 /* Reserved */ | F(SYSCALL) |\n\t\tF(MTRR) | F(PGE) | F(MCA) | F(CMOV) |\n\t\tF(PAT) | F(PSE36) | 0 /* Reserved */ |\n\t\tf_nx | 0 /* Reserved */ | F(MMXEXT) | F(MMX) |\n\t\tF(FXSR) | F(FXSR_OPT) | f_gbpages | F(RDTSCP) |\n\t\t0 /* Reserved */ | f_lm | F(3DNOWEXT) | F(3DNOW)\n\t);\n\n\tif (!tdp_enabled && IS_ENABLED(CONFIG_X86_64))\n\t\tkvm_cpu_cap_set(X86_FEATURE_GBPAGES);\n\n\tkvm_cpu_cap_mask(CPUID_8000_0008_EBX,\n\t\tF(CLZERO) | F(XSAVEERPTR) |\n\t\tF(WBNOINVD) | F(AMD_IBPB) | F(AMD_IBRS) | F(AMD_SSBD) | F(VIRT_SSBD) |\n\t\tF(AMD_SSB_NO) | F(AMD_STIBP) | F(AMD_STIBP_ALWAYS_ON)\n\t);\n\n\t/*\n\t * AMD has separate bits for each SPEC_CTRL bit.\n\t * arch/x86/kernel/cpu/bugs.c is kind enough to\n\t * record that in cpufeatures so use them.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_IBPB))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_IBPB);\n\tif (boot_cpu_has(X86_FEATURE_IBRS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_IBRS);\n\tif (boot_cpu_has(X86_FEATURE_STIBP))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_STIBP);\n\tif (boot_cpu_has(X86_FEATURE_SPEC_CTRL_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_SSBD);\n\tif (!boot_cpu_has_bug(X86_BUG_SPEC_STORE_BYPASS))\n\t\tkvm_cpu_cap_set(X86_FEATURE_AMD_SSB_NO);\n\t/*\n\t * The preference is to use SPEC CTRL MSR instead of the\n\t * VIRT_SPEC MSR.\n\t */\n\tif (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) &&\n\t    !boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);\n\n\t/*\n\t * Hide all SVM features by default, SVM will set the cap bits for\n\t * features it emulates and/or exposes for L1.\n\t */\n\tkvm_cpu_cap_mask(CPUID_8000_000A_EDX, 0);\n\n\tkvm_cpu_cap_mask(CPUID_C000_0001_EDX,\n\t\tF(XSTORE) | F(XSTORE_EN) | F(XCRYPT) | F(XCRYPT_EN) |\n\t\tF(ACE2) | F(ACE2_EN) | F(PHE) | F(PHE_EN) |\n\t\tF(PMM) | F(PMM_EN)\n\t);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic int nrips = true;\n\nstatic __init void svm_set_cpu_caps(void)\n{\n\tkvm_set_cpu_caps();\n\n\tsupported_xss = 0;\n\n\t/* CPUID 0x80000001 and 0x8000000A (SVM features) */\n\tif (nested) {\n\t\tkvm_cpu_cap_set(X86_FEATURE_SVM);\n\n\t\tif (nrips)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NRIPS);\n\n\t\tif (npt_enabled)\n\t\t\tkvm_cpu_cap_set(X86_FEATURE_NPT);\n\t}\n\n\t/* CPUID 0x80000008 */\n\tif (boot_cpu_has(X86_FEATURE_LS_CFG_SSBD) ||\n\t    boot_cpu_has(X86_FEATURE_AMD_SSBD))\n\t\tkvm_cpu_cap_set(X86_FEATURE_VIRT_SSBD);\n}"
  },
  {
    "function_name": "svm_hardware_teardown",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "1024-1040",
    "snippet": "static void svm_hardware_teardown(void)\n{\n\tint cpu;\n\n\tif (svm_sev_enabled()) {\n\t\tbitmap_free(sev_asid_bitmap);\n\t\tbitmap_free(sev_reclaim_asid_bitmap);\n\n\t\tsev_flush_asids();\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\tsvm_cpu_uninit(cpu);\n\n\t__free_pages(pfn_to_page(iopm_base >> PAGE_SHIFT), IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define IOPM_ALLOC_ORDER 2"
    ],
    "globals_used": [
      "static int sev_flush_asids(void);",
      "static unsigned long *sev_asid_bitmap;",
      "static unsigned long *sev_reclaim_asid_bitmap;",
      "static unsigned long iopm_base;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__free_pages",
          "args": [
            "pfn_to_page(iopm_base >> PAGE_SHIFT)",
            "IOPM_ALLOC_ORDER"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pfn_to_page",
          "args": [
            "iopm_base >> PAGE_SHIFT"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_flush_asids",
          "args": [],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "sev_flush_asids",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "5250-5269",
          "snippet": "static int sev_flush_asids(void)\n{\n\tint ret, error;\n\n\t/*\n\t * DEACTIVATE will clear the WBINVD indicator causing DF_FLUSH to fail,\n\t * so it must be guarded.\n\t */\n\tdown_write(&sev_deactivate_lock);\n\n\twbinvd_on_all_cpus();\n\tret = sev_guest_df_flush(&error);\n\n\tup_write(&sev_deactivate_lock);\n\n\tif (ret)\n\t\tpr_err(\"SEV: DF_FLUSH failed, ret=%d, error=%#x\\n\", ret, error);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int sev_flush_asids(void);",
            "static DECLARE_RWSEM(sev_deactivate_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev_flush_asids(void);\nstatic DECLARE_RWSEM(sev_deactivate_lock);\n\nstatic int sev_flush_asids(void)\n{\n\tint ret, error;\n\n\t/*\n\t * DEACTIVATE will clear the WBINVD indicator causing DF_FLUSH to fail,\n\t * so it must be guarded.\n\t */\n\tdown_write(&sev_deactivate_lock);\n\n\twbinvd_on_all_cpus();\n\tret = sev_guest_df_flush(&error);\n\n\tup_write(&sev_deactivate_lock);\n\n\tif (ret)\n\t\tpr_err(\"SEV: DF_FLUSH failed, ret=%d, error=%#x\\n\", ret, error);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "sev_reclaim_asid_bitmap"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_free",
          "args": [
            "sev_asid_bitmap"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_sev_enabled",
          "args": [],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "svm_sev_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "290-293",
          "snippet": "static inline bool svm_sev_enabled(void)\n{\n\treturn IS_ENABLED(CONFIG_KVM_AMD_SEV) ? max_sev_asid : 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int max_sev_asid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned int max_sev_asid;\n\nstatic inline bool svm_sev_enabled(void)\n{\n\treturn IS_ENABLED(CONFIG_KVM_AMD_SEV) ? max_sev_asid : 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define IOPM_ALLOC_ORDER 2\n\nstatic int sev_flush_asids(void);\nstatic unsigned long *sev_asid_bitmap;\nstatic unsigned long *sev_reclaim_asid_bitmap;\nstatic unsigned long iopm_base;\n\nstatic void svm_hardware_teardown(void)\n{\n\tint cpu;\n\n\tif (svm_sev_enabled()) {\n\t\tbitmap_free(sev_asid_bitmap);\n\t\tbitmap_free(sev_reclaim_asid_bitmap);\n\n\t\tsev_flush_asids();\n\t}\n\n\tfor_each_possible_cpu(cpu)\n\t\tsvm_cpu_uninit(cpu);\n\n\t__free_pages(pfn_to_page(iopm_base >> PAGE_SHIFT), IOPM_ALLOC_ORDER);\n\tiopm_base = 0;\n}"
  },
  {
    "function_name": "svm_adjust_mmio_mask",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "989-1022",
    "snippet": "static __init void svm_adjust_mmio_mask(void)\n{\n\tunsigned int enc_bit, mask_bit;\n\tu64 msr, mask;\n\n\t/* If there is no memory encryption support, use existing mask */\n\tif (cpuid_eax(0x80000000) < 0x8000001f)\n\t\treturn;\n\n\t/* If memory encryption is not enabled, use existing mask */\n\trdmsrl(MSR_K8_SYSCFG, msr);\n\tif (!(msr & MSR_K8_SYSCFG_MEM_ENCRYPT))\n\t\treturn;\n\n\tenc_bit = cpuid_ebx(0x8000001f) & 0x3f;\n\tmask_bit = boot_cpu_data.x86_phys_bits;\n\n\t/* Increment the mask bit if it is the same as the encryption bit */\n\tif (enc_bit == mask_bit)\n\t\tmask_bit++;\n\n\t/*\n\t * If the mask bit location is below 52, then some bits above the\n\t * physical addressing limit will always be reserved, so use the\n\t * rsvd_bits() function to generate the mask. This mask, along with\n\t * the present bit, will be used to generate a page fault with\n\t * PFER.RSV = 1.\n\t *\n\t * If the mask bit location is 52 (or above), then clear the mask.\n\t */\n\tmask = (mask_bit < 52) ? rsvd_bits(mask_bit, 51) | PT_PRESENT_MASK : 0;\n\n\tkvm_mmu_set_mmio_spte_mask(mask, mask, PT_WRITABLE_MASK | PT_USER_MASK);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_mmu_set_mmio_spte_mask",
          "args": [
            "mask",
            "mask",
            "PT_WRITABLE_MASK | PT_USER_MASK"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_mmu_set_mmio_spte_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu/mmu.c",
          "lines": "334-341",
          "snippet": "void kvm_mmu_set_mmio_spte_mask(u64 mmio_mask, u64 mmio_value, u64 access_mask)\n{\n\tBUG_ON((u64)(unsigned)access_mask != access_mask);\n\tBUG_ON((mmio_mask & mmio_value) != mmio_value);\n\tshadow_mmio_value = mmio_value | SPTE_MMIO_MASK;\n\tshadow_mmio_mask = mmio_mask | SPTE_SPECIAL_MASK;\n\tshadow_mmio_access_mask = access_mask;\n}",
          "includes": [
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"paging_tmpl.h\"",
            "#include \"mmu_audit.c\"",
            "#include \"mmutrace.h\"",
            "#include <trace/events/kvm.h>",
            "#include \"trace.h\"",
            "#include <asm/kvm_page_track.h>",
            "#include <asm/vmx.h>",
            "#include <asm/io.h>",
            "#include <asm/e820/api.h>",
            "#include <asm/cmpxchg.h>",
            "#include <asm/memtype.h>",
            "#include <asm/page.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kern_levels.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/compiler.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/swap.h>",
            "#include <linux/export.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/kvm_host.h>",
            "#include \"cpuid.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\""
          ],
          "macros_used": [
            "#define SPTE_MMIO_MASK (3ULL << 52)",
            "#define SPTE_SPECIAL_MASK (3ULL << 52)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"paging_tmpl.h\"\n#include \"mmu_audit.c\"\n#include \"mmutrace.h\"\n#include <trace/events/kvm.h>\n#include \"trace.h\"\n#include <asm/kvm_page_track.h>\n#include <asm/vmx.h>\n#include <asm/io.h>\n#include <asm/e820/api.h>\n#include <asm/cmpxchg.h>\n#include <asm/memtype.h>\n#include <asm/page.h>\n#include <linux/kthread.h>\n#include <linux/kern_levels.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/compiler.h>\n#include <linux/hugetlb.h>\n#include <linux/swap.h>\n#include <linux/export.h>\n#include <linux/moduleparam.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/kvm_host.h>\n#include \"cpuid.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n\n#define SPTE_MMIO_MASK (3ULL << 52)\n#define SPTE_SPECIAL_MASK (3ULL << 52)\n\nvoid kvm_mmu_set_mmio_spte_mask(u64 mmio_mask, u64 mmio_value, u64 access_mask)\n{\n\tBUG_ON((u64)(unsigned)access_mask != access_mask);\n\tBUG_ON((mmio_mask & mmio_value) != mmio_value);\n\tshadow_mmio_value = mmio_value | SPTE_MMIO_MASK;\n\tshadow_mmio_mask = mmio_mask | SPTE_SPECIAL_MASK;\n\tshadow_mmio_access_mask = access_mask;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rsvd_bits",
          "args": [
            "mask_bit",
            "51"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "rsvd_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/mmu.h",
          "lines": "46-52",
          "snippet": "static inline u64 rsvd_bits(int s, int e)\n{\n\tif (e < s)\n\t\treturn 0;\n\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}",
          "includes": [
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_cache_regs.h\"\n#include <linux/kvm_host.h>\n\nstatic inline u64 rsvd_bits(int s, int e)\n{\n\tif (e < s)\n\t\treturn 0;\n\n\treturn ((1ULL << (e - s + 1)) - 1) << s;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuid_ebx",
          "args": [
            "0x8000001f"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_K8_SYSCFG",
            "msr"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_eax",
          "args": [
            "0x80000000"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic __init void svm_adjust_mmio_mask(void)\n{\n\tunsigned int enc_bit, mask_bit;\n\tu64 msr, mask;\n\n\t/* If there is no memory encryption support, use existing mask */\n\tif (cpuid_eax(0x80000000) < 0x8000001f)\n\t\treturn;\n\n\t/* If memory encryption is not enabled, use existing mask */\n\trdmsrl(MSR_K8_SYSCFG, msr);\n\tif (!(msr & MSR_K8_SYSCFG_MEM_ENCRYPT))\n\t\treturn;\n\n\tenc_bit = cpuid_ebx(0x8000001f) & 0x3f;\n\tmask_bit = boot_cpu_data.x86_phys_bits;\n\n\t/* Increment the mask bit if it is the same as the encryption bit */\n\tif (enc_bit == mask_bit)\n\t\tmask_bit++;\n\n\t/*\n\t * If the mask bit location is below 52, then some bits above the\n\t * physical addressing limit will always be reserved, so use the\n\t * rsvd_bits() function to generate the mask. This mask, along with\n\t * the present bit, will be used to generate a page fault with\n\t * PFER.RSV = 1.\n\t *\n\t * If the mask bit location is 52 (or above), then clear the mask.\n\t */\n\tmask = (mask_bit < 52) ? rsvd_bits(mask_bit, 51) | PT_PRESENT_MASK : 0;\n\n\tkvm_mmu_set_mmio_spte_mask(mask, mask, PT_WRITABLE_MASK | PT_USER_MASK);\n}"
  },
  {
    "function_name": "shrink_ple_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "965-981",
    "snippet": "static void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tcontrol->pause_filter_count =\n\t\t\t\t__shrink_ple_window(old,\n\t\t\t\t\t\t    pause_filter_count,\n\t\t\t\t\t\t    pause_filter_count_shrink,\n\t\t\t\t\t\t    pause_filter_count);\n\tif (control->pause_filter_count != old) {\n\t\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;",
      "static unsigned short pause_filter_count_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_ple_window_update",
          "args": [
            "vcpu->vcpu_id",
            "control->pause_filter_count",
            "old"
          ],
          "line": 978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTERCEPTS"
          ],
          "line": 977
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__shrink_ple_window",
          "args": [
            "old",
            "pause_filter_count",
            "pause_filter_count_shrink",
            "pause_filter_count"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "__shrink_ple_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "34-46",
          "snippet": "static inline unsigned int __shrink_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int min)\n{\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tval /= modifier;\n\telse\n\t\tval -= modifier;\n\n\treturn max(val, min);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline unsigned int __shrink_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int min)\n{\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tval /= modifier;\n\telse\n\t\tval -= modifier;\n\n\treturn max(val, min);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nstatic unsigned short pause_filter_count_shrink = KVM_DEFAULT_PLE_WINDOW_SHRINK;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void shrink_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tcontrol->pause_filter_count =\n\t\t\t\t__shrink_ple_window(old,\n\t\t\t\t\t\t    pause_filter_count,\n\t\t\t\t\t\t    pause_filter_count_shrink,\n\t\t\t\t\t\t    pause_filter_count);\n\tif (control->pause_filter_count != old) {\n\t\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}"
  },
  {
    "function_name": "grow_ple_window",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "947-963",
    "snippet": "static void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tcontrol->pause_filter_count = __grow_ple_window(old,\n\t\t\t\t\t\t\tpause_filter_count,\n\t\t\t\t\t\t\tpause_filter_count_grow,\n\t\t\t\t\t\t\tpause_filter_count_max);\n\n\tif (control->pause_filter_count != old) {\n\t\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;",
      "static unsigned short pause_filter_count_grow = KVM_DEFAULT_PLE_WINDOW_GROW;",
      "static unsigned short pause_filter_count_max = KVM_SVM_DEFAULT_PLE_WINDOW_MAX;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_ple_window_update",
          "args": [
            "vcpu->vcpu_id",
            "control->pause_filter_count",
            "old"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_INTERCEPTS"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__grow_ple_window",
          "args": [
            "old",
            "pause_filter_count",
            "pause_filter_count_grow",
            "pause_filter_count_max"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "__grow_ple_window",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.h",
          "lines": "18-32",
          "snippet": "static inline unsigned int __grow_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int max)\n{\n\tu64 ret = val;\n\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tret *= modifier;\n\telse\n\t\tret += modifier;\n\n\treturn min(ret, (u64)max);\n}",
          "includes": [
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <asm/pvclock.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include <asm/pvclock.h>\n#include <linux/kvm_host.h>\n\nstatic inline unsigned int __grow_ple_window(unsigned int val,\n\t\tunsigned int base, unsigned int modifier, unsigned int max)\n{\n\tu64 ret = val;\n\n\tif (modifier < 1)\n\t\treturn base;\n\n\tif (modifier < base)\n\t\tret *= modifier;\n\telse\n\t\tret += modifier;\n\n\treturn min(ret, (u64)max);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 949
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned short pause_filter_count = KVM_SVM_DEFAULT_PLE_WINDOW;\nstatic unsigned short pause_filter_count_grow = KVM_DEFAULT_PLE_WINDOW_GROW;\nstatic unsigned short pause_filter_count_max = KVM_SVM_DEFAULT_PLE_WINDOW_MAX;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void grow_ple_window(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tstruct vmcb_control_area *control = &svm->vmcb->control;\n\tint old = control->pause_filter_count;\n\n\tcontrol->pause_filter_count = __grow_ple_window(old,\n\t\t\t\t\t\t\tpause_filter_count,\n\t\t\t\t\t\t\tpause_filter_count_grow,\n\t\t\t\t\t\t\tpause_filter_count_max);\n\n\tif (control->pause_filter_count != old) {\n\t\tmark_dirty(svm->vmcb, VMCB_INTERCEPTS);\n\t\ttrace_kvm_ple_window_update(vcpu->vcpu_id,\n\t\t\t\t\t    control->pause_filter_count, old);\n\t}\n}"
  },
  {
    "function_name": "sev_hardware_setup",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "902-945",
    "snippet": "static __init int sev_hardware_setup(void)\n{\n\tstruct sev_user_data_status *status;\n\tint rc;\n\n\t/* Maximum number of encrypted guests supported simultaneously */\n\tmax_sev_asid = cpuid_ecx(0x8000001F);\n\n\tif (!max_sev_asid)\n\t\treturn 1;\n\n\t/* Minimum ASID value that should be used for SEV guest */\n\tmin_sev_asid = cpuid_edx(0x8000001F);\n\n\t/* Initialize SEV ASID bitmaps */\n\tsev_asid_bitmap = bitmap_zalloc(max_sev_asid, GFP_KERNEL);\n\tif (!sev_asid_bitmap)\n\t\treturn 1;\n\n\tsev_reclaim_asid_bitmap = bitmap_zalloc(max_sev_asid, GFP_KERNEL);\n\tif (!sev_reclaim_asid_bitmap)\n\t\treturn 1;\n\n\tstatus = kmalloc(sizeof(*status), GFP_KERNEL);\n\tif (!status)\n\t\treturn 1;\n\n\t/*\n\t * Check SEV platform status.\n\t *\n\t * PLATFORM_STATUS can be called in any state, if we failed to query\n\t * the PLATFORM status then either PSP firmware does not support SEV\n\t * feature or SEV firmware is dead.\n\t */\n\trc = sev_platform_status(status, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\tpr_info(\"SEV supported\\n\");\n\nerr:\n\tkfree(status);\n\treturn rc;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int max_sev_asid;",
      "static unsigned int min_sev_asid;",
      "static unsigned long *sev_asid_bitmap;",
      "static unsigned long *sev_reclaim_asid_bitmap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "status"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"SEV supported\\n\""
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sev_platform_status",
          "args": [
            "status",
            "NULL"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*status)",
            "GFP_KERNEL"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zalloc",
          "args": [
            "max_sev_asid",
            "GFP_KERNEL"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zalloc",
          "args": [
            "max_sev_asid",
            "GFP_KERNEL"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_edx",
          "args": [
            "0x8000001F"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_ecx",
          "args": [
            "0x8000001F"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned int max_sev_asid;\nstatic unsigned int min_sev_asid;\nstatic unsigned long *sev_asid_bitmap;\nstatic unsigned long *sev_reclaim_asid_bitmap;\n\nstatic __init int sev_hardware_setup(void)\n{\n\tstruct sev_user_data_status *status;\n\tint rc;\n\n\t/* Maximum number of encrypted guests supported simultaneously */\n\tmax_sev_asid = cpuid_ecx(0x8000001F);\n\n\tif (!max_sev_asid)\n\t\treturn 1;\n\n\t/* Minimum ASID value that should be used for SEV guest */\n\tmin_sev_asid = cpuid_edx(0x8000001F);\n\n\t/* Initialize SEV ASID bitmaps */\n\tsev_asid_bitmap = bitmap_zalloc(max_sev_asid, GFP_KERNEL);\n\tif (!sev_asid_bitmap)\n\t\treturn 1;\n\n\tsev_reclaim_asid_bitmap = bitmap_zalloc(max_sev_asid, GFP_KERNEL);\n\tif (!sev_reclaim_asid_bitmap)\n\t\treturn 1;\n\n\tstatus = kmalloc(sizeof(*status), GFP_KERNEL);\n\tif (!status)\n\t\treturn 1;\n\n\t/*\n\t * Check SEV platform status.\n\t *\n\t * PLATFORM_STATUS can be called in any state, if we failed to query\n\t * the PLATFORM status then either PSP firmware does not support SEV\n\t * feature or SEV firmware is dead.\n\t */\n\trc = sev_platform_status(status, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\tpr_info(\"SEV supported\\n\");\n\nerr:\n\tkfree(status);\n\treturn rc;\n}"
  },
  {
    "function_name": "avic_ga_log_notifier",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "871-900",
    "snippet": "static int avic_ga_log_notifier(u32 ga_tag)\n{\n\tunsigned long flags;\n\tstruct kvm_svm *kvm_svm;\n\tstruct kvm_vcpu *vcpu = NULL;\n\tu32 vm_id = AVIC_GATAG_TO_VMID(ga_tag);\n\tu32 vcpu_id = AVIC_GATAG_TO_VCPUID(ga_tag);\n\n\tpr_debug(\"SVM: %s: vm_id=%#x, vcpu_id=%#x\\n\", __func__, vm_id, vcpu_id);\n\ttrace_kvm_avic_ga_log(vm_id, vcpu_id);\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n\thash_for_each_possible(svm_vm_data_hash, kvm_svm, hnode, vm_id) {\n\t\tif (kvm_svm->avic_vm_id != vm_id)\n\t\t\tcontinue;\n\t\tvcpu = kvm_get_vcpu_by_id(&kvm_svm->kvm, vcpu_id);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n\n\t/* Note:\n\t * At this point, the IOMMU should have already set the pending\n\t * bit in the vAPIC backing page. So, we just need to schedule\n\t * in the vcpu.\n\t */\n\tif (vcpu)\n\t\tkvm_vcpu_wake_up(vcpu);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);",
      "static DEFINE_SPINLOCK(svm_vm_data_hash_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_vcpu_wake_up",
          "args": [
            "vcpu"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&svm_vm_data_hash_lock",
            "flags"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_get_vcpu_by_id",
          "args": [
            "&kvm_svm->kvm",
            "vcpu_id"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_for_each_possible",
          "args": [
            "svm_vm_data_hash",
            "kvm_svm",
            "hnode",
            "vm_id"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&svm_vm_data_hash_lock",
            "flags"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_kvm_avic_ga_log",
          "args": [
            "vm_id",
            "vcpu_id"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"SVM: %s: vm_id=%#x, vcpu_id=%#x\\n\"",
            "__func__",
            "vm_id",
            "vcpu_id"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AVIC_GATAG_TO_VCPUID",
          "args": [
            "ga_tag"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AVIC_GATAG_TO_VMID",
          "args": [
            "ga_tag"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\nstatic DEFINE_SPINLOCK(svm_vm_data_hash_lock);\n\nstatic int avic_ga_log_notifier(u32 ga_tag)\n{\n\tunsigned long flags;\n\tstruct kvm_svm *kvm_svm;\n\tstruct kvm_vcpu *vcpu = NULL;\n\tu32 vm_id = AVIC_GATAG_TO_VMID(ga_tag);\n\tu32 vcpu_id = AVIC_GATAG_TO_VCPUID(ga_tag);\n\n\tpr_debug(\"SVM: %s: vm_id=%#x, vcpu_id=%#x\\n\", __func__, vm_id, vcpu_id);\n\ttrace_kvm_avic_ga_log(vm_id, vcpu_id);\n\n\tspin_lock_irqsave(&svm_vm_data_hash_lock, flags);\n\thash_for_each_possible(svm_vm_data_hash, kvm_svm, hnode, vm_id) {\n\t\tif (kvm_svm->avic_vm_id != vm_id)\n\t\t\tcontinue;\n\t\tvcpu = kvm_get_vcpu_by_id(&kvm_svm->kvm, vcpu_id);\n\t\tbreak;\n\t}\n\tspin_unlock_irqrestore(&svm_vm_data_hash_lock, flags);\n\n\t/* Note:\n\t * At this point, the IOMMU should have already set the pending\n\t * bit in the vAPIC backing page. So, we just need to schedule\n\t * in the vcpu.\n\t */\n\tif (vcpu)\n\t\tkvm_vcpu_wake_up(vcpu);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "disable_nmi_singlestep",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "843-854",
    "snippet": "void disable_nmi_singlestep(struct vcpu_svm *svm)\n{\n\tsvm->nmi_singlestep = false;\n\n\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP)) {\n\t\t/* Clear our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_RF;\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nvoid disable_nmi_singlestep(struct vcpu_svm *svm)\n{\n\tsvm->nmi_singlestep = false;\n\n\tif (!(svm->vcpu.guest_debug & KVM_GUESTDBG_SINGLESTEP)) {\n\t\t/* Clear our flags if they were not set by the guest */\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_TF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_TF;\n\t\tif (!(svm->nmi_singlestep_guest_rflags & X86_EFLAGS_RF))\n\t\t\tsvm->vmcb->save.rflags &= ~X86_EFLAGS_RF;\n\t}\n}"
  },
  {
    "function_name": "svm_disable_lbrv",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "832-841",
    "snippet": "static void svm_disable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.virt_ext &= ~LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_msr_interception",
          "args": [
            "msrpm",
            "MSR_IA32_LASTINTTOIP",
            "0",
            "0"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "set_msr_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "738-762",
          "snippet": "static void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_disable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.virt_ext &= ~LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 0, 0);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 0, 0);\n}"
  },
  {
    "function_name": "svm_enable_lbrv",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "821-830",
    "snippet": "static void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_msr_interception",
          "args": [
            "msrpm",
            "MSR_IA32_LASTINTTOIP",
            "1",
            "1"
          ],
          "line": 829
        },
        "resolved": true,
        "details": {
          "function_name": "set_msr_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "738-762",
          "snippet": "static void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic void svm_enable_lbrv(struct vcpu_svm *svm)\n{\n\tu32 *msrpm = svm->msrpm;\n\n\tsvm->vmcb->control.virt_ext |= LBR_CTL_ENABLE_MASK;\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTBRANCHTOIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTFROMIP, 1, 1);\n\tset_msr_interception(msrpm, MSR_IA32_LASTINTTOIP, 1, 1);\n}"
  },
  {
    "function_name": "init_msrpm_offsets",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "805-819",
    "snippet": "static void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32 msrpm_offsets[MSRPM_OFFSETS]",
      "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_msr_offset",
          "args": [
            "offset"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "add_msr_offset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "778-803",
          "snippet": "static void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "u32 msrpm_offsets[MSRPM_OFFSETS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nu32 msrpm_offsets[MSRPM_OFFSETS];\n\nstatic void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset == MSR_INVALID"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_msrpm_offset",
          "args": [
            "direct_access_msrs[i].index"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "svm_msrpm_offset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "365-384",
          "snippet": "u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)",
            "#define MSRS_RANGE_SIZE 2048",
            "#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)"
          ],
          "globals_used": [
            "static const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n#define MSRS_RANGE_SIZE 2048\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\nu32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "msrpm_offsets",
            "0xff",
            "sizeof(msrpm_offsets)"
          ],
          "line": 809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nu32 msrpm_offsets[MSRPM_OFFSETS];\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void init_msrpm_offsets(void)\n{\n\tint i;\n\n\tmemset(msrpm_offsets, 0xff, sizeof(msrpm_offsets));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tu32 offset;\n\n\t\toffset = svm_msrpm_offset(direct_access_msrs[i].index);\n\t\tBUG_ON(offset == MSR_INVALID);\n\n\t\tadd_msr_offset(offset);\n\t}\n}"
  },
  {
    "function_name": "add_msr_offset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "778-803",
    "snippet": "static void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "u32 msrpm_offsets[MSRPM_OFFSETS]"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nu32 msrpm_offsets[MSRPM_OFFSETS];\n\nstatic void add_msr_offset(u32 offset)\n{\n\tint i;\n\n\tfor (i = 0; i < MSRPM_OFFSETS; ++i) {\n\n\t\t/* Offset already in list? */\n\t\tif (msrpm_offsets[i] == offset)\n\t\t\treturn;\n\n\t\t/* Slot used by another offset? */\n\t\tif (msrpm_offsets[i] != MSR_INVALID)\n\t\t\tcontinue;\n\n\t\t/* Add offset to list */\n\t\tmsrpm_offsets[i] = offset;\n\n\t\treturn;\n\t}\n\n\t/*\n\t * If this BUG triggers the msrpm_offsets table has an overflow. Just\n\t * increase MSRPM_OFFSETS in this case.\n\t */\n\tBUG();\n}"
  },
  {
    "function_name": "svm_vcpu_init_msrpm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "764-776",
    "snippet": "static void svm_vcpu_init_msrpm(u32 *msrpm)\n{\n\tint i;\n\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\n\t\tset_msr_interception(msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSRPM_ALLOC_ORDER 1"
    ],
    "globals_used": [
      "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_msr_interception",
          "args": [
            "msrpm",
            "direct_access_msrs[i].index",
            "1",
            "1"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "set_msr_interception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "738-762",
          "snippet": "static void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "msrpm",
            "0xff",
            "PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER)"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRPM_ALLOC_ORDER 1\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void svm_vcpu_init_msrpm(u32 *msrpm)\n{\n\tint i;\n\n\tmemset(msrpm, 0xff, PAGE_SIZE * (1 << MSRPM_ALLOC_ORDER));\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++) {\n\t\tif (!direct_access_msrs[i].always)\n\t\t\tcontinue;\n\n\t\tset_msr_interception(msrpm, direct_access_msrs[i].index, 1, 1);\n\t}\n}"
  },
  {
    "function_name": "set_msr_interception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "738-762",
    "snippet": "static void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "bit_write",
            "&tmp"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_set_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "224-232",
          "snippet": "static __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_set_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_set_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) | mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) | mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "bit_write",
            "&tmp"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_clear_bits",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "214-222",
          "snippet": "static __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline void vmcs_clear_bits(unsigned long field, u32 mask)\n{\n\tBUILD_BUG_ON_MSG(__builtin_constant_p(field) && ((field) & 0x6000) == 0x2000,\n\t\t\t \"vmcs_clear_bits does not support 64-bit fields\");\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_write32(field, evmcs_read32(field) & ~mask);\n\n\t__vmcs_writel(field, __vmcs_readl(field) & ~mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset == MSR_INVALID"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_msrpm_offset",
          "args": [
            "msr"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "svm_msrpm_offset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "365-384",
          "snippet": "u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)",
            "#define MSRS_RANGE_SIZE 2048",
            "#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)"
          ],
          "globals_used": [
            "static const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n#define MSRS_RANGE_SIZE 2048\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\nu32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!valid_msr_intercept(msr)"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_msr_intercept",
          "args": [
            "msr"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "valid_msr_intercept",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "708-717",
          "snippet": "static bool valid_msr_intercept(u32 index)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == index)\n\t\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic bool valid_msr_intercept(u32 index)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == index)\n\t\t\treturn true;\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic void set_msr_interception(u32 *msrpm, unsigned msr,\n\t\t\t\t int read, int write)\n{\n\tu8 bit_read, bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\n\t/*\n\t * If this warning triggers extend the direct_access_msrs list at the\n\t * beginning of the file\n\t */\n\tWARN_ON(!valid_msr_intercept(msr));\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_read  = 2 * (msr & 0x0f);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\tread  ? clear_bit(bit_read,  &tmp) : set_bit(bit_read,  &tmp);\n\twrite ? clear_bit(bit_write, &tmp) : set_bit(bit_write, &tmp);\n\n\tmsrpm[offset] = tmp;\n}"
  },
  {
    "function_name": "msr_write_intercepted",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "719-736",
    "snippet": "static bool msr_write_intercepted(struct kvm_vcpu *vcpu, unsigned msr)\n{\n\tu8 bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\tu32 *msrpm;\n\n\tmsrpm = is_guest_mode(vcpu) ? to_svm(vcpu)->nested.msrpm:\n\t\t\t\t      to_svm(vcpu)->msrpm;\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\treturn !!test_bit(bit_write,  &tmp);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "bit_write",
            "&tmp"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "offset == MSR_INVALID"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_msrpm_offset",
          "args": [
            "msr"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "svm_msrpm_offset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "365-384",
          "snippet": "u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)",
            "#define MSRS_RANGE_SIZE 2048",
            "#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)"
          ],
          "globals_used": [
            "static const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n#define MSRS_RANGE_SIZE 2048\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\nu32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 726
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic bool msr_write_intercepted(struct kvm_vcpu *vcpu, unsigned msr)\n{\n\tu8 bit_write;\n\tunsigned long tmp;\n\tu32 offset;\n\tu32 *msrpm;\n\n\tmsrpm = is_guest_mode(vcpu) ? to_svm(vcpu)->nested.msrpm:\n\t\t\t\t      to_svm(vcpu)->msrpm;\n\n\toffset    = svm_msrpm_offset(msr);\n\tbit_write = 2 * (msr & 0x0f) + 1;\n\ttmp       = msrpm[offset];\n\n\tBUG_ON(offset == MSR_INVALID);\n\n\treturn !!test_bit(bit_write,  &tmp);\n}"
  },
  {
    "function_name": "valid_msr_intercept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "708-717",
    "snippet": "static bool valid_msr_intercept(u32 index)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == index)\n\t\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic const struct svm_direct_access_msrs {\n\tu32 index;   /* Index of the MSR */\n\tbool always; /* True if intercept is always on */\n} direct_access_msrs[] = {\n\t{ .index = MSR_STAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_IA32_SYSENTER_CS,\t\t.always = true  },\n#ifdef CONFIG_X86_64\n\t{ .index = MSR_GS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_FS_BASE,\t\t\t\t.always = true  },\n\t{ .index = MSR_KERNEL_GS_BASE,\t\t\t.always = true  },\n\t{ .index = MSR_LSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_CSTAR,\t\t\t\t.always = true  },\n\t{ .index = MSR_SYSCALL_MASK,\t\t\t.always = true  },\n#endif\n\t{ .index = MSR_IA32_SPEC_CTRL,\t\t\t.always = false },\n\t{ .index = MSR_IA32_PRED_CMD,\t\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTBRANCHTOIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTFROMIP,\t\t.always = false },\n\t{ .index = MSR_IA32_LASTINTTOIP,\t\t.always = false },\n\t{ .index = MSR_INVALID,\t\t\t\t.always = false },\n};\n\nstatic bool valid_msr_intercept(u32 index)\n{\n\tint i;\n\n\tfor (i = 0; direct_access_msrs[i].index != MSR_INVALID; i++)\n\t\tif (direct_access_msrs[i].index == index)\n\t\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "svm_cpu_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "676-706",
    "snippet": "static int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto free_cpu_data;\n\n\tif (svm_sev_enabled()) {\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto free_save_area;\n\t}\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nfree_save_area:\n\t__free_page(sd->save_area);\nfree_cpu_data:\n\tkfree(sd);\n\treturn -ENOMEM;\n\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int max_sev_asid;",
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sd"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "sd->save_area"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "cpu"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "max_sev_asid + 1",
            "sizeof(void *)",
            "GFP_KERNEL"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_sev_enabled",
          "args": [],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "svm_sev_enabled",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "290-293",
          "snippet": "static inline bool svm_sev_enabled(void)\n{\n\treturn IS_ENABLED(CONFIG_KVM_AMD_SEV) ? max_sev_asid : 0;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int max_sev_asid;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned int max_sev_asid;\n\nstatic inline bool svm_sev_enabled(void)\n{\n\treturn IS_ENABLED(CONFIG_KVM_AMD_SEV) ? max_sev_asid : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct svm_cpu_data)",
            "GFP_KERNEL"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned int max_sev_asid;\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic int svm_cpu_init(int cpu)\n{\n\tstruct svm_cpu_data *sd;\n\n\tsd = kzalloc(sizeof(struct svm_cpu_data), GFP_KERNEL);\n\tif (!sd)\n\t\treturn -ENOMEM;\n\tsd->cpu = cpu;\n\tsd->save_area = alloc_page(GFP_KERNEL);\n\tif (!sd->save_area)\n\t\tgoto free_cpu_data;\n\n\tif (svm_sev_enabled()) {\n\t\tsd->sev_vmcbs = kmalloc_array(max_sev_asid + 1,\n\t\t\t\t\t      sizeof(void *),\n\t\t\t\t\t      GFP_KERNEL);\n\t\tif (!sd->sev_vmcbs)\n\t\t\tgoto free_save_area;\n\t}\n\n\tper_cpu(svm_data, cpu) = sd;\n\n\treturn 0;\n\nfree_save_area:\n\t__free_page(sd->save_area);\nfree_cpu_data:\n\tkfree(sd);\n\treturn -ENOMEM;\n\n}"
  },
  {
    "function_name": "svm_cpu_uninit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "663-674",
    "snippet": "static void svm_cpu_uninit(int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, raw_smp_processor_id());\n\n\tif (!sd)\n\t\treturn;\n\n\tper_cpu(svm_data, raw_smp_processor_id()) = NULL;\n\tkfree(sd->sev_vmcbs);\n\t__free_page(sd->save_area);\n\tkfree(sd);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sd"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__free_page",
          "args": [
            "sd->save_area"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sd->sev_vmcbs"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "raw_smp_processor_id()"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "raw_smp_processor_id()"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic void svm_cpu_uninit(int cpu)\n{\n\tstruct svm_cpu_data *sd = per_cpu(svm_data, raw_smp_processor_id());\n\n\tif (!sd)\n\t\treturn;\n\n\tper_cpu(svm_data, raw_smp_processor_id()) = NULL;\n\tkfree(sd->sev_vmcbs);\n\t__free_page(sd->save_area);\n\tkfree(sd);\n}"
  },
  {
    "function_name": "svm_hardware_enable",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "587-661",
    "snippet": "static int svm_hardware_enable(void)\n{\n\n\tstruct svm_cpu_data *sd;\n\tuint64_t efer;\n\tstruct desc_struct *gdt;\n\tint me = raw_smp_processor_id();\n\n\trdmsrl(MSR_EFER, efer);\n\tif (efer & EFER_SVME)\n\t\treturn -EBUSY;\n\n\tif (!has_svm()) {\n\t\tpr_err(\"%s: err EOPNOTSUPP on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\tsd = per_cpu(svm_data, me);\n\tif (!sd) {\n\t\tpr_err(\"%s: svm_data is NULL on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\n\tsd->asid_generation = 1;\n\tsd->max_asid = cpuid_ebx(SVM_CPUID_FUNC) - 1;\n\tsd->next_asid = sd->max_asid + 1;\n\tsd->min_asid = max_sev_asid + 1;\n\n\tgdt = get_current_gdt_rw();\n\tsd->tss_desc = (struct kvm_ldttss_desc *)(gdt + GDT_ENTRY_TSS);\n\n\twrmsrl(MSR_EFER, efer | EFER_SVME);\n\n\twrmsrl(MSR_VM_HSAVE_PA, page_to_pfn(sd->save_area) << PAGE_SHIFT);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\t\t__this_cpu_write(current_tsc_ratio, TSC_RATIO_DEFAULT);\n\t}\n\n\n\t/*\n\t * Get OSVW bits.\n\t *\n\t * Note that it is possible to have a system with mixed processor\n\t * revisions and therefore different OSVW bits. If bits are not the same\n\t * on different processors then choose the worst case (i.e. if erratum\n\t * is present on one processor and not on another then assume that the\n\t * erratum is present everywhere).\n\t */\n\tif (cpu_has(&boot_cpu_data, X86_FEATURE_OSVW)) {\n\t\tuint64_t len, status = 0;\n\t\tint err;\n\n\t\tlen = native_read_msr_safe(MSR_AMD64_OSVW_ID_LENGTH, &err);\n\t\tif (!err)\n\t\t\tstatus = native_read_msr_safe(MSR_AMD64_OSVW_STATUS,\n\t\t\t\t\t\t      &err);\n\n\t\tif (err)\n\t\t\tosvw_status = osvw_len = 0;\n\t\telse {\n\t\t\tif (len < osvw_len)\n\t\t\t\tosvw_len = len;\n\t\t\tosvw_status |= status;\n\t\t\tosvw_status &= (1ULL << osvw_len) - 1;\n\t\t}\n\t} else\n\t\tosvw_status = osvw_len = 0;\n\n\tsvm_init_erratum_383();\n\n\tamd_pmu_enable_virt();\n\n\treturn 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define TSC_RATIO_DEFAULT\t0x0100000000ULL"
    ],
    "globals_used": [
      "static uint64_t osvw_len = 4, osvw_status;",
      "static DEFINE_PER_CPU(u64, current_tsc_ratio);",
      "static unsigned int max_sev_asid;",
      "static DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "amd_pmu_enable_virt",
          "args": [],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "svm_init_erratum_383",
          "args": [],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "svm_init_erratum_383",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "519-541",
          "snippet": "static void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool erratum_383_found",
            "static int nested = true;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool erratum_383_found;\nstatic int nested = true;\n\nstatic void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "native_read_msr_safe",
          "args": [
            "MSR_AMD64_OSVW_STATUS",
            "&err"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_read_msr_safe",
          "args": [
            "MSR_AMD64_OSVW_ID_LENGTH",
            "&err"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has",
          "args": [
            "&boot_cpu_data",
            "X86_FEATURE_OSVW"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_write",
          "args": [
            "current_tsc_ratio",
            "TSC_RATIO_DEFAULT"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_AMD64_TSC_RATIO",
            "TSC_RATIO_DEFAULT"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_TSCRATEMSR"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_VM_HSAVE_PA",
            "page_to_pfn(sd->save_area) << PAGE_SHIFT"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_to_pfn",
          "args": [
            "sd->save_area"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_EFER",
            "efer | EFER_SVME"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_gdt_rw",
          "args": [],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuid_ebx",
          "args": [
            "SVM_CPUID_FUNC"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: svm_data is NULL on %d\\n\"",
            "__func__",
            "me"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "svm_data",
            "me"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: err EOPNOTSUPP on %d\\n\"",
            "__func__",
            "me"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_svm",
          "args": [],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "has_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "564-574",
          "snippet": "static int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rdmsrl",
          "args": [
            "MSR_EFER",
            "efer"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define TSC_RATIO_DEFAULT\t0x0100000000ULL\n\nstatic uint64_t osvw_len = 4, osvw_status;\nstatic DEFINE_PER_CPU(u64, current_tsc_ratio);\nstatic unsigned int max_sev_asid;\nstatic DEFINE_PER_CPU(struct svm_cpu_data *, svm_data);\n\nstatic int svm_hardware_enable(void)\n{\n\n\tstruct svm_cpu_data *sd;\n\tuint64_t efer;\n\tstruct desc_struct *gdt;\n\tint me = raw_smp_processor_id();\n\n\trdmsrl(MSR_EFER, efer);\n\tif (efer & EFER_SVME)\n\t\treturn -EBUSY;\n\n\tif (!has_svm()) {\n\t\tpr_err(\"%s: err EOPNOTSUPP on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\tsd = per_cpu(svm_data, me);\n\tif (!sd) {\n\t\tpr_err(\"%s: svm_data is NULL on %d\\n\", __func__, me);\n\t\treturn -EINVAL;\n\t}\n\n\tsd->asid_generation = 1;\n\tsd->max_asid = cpuid_ebx(SVM_CPUID_FUNC) - 1;\n\tsd->next_asid = sd->max_asid + 1;\n\tsd->min_asid = max_sev_asid + 1;\n\n\tgdt = get_current_gdt_rw();\n\tsd->tss_desc = (struct kvm_ldttss_desc *)(gdt + GDT_ENTRY_TSS);\n\n\twrmsrl(MSR_EFER, efer | EFER_SVME);\n\n\twrmsrl(MSR_VM_HSAVE_PA, page_to_pfn(sd->save_area) << PAGE_SHIFT);\n\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR)) {\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\t\t__this_cpu_write(current_tsc_ratio, TSC_RATIO_DEFAULT);\n\t}\n\n\n\t/*\n\t * Get OSVW bits.\n\t *\n\t * Note that it is possible to have a system with mixed processor\n\t * revisions and therefore different OSVW bits. If bits are not the same\n\t * on different processors then choose the worst case (i.e. if erratum\n\t * is present on one processor and not on another then assume that the\n\t * erratum is present everywhere).\n\t */\n\tif (cpu_has(&boot_cpu_data, X86_FEATURE_OSVW)) {\n\t\tuint64_t len, status = 0;\n\t\tint err;\n\n\t\tlen = native_read_msr_safe(MSR_AMD64_OSVW_ID_LENGTH, &err);\n\t\tif (!err)\n\t\t\tstatus = native_read_msr_safe(MSR_AMD64_OSVW_STATUS,\n\t\t\t\t\t\t      &err);\n\n\t\tif (err)\n\t\t\tosvw_status = osvw_len = 0;\n\t\telse {\n\t\t\tif (len < osvw_len)\n\t\t\t\tosvw_len = len;\n\t\t\tosvw_status |= status;\n\t\t\tosvw_status &= (1ULL << osvw_len) - 1;\n\t\t}\n\t} else\n\t\tosvw_status = osvw_len = 0;\n\n\tsvm_init_erratum_383();\n\n\tamd_pmu_enable_virt();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "svm_hardware_disable",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "576-585",
    "snippet": "static void svm_hardware_disable(void)\n{\n\t/* Make sure we clean up behind us */\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR))\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\n\tcpu_svm_disable();\n\n\tamd_pmu_disable_virt();\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define TSC_RATIO_DEFAULT\t0x0100000000ULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "amd_pmu_disable_virt",
          "args": [],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_svm_disable",
          "args": [],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrmsrl",
          "args": [
            "MSR_AMD64_TSC_RATIO",
            "TSC_RATIO_DEFAULT"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_TSCRATEMSR"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define TSC_RATIO_DEFAULT\t0x0100000000ULL\n\nstatic void svm_hardware_disable(void)\n{\n\t/* Make sure we clean up behind us */\n\tif (static_cpu_has(X86_FEATURE_TSCRATEMSR))\n\t\twrmsrl(MSR_AMD64_TSC_RATIO, TSC_RATIO_DEFAULT);\n\n\tcpu_svm_disable();\n\n\tamd_pmu_disable_virt();\n}"
  },
  {
    "function_name": "has_svm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "564-574",
    "snippet": "static int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"has_svm: %s\\n\"",
            "msg"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_has_svm",
          "args": [
            "&msg"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int has_svm(void)\n{\n\tconst char *msg;\n\n\tif (!cpu_has_svm(&msg)) {\n\t\tprintk(KERN_INFO \"has_svm: %s\\n\", msg);\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "svm_init_osvw",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "543-562",
    "snippet": "static void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static uint64_t osvw_len = 4, osvw_status;",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic uint64_t osvw_len = 4, osvw_status;\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_init_osvw(struct kvm_vcpu *vcpu)\n{\n\t/*\n\t * Guests should see errata 400 and 415 as fixed (assuming that\n\t * HLT and IO instructions are intercepted).\n\t */\n\tvcpu->arch.osvw.length = (osvw_len >= 3) ? (osvw_len) : 3;\n\tvcpu->arch.osvw.status = osvw_status & ~(6ULL);\n\n\t/*\n\t * By increasing VCPU's osvw.length to 3 we are telling the guest that\n\t * all osvw.status bits inside that length, including bit 0 (which is\n\t * reserved for erratum 298), are valid. However, if host processor's\n\t * osvw_len is 0 then osvw_status[0] carries no information. We need to\n\t * be conservative here and therefore we tell the guest that erratum 298\n\t * is present (because we really don't know).\n\t */\n\tif (osvw_len == 0 && boot_cpu_data.x86 == 0x10)\n\t\tvcpu->arch.osvw.status |= 1;\n}"
  },
  {
    "function_name": "svm_init_erratum_383",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "519-541",
    "snippet": "static void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool erratum_383_found",
      "static int nested = true;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "native_write_msr_safe",
          "args": [
            "MSR_AMD64_DC_CFG",
            "low",
            "high"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "upper_32_bits",
          "args": [
            "val"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lower_32_bits",
          "args": [
            "val"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "native_read_msr_safe",
          "args": [
            "MSR_AMD64_DC_CFG",
            "&err"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has_bug",
          "args": [
            "X86_BUG_AMD_TLB_MMATCH"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic bool erratum_383_found;\nstatic int nested = true;\n\nstatic void svm_init_erratum_383(void)\n{\n\tu32 low, high;\n\tint err;\n\tu64 val;\n\n\tif (!static_cpu_has_bug(X86_BUG_AMD_TLB_MMATCH))\n\t\treturn;\n\n\t/* Use _safe variants to not break nested virtualization */\n\tval = native_read_msr_safe(MSR_AMD64_DC_CFG, &err);\n\tif (err)\n\t\treturn;\n\n\tval |= (1ULL << 47);\n\n\tlow  = lower_32_bits(val);\n\thigh = upper_32_bits(val);\n\n\tnative_write_msr_safe(MSR_AMD64_DC_CFG, low, high);\n\n\terratum_383_found = true;\n}"
  },
  {
    "function_name": "svm_queue_exception",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "478-517",
    "snippet": "static void svm_queue_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_error_code = vcpu->arch.exception.has_error_code;\n\tbool reinject = vcpu->arch.exception.injected;\n\tu32 error_code = vcpu->arch.exception.error_code;\n\n\t/*\n\t * If we are within a nested VM we'd better #VMEXIT and let the guest\n\t * handle the exception\n\t */\n\tif (!reinject &&\n\t    nested_svm_check_exception(svm, nr, has_error_code, error_code))\n\t\treturn;\n\n\tkvm_deliver_exception_payload(&svm->vcpu);\n\n\tif (nr == BP_VECTOR && !nrips) {\n\t\tunsigned long rip, old_rip = kvm_rip_read(&svm->vcpu);\n\n\t\t/*\n\t\t * For guest debugging where we have to reinject #BP if some\n\t\t * INT3 is guest-owned:\n\t\t * Emulate nRIP by moving RIP forward. Will fail if injection\n\t\t * raises a fault that is not intercepted. Still better than\n\t\t * failing in all cases.\n\t\t */\n\t\t(void)skip_emulated_instruction(&svm->vcpu);\n\t\trip = kvm_rip_read(&svm->vcpu);\n\t\tsvm->int3_rip = rip + svm->vmcb->save.cs.base;\n\t\tsvm->int3_injected = rip - old_rip;\n\t}\n\n\tsvm->vmcb->control.event_inj = nr\n\t\t| SVM_EVTINJ_VALID\n\t\t| (has_error_code ? SVM_EVTINJ_VALID_ERR : 0)\n\t\t| SVM_EVTINJ_TYPE_EXEPT;\n\tsvm->vmcb->control.event_inj_err = error_code;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int nested = true;",
      "static int nrips = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "&svm->vcpu"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "86-89",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skip_emulated_instruction",
          "args": [
            "&svm->vcpu"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "skip_emulated_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "455-476",
          "snippet": "static int skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (nrips && svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t} else {\n\t\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\t\tpr_err(\"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\t\tkvm_rip_write(vcpu, svm->next_rip);\n\t}\n\tsvm_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define MAX_INST_SIZE 15"
          ],
          "globals_used": [
            "static int nrips = true;",
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic int nrips = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (nrips && svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t} else {\n\t\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\t\tpr_err(\"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\t\tkvm_rip_write(vcpu, svm->next_rip);\n\t}\n\tsvm_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_deliver_exception_payload",
          "args": [
            "&svm->vcpu"
          ],
          "line": 494
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_deliver_exception_payload",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "437-484",
          "snippet": "void kvm_deliver_exception_payload(struct kvm_vcpu *vcpu)\n{\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_payload = vcpu->arch.exception.has_payload;\n\tunsigned long payload = vcpu->arch.exception.payload;\n\n\tif (!has_payload)\n\t\treturn;\n\n\tswitch (nr) {\n\tcase DB_VECTOR:\n\t\t/*\n\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t * remaining contents of the DR6 register are never\n\t\t * cleared by the processor\".\n\t\t */\n\t\tvcpu->arch.dr6 &= ~DR_TRAP_BITS;\n\t\t/*\n\t\t * DR6.RTM is set by all #DB exceptions that don't clear it.\n\t\t */\n\t\tvcpu->arch.dr6 |= DR6_RTM;\n\t\tvcpu->arch.dr6 |= payload;\n\t\t/*\n\t\t * Bit 16 should be set in the payload whenever the #DB\n\t\t * exception should clear DR6.RTM. This makes the payload\n\t\t * compatible with the pending debug exceptions under VMX.\n\t\t * Though not currently documented in the SDM, this also\n\t\t * makes the payload compatible with the exit qualification\n\t\t * for #DB exceptions under VMX.\n\t\t */\n\t\tvcpu->arch.dr6 ^= payload & DR6_RTM;\n\n\t\t/*\n\t\t * The #DB payload is defined as compatible with the 'pending\n\t\t * debug exceptions' field under VMX, not DR6. While bit 12 is\n\t\t * defined in the 'pending debug exceptions' field (enabled\n\t\t * breakpoint), it is reserved and must be zero in DR6.\n\t\t */\n\t\tvcpu->arch.dr6 &= ~BIT(12);\n\t\tbreak;\n\tcase PF_VECTOR:\n\t\tvcpu->arch.cr2 = payload;\n\t\tbreak;\n\t}\n\n\tvcpu->arch.exception.has_payload = false;\n\tvcpu->arch.exception.payload = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nvoid kvm_deliver_exception_payload(struct kvm_vcpu *vcpu)\n{\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_payload = vcpu->arch.exception.has_payload;\n\tunsigned long payload = vcpu->arch.exception.payload;\n\n\tif (!has_payload)\n\t\treturn;\n\n\tswitch (nr) {\n\tcase DB_VECTOR:\n\t\t/*\n\t\t * \"Certain debug exceptions may clear bit 0-3.  The\n\t\t * remaining contents of the DR6 register are never\n\t\t * cleared by the processor\".\n\t\t */\n\t\tvcpu->arch.dr6 &= ~DR_TRAP_BITS;\n\t\t/*\n\t\t * DR6.RTM is set by all #DB exceptions that don't clear it.\n\t\t */\n\t\tvcpu->arch.dr6 |= DR6_RTM;\n\t\tvcpu->arch.dr6 |= payload;\n\t\t/*\n\t\t * Bit 16 should be set in the payload whenever the #DB\n\t\t * exception should clear DR6.RTM. This makes the payload\n\t\t * compatible with the pending debug exceptions under VMX.\n\t\t * Though not currently documented in the SDM, this also\n\t\t * makes the payload compatible with the exit qualification\n\t\t * for #DB exceptions under VMX.\n\t\t */\n\t\tvcpu->arch.dr6 ^= payload & DR6_RTM;\n\n\t\t/*\n\t\t * The #DB payload is defined as compatible with the 'pending\n\t\t * debug exceptions' field under VMX, not DR6. While bit 12 is\n\t\t * defined in the 'pending debug exceptions' field (enabled\n\t\t * breakpoint), it is reserved and must be zero in DR6.\n\t\t */\n\t\tvcpu->arch.dr6 &= ~BIT(12);\n\t\tbreak;\n\tcase PF_VECTOR:\n\t\tvcpu->arch.cr2 = payload;\n\t\tbreak;\n\t}\n\n\tvcpu->arch.exception.has_payload = false;\n\tvcpu->arch.exception.payload = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_svm_check_exception",
          "args": [
            "svm",
            "nr",
            "has_error_code",
            "error_code"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "nested_svm_check_exception",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/nested.c",
          "lines": "736-765",
          "snippet": "int nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t       bool has_error_code, u32 error_code)\n{\n\tint vmexit;\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn 0;\n\n\tvmexit = nested_svm_intercept(svm);\n\tif (vmexit != NESTED_EXIT_DONE)\n\t\treturn 0;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_EXCP_BASE + nr;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1 = error_code;\n\n\t/*\n\t * EXITINFO2 is undefined for all exception intercepts other\n\t * than #PF.\n\t */\n\tif (svm->vcpu.arch.exception.nested_apf)\n\t\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.apf.nested_apf_token;\n\telse if (svm->vcpu.arch.exception.has_payload)\n\t\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.exception.payload;\n\telse\n\t\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.cr2;\n\n\tsvm->nested.exit_required = true;\n\treturn vmexit;\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"x86.h\"",
            "#include \"mmu.h\"",
            "#include \"trace.h\"",
            "#include \"kvm_emulate.h\"",
            "#include <asm/msr-index.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"x86.h\"\n#include \"mmu.h\"\n#include \"trace.h\"\n#include \"kvm_emulate.h\"\n#include <asm/msr-index.h>\n#include <linux/kernel.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nint nested_svm_check_exception(struct vcpu_svm *svm, unsigned nr,\n\t\t\t       bool has_error_code, u32 error_code)\n{\n\tint vmexit;\n\n\tif (!is_guest_mode(&svm->vcpu))\n\t\treturn 0;\n\n\tvmexit = nested_svm_intercept(svm);\n\tif (vmexit != NESTED_EXIT_DONE)\n\t\treturn 0;\n\n\tsvm->vmcb->control.exit_code = SVM_EXIT_EXCP_BASE + nr;\n\tsvm->vmcb->control.exit_code_hi = 0;\n\tsvm->vmcb->control.exit_info_1 = error_code;\n\n\t/*\n\t * EXITINFO2 is undefined for all exception intercepts other\n\t * than #PF.\n\t */\n\tif (svm->vcpu.arch.exception.nested_apf)\n\t\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.apf.nested_apf_token;\n\telse if (svm->vcpu.arch.exception.has_payload)\n\t\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.exception.payload;\n\telse\n\t\tsvm->vmcb->control.exit_info_2 = svm->vcpu.arch.cr2;\n\n\tsvm->nested.exit_required = true;\n\treturn vmexit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int nested = true;\nstatic int nrips = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_queue_exception(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tunsigned nr = vcpu->arch.exception.nr;\n\tbool has_error_code = vcpu->arch.exception.has_error_code;\n\tbool reinject = vcpu->arch.exception.injected;\n\tu32 error_code = vcpu->arch.exception.error_code;\n\n\t/*\n\t * If we are within a nested VM we'd better #VMEXIT and let the guest\n\t * handle the exception\n\t */\n\tif (!reinject &&\n\t    nested_svm_check_exception(svm, nr, has_error_code, error_code))\n\t\treturn;\n\n\tkvm_deliver_exception_payload(&svm->vcpu);\n\n\tif (nr == BP_VECTOR && !nrips) {\n\t\tunsigned long rip, old_rip = kvm_rip_read(&svm->vcpu);\n\n\t\t/*\n\t\t * For guest debugging where we have to reinject #BP if some\n\t\t * INT3 is guest-owned:\n\t\t * Emulate nRIP by moving RIP forward. Will fail if injection\n\t\t * raises a fault that is not intercepted. Still better than\n\t\t * failing in all cases.\n\t\t */\n\t\t(void)skip_emulated_instruction(&svm->vcpu);\n\t\trip = kvm_rip_read(&svm->vcpu);\n\t\tsvm->int3_rip = rip + svm->vmcb->save.cs.base;\n\t\tsvm->int3_injected = rip - old_rip;\n\t}\n\n\tsvm->vmcb->control.event_inj = nr\n\t\t| SVM_EVTINJ_VALID\n\t\t| (has_error_code ? SVM_EVTINJ_VALID_ERR : 0)\n\t\t| SVM_EVTINJ_TYPE_EXEPT;\n\tsvm->vmcb->control.event_inj_err = error_code;\n}"
  },
  {
    "function_name": "skip_emulated_instruction",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "455-476",
    "snippet": "static int skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (nrips && svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t} else {\n\t\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\t\tpr_err(\"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\t\tkvm_rip_write(vcpu, svm->next_rip);\n\t}\n\tsvm_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MAX_INST_SIZE 15"
    ],
    "globals_used": [
      "static int nrips = true;",
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "svm_set_interrupt_shadow",
          "args": [
            "vcpu",
            "0"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "svm_set_interrupt_shadow",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "444-453",
          "snippet": "static void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void svm_complete_interrupts(struct vcpu_svm *svm);",
            "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_rip_write",
          "args": [
            "vcpu",
            "svm->next_rip"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_write",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "91-94",
          "snippet": "static inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline void kvm_rip_write(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tkvm_register_write(vcpu, VCPU_REGS_RIP, val);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: ip 0x%lx next 0x%llx\\n\"",
            "__func__",
            "kvm_rip_read(vcpu)",
            "svm->next_rip"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_rip_read",
          "args": [
            "vcpu"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rip_read",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "86-89",
          "snippet": "static inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline unsigned long kvm_rip_read(struct kvm_vcpu *vcpu)\n{\n\treturn kvm_register_read(vcpu, VCPU_REGS_RIP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_emulate_instruction",
          "args": [
            "vcpu",
            "EMULTYPE_SKIP"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_emulate_instruction",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "6922-6925",
          "snippet": "int kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_cr8_intercept(struct kvm_vcpu *vcpu);",
            "static void process_nmi(struct kvm_vcpu *vcpu);",
            "static void enter_smm(struct kvm_vcpu *vcpu);",
            "static void store_regs(struct kvm_vcpu *vcpu);",
            "static int sync_regs(struct kvm_vcpu *vcpu);",
            "static void kvm_smm_changed(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_mmio(struct kvm_vcpu *vcpu);",
            "static int complete_emulated_pio(struct kvm_vcpu *vcpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void update_cr8_intercept(struct kvm_vcpu *vcpu);\nstatic void process_nmi(struct kvm_vcpu *vcpu);\nstatic void enter_smm(struct kvm_vcpu *vcpu);\nstatic void store_regs(struct kvm_vcpu *vcpu);\nstatic int sync_regs(struct kvm_vcpu *vcpu);\nstatic void kvm_smm_changed(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_mmio(struct kvm_vcpu *vcpu);\nstatic int complete_emulated_pio(struct kvm_vcpu *vcpu);\n\nint kvm_emulate_instruction(struct kvm_vcpu *vcpu, int emulation_type)\n{\n\treturn x86_emulate_instruction(vcpu, 0, emulation_type, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!static_cpu_has(X86_FEATURE_NRIPS)"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_cpu_has",
          "args": [
            "X86_FEATURE_NRIPS"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 457
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MAX_INST_SIZE 15\n\nstatic int nrips = true;\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int skip_emulated_instruction(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (nrips && svm->vmcb->control.next_rip != 0) {\n\t\tWARN_ON_ONCE(!static_cpu_has(X86_FEATURE_NRIPS));\n\t\tsvm->next_rip = svm->vmcb->control.next_rip;\n\t}\n\n\tif (!svm->next_rip) {\n\t\tif (!kvm_emulate_instruction(vcpu, EMULTYPE_SKIP))\n\t\t\treturn 0;\n\t} else {\n\t\tif (svm->next_rip - kvm_rip_read(vcpu) > MAX_INST_SIZE)\n\t\t\tpr_err(\"%s: ip 0x%lx next 0x%llx\\n\",\n\t\t\t       __func__, kvm_rip_read(vcpu), svm->next_rip);\n\t\tkvm_rip_write(vcpu, svm->next_rip);\n\t}\n\tsvm_set_interrupt_shadow(vcpu, 0);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "svm_set_interrupt_shadow",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "444-453",
    "snippet": "static void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic void svm_set_interrupt_shadow(struct kvm_vcpu *vcpu, int mask)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\n\tif (mask == 0)\n\t\tsvm->vmcb->control.int_state &= ~SVM_INTERRUPT_SHADOW_MASK;\n\telse\n\t\tsvm->vmcb->control.int_state |= SVM_INTERRUPT_SHADOW_MASK;\n\n}"
  },
  {
    "function_name": "svm_get_interrupt_shadow",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "434-442",
    "snippet": "static u32 svm_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ret = 0;\n\n\tif (svm->vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK)\n\t\tret = KVM_X86_SHADOW_INT_STI | KVM_X86_SHADOW_INT_MOV_SS;\n\treturn ret;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic u32 svm_get_interrupt_shadow(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu32 ret = 0;\n\n\tif (svm->vmcb->control.int_state & SVM_INTERRUPT_SHADOW_MASK)\n\t\tret = KVM_X86_SHADOW_INT_STI | KVM_X86_SHADOW_INT_MOV_SS;\n\treturn ret;\n}"
  },
  {
    "function_name": "is_external_interrupt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "428-432",
    "snippet": "static int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int is_external_interrupt(u32 info)\n{\n\tinfo &= SVM_EVTINJ_TYPE_MASK | SVM_EVTINJ_VALID;\n\treturn info == (SVM_EVTINJ_VALID | SVM_EVTINJ_TYPE_INTR);\n}"
  },
  {
    "function_name": "svm_set_efer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "412-426",
    "snippet": "void svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\n\tif (!npt_enabled) {\n\t\t/* Shadow paging assumes NX to be available.  */\n\t\tefer |= EFER_NX;\n\n\t\tif (!(efer & EFER_LMA))\n\t\t\tefer &= ~EFER_LME;\n\t}\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "to_svm(vcpu)->vmcb",
            "VMCB_CR"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nvoid svm_set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n\tvcpu->arch.efer = efer;\n\n\tif (!npt_enabled) {\n\t\t/* Shadow paging assumes NX to be available.  */\n\t\tefer |= EFER_NX;\n\n\t\tif (!(efer & EFER_LMA))\n\t\t\tefer &= ~EFER_LME;\n\t}\n\n\tto_svm(vcpu)->vmcb->save.efer = efer | EFER_SVME;\n\tmark_dirty(to_svm(vcpu)->vmcb, VMCB_CR);\n}"
  },
  {
    "function_name": "get_npt_level",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "403-410",
    "snippet": "static int get_npt_level(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn PT64_ROOT_4LEVEL;\n#else\n\treturn PT32E_ROOT_LEVEL;\n#endif\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic int get_npt_level(struct kvm_vcpu *vcpu)\n{\n#ifdef CONFIG_X86_64\n\treturn PT64_ROOT_4LEVEL;\n#else\n\treturn PT32E_ROOT_LEVEL;\n#endif\n}"
  },
  {
    "function_name": "invlpga",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "398-401",
    "snippet": "static inline void invlpga(unsigned long addr, u32 asid)\n{\n\tasm volatile (__ex(\"invlpga %1, %0\") : : \"c\"(asid), \"a\"(addr));\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "\"a\"",
          "args": [
            "addr"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "\"c\"",
          "args": [
            "asid"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void invlpga(unsigned long addr, u32 asid)\n{\n\tasm volatile (__ex(\"invlpga %1, %0\") : : \"c\"(asid), \"a\"(addr));\n}"
  },
  {
    "function_name": "stgi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "393-396",
    "snippet": "static inline void stgi(void)\n{\n\tasm volatile (__ex(\"stgi\"));\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void stgi(void)\n{\n\tasm volatile (__ex(\"stgi\"));\n}"
  },
  {
    "function_name": "clgi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "388-391",
    "snippet": "static inline void clgi(void)\n{\n\tasm volatile (__ex(\"clgi\"));\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline void clgi(void)\n{\n\tasm volatile (__ex(\"clgi\"));\n}"
  },
  {
    "function_name": "svm_msrpm_offset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "365-384",
    "snippet": "u32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)",
      "#define MSRS_RANGE_SIZE 2048",
      "#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)"
    ],
    "globals_used": [
      "static const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define MSRS_IN_RANGE (MSRS_RANGE_SIZE * 8 / 2)\n#define MSRS_RANGE_SIZE 2048\n#define NUM_MSR_MAPS ARRAY_SIZE(msrpm_ranges)\n\nstatic const u32 msrpm_ranges[] = {0, 0xc0000000, 0xc0010000};\n\nu32 svm_msrpm_offset(u32 msr)\n{\n\tu32 offset;\n\tint i;\n\n\tfor (i = 0; i < NUM_MSR_MAPS; i++) {\n\t\tif (msr < msrpm_ranges[i] ||\n\t\t    msr >= msrpm_ranges[i] + MSRS_IN_RANGE)\n\t\t\tcontinue;\n\n\t\toffset  = (msr - msrpm_ranges[i]) / 4; /* 4 msrs per u8 */\n\t\toffset += (i * MSRS_RANGE_SIZE);       /* add range offset */\n\n\t\t/* Now we have the u8 offset - but need the u32 offset */\n\t\treturn offset / 4;\n\t}\n\n\t/* MSR not in any range */\n\treturn MSR_INVALID;\n}"
  },
  {
    "function_name": "avic_vcpu_is_running",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "319-328",
    "snippet": "static inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);",
      "static inline void avic_post_state_restore(struct kvm_vcpu *vcpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*entry"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_svm",
          "args": [
            "vcpu"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "to_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "192-195",
          "snippet": "static inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline struct vcpu_svm *to_svm(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_svm, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK\t\t(1ULL << 62)\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\nstatic inline void avic_post_state_restore(struct kvm_vcpu *vcpu);\n\nstatic inline bool avic_vcpu_is_running(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_svm *svm = to_svm(vcpu);\n\tu64 *entry = svm->avic_physical_id_cache;\n\n\tif (!entry)\n\t\treturn false;\n\n\treturn (READ_ONCE(*entry) & AVIC_PHYSICAL_ID_ENTRY_IS_RUNNING_MASK);\n}"
  },
  {
    "function_name": "avic_update_vapic_bar",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "313-317",
    "snippet": "static inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL"
    ],
    "globals_used": [
      "static void svm_complete_interrupts(struct vcpu_svm *svm);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mark_dirty",
          "args": [
            "svm->vmcb",
            "VMCB_AVIC"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "mark_dirty",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.h",
          "lines": "187-190",
          "snippet": "static inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}",
          "includes": [
            "#include <asm/svm.h>",
            "#include <linux/kvm_host.h>",
            "#include <linux/kvm_types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/svm.h>\n#include <linux/kvm_host.h>\n#include <linux/kvm_types.h>\n\nstatic inline void mark_dirty(struct vmcb *vmcb, int bit)\n{\n\tvmcb->control.clean &= ~(1 << bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\n#define VMCB_AVIC_APIC_BAR_MASK\t\t0xFFFFFFFFFF000ULL\n\nstatic void svm_complete_interrupts(struct vcpu_svm *svm);\n\nstatic inline void avic_update_vapic_bar(struct vcpu_svm *svm, u64 data)\n{\n\tsvm->vmcb->control.avic_vapic_bar = data & VMCB_AVIC_APIC_BAR_MASK;\n\tmark_dirty(svm->vmcb, VMCB_AVIC);\n}"
  },
  {
    "function_name": "sev_get_asid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "306-311",
    "snippet": "static inline int sev_get_asid(struct kvm *kvm)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->asid;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline int sev_get_asid(struct kvm *kvm)\n{\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->asid;\n}"
  },
  {
    "function_name": "sev_guest",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "295-304",
    "snippet": "static inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_kvm_svm",
          "args": [
            "kvm"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "to_kvm_svm",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
          "lines": "285-288",
          "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
          "includes": [
            "#include \"svm.h\"",
            "#include \"trace.h\"",
            "#include <asm/virtext.h>",
            "#include <asm/cpu_device_id.h>",
            "#include <asm/spec-ctrl.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/kvm_para.h>",
            "#include <asm/debugreg.h>",
            "#include <asm/desc.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/perf_event.h>",
            "#include <asm/apic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/file.h>",
            "#include <linux/psp-sev.h>",
            "#include <linux/frame.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/amd-iommu.h>",
            "#include <linux/slab.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/sched.h>",
            "#include <linux/highmem.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mod_devicetable.h>",
            "#include <linux/module.h>",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic int sev = IS_ENABLED(CONFIG_AMD_MEM_ENCRYPT_ACTIVE_BY_DEFAULT);\n\nstatic inline bool sev_guest(struct kvm *kvm)\n{\n#ifdef CONFIG_KVM_AMD_SEV\n\tstruct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;\n\n\treturn sev->active;\n#else\n\treturn false;\n#endif\n}"
  },
  {
    "function_name": "svm_sev_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "290-293",
    "snippet": "static inline bool svm_sev_enabled(void)\n{\n\treturn IS_ENABLED(CONFIG_KVM_AMD_SEV) ? max_sev_asid : 0;\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int max_sev_asid;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_KVM_AMD_SEV"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic unsigned int max_sev_asid;\n\nstatic inline bool svm_sev_enabled(void)\n{\n\treturn IS_ENABLED(CONFIG_KVM_AMD_SEV) ? max_sev_asid : 0;\n}"
  },
  {
    "function_name": "to_kvm_svm",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/svm/svm.c",
    "lines": "285-288",
    "snippet": "static inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}",
    "includes": [
      "#include \"svm.h\"",
      "#include \"trace.h\"",
      "#include <asm/virtext.h>",
      "#include <asm/cpu_device_id.h>",
      "#include <asm/spec-ctrl.h>",
      "#include <asm/irq_remapping.h>",
      "#include <asm/kvm_para.h>",
      "#include <asm/debugreg.h>",
      "#include <asm/desc.h>",
      "#include <asm/tlbflush.h>",
      "#include <asm/perf_event.h>",
      "#include <asm/apic.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/swap.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/file.h>",
      "#include <linux/psp-sev.h>",
      "#include <linux/frame.h>",
      "#include <linux/hashtable.h>",
      "#include <linux/amd-iommu.h>",
      "#include <linux/slab.h>",
      "#include <linux/trace_events.h>",
      "#include <linux/sched.h>",
      "#include <linux/highmem.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mod_devicetable.h>",
      "#include <linux/module.h>",
      "#include \"pmu.h\"",
      "#include \"cpuid.h\"",
      "#include \"x86.h\"",
      "#include \"kvm_cache_regs.h\"",
      "#include \"mmu.h\"",
      "#include \"irq.h\"",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kvm",
            "structkvm_svm",
            "kvm"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"svm.h\"\n#include \"trace.h\"\n#include <asm/virtext.h>\n#include <asm/cpu_device_id.h>\n#include <asm/spec-ctrl.h>\n#include <asm/irq_remapping.h>\n#include <asm/kvm_para.h>\n#include <asm/debugreg.h>\n#include <asm/desc.h>\n#include <asm/tlbflush.h>\n#include <asm/perf_event.h>\n#include <asm/apic.h>\n#include <linux/rwsem.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/file.h>\n#include <linux/psp-sev.h>\n#include <linux/frame.h>\n#include <linux/hashtable.h>\n#include <linux/amd-iommu.h>\n#include <linux/slab.h>\n#include <linux/trace_events.h>\n#include <linux/sched.h>\n#include <linux/highmem.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n#include <linux/mod_devicetable.h>\n#include <linux/module.h>\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_cache_regs.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_svm *to_kvm_svm(struct kvm *kvm)\n{\n\treturn container_of(kvm, struct kvm_svm, kvm);\n}"
  }
]