[
  {
    "function_name": "nested_cr4_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "290-296",
    "snippet": "static inline bool nested_cr4_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr4_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr4_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fixed_bits_valid",
          "args": [
            "val",
            "fixed0",
            "fixed1"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_bits_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "263-266",
          "snippet": "static inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cr4_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr4_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr4_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}"
  },
  {
    "function_name": "nested_host_cr0_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "282-288",
    "snippet": "static inline bool nested_host_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr0_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fixed_bits_valid",
          "args": [
            "val",
            "fixed0",
            "fixed1"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_bits_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "263-266",
          "snippet": "static inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_host_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr0_fixed1;\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}"
  },
  {
    "function_name": "nested_guest_cr0_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "268-280",
    "snippet": "static inline bool nested_guest_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr0_fixed1;\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (to_vmx(vcpu)->nested.msrs.secondary_ctls_high &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))\n\t\tfixed0 &= ~(X86_CR0_PE | X86_CR0_PG);\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fixed_bits_valid",
          "args": [
            "val",
            "fixed0",
            "fixed1"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "fixed_bits_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "263-266",
          "snippet": "static inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "vmcs12",
            "SECONDARY_EXEC_UNRESTRICTED_GUEST"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_guest_cr0_valid(struct kvm_vcpu *vcpu, unsigned long val)\n{\n\tu64 fixed0 = to_vmx(vcpu)->nested.msrs.cr0_fixed0;\n\tu64 fixed1 = to_vmx(vcpu)->nested.msrs.cr0_fixed1;\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\tif (to_vmx(vcpu)->nested.msrs.secondary_ctls_high &\n\t\tSECONDARY_EXEC_UNRESTRICTED_GUEST &&\n\t    nested_cpu_has2(vmcs12, SECONDARY_EXEC_UNRESTRICTED_GUEST))\n\t\tfixed0 &= ~(X86_CR0_PE | X86_CR0_PG);\n\n\treturn fixed_bits_valid(val, fixed0, fixed1);\n}"
  },
  {
    "function_name": "fixed_bits_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "263-266",
    "snippet": "static inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool fixed_bits_valid(u64 val, u64 fixed0, u64 fixed1)\n{\n\treturn ((val & fixed1) | fixed0) == val;\n}"
  },
  {
    "function_name": "nested_exit_on_intr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "253-257",
    "snippet": "static inline bool nested_exit_on_intr(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_EXT_INTR_MASK;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_exit_on_intr(struct kvm_vcpu *vcpu)\n{\n\treturn get_vmcs12(vcpu)->pin_based_vm_exec_control &\n\t\tPIN_BASED_EXT_INTR_MASK;\n}"
  },
  {
    "function_name": "nested_cpu_has_save_preemption_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "243-247",
    "snippet": "static inline bool nested_cpu_has_save_preemption_timer(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->vm_exit_controls &\n\t    VM_EXIT_SAVE_VMX_PREEMPTION_TIMER;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_save_preemption_timer(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->vm_exit_controls &\n\t    VM_EXIT_SAVE_VMX_PREEMPTION_TIMER;\n}"
  },
  {
    "function_name": "nested_cpu_has_shadow_vmcs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "238-241",
    "snippet": "static inline bool nested_cpu_has_shadow_vmcs(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_SHADOW_VMCS);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "vmcs12",
            "SECONDARY_EXEC_SHADOW_VMCS"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_shadow_vmcs(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_SHADOW_VMCS);\n}"
  },
  {
    "function_name": "nested_cpu_has_eptp_switching",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "231-236",
    "snippet": "static inline bool nested_cpu_has_eptp_switching(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has_vmfunc(vmcs12) &&\n\t\t(vmcs12->vm_function_control &\n\t\t VMX_VMFUNC_EPTP_SWITCHING);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has_vmfunc",
          "args": [
            "vmcs12"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has_vmfunc",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "226-229",
          "snippet": "static inline bool nested_cpu_has_vmfunc(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_VMFUNC);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_vmfunc(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_VMFUNC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_eptp_switching(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has_vmfunc(vmcs12) &&\n\t\t(vmcs12->vm_function_control &\n\t\t VMX_VMFUNC_EPTP_SWITCHING);\n}"
  },
  {
    "function_name": "nested_cpu_has_vmfunc",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "226-229",
    "snippet": "static inline bool nested_cpu_has_vmfunc(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_VMFUNC);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "vmcs12",
            "SECONDARY_EXEC_ENABLE_VMFUNC"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_vmfunc(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_VMFUNC);\n}"
  },
  {
    "function_name": "nested_cpu_has_posted_intr",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "221-224",
    "snippet": "static inline bool nested_cpu_has_posted_intr(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_POSTED_INTR;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_posted_intr(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_POSTED_INTR;\n}"
  },
  {
    "function_name": "nested_cpu_has_vid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "216-219",
    "snippet": "static inline bool nested_cpu_has_vid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "vmcs12",
            "SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_vid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUAL_INTR_DELIVERY);\n}"
  },
  {
    "function_name": "nested_cpu_has_apic_reg_virt",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "211-214",
    "snippet": "static inline bool nested_cpu_has_apic_reg_virt(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_APIC_REGISTER_VIRT);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "vmcs12",
            "SECONDARY_EXEC_APIC_REGISTER_VIRT"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_apic_reg_virt(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_APIC_REGISTER_VIRT);\n}"
  },
  {
    "function_name": "nested_cpu_has_vpid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "206-209",
    "snippet": "static inline bool nested_cpu_has_vpid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_VPID);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "vmcs12",
            "SECONDARY_EXEC_ENABLE_VPID"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_vpid(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_VPID);\n}"
  },
  {
    "function_name": "nested_cpu_has_virt_x2apic_mode",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "201-204",
    "snippet": "static inline bool nested_cpu_has_virt_x2apic_mode(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "vmcs12",
            "SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_virt_x2apic_mode(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE);\n}"
  },
  {
    "function_name": "nested_cpu_has_pml",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "196-199",
    "snippet": "static inline bool nested_cpu_has_pml(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_PML);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "vmcs12",
            "SECONDARY_EXEC_ENABLE_PML"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_pml(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_PML);\n}"
  },
  {
    "function_name": "nested_cpu_has_xsaves",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "191-194",
    "snippet": "static inline bool nested_cpu_has_xsaves(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "vmcs12",
            "SECONDARY_EXEC_XSAVES"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_xsaves(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_XSAVES);\n}"
  },
  {
    "function_name": "nested_cpu_has_ept",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "186-189",
    "snippet": "static inline int nested_cpu_has_ept(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_EPT);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has2",
          "args": [
            "vmcs12",
            "SECONDARY_EXEC_ENABLE_EPT"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline int nested_cpu_has_ept(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has2(vmcs12, SECONDARY_EXEC_ENABLE_EPT);\n}"
  },
  {
    "function_name": "nested_cpu_has_mtf",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "181-184",
    "snippet": "static inline int nested_cpu_has_mtf(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_TRAP_FLAG);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_cpu_has",
          "args": [
            "vmcs12",
            "CPU_BASED_MONITOR_TRAP_FLAG"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_has2",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "158-163",
          "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline int nested_cpu_has_mtf(struct vmcs12 *vmcs12)\n{\n\treturn nested_cpu_has(vmcs12, CPU_BASED_MONITOR_TRAP_FLAG);\n}"
  },
  {
    "function_name": "nested_cpu_has_virtual_nmis",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "176-179",
    "snippet": "static inline bool nested_cpu_has_virtual_nmis(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_VIRTUAL_NMIS;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_virtual_nmis(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_VIRTUAL_NMIS;\n}"
  },
  {
    "function_name": "nested_cpu_has_nmi_exiting",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "171-174",
    "snippet": "static inline bool nested_cpu_has_nmi_exiting(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_NMI_EXITING;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_nmi_exiting(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control & PIN_BASED_NMI_EXITING;\n}"
  },
  {
    "function_name": "nested_cpu_has_preemption_timer",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "165-169",
    "snippet": "static inline bool nested_cpu_has_preemption_timer(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_preemption_timer(struct vmcs12 *vmcs12)\n{\n\treturn vmcs12->pin_based_vm_exec_control &\n\t\tPIN_BASED_VMX_PREEMPTION_TIMER;\n}"
  },
  {
    "function_name": "nested_cpu_has2",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "158-163",
    "snippet": "static inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has2(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn (vmcs12->cpu_based_vm_exec_control &\n\t\t\tCPU_BASED_ACTIVATE_SECONDARY_CONTROLS) &&\n\t\t(vmcs12->secondary_vm_exec_control & bit);\n}"
  },
  {
    "function_name": "nested_cpu_has",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "153-156",
    "snippet": "static inline bool nested_cpu_has(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn vmcs12->cpu_based_vm_exec_control & bit;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has(struct vmcs12 *vmcs12, u32 bit)\n{\n\treturn vmcs12->cpu_based_vm_exec_control & bit;\n}"
  },
  {
    "function_name": "nested_cpu_has_vmx_shadow_vmcs",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "147-151",
    "snippet": "static inline bool nested_cpu_has_vmx_shadow_vmcs(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.secondary_ctls_high &\n\t\tSECONDARY_EXEC_SHADOW_VMCS;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_vmx_shadow_vmcs(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.secondary_ctls_high &\n\t\tSECONDARY_EXEC_SHADOW_VMCS;\n}"
  },
  {
    "function_name": "nested_cpu_supports_monitor_trap_flag",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "141-145",
    "snippet": "static inline bool nested_cpu_supports_monitor_trap_flag(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.procbased_ctls_high &\n\t\t\tCPU_BASED_MONITOR_TRAP_FLAG;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_supports_monitor_trap_flag(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.procbased_ctls_high &\n\t\t\tCPU_BASED_MONITOR_TRAP_FLAG;\n}"
  },
  {
    "function_name": "nested_cpu_has_zero_length_injection",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "136-139",
    "snippet": "static inline bool nested_cpu_has_zero_length_injection(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.misc_low & VMX_MISC_ZERO_LEN_INS;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_zero_length_injection(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.misc_low & VMX_MISC_ZERO_LEN_INS;\n}"
  },
  {
    "function_name": "nested_cpu_has_vmwrite_any_field",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "130-134",
    "snippet": "static inline bool nested_cpu_has_vmwrite_any_field(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.misc_low &\n\t\tMSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_cpu_has_vmwrite_any_field(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.msrs.misc_low &\n\t\tMSR_IA32_VMX_MISC_VMWRITE_SHADOW_RO_FIELDS;\n}"
  },
  {
    "function_name": "nested_cpu_vmx_misc_cr3_count",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "120-123",
    "snippet": "static inline unsigned nested_cpu_vmx_misc_cr3_count(struct kvm_vcpu *vcpu)\n{\n\treturn vmx_misc_cr3_count(to_vmx(vcpu)->nested.msrs.misc_low);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vmx_misc_cr3_count",
          "args": [
            "to_vmx(vcpu)->nested.msrs.misc_low"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "nested_cpu_vmx_misc_cr3_count",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "120-123",
          "snippet": "static inline unsigned nested_cpu_vmx_misc_cr3_count(struct kvm_vcpu *vcpu)\n{\n\treturn vmx_misc_cr3_count(to_vmx(vcpu)->nested.msrs.misc_low);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline unsigned nested_cpu_vmx_misc_cr3_count(struct kvm_vcpu *vcpu)\n{\n\treturn vmx_misc_cr3_count(to_vmx(vcpu)->nested.msrs.misc_low);\n}"
  },
  {
    "function_name": "nested_read_cr4",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "114-118",
    "snippet": "static inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline unsigned long nested_read_cr4(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr4 & ~fields->cr4_guest_host_mask) |\n\t\t(fields->cr4_read_shadow & fields->cr4_guest_host_mask);\n}"
  },
  {
    "function_name": "nested_read_cr0",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "109-113",
    "snippet": "static inline unsigned long nested_read_cr0(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr0 & ~fields->cr0_guest_host_mask) |\n\t\t(fields->cr0_read_shadow & fields->cr0_guest_host_mask);\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline unsigned long nested_read_cr0(struct vmcs12 *fields)\n{\n\treturn (fields->guest_cr0 & ~fields->cr0_guest_host_mask) |\n\t\t(fields->cr0_read_shadow & fields->cr0_guest_host_mask);\n}"
  },
  {
    "function_name": "nested_vmx_reflect_vmexit",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "79-102",
    "snippet": "static inline int nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    u32 exit_reason)\n{\n\tu32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\t/*\n\t * At this point, the exit interruption info in exit_intr_info\n\t * is only valid for EXCEPTION_NMI exits.  For EXTERNAL_INTERRUPT\n\t * we need to query the in-kernel LAPIC.\n\t */\n\tWARN_ON(exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT);\n\tif ((exit_intr_info &\n\t     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==\n\t    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\t\tvmcs12->vm_exit_intr_error_code =\n\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\t}\n\n\tnested_vmx_vmexit(vcpu, exit_reason, exit_intr_info,\n\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\treturn 1;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_vmx_vmexit",
          "args": [
            "vcpu",
            "exit_reason",
            "exit_intr_info",
            "vmcs_readl(EXIT_QUALIFICATION)"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "nested_vmx_vmexit",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.c",
          "lines": "4274-4398",
          "snippet": "void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t       u32 exit_intr_info, unsigned long exit_qualification)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\t/* trying to cancel vmlaunch/vmresume is a bug */\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\tleave_guest_mode(vcpu);\n\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\thrtimer_cancel(&to_vmx(vcpu)->nested.preemption_timer);\n\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING)\n\t\tvcpu->arch.tsc_offset -= vmcs12->tsc_offset;\n\n\tif (likely(!vmx->fail)) {\n\t\tsync_vmcs02_to_vmcs12(vcpu, vmcs12);\n\n\t\tif (exit_reason != -1)\n\t\t\tprepare_vmcs12(vcpu, vmcs12, exit_reason, exit_intr_info,\n\t\t\t\t       exit_qualification);\n\n\t\t/*\n\t\t * Must happen outside of sync_vmcs02_to_vmcs12() as it will\n\t\t * also be used to capture vmcs12 cache as part of\n\t\t * capturing nVMX state for snapshot (migration).\n\t\t *\n\t\t * Otherwise, this flush will dirty guest memory at a\n\t\t * point it is already assumed by user-space to be\n\t\t * immutable.\n\t\t */\n\t\tnested_flush_cached_shadow_vmcs12(vcpu, vmcs12);\n\t} else {\n\t\t/*\n\t\t * The only expected VM-instruction error is \"VM entry with\n\t\t * invalid control field(s).\" Anything else indicates a\n\t\t * problem with L0.  And we should never get here with a\n\t\t * VMFail of any type if early consistency checks are enabled.\n\t\t */\n\t\tWARN_ON_ONCE(vmcs_read32(VM_INSTRUCTION_ERROR) !=\n\t\t\t     VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tWARN_ON_ONCE(nested_early_check);\n\t}\n\n\tvmx_switch_vmcs(vcpu, &vmx->vmcs01);\n\n\t/* Update any VMCS fields that might have changed while L2 ran */\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.host.nr);\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.guest.nr);\n\tvmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);\n\tif (vmx->nested.l1_tpr_threshold != -1)\n\t\tvmcs_write32(TPR_THRESHOLD, vmx->nested.l1_tpr_threshold);\n\n\tif (kvm_has_tsc_control)\n\t\tdecache_tsc_multiplier(vmx);\n\n\tif (vmx->nested.change_vmcs01_virtual_apic_mode) {\n\t\tvmx->nested.change_vmcs01_virtual_apic_mode = false;\n\t\tvmx_set_virtual_apic_mode(vcpu);\n\t}\n\n\t/* Unpin physical memory we referred to in vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tkvm_release_page_clean(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tkvm_vcpu_unmap(vcpu, &vmx->nested.virtual_apic_map, true);\n\tkvm_vcpu_unmap(vcpu, &vmx->nested.pi_desc_map, true);\n\tvmx->nested.pi_desc = NULL;\n\n\t/*\n\t * We are now running in L2, mmu_notifier will force to reload the\n\t * page's hpa for L2 vmcs. Need to reload it for L1 before entering L1.\n\t */\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\tif ((exit_reason != -1) && (enable_shadow_vmcs || vmx->nested.hv_evmcs))\n\t\tvmx->nested.need_vmcs12_to_shadow_sync = true;\n\n\t/* in case we halted in L2 */\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tif (likely(!vmx->fail)) {\n\t\tif (exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT &&\n\t\t    nested_exit_intr_ack_set(vcpu)) {\n\t\t\tint irq = kvm_cpu_get_interrupt(vcpu);\n\t\t\tWARN_ON(irq < 0);\n\t\t\tvmcs12->vm_exit_intr_info = irq |\n\t\t\t\tINTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR;\n\t\t}\n\n\t\tif (exit_reason != -1)\n\t\t\ttrace_kvm_nested_vmexit_inject(vmcs12->vm_exit_reason,\n\t\t\t\t\t\t       vmcs12->exit_qualification,\n\t\t\t\t\t\t       vmcs12->idt_vectoring_info_field,\n\t\t\t\t\t\t       vmcs12->vm_exit_intr_info,\n\t\t\t\t\t\t       vmcs12->vm_exit_intr_error_code,\n\t\t\t\t\t\t       KVM_ISA_VMX);\n\n\t\tload_vmcs12_host_state(vcpu, vmcs12);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * After an early L2 VM-entry failure, we're now back\n\t * in L1 which thinks it just finished a VMLAUNCH or\n\t * VMRESUME instruction, so we need to set the failure\n\t * flag and the VM-instruction error field of the VMCS\n\t * accordingly, and skip the emulated instruction.\n\t */\n\t(void)nested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\n\t/*\n\t * Restore L1's host state to KVM's software model.  We're here\n\t * because a consistency check was caught by hardware, which\n\t * means some amount of guest state has been propagated to KVM's\n\t * model and needs to be unwound to the host's state.\n\t */\n\tnested_vmx_restore_host_state(vcpu);\n\n\tvmx->fail = 0;\n}",
          "includes": [
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"vmcs_shadow_fields.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"pmu.h\"",
            "#include \"nested.h\"",
            "#include \"mmu.h\"",
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include <asm/mmu_context.h>",
            "#include <asm/debugreg.h>",
            "#include <linux/percpu.h>",
            "#include <linux/frame.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs_shadow_fields.h\"\n#include \"vmcs_shadow_fields.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"pmu.h\"\n#include \"nested.h\"\n#include \"mmu.h\"\n#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include <asm/mmu_context.h>\n#include <asm/debugreg.h>\n#include <linux/percpu.h>\n#include <linux/frame.h>\n\nstatic void load_vmcs12_host_state(struct kvm_vcpu *vcpu,\n\t\t\t\t   struct vmcs12 *vmcs12);\n\nvoid nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,\n\t\t       u32 exit_intr_info, unsigned long exit_qualification)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\t/* trying to cancel vmlaunch/vmresume is a bug */\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\tleave_guest_mode(vcpu);\n\n\tif (nested_cpu_has_preemption_timer(vmcs12))\n\t\thrtimer_cancel(&to_vmx(vcpu)->nested.preemption_timer);\n\n\tif (vmcs12->cpu_based_vm_exec_control & CPU_BASED_USE_TSC_OFFSETTING)\n\t\tvcpu->arch.tsc_offset -= vmcs12->tsc_offset;\n\n\tif (likely(!vmx->fail)) {\n\t\tsync_vmcs02_to_vmcs12(vcpu, vmcs12);\n\n\t\tif (exit_reason != -1)\n\t\t\tprepare_vmcs12(vcpu, vmcs12, exit_reason, exit_intr_info,\n\t\t\t\t       exit_qualification);\n\n\t\t/*\n\t\t * Must happen outside of sync_vmcs02_to_vmcs12() as it will\n\t\t * also be used to capture vmcs12 cache as part of\n\t\t * capturing nVMX state for snapshot (migration).\n\t\t *\n\t\t * Otherwise, this flush will dirty guest memory at a\n\t\t * point it is already assumed by user-space to be\n\t\t * immutable.\n\t\t */\n\t\tnested_flush_cached_shadow_vmcs12(vcpu, vmcs12);\n\t} else {\n\t\t/*\n\t\t * The only expected VM-instruction error is \"VM entry with\n\t\t * invalid control field(s).\" Anything else indicates a\n\t\t * problem with L0.  And we should never get here with a\n\t\t * VMFail of any type if early consistency checks are enabled.\n\t\t */\n\t\tWARN_ON_ONCE(vmcs_read32(VM_INSTRUCTION_ERROR) !=\n\t\t\t     VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\t\tWARN_ON_ONCE(nested_early_check);\n\t}\n\n\tvmx_switch_vmcs(vcpu, &vmx->vmcs01);\n\n\t/* Update any VMCS fields that might have changed while L2 ran */\n\tvmcs_write32(VM_EXIT_MSR_LOAD_COUNT, vmx->msr_autoload.host.nr);\n\tvmcs_write32(VM_ENTRY_MSR_LOAD_COUNT, vmx->msr_autoload.guest.nr);\n\tvmcs_write64(TSC_OFFSET, vcpu->arch.tsc_offset);\n\tif (vmx->nested.l1_tpr_threshold != -1)\n\t\tvmcs_write32(TPR_THRESHOLD, vmx->nested.l1_tpr_threshold);\n\n\tif (kvm_has_tsc_control)\n\t\tdecache_tsc_multiplier(vmx);\n\n\tif (vmx->nested.change_vmcs01_virtual_apic_mode) {\n\t\tvmx->nested.change_vmcs01_virtual_apic_mode = false;\n\t\tvmx_set_virtual_apic_mode(vcpu);\n\t}\n\n\t/* Unpin physical memory we referred to in vmcs02 */\n\tif (vmx->nested.apic_access_page) {\n\t\tkvm_release_page_clean(vmx->nested.apic_access_page);\n\t\tvmx->nested.apic_access_page = NULL;\n\t}\n\tkvm_vcpu_unmap(vcpu, &vmx->nested.virtual_apic_map, true);\n\tkvm_vcpu_unmap(vcpu, &vmx->nested.pi_desc_map, true);\n\tvmx->nested.pi_desc = NULL;\n\n\t/*\n\t * We are now running in L2, mmu_notifier will force to reload the\n\t * page's hpa for L2 vmcs. Need to reload it for L1 before entering L1.\n\t */\n\tkvm_make_request(KVM_REQ_APIC_PAGE_RELOAD, vcpu);\n\n\tif ((exit_reason != -1) && (enable_shadow_vmcs || vmx->nested.hv_evmcs))\n\t\tvmx->nested.need_vmcs12_to_shadow_sync = true;\n\n\t/* in case we halted in L2 */\n\tvcpu->arch.mp_state = KVM_MP_STATE_RUNNABLE;\n\n\tif (likely(!vmx->fail)) {\n\t\tif (exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT &&\n\t\t    nested_exit_intr_ack_set(vcpu)) {\n\t\t\tint irq = kvm_cpu_get_interrupt(vcpu);\n\t\t\tWARN_ON(irq < 0);\n\t\t\tvmcs12->vm_exit_intr_info = irq |\n\t\t\t\tINTR_INFO_VALID_MASK | INTR_TYPE_EXT_INTR;\n\t\t}\n\n\t\tif (exit_reason != -1)\n\t\t\ttrace_kvm_nested_vmexit_inject(vmcs12->vm_exit_reason,\n\t\t\t\t\t\t       vmcs12->exit_qualification,\n\t\t\t\t\t\t       vmcs12->idt_vectoring_info_field,\n\t\t\t\t\t\t       vmcs12->vm_exit_intr_info,\n\t\t\t\t\t\t       vmcs12->vm_exit_intr_error_code,\n\t\t\t\t\t\t       KVM_ISA_VMX);\n\n\t\tload_vmcs12_host_state(vcpu, vmcs12);\n\n\t\treturn;\n\t}\n\n\t/*\n\t * After an early L2 VM-entry failure, we're now back\n\t * in L1 which thinks it just finished a VMLAUNCH or\n\t * VMRESUME instruction, so we need to set the failure\n\t * flag and the VM-instruction error field of the VMCS\n\t * accordingly, and skip the emulated instruction.\n\t */\n\t(void)nested_vmx_failValid(vcpu, VMXERR_ENTRY_INVALID_CONTROL_FIELD);\n\n\t/*\n\t * Restore L1's host state to KVM's software model.  We're here\n\t * because a consistency check was caught by hardware, which\n\t * means some amount of guest state has been propagated to KVM's\n\t * model and needs to be unwound to the host's state.\n\t */\n\tnested_vmx_restore_host_state(vcpu);\n\n\tvmx->fail = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_readl",
          "args": [
            "EXIT_QUALIFICATION"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_readl",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "132-138",
          "snippet": "static __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline unsigned long vmcs_readl(unsigned long field)\n{\n\tvmcs_checkl(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read64(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vmcs_read32",
          "args": [
            "VM_EXIT_INTR_ERROR_CODE"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "vmcs_read32",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/ops.h",
          "lines": "112-118",
          "snippet": "static __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"evmcs.h\"",
            "#include <asm/vmx.h>",
            "#include <asm/kvm_host.h>",
            "#include <linux/nospec.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"evmcs.h\"\n#include <asm/vmx.h>\n#include <asm/kvm_host.h>\n#include <linux/nospec.h>\n\nstatic __always_inline u32 vmcs_read32(unsigned long field)\n{\n\tvmcs_check32(field);\n\tif (static_branch_unlikely(&enable_evmcs))\n\t\treturn evmcs_read32(field);\n\treturn __vmcs_readl(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline int nested_vmx_reflect_vmexit(struct kvm_vcpu *vcpu,\n\t\t\t\t\t    u32 exit_reason)\n{\n\tu32 exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n\n\t/*\n\t * At this point, the exit interruption info in exit_intr_info\n\t * is only valid for EXCEPTION_NMI exits.  For EXTERNAL_INTERRUPT\n\t * we need to query the in-kernel LAPIC.\n\t */\n\tWARN_ON(exit_reason == EXIT_REASON_EXTERNAL_INTERRUPT);\n\tif ((exit_intr_info &\n\t     (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) ==\n\t    (INTR_INFO_VALID_MASK | INTR_INFO_DELIVER_CODE_MASK)) {\n\t\tstruct vmcs12 *vmcs12 = get_vmcs12(vcpu);\n\n\t\tvmcs12->vm_exit_intr_error_code =\n\t\t\tvmcs_read32(VM_EXIT_INTR_ERROR_CODE);\n\t}\n\n\tnested_vmx_vmexit(vcpu, exit_reason, exit_intr_info,\n\t\t\t  vmcs_readl(EXIT_QUALIFICATION));\n\treturn 1;\n}"
  },
  {
    "function_name": "nested_ept_ad_enabled",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "71-74",
    "snippet": "static inline bool nested_ept_ad_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn nested_ept_get_eptp(vcpu) & VMX_EPTP_AD_ENABLE_BIT;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nested_ept_get_eptp",
          "args": [
            "vcpu"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "nested_ept_get_eptp",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "65-69",
          "snippet": "static inline unsigned long nested_ept_get_eptp(struct kvm_vcpu *vcpu)\n{\n\t/* return the page table to be shadowed - in our case, EPT12 */\n\treturn get_vmcs12(vcpu)->ept_pointer;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline unsigned long nested_ept_get_eptp(struct kvm_vcpu *vcpu)\n{\n\t/* return the page table to be shadowed - in our case, EPT12 */\n\treturn get_vmcs12(vcpu)->ept_pointer;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline bool nested_ept_ad_enabled(struct kvm_vcpu *vcpu)\n{\n\treturn nested_ept_get_eptp(vcpu) & VMX_EPTP_AD_ENABLE_BIT;\n}"
  },
  {
    "function_name": "nested_ept_get_eptp",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "65-69",
    "snippet": "static inline unsigned long nested_ept_get_eptp(struct kvm_vcpu *vcpu)\n{\n\t/* return the page table to be shadowed - in our case, EPT12 */\n\treturn get_vmcs12(vcpu)->ept_pointer;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_vmcs12",
          "args": [
            "vcpu"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "get_vmcs12",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
          "lines": "41-44",
          "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
          "includes": [
            "#include \"vmx.h\"",
            "#include \"vmcs12.h\"",
            "#include \"kvm_cache_regs.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline unsigned long nested_ept_get_eptp(struct kvm_vcpu *vcpu)\n{\n\t/* return the page table to be shadowed - in our case, EPT12 */\n\treturn get_vmcs12(vcpu)->ept_pointer;\n}"
  },
  {
    "function_name": "vmx_has_valid_vmcs12",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "51-63",
    "snippet": "static inline int vmx_has_valid_vmcs12(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * In case we do two consecutive get/set_nested_state()s while L2 was\n\t * running hv_evmcs may end up not being mapped (we map it from\n\t * nested_vmx_run()/vmx_vcpu_run()). Check is_guest_mode() as we always\n\t * have vmcs12 if it is true.\n\t */\n\treturn is_guest_mode(vcpu) || vmx->nested.current_vmptr != -1ull ||\n\t\tvmx->nested.hv_evmcs;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_guest_mode",
          "args": [
            "vcpu"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "is_guest_mode",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/kvm_cache_regs.h",
          "lines": "170-173",
          "snippet": "static inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}",
          "includes": [
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n\nstatic inline bool is_guest_mode(struct kvm_vcpu *vcpu)\n{\n\treturn vcpu->arch.hflags & HF_GUEST_MASK;\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline int vmx_has_valid_vmcs12(struct kvm_vcpu *vcpu)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\n\t/*\n\t * In case we do two consecutive get/set_nested_state()s while L2 was\n\t * running hv_evmcs may end up not being mapped (we map it from\n\t * nested_vmx_run()/vmx_vcpu_run()). Check is_guest_mode() as we always\n\t * have vmcs12 if it is true.\n\t */\n\treturn is_guest_mode(vcpu) || vmx->nested.current_vmptr != -1ull ||\n\t\tvmx->nested.hv_evmcs;\n}"
  },
  {
    "function_name": "get_shadow_vmcs12",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "46-49",
    "snippet": "static inline struct vmcs12 *get_shadow_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_shadow_vmcs12;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_shadow_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_shadow_vmcs12;\n}"
  },
  {
    "function_name": "get_vmcs12",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/nested.h",
    "lines": "41-44",
    "snippet": "static inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}",
    "includes": [
      "#include \"vmx.h\"",
      "#include \"vmcs12.h\"",
      "#include \"kvm_cache_regs.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_vmx",
          "args": [
            "vcpu"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "to_vmx",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/vmx/vmx.h",
          "lines": "479-482",
          "snippet": "static inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}",
          "includes": [
            "#include \"vmcs.h\"",
            "#include \"ops.h\"",
            "#include \"capabilities.h\"",
            "#include <asm/intel_pt.h>",
            "#include <asm/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vmcs.h\"\n#include \"ops.h\"\n#include \"capabilities.h\"\n#include <asm/intel_pt.h>\n#include <asm/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct vcpu_vmx *to_vmx(struct kvm_vcpu *vcpu)\n{\n\treturn container_of(vcpu, struct vcpu_vmx, vcpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"vmx.h\"\n#include \"vmcs12.h\"\n#include \"kvm_cache_regs.h\"\n\nstatic inline struct vmcs12 *get_vmcs12(struct kvm_vcpu *vcpu)\n{\n\treturn to_vmx(vcpu)->nested.cached_vmcs12;\n}"
  }
]