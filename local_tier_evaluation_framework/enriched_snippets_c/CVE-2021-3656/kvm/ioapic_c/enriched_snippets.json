[
  {
    "function_name": "kvm_set_ioapic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "739-750",
    "snippet": "void kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(ioapic, state, sizeof(struct kvm_ioapic_state));\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tkvm_make_scan_ioapic_request(kvm);\n\tkvm_ioapic_inject_all(ioapic, state->irr);\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_inject_all",
          "args": [
            "ioapic",
            "state->irr"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_inject_all",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "270-279",
          "snippet": "static void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)\n{\n\tu32 idx;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tfor_each_set_bit(idx, &irr, IOAPIC_NUM_PINS)\n\t\tioapic_set_irq(ioapic, idx, 1, true);\n\n\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)\n{\n\tu32 idx;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tfor_each_set_bit(idx, &irr, IOAPIC_NUM_PINS)\n\t\tioapic_set_irq(ioapic, idx, 1, true);\n\n\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_scan_ioapic_request",
          "args": [
            "kvm"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_make_scan_ioapic_request",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8034-8037",
          "snippet": "void kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ioapic",
            "state",
            "sizeof(struct kvm_ioapic_state)"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_set_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(ioapic, state, sizeof(struct kvm_ioapic_state));\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tkvm_make_scan_ioapic_request(kvm);\n\tkvm_ioapic_inject_all(ioapic, state->irr);\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "kvm_get_ioapic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "729-737",
    "snippet": "void kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(state, ioapic, sizeof(struct kvm_ioapic_state));\n\tstate->irr &= ~ioapic->irr_delivered;\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "state",
            "ioapic",
            "sizeof(struct kvm_ioapic_state)"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_get_ioapic(struct kvm *kvm, struct kvm_ioapic_state *state)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\tmemcpy(state, ioapic, sizeof(struct kvm_ioapic_state));\n\tstate->irr &= ~ioapic->irr_delivered;\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "kvm_ioapic_destroy",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "714-727",
    "snippet": "void kvm_ioapic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!ioapic)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tkvm->arch.vioapic = NULL;\n\tkfree(ioapic);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ioapic"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_unregister_dev",
          "args": [
            "kvm",
            "KVM_MMIO_BUS",
            "&ioapic->dev"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&ioapic->eoi_inject"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_destroy(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic = kvm->arch.vioapic;\n\n\tif (!ioapic)\n\t\treturn;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tmutex_lock(&kvm->slots_lock);\n\tkvm_io_bus_unregister_dev(kvm, KVM_MMIO_BUS, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tkvm->arch.vioapic = NULL;\n\tkfree(ioapic);\n}"
  },
  {
    "function_name": "kvm_ioapic_init",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "688-712",
    "snippet": "int kvm_ioapic_init(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic;\n\tint ret;\n\n\tioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL_ACCOUNT);\n\tif (!ioapic)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ioapic->lock);\n\tINIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);\n\tkvm->arch.vioapic = ioapic;\n\tkvm_ioapic_reset(ioapic);\n\tkvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);\n\tioapic->kvm = kvm;\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, ioapic->base_address,\n\t\t\t\t      IOAPIC_MEM_LENGTH, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tif (ret < 0) {\n\t\tkvm->arch.vioapic = NULL;\n\t\tkfree(ioapic);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);",
      "static const struct kvm_io_device_ops ioapic_mmio_ops = {\n\t.read     = ioapic_mmio_read,\n\t.write    = ioapic_mmio_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ioapic"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_io_bus_register_dev",
          "args": [
            "kvm",
            "KVM_MMIO_BUS",
            "ioapic->base_address",
            "IOAPIC_MEM_LENGTH",
            "&ioapic->dev"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&kvm->slots_lock"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_iodevice_init",
          "args": [
            "&ioapic->dev",
            "&ioapic_mmio_ops"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_reset",
          "args": [
            "ioapic"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_reset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "667-681",
          "snippet": "static void kvm_ioapic_reset(struct kvm_ioapic *ioapic)\n{\n\tint i;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++)\n\t\tioapic->redirtbl[i].fields.mask = 1;\n\tioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\n\tioapic->ioregsel = 0;\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tioapic->id = 0;\n\tmemset(ioapic->irq_eoi, 0x00, sizeof(ioapic->irq_eoi));\n\trtc_irq_eoi_tracking_reset(ioapic);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_reset(struct kvm_ioapic *ioapic)\n{\n\tint i;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++)\n\t\tioapic->redirtbl[i].fields.mask = 1;\n\tioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\n\tioapic->ioregsel = 0;\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tioapic->id = 0;\n\tmemset(ioapic->irq_eoi, 0x00, sizeof(ioapic->irq_eoi));\n\trtc_irq_eoi_tracking_reset(ioapic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&ioapic->eoi_inject",
            "kvm_ioapic_eoi_inject_work"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_init",
          "args": [
            "&ioapic->lock"
          ],
          "line": 696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct kvm_ioapic)",
            "GFP_KERNEL_ACCOUNT"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\nstatic const struct kvm_io_device_ops ioapic_mmio_ops = {\n\t.read     = ioapic_mmio_read,\n\t.write    = ioapic_mmio_write,\n};\n\nint kvm_ioapic_init(struct kvm *kvm)\n{\n\tstruct kvm_ioapic *ioapic;\n\tint ret;\n\n\tioapic = kzalloc(sizeof(struct kvm_ioapic), GFP_KERNEL_ACCOUNT);\n\tif (!ioapic)\n\t\treturn -ENOMEM;\n\tspin_lock_init(&ioapic->lock);\n\tINIT_DELAYED_WORK(&ioapic->eoi_inject, kvm_ioapic_eoi_inject_work);\n\tkvm->arch.vioapic = ioapic;\n\tkvm_ioapic_reset(ioapic);\n\tkvm_iodevice_init(&ioapic->dev, &ioapic_mmio_ops);\n\tioapic->kvm = kvm;\n\tmutex_lock(&kvm->slots_lock);\n\tret = kvm_io_bus_register_dev(kvm, KVM_MMIO_BUS, ioapic->base_address,\n\t\t\t\t      IOAPIC_MEM_LENGTH, &ioapic->dev);\n\tmutex_unlock(&kvm->slots_lock);\n\tif (ret < 0) {\n\t\tkvm->arch.vioapic = NULL;\n\t\tkfree(ioapic);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kvm_ioapic_reset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "667-681",
    "snippet": "static void kvm_ioapic_reset(struct kvm_ioapic *ioapic)\n{\n\tint i;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++)\n\t\tioapic->redirtbl[i].fields.mask = 1;\n\tioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\n\tioapic->ioregsel = 0;\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tioapic->id = 0;\n\tmemset(ioapic->irq_eoi, 0x00, sizeof(ioapic->irq_eoi));\n\trtc_irq_eoi_tracking_reset(ioapic);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_irq_eoi_tracking_reset",
          "args": [
            "ioapic"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_irq_eoi_tracking_reset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "96-100",
          "snippet": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ioapic->irq_eoi",
            "0x00",
            "sizeof(ioapic->irq_eoi)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cancel_delayed_work_sync",
          "args": [
            "&ioapic->eoi_inject"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_reset(struct kvm_ioapic *ioapic)\n{\n\tint i;\n\n\tcancel_delayed_work_sync(&ioapic->eoi_inject);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++)\n\t\tioapic->redirtbl[i].fields.mask = 1;\n\tioapic->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;\n\tioapic->ioregsel = 0;\n\tioapic->irr = 0;\n\tioapic->irr_delivered = 0;\n\tioapic->id = 0;\n\tmemset(ioapic->irq_eoi, 0x00, sizeof(ioapic->irq_eoi));\n\trtc_irq_eoi_tracking_reset(ioapic);\n}"
  },
  {
    "function_name": "ioapic_mmio_write",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "623-665",
    "snippet": "static int ioapic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t\t gpa_t addr, int len, const void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 data;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\tswitch (len) {\n\tcase 8:\n\tcase 4:\n\t\tdata = *(u32 *) val;\n\t\tbreak;\n\tcase 2:\n\t\tdata = *(u16 *) val;\n\t\tbreak;\n\tcase 1:\n\t\tdata = *(u8  *) val;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: Unsupported size %d\\n\", len);\n\t\treturn 0;\n\t}\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tioapic->ioregsel = data & 0xFF; /* 8-bit register */\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tioapic_write_indirect(ioapic, data);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_write_indirect",
          "args": [
            "ioapic",
            "data"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_write_indirect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "320-414",
          "snippet": "static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\n{\n\tunsigned index;\n\tbool mask_before, mask_after;\n\tunion kvm_ioapic_redirect_entry *e;\n\tunsigned long vcpu_bitmap;\n\tint old_remote_irr, old_delivery_status, old_dest_id, old_dest_mode;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\t/* Writes are ignored. */\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\t\tioapic->id = (val >> 24) & 0xf;\n\t\tbreak;\n\n\tcase IOAPIC_REG_ARB_ID:\n\t\tbreak;\n\n\tdefault:\n\t\tindex = (ioapic->ioregsel - 0x10) >> 1;\n\n\t\tif (index >= IOAPIC_NUM_PINS)\n\t\t\treturn;\n\t\tindex = array_index_nospec(index, IOAPIC_NUM_PINS);\n\t\te = &ioapic->redirtbl[index];\n\t\tmask_before = e->fields.mask;\n\t\t/* Preserve read-only fields */\n\t\told_remote_irr = e->fields.remote_irr;\n\t\told_delivery_status = e->fields.delivery_status;\n\t\told_dest_id = e->fields.dest_id;\n\t\told_dest_mode = e->fields.dest_mode;\n\t\tif (ioapic->ioregsel & 1) {\n\t\t\te->bits &= 0xffffffff;\n\t\t\te->bits |= (u64) val << 32;\n\t\t} else {\n\t\t\te->bits &= ~0xffffffffULL;\n\t\t\te->bits |= (u32) val;\n\t\t}\n\t\te->fields.remote_irr = old_remote_irr;\n\t\te->fields.delivery_status = old_delivery_status;\n\n\t\t/*\n\t\t * Some OSes (Linux, Xen) assume that Remote IRR bit will\n\t\t * be cleared by IOAPIC hardware when the entry is configured\n\t\t * as edge-triggered. This behavior is used to simulate an\n\t\t * explicit EOI on IOAPICs that don't have the EOI register.\n\t\t */\n\t\tif (e->fields.trig_mode == IOAPIC_EDGE_TRIG)\n\t\t\te->fields.remote_irr = 0;\n\n\t\tmask_after = e->fields.mask;\n\t\tif (mask_before != mask_after)\n\t\t\tkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG\n\t\t    && ioapic->irr & (1 << index))\n\t\t\tioapic_service(ioapic, index, false);\n\t\tif (e->fields.delivery_mode == APIC_DM_FIXED) {\n\t\t\tstruct kvm_lapic_irq irq;\n\n\t\t\tirq.vector = e->fields.vector;\n\t\t\tirq.delivery_mode = e->fields.delivery_mode << 8;\n\t\t\tirq.dest_mode =\n\t\t\t    kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);\n\t\t\tirq.level = false;\n\t\t\tirq.trig_mode = e->fields.trig_mode;\n\t\t\tirq.shorthand = APIC_DEST_NOSHORT;\n\t\t\tirq.dest_id = e->fields.dest_id;\n\t\t\tirq.msi_redir_hint = false;\n\t\t\tbitmap_zero(&vcpu_bitmap, 16);\n\t\t\tkvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,\n\t\t\t\t\t\t &vcpu_bitmap);\n\t\t\tif (old_dest_mode != e->fields.dest_mode ||\n\t\t\t    old_dest_id != e->fields.dest_id) {\n\t\t\t\t/*\n\t\t\t\t * Update vcpu_bitmap with vcpus specified in\n\t\t\t\t * the previous request as well. This is done to\n\t\t\t\t * keep ioapic_handled_vectors synchronized.\n\t\t\t\t */\n\t\t\t\tirq.dest_id = old_dest_id;\n\t\t\t\tirq.dest_mode =\n\t\t\t\t    kvm_lapic_irq_dest_mode(\n\t\t\t\t\t!!e->fields.dest_mode);\n\t\t\t\tkvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,\n\t\t\t\t\t\t\t &vcpu_bitmap);\n\t\t\t}\n\t\t\tkvm_make_scan_ioapic_request_mask(ioapic->kvm,\n\t\t\t\t\t\t\t  &vcpu_bitmap);\n\t\t} else {\n\t\t\tkvm_make_scan_ioapic_request(ioapic->kvm);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\n{\n\tunsigned index;\n\tbool mask_before, mask_after;\n\tunion kvm_ioapic_redirect_entry *e;\n\tunsigned long vcpu_bitmap;\n\tint old_remote_irr, old_delivery_status, old_dest_id, old_dest_mode;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\t/* Writes are ignored. */\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\t\tioapic->id = (val >> 24) & 0xf;\n\t\tbreak;\n\n\tcase IOAPIC_REG_ARB_ID:\n\t\tbreak;\n\n\tdefault:\n\t\tindex = (ioapic->ioregsel - 0x10) >> 1;\n\n\t\tif (index >= IOAPIC_NUM_PINS)\n\t\t\treturn;\n\t\tindex = array_index_nospec(index, IOAPIC_NUM_PINS);\n\t\te = &ioapic->redirtbl[index];\n\t\tmask_before = e->fields.mask;\n\t\t/* Preserve read-only fields */\n\t\told_remote_irr = e->fields.remote_irr;\n\t\told_delivery_status = e->fields.delivery_status;\n\t\told_dest_id = e->fields.dest_id;\n\t\told_dest_mode = e->fields.dest_mode;\n\t\tif (ioapic->ioregsel & 1) {\n\t\t\te->bits &= 0xffffffff;\n\t\t\te->bits |= (u64) val << 32;\n\t\t} else {\n\t\t\te->bits &= ~0xffffffffULL;\n\t\t\te->bits |= (u32) val;\n\t\t}\n\t\te->fields.remote_irr = old_remote_irr;\n\t\te->fields.delivery_status = old_delivery_status;\n\n\t\t/*\n\t\t * Some OSes (Linux, Xen) assume that Remote IRR bit will\n\t\t * be cleared by IOAPIC hardware when the entry is configured\n\t\t * as edge-triggered. This behavior is used to simulate an\n\t\t * explicit EOI on IOAPICs that don't have the EOI register.\n\t\t */\n\t\tif (e->fields.trig_mode == IOAPIC_EDGE_TRIG)\n\t\t\te->fields.remote_irr = 0;\n\n\t\tmask_after = e->fields.mask;\n\t\tif (mask_before != mask_after)\n\t\t\tkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG\n\t\t    && ioapic->irr & (1 << index))\n\t\t\tioapic_service(ioapic, index, false);\n\t\tif (e->fields.delivery_mode == APIC_DM_FIXED) {\n\t\t\tstruct kvm_lapic_irq irq;\n\n\t\t\tirq.vector = e->fields.vector;\n\t\t\tirq.delivery_mode = e->fields.delivery_mode << 8;\n\t\t\tirq.dest_mode =\n\t\t\t    kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);\n\t\t\tirq.level = false;\n\t\t\tirq.trig_mode = e->fields.trig_mode;\n\t\t\tirq.shorthand = APIC_DEST_NOSHORT;\n\t\t\tirq.dest_id = e->fields.dest_id;\n\t\t\tirq.msi_redir_hint = false;\n\t\t\tbitmap_zero(&vcpu_bitmap, 16);\n\t\t\tkvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,\n\t\t\t\t\t\t &vcpu_bitmap);\n\t\t\tif (old_dest_mode != e->fields.dest_mode ||\n\t\t\t    old_dest_id != e->fields.dest_id) {\n\t\t\t\t/*\n\t\t\t\t * Update vcpu_bitmap with vcpus specified in\n\t\t\t\t * the previous request as well. This is done to\n\t\t\t\t * keep ioapic_handled_vectors synchronized.\n\t\t\t\t */\n\t\t\t\tirq.dest_id = old_dest_id;\n\t\t\t\tirq.dest_mode =\n\t\t\t\t    kvm_lapic_irq_dest_mode(\n\t\t\t\t\t!!e->fields.dest_mode);\n\t\t\t\tkvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,\n\t\t\t\t\t\t\t &vcpu_bitmap);\n\t\t\t}\n\t\t\tkvm_make_scan_ioapic_request_mask(ioapic->kvm,\n\t\t\t\t\t\t\t  &vcpu_bitmap);\n\t\t} else {\n\t\t\tkvm_make_scan_ioapic_request(ioapic->kvm);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"ioapic: Unsupported size %d\\n\"",
            "len"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(addr & 0xf)"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_in_range",
          "args": [
            "ioapic",
            "addr"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "575-579",
          "snippet": "static inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ioapic",
          "args": [
            "this"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "to_ioapic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "570-573",
          "snippet": "static inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_mmio_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t\t gpa_t addr, int len, const void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 data;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\tswitch (len) {\n\tcase 8:\n\tcase 4:\n\t\tdata = *(u32 *) val;\n\t\tbreak;\n\tcase 2:\n\t\tdata = *(u16 *) val;\n\t\tbreak;\n\tcase 1:\n\t\tdata = *(u8  *) val;\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: Unsupported size %d\\n\", len);\n\t\treturn 0;\n\t}\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tioapic->ioregsel = data & 0xFF; /* 8-bit register */\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tioapic_write_indirect(ioapic, data);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\treturn 0;\n}"
  },
  {
    "function_name": "ioapic_mmio_read",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "581-621",
    "snippet": "static int ioapic_mmio_read(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t\tgpa_t addr, int len, void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic, addr, len);\n\t\tbreak;\n\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"ioapic: wrong length %d\\n\"",
            "len"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "val",
            "(char *)&result",
            "len"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_read_indirect",
          "args": [
            "ioapic",
            "addr",
            "len"
          ],
          "line": 599
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_read_indirect",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "57-94",
          "snippet": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content = ~0ULL;\n\n\t\t\tif (redir_index < IOAPIC_NUM_PINS) {\n\t\t\t\tu32 index = array_index_nospec(\n\t\t\t\t\tredir_index, IOAPIC_NUM_PINS);\n\n\t\t\t\tredir_content = ioapic->redirtbl[index].bits;\n\t\t\t}\n\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content = ~0ULL;\n\n\t\t\tif (redir_index < IOAPIC_NUM_PINS) {\n\t\t\t\tu32 index = array_index_nospec(\n\t\t\t\t\tredir_index, IOAPIC_NUM_PINS);\n\n\t\t\t\tredir_content = ioapic->redirtbl[index].bits;\n\t\t\t}\n\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "!(addr & 0xf)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_in_range",
          "args": [
            "ioapic",
            "addr"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_range",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "575-579",
          "snippet": "static inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ioapic",
          "args": [
            "this"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "to_ioapic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "570-573",
          "snippet": "static inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_mmio_read(struct kvm_vcpu *vcpu, struct kvm_io_device *this,\n\t\t\t\tgpa_t addr, int len, void *val)\n{\n\tstruct kvm_ioapic *ioapic = to_ioapic(this);\n\tu32 result;\n\tif (!ioapic_in_range(ioapic, addr))\n\t\treturn -EOPNOTSUPP;\n\n\tASSERT(!(addr & 0xf));\t/* check alignment */\n\n\taddr &= 0xff;\n\tspin_lock(&ioapic->lock);\n\tswitch (addr) {\n\tcase IOAPIC_REG_SELECT:\n\t\tresult = ioapic->ioregsel;\n\t\tbreak;\n\n\tcase IOAPIC_REG_WINDOW:\n\t\tresult = ioapic_read_indirect(ioapic, addr, len);\n\t\tbreak;\n\n\tdefault:\n\t\tresult = 0;\n\t\tbreak;\n\t}\n\tspin_unlock(&ioapic->lock);\n\n\tswitch (len) {\n\tcase 8:\n\t\t*(u64 *) val = result;\n\t\tbreak;\n\tcase 1:\n\tcase 2:\n\tcase 4:\n\t\tmemcpy(val, (char *)&result, len);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"ioapic: wrong length %d\\n\", len);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ioapic_in_range",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "575-579",
    "snippet": "static inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic inline int ioapic_in_range(struct kvm_ioapic *ioapic, gpa_t addr)\n{\n\treturn ((addr >= ioapic->base_address &&\n\t\t (addr < ioapic->base_address + IOAPIC_MEM_LENGTH)));\n}"
  },
  {
    "function_name": "to_ioapic",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "570-573",
    "snippet": "static inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structkvm_ioapic",
            "dev"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic inline struct kvm_ioapic *to_ioapic(struct kvm_io_device *dev)\n{\n\treturn container_of(dev, struct kvm_ioapic, dev);\n}"
  },
  {
    "function_name": "kvm_ioapic_update_eoi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "553-568",
    "snippet": "void kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)\n{\n\tint i;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\trtc_irq_eoi(ioapic, vcpu, vector);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.vector != vector)\n\t\t\tcontinue;\n\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic, trigger_mode, i);\n\t}\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_ioapic_update_eoi_one",
          "args": [
            "vcpu",
            "ioapic",
            "trigger_mode",
            "i"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_update_eoi_one",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "505-551",
          "snippet": "static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];\n\n\t/*\n\t * We are dropping lock while calling ack notifiers because ack\n\t * notifier callbacks for assigned devices call into IOAPIC\n\t * recursively. Since remote_irr is cleared only after call\n\t * to notifiers if the same vector will be delivered while lock\n\t * is dropped it will be put into irr and will be delivered\n\t * after ack notifier returns.\n\t */\n\tspin_unlock(&ioapic->lock);\n\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, pin);\n\tspin_lock(&ioapic->lock);\n\n\tif (trigger_mode != IOAPIC_LEVEL_TRIG ||\n\t    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)\n\t\treturn;\n\n\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\tent->fields.remote_irr = 0;\n\tif (!ent->fields.mask && (ioapic->irr & (1 << pin))) {\n\t\t++ioapic->irq_eoi[pin];\n\t\tif (ioapic->irq_eoi[pin] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {\n\t\t\t/*\n\t\t\t * Real hardware does not deliver the interrupt\n\t\t\t * immediately during eoi broadcast, and this\n\t\t\t * lets a buggy guest make slow progress\n\t\t\t * even if it does not correctly handle a\n\t\t\t * level-triggered interrupt.  Emulate this\n\t\t\t * behavior if we detect an interrupt storm.\n\t\t\t */\n\t\t\tschedule_delayed_work(&ioapic->eoi_inject, HZ / 100);\n\t\t\tioapic->irq_eoi[pin] = 0;\n\t\t\ttrace_kvm_ioapic_delayed_eoi_inj(ent->bits);\n\t\t} else {\n\t\t\tioapic_service(ioapic, pin, false);\n\t\t}\n\t} else {\n\t\tioapic->irq_eoi[pin] = 0;\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000"
          ],
          "globals_used": [
            "static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000\n\nstatic void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];\n\n\t/*\n\t * We are dropping lock while calling ack notifiers because ack\n\t * notifier callbacks for assigned devices call into IOAPIC\n\t * recursively. Since remote_irr is cleared only after call\n\t * to notifiers if the same vector will be delivered while lock\n\t * is dropped it will be put into irr and will be delivered\n\t * after ack notifier returns.\n\t */\n\tspin_unlock(&ioapic->lock);\n\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, pin);\n\tspin_lock(&ioapic->lock);\n\n\tif (trigger_mode != IOAPIC_LEVEL_TRIG ||\n\t    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)\n\t\treturn;\n\n\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\tent->fields.remote_irr = 0;\n\tif (!ent->fields.mask && (ioapic->irr & (1 << pin))) {\n\t\t++ioapic->irq_eoi[pin];\n\t\tif (ioapic->irq_eoi[pin] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {\n\t\t\t/*\n\t\t\t * Real hardware does not deliver the interrupt\n\t\t\t * immediately during eoi broadcast, and this\n\t\t\t * lets a buggy guest make slow progress\n\t\t\t * even if it does not correctly handle a\n\t\t\t * level-triggered interrupt.  Emulate this\n\t\t\t * behavior if we detect an interrupt storm.\n\t\t\t */\n\t\t\tschedule_delayed_work(&ioapic->eoi_inject, HZ / 100);\n\t\t\tioapic->irq_eoi[pin] = 0;\n\t\t\ttrace_kvm_ioapic_delayed_eoi_inj(ent->bits);\n\t\t} else {\n\t\t\tioapic_service(ioapic, pin, false);\n\t\t}\n\t} else {\n\t\tioapic->irq_eoi[pin] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtc_irq_eoi",
          "args": [
            "ioapic",
            "vcpu",
            "vector"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_irq_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "162-175",
          "snippet": "static void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu,\n\t\t\tint vector)\n{\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\n\t/* RTC special handling */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map) &&\n\t    (vector == dest_map->vectors[vcpu->vcpu_id]) &&\n\t    (test_and_clear_bit(vcpu->vcpu_id,\n\t\t\t\tioapic->rtc_status.dest_map.map))) {\n\t\t--ioapic->rtc_status.pending_eoi;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu,\n\t\t\tint vector)\n{\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\n\t/* RTC special handling */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map) &&\n\t    (vector == dest_map->vectors[vcpu->vcpu_id]) &&\n\t    (test_and_clear_bit(vcpu->vcpu_id,\n\t\t\t\tioapic->rtc_status.dest_map.map))) {\n\t\t--ioapic->rtc_status.pending_eoi;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_update_eoi(struct kvm_vcpu *vcpu, int vector, int trigger_mode)\n{\n\tint i;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\trtc_irq_eoi(ioapic, vcpu, vector);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.vector != vector)\n\t\t\tcontinue;\n\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic, trigger_mode, i);\n\t}\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "kvm_ioapic_update_eoi_one",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "505-551",
    "snippet": "static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];\n\n\t/*\n\t * We are dropping lock while calling ack notifiers because ack\n\t * notifier callbacks for assigned devices call into IOAPIC\n\t * recursively. Since remote_irr is cleared only after call\n\t * to notifiers if the same vector will be delivered while lock\n\t * is dropped it will be put into irr and will be delivered\n\t * after ack notifier returns.\n\t */\n\tspin_unlock(&ioapic->lock);\n\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, pin);\n\tspin_lock(&ioapic->lock);\n\n\tif (trigger_mode != IOAPIC_LEVEL_TRIG ||\n\t    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)\n\t\treturn;\n\n\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\tent->fields.remote_irr = 0;\n\tif (!ent->fields.mask && (ioapic->irr & (1 << pin))) {\n\t\t++ioapic->irq_eoi[pin];\n\t\tif (ioapic->irq_eoi[pin] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {\n\t\t\t/*\n\t\t\t * Real hardware does not deliver the interrupt\n\t\t\t * immediately during eoi broadcast, and this\n\t\t\t * lets a buggy guest make slow progress\n\t\t\t * even if it does not correctly handle a\n\t\t\t * level-triggered interrupt.  Emulate this\n\t\t\t * behavior if we detect an interrupt storm.\n\t\t\t */\n\t\t\tschedule_delayed_work(&ioapic->eoi_inject, HZ / 100);\n\t\t\tioapic->irq_eoi[pin] = 0;\n\t\t\ttrace_kvm_ioapic_delayed_eoi_inj(ent->bits);\n\t\t} else {\n\t\t\tioapic_service(ioapic, pin, false);\n\t\t}\n\t} else {\n\t\tioapic->irq_eoi[pin] = 0;\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [
      "#define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000"
    ],
    "globals_used": [
      "static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin);",
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ioapic_service",
          "args": [
            "ioapic",
            "pin",
            "false"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_service",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "416-457",
          "snippet": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask ||\n\t    (entry->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t    entry->fields.remote_irr))\n\t\treturn -1;\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = APIC_DEST_NOSHORT;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask ||\n\t    (entry->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t    entry->fields.remote_irr))\n\t\treturn -1;\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = APIC_DEST_NOSHORT;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_kvm_ioapic_delayed_eoi_inj",
          "args": [
            "ent->bits"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "&ioapic->eoi_inject",
            "HZ / 100"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ASSERT",
          "args": [
            "ent->fields.trig_mode == IOAPIC_LEVEL_TRIG"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_get_reg",
          "args": [
            "apic",
            "APIC_SPIV"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_lapic_get_reg",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.h",
          "lines": "156-159",
          "snippet": "static inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}",
          "includes": [
            "#include <linux/kvm_host.h>",
            "#include <kvm/iodev.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kvm_host.h>\n#include <kvm/iodev.h>\n\nstatic inline u32 kvm_lapic_get_reg(struct kvm_lapic *apic, int reg_off)\n{\n\treturn *((u32 *) (apic->regs + reg_off));\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_notify_acked_irq",
          "args": [
            "ioapic->kvm",
            "KVM_IRQCHIP_IOAPIC",
            "pin"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000\n\nstatic void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];\n\n\t/*\n\t * We are dropping lock while calling ack notifiers because ack\n\t * notifier callbacks for assigned devices call into IOAPIC\n\t * recursively. Since remote_irr is cleared only after call\n\t * to notifiers if the same vector will be delivered while lock\n\t * is dropped it will be put into irr and will be delivered\n\t * after ack notifier returns.\n\t */\n\tspin_unlock(&ioapic->lock);\n\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, pin);\n\tspin_lock(&ioapic->lock);\n\n\tif (trigger_mode != IOAPIC_LEVEL_TRIG ||\n\t    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)\n\t\treturn;\n\n\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\tent->fields.remote_irr = 0;\n\tif (!ent->fields.mask && (ioapic->irr & (1 << pin))) {\n\t\t++ioapic->irq_eoi[pin];\n\t\tif (ioapic->irq_eoi[pin] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {\n\t\t\t/*\n\t\t\t * Real hardware does not deliver the interrupt\n\t\t\t * immediately during eoi broadcast, and this\n\t\t\t * lets a buggy guest make slow progress\n\t\t\t * even if it does not correctly handle a\n\t\t\t * level-triggered interrupt.  Emulate this\n\t\t\t * behavior if we detect an interrupt storm.\n\t\t\t */\n\t\t\tschedule_delayed_work(&ioapic->eoi_inject, HZ / 100);\n\t\t\tioapic->irq_eoi[pin] = 0;\n\t\t\ttrace_kvm_ioapic_delayed_eoi_inj(ent->bits);\n\t\t} else {\n\t\t\tioapic_service(ioapic, pin, false);\n\t\t}\n\t} else {\n\t\tioapic->irq_eoi[pin] = 0;\n\t}\n}"
  },
  {
    "function_name": "kvm_ioapic_eoi_inject_work",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "486-502",
    "snippet": "static void kvm_ioapic_eoi_inject_work(struct work_struct *work)\n{\n\tint i;\n\tstruct kvm_ioapic *ioapic = container_of(work, struct kvm_ioapic,\n\t\t\t\t\t\t eoi_inject.work);\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.trig_mode != IOAPIC_LEVEL_TRIG)\n\t\t\tcontinue;\n\n\t\tif (ioapic->irr & (1 << i) && !ent->fields.remote_irr)\n\t\t\tioapic_service(ioapic, i, false);\n\t}\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_service",
          "args": [
            "ioapic",
            "i",
            "false"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_service",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "416-457",
          "snippet": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask ||\n\t    (entry->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t    entry->fields.remote_irr))\n\t\treturn -1;\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = APIC_DEST_NOSHORT;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask ||\n\t    (entry->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t    entry->fields.remote_irr))\n\t\treturn -1;\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = APIC_DEST_NOSHORT;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structkvm_ioapic",
            "eoi_inject.work"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_eoi_inject_work(struct work_struct *work)\n{\n\tint i;\n\tstruct kvm_ioapic *ioapic = container_of(work, struct kvm_ioapic,\n\t\t\t\t\t\t eoi_inject.work);\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < IOAPIC_NUM_PINS; i++) {\n\t\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[i];\n\n\t\tif (ent->fields.trig_mode != IOAPIC_LEVEL_TRIG)\n\t\t\tcontinue;\n\n\t\tif (ioapic->irr & (1 << i) && !ent->fields.remote_irr)\n\t\t\tioapic_service(ioapic, i, false);\n\t}\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "kvm_ioapic_clear_all",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "476-484",
    "snippet": "void kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)\n{\n\tint i;\n\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &ioapic->irq_states[i]);\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "irq_source_id",
            "&ioapic->irq_states[i]"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_clear_all(struct kvm_ioapic *ioapic, int irq_source_id)\n{\n\tint i;\n\n\tspin_lock(&ioapic->lock);\n\tfor (i = 0; i < KVM_IOAPIC_NUM_PINS; i++)\n\t\t__clear_bit(irq_source_id, &ioapic->irq_states[i]);\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "kvm_ioapic_set_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "459-474",
    "snippet": "int kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level, bool line_status)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);\n\n\tspin_lock(&ioapic->lock);\n\tirq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = ioapic_set_irq(ioapic, irq, irq_level, line_status);\n\n\tspin_unlock(&ioapic->lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_set_irq",
          "args": [
            "ioapic",
            "irq",
            "irq_level",
            "line_status"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "210-268",
          "snippet": "static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * AMD SVM AVIC accelerate EOI write and do not trap,\n\t * in-kernel IOAPIC will not be able to receive the EOI.\n\t * In this case, we do lazy update of the pending EOI when\n\t * trying to set IOAPIC irq.\n\t */\n\tif (kvm_apicv_activated(ioapic->kvm))\n\t\tioapic_lazy_update_eoi(ioapic, irq);\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * to masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge) {\n\t\tioapic->irr_delivered &= ~mask;\n\t\tif (old_irr == ioapic->irr) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * AMD SVM AVIC accelerate EOI write and do not trap,\n\t * in-kernel IOAPIC will not be able to receive the EOI.\n\t * In this case, we do lazy update of the pending EOI when\n\t * trying to set IOAPIC irq.\n\t */\n\tif (kvm_apicv_activated(ioapic->kvm))\n\t\tioapic_lazy_update_eoi(ioapic, irq);\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * to masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge) {\n\t\tioapic->irr_delivered &= ~mask;\n\t\tif (old_irr == ioapic->irr) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kvm_irq_line_state",
          "args": [
            "&ioapic->irq_states[irq]",
            "irq_source_id",
            "level"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "irq < 0 || irq >= IOAPIC_NUM_PINS"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nint kvm_ioapic_set_irq(struct kvm_ioapic *ioapic, int irq, int irq_source_id,\n\t\t       int level, bool line_status)\n{\n\tint ret, irq_level;\n\n\tBUG_ON(irq < 0 || irq >= IOAPIC_NUM_PINS);\n\n\tspin_lock(&ioapic->lock);\n\tirq_level = __kvm_irq_line_state(&ioapic->irq_states[irq],\n\t\t\t\t\t irq_source_id, level);\n\tret = ioapic_set_irq(ioapic, irq, irq_level, line_status);\n\n\tspin_unlock(&ioapic->lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ioapic_service",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "416-457",
    "snippet": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask ||\n\t    (entry->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t    entry->fields.remote_irr))\n\t\treturn -1;\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = APIC_DEST_NOSHORT;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_irq_delivery_to_apic",
          "args": [
            "ioapic->kvm",
            "NULL",
            "&irqe",
            "NULL"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_irq_delivery_to_apic",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "47-102",
          "snippet": "int kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL &&\n\t    irq->dest_id == 0xff && kvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nint kvm_irq_delivery_to_apic(struct kvm *kvm, struct kvm_lapic *src,\n\t\tstruct kvm_lapic_irq *irq, struct dest_map *dest_map)\n{\n\tint i, r = -1;\n\tstruct kvm_vcpu *vcpu, *lowest = NULL;\n\tunsigned long dest_vcpu_bitmap[BITS_TO_LONGS(KVM_MAX_VCPUS)];\n\tunsigned int dest_vcpus = 0;\n\n\tif (kvm_irq_delivery_to_apic_fast(kvm, src, irq, &r, dest_map))\n\t\treturn r;\n\n\tif (irq->dest_mode == APIC_DEST_PHYSICAL &&\n\t    irq->dest_id == 0xff && kvm_lowest_prio_delivery(irq)) {\n\t\tprintk(KERN_INFO \"kvm: apic: phys broadcast and lowest prio\\n\");\n\t\tirq->delivery_mode = APIC_DM_FIXED;\n\t}\n\n\tmemset(dest_vcpu_bitmap, 0, sizeof(dest_vcpu_bitmap));\n\n\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\tif (!kvm_apic_present(vcpu))\n\t\t\tcontinue;\n\n\t\tif (!kvm_apic_match_dest(vcpu, src, irq->shorthand,\n\t\t\t\t\tirq->dest_id, irq->dest_mode))\n\t\t\tcontinue;\n\n\t\tif (!kvm_lowest_prio_delivery(irq)) {\n\t\t\tif (r < 0)\n\t\t\t\tr = 0;\n\t\t\tr += kvm_apic_set_irq(vcpu, irq, dest_map);\n\t\t} else if (kvm_apic_sw_enabled(vcpu->arch.apic)) {\n\t\t\tif (!kvm_vector_hashing_enabled()) {\n\t\t\t\tif (!lowest)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t\telse if (kvm_apic_compare_prio(vcpu, lowest) < 0)\n\t\t\t\t\tlowest = vcpu;\n\t\t\t} else {\n\t\t\t\t__set_bit(i, dest_vcpu_bitmap);\n\t\t\t\tdest_vcpus++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (dest_vcpus != 0) {\n\t\tint idx = kvm_vector_to_index(irq->vector, dest_vcpus,\n\t\t\t\t\tdest_vcpu_bitmap, KVM_MAX_VCPUS);\n\n\t\tlowest = kvm_get_vcpu(kvm, idx);\n\t}\n\n\tif (lowest)\n\t\tr = kvm_apic_set_irq(lowest, irq, dest_map);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "ioapic->rtc_status.pending_eoi != 0"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_irq_dest_mode",
          "args": [
            "!!entry->fields.dest_mode"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask ||\n\t    (entry->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t    entry->fields.remote_irr))\n\t\treturn -1;\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = APIC_DEST_NOSHORT;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "ioapic_write_indirect",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "320-414",
    "snippet": "static void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\n{\n\tunsigned index;\n\tbool mask_before, mask_after;\n\tunion kvm_ioapic_redirect_entry *e;\n\tunsigned long vcpu_bitmap;\n\tint old_remote_irr, old_delivery_status, old_dest_id, old_dest_mode;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\t/* Writes are ignored. */\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\t\tioapic->id = (val >> 24) & 0xf;\n\t\tbreak;\n\n\tcase IOAPIC_REG_ARB_ID:\n\t\tbreak;\n\n\tdefault:\n\t\tindex = (ioapic->ioregsel - 0x10) >> 1;\n\n\t\tif (index >= IOAPIC_NUM_PINS)\n\t\t\treturn;\n\t\tindex = array_index_nospec(index, IOAPIC_NUM_PINS);\n\t\te = &ioapic->redirtbl[index];\n\t\tmask_before = e->fields.mask;\n\t\t/* Preserve read-only fields */\n\t\told_remote_irr = e->fields.remote_irr;\n\t\told_delivery_status = e->fields.delivery_status;\n\t\told_dest_id = e->fields.dest_id;\n\t\told_dest_mode = e->fields.dest_mode;\n\t\tif (ioapic->ioregsel & 1) {\n\t\t\te->bits &= 0xffffffff;\n\t\t\te->bits |= (u64) val << 32;\n\t\t} else {\n\t\t\te->bits &= ~0xffffffffULL;\n\t\t\te->bits |= (u32) val;\n\t\t}\n\t\te->fields.remote_irr = old_remote_irr;\n\t\te->fields.delivery_status = old_delivery_status;\n\n\t\t/*\n\t\t * Some OSes (Linux, Xen) assume that Remote IRR bit will\n\t\t * be cleared by IOAPIC hardware when the entry is configured\n\t\t * as edge-triggered. This behavior is used to simulate an\n\t\t * explicit EOI on IOAPICs that don't have the EOI register.\n\t\t */\n\t\tif (e->fields.trig_mode == IOAPIC_EDGE_TRIG)\n\t\t\te->fields.remote_irr = 0;\n\n\t\tmask_after = e->fields.mask;\n\t\tif (mask_before != mask_after)\n\t\t\tkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG\n\t\t    && ioapic->irr & (1 << index))\n\t\t\tioapic_service(ioapic, index, false);\n\t\tif (e->fields.delivery_mode == APIC_DM_FIXED) {\n\t\t\tstruct kvm_lapic_irq irq;\n\n\t\t\tirq.vector = e->fields.vector;\n\t\t\tirq.delivery_mode = e->fields.delivery_mode << 8;\n\t\t\tirq.dest_mode =\n\t\t\t    kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);\n\t\t\tirq.level = false;\n\t\t\tirq.trig_mode = e->fields.trig_mode;\n\t\t\tirq.shorthand = APIC_DEST_NOSHORT;\n\t\t\tirq.dest_id = e->fields.dest_id;\n\t\t\tirq.msi_redir_hint = false;\n\t\t\tbitmap_zero(&vcpu_bitmap, 16);\n\t\t\tkvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,\n\t\t\t\t\t\t &vcpu_bitmap);\n\t\t\tif (old_dest_mode != e->fields.dest_mode ||\n\t\t\t    old_dest_id != e->fields.dest_id) {\n\t\t\t\t/*\n\t\t\t\t * Update vcpu_bitmap with vcpus specified in\n\t\t\t\t * the previous request as well. This is done to\n\t\t\t\t * keep ioapic_handled_vectors synchronized.\n\t\t\t\t */\n\t\t\t\tirq.dest_id = old_dest_id;\n\t\t\t\tirq.dest_mode =\n\t\t\t\t    kvm_lapic_irq_dest_mode(\n\t\t\t\t\t!!e->fields.dest_mode);\n\t\t\t\tkvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,\n\t\t\t\t\t\t\t &vcpu_bitmap);\n\t\t\t}\n\t\t\tkvm_make_scan_ioapic_request_mask(ioapic->kvm,\n\t\t\t\t\t\t\t  &vcpu_bitmap);\n\t\t} else {\n\t\t\tkvm_make_scan_ioapic_request(ioapic->kvm);\n\t\t}\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_scan_ioapic_request",
          "args": [
            "ioapic->kvm"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_make_scan_ioapic_request",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8034-8037",
          "snippet": "void kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_make_scan_ioapic_request_mask",
          "args": [
            "ioapic->kvm",
            "&vcpu_bitmap"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_make_scan_ioapic_request_mask",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8021-8032",
          "snippet": "void kvm_make_scan_ioapic_request_mask(struct kvm *kvm,\n\t\t\t\t       unsigned long *vcpu_bitmap)\n{\n\tcpumask_var_t cpus;\n\n\tzalloc_cpumask_var(&cpus, GFP_ATOMIC);\n\n\tkvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,\n\t\t\t\t    vcpu_bitmap, cpus);\n\n\tfree_cpumask_var(cpus);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_scan_ioapic_request_mask(struct kvm *kvm,\n\t\t\t\t       unsigned long *vcpu_bitmap)\n{\n\tcpumask_var_t cpus;\n\n\tzalloc_cpumask_var(&cpus, GFP_ATOMIC);\n\n\tkvm_make_vcpus_request_mask(kvm, KVM_REQ_SCAN_IOAPIC,\n\t\t\t\t    vcpu_bitmap, cpus);\n\n\tfree_cpumask_var(cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_bitmap_or_dest_vcpus",
          "args": [
            "ioapic->kvm",
            "&irq",
            "&vcpu_bitmap"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_bitmap_or_dest_vcpus",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "1134-1170",
          "snippet": "void kvm_bitmap_or_dest_vcpus(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\t      unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_lapic **dest_vcpu = NULL;\n\tstruct kvm_lapic *src = NULL;\n\tstruct kvm_apic_map *map;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long bitmap;\n\tint i, vcpu_idx;\n\tbool ret;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dest_vcpu,\n\t\t\t\t\t  &bitmap);\n\tif (ret) {\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dest_vcpu[i])\n\t\t\t\tcontinue;\n\t\t\tvcpu_idx = dest_vcpu[i]->vcpu->vcpu_idx;\n\t\t\t__set_bit(vcpu_idx, vcpu_bitmap);\n\t\t}\n\t} else {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!kvm_apic_present(vcpu))\n\t\t\t\tcontinue;\n\t\t\tif (!kvm_apic_match_dest(vcpu, NULL,\n\t\t\t\t\t\t irq->shorthand,\n\t\t\t\t\t\t irq->dest_id,\n\t\t\t\t\t\t irq->dest_mode))\n\t\t\t\tcontinue;\n\t\t\t__set_bit(i, vcpu_bitmap);\n\t\t}\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_bitmap_or_dest_vcpus(struct kvm *kvm, struct kvm_lapic_irq *irq,\n\t\t\t      unsigned long *vcpu_bitmap)\n{\n\tstruct kvm_lapic **dest_vcpu = NULL;\n\tstruct kvm_lapic *src = NULL;\n\tstruct kvm_apic_map *map;\n\tstruct kvm_vcpu *vcpu;\n\tunsigned long bitmap;\n\tint i, vcpu_idx;\n\tbool ret;\n\n\trcu_read_lock();\n\tmap = rcu_dereference(kvm->arch.apic_map);\n\n\tret = kvm_apic_map_get_dest_lapic(kvm, &src, irq, map, &dest_vcpu,\n\t\t\t\t\t  &bitmap);\n\tif (ret) {\n\t\tfor_each_set_bit(i, &bitmap, 16) {\n\t\t\tif (!dest_vcpu[i])\n\t\t\t\tcontinue;\n\t\t\tvcpu_idx = dest_vcpu[i]->vcpu->vcpu_idx;\n\t\t\t__set_bit(vcpu_idx, vcpu_bitmap);\n\t\t}\n\t} else {\n\t\tkvm_for_each_vcpu(i, vcpu, kvm) {\n\t\t\tif (!kvm_apic_present(vcpu))\n\t\t\t\tcontinue;\n\t\t\tif (!kvm_apic_match_dest(vcpu, NULL,\n\t\t\t\t\t\t irq->shorthand,\n\t\t\t\t\t\t irq->dest_id,\n\t\t\t\t\t\t irq->dest_mode))\n\t\t\t\tcontinue;\n\t\t\t__set_bit(i, vcpu_bitmap);\n\t\t}\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_irq_dest_mode",
          "args": [
            "!!e->fields.dest_mode"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "&vcpu_bitmap",
            "16"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_lapic_irq_dest_mode",
          "args": [
            "!!e->fields.dest_mode"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_service",
          "args": [
            "ioapic",
            "index",
            "false"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_service",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "416-457",
          "snippet": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask ||\n\t    (entry->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t    entry->fields.remote_irr))\n\t\treturn -1;\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = APIC_DEST_NOSHORT;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask ||\n\t    (entry->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t    entry->fields.remote_irr))\n\t\treturn -1;\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = APIC_DEST_NOSHORT;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_fire_mask_notifiers",
          "args": [
            "ioapic->kvm",
            "KVM_IRQCHIP_IOAPIC",
            "index",
            "mask_after"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_fire_mask_notifiers",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/irq_comm.c",
          "lines": "252-265",
          "snippet": "void kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}",
          "includes": [
            "#include \"x86.h\"",
            "#include \"hyperv.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include \"irq.h\"",
            "#include <asm/msidef.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/rculist.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"x86.h\"\n#include \"hyperv.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include \"irq.h\"\n#include <asm/msidef.h>\n#include <trace/events/kvm.h>\n#include <linux/rculist.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_fire_mask_notifiers(struct kvm *kvm, unsigned irqchip, unsigned pin,\n\t\t\t     bool mask)\n{\n\tstruct kvm_irq_mask_notifier *kimn;\n\tint idx, gsi;\n\n\tidx = srcu_read_lock(&kvm->irq_srcu);\n\tgsi = kvm_irq_map_chip_pin(kvm, irqchip, pin);\n\tif (gsi != -1)\n\t\thlist_for_each_entry_rcu(kimn, &kvm->arch.mask_notifier_list, link)\n\t\t\tif (kimn->irq == gsi)\n\t\t\t\tkimn->func(kimn, mask);\n\tsrcu_read_unlock(&kvm->irq_srcu, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "index",
            "IOAPIC_NUM_PINS"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void ioapic_write_indirect(struct kvm_ioapic *ioapic, u32 val)\n{\n\tunsigned index;\n\tbool mask_before, mask_after;\n\tunion kvm_ioapic_redirect_entry *e;\n\tunsigned long vcpu_bitmap;\n\tint old_remote_irr, old_delivery_status, old_dest_id, old_dest_mode;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\t/* Writes are ignored. */\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\t\tioapic->id = (val >> 24) & 0xf;\n\t\tbreak;\n\n\tcase IOAPIC_REG_ARB_ID:\n\t\tbreak;\n\n\tdefault:\n\t\tindex = (ioapic->ioregsel - 0x10) >> 1;\n\n\t\tif (index >= IOAPIC_NUM_PINS)\n\t\t\treturn;\n\t\tindex = array_index_nospec(index, IOAPIC_NUM_PINS);\n\t\te = &ioapic->redirtbl[index];\n\t\tmask_before = e->fields.mask;\n\t\t/* Preserve read-only fields */\n\t\told_remote_irr = e->fields.remote_irr;\n\t\told_delivery_status = e->fields.delivery_status;\n\t\told_dest_id = e->fields.dest_id;\n\t\told_dest_mode = e->fields.dest_mode;\n\t\tif (ioapic->ioregsel & 1) {\n\t\t\te->bits &= 0xffffffff;\n\t\t\te->bits |= (u64) val << 32;\n\t\t} else {\n\t\t\te->bits &= ~0xffffffffULL;\n\t\t\te->bits |= (u32) val;\n\t\t}\n\t\te->fields.remote_irr = old_remote_irr;\n\t\te->fields.delivery_status = old_delivery_status;\n\n\t\t/*\n\t\t * Some OSes (Linux, Xen) assume that Remote IRR bit will\n\t\t * be cleared by IOAPIC hardware when the entry is configured\n\t\t * as edge-triggered. This behavior is used to simulate an\n\t\t * explicit EOI on IOAPICs that don't have the EOI register.\n\t\t */\n\t\tif (e->fields.trig_mode == IOAPIC_EDGE_TRIG)\n\t\t\te->fields.remote_irr = 0;\n\n\t\tmask_after = e->fields.mask;\n\t\tif (mask_before != mask_after)\n\t\t\tkvm_fire_mask_notifiers(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index, mask_after);\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG\n\t\t    && ioapic->irr & (1 << index))\n\t\t\tioapic_service(ioapic, index, false);\n\t\tif (e->fields.delivery_mode == APIC_DM_FIXED) {\n\t\t\tstruct kvm_lapic_irq irq;\n\n\t\t\tirq.vector = e->fields.vector;\n\t\t\tirq.delivery_mode = e->fields.delivery_mode << 8;\n\t\t\tirq.dest_mode =\n\t\t\t    kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);\n\t\t\tirq.level = false;\n\t\t\tirq.trig_mode = e->fields.trig_mode;\n\t\t\tirq.shorthand = APIC_DEST_NOSHORT;\n\t\t\tirq.dest_id = e->fields.dest_id;\n\t\t\tirq.msi_redir_hint = false;\n\t\t\tbitmap_zero(&vcpu_bitmap, 16);\n\t\t\tkvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,\n\t\t\t\t\t\t &vcpu_bitmap);\n\t\t\tif (old_dest_mode != e->fields.dest_mode ||\n\t\t\t    old_dest_id != e->fields.dest_id) {\n\t\t\t\t/*\n\t\t\t\t * Update vcpu_bitmap with vcpus specified in\n\t\t\t\t * the previous request as well. This is done to\n\t\t\t\t * keep ioapic_handled_vectors synchronized.\n\t\t\t\t */\n\t\t\t\tirq.dest_id = old_dest_id;\n\t\t\t\tirq.dest_mode =\n\t\t\t\t    kvm_lapic_irq_dest_mode(\n\t\t\t\t\t!!e->fields.dest_mode);\n\t\t\t\tkvm_bitmap_or_dest_vcpus(ioapic->kvm, &irq,\n\t\t\t\t\t\t\t &vcpu_bitmap);\n\t\t\t}\n\t\t\tkvm_make_scan_ioapic_request_mask(ioapic->kvm,\n\t\t\t\t\t\t\t  &vcpu_bitmap);\n\t\t} else {\n\t\t\tkvm_make_scan_ioapic_request(ioapic->kvm);\n\t\t}\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "kvm_arch_post_irq_ack_notifier_list_update",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "313-318",
    "snippet": "void kvm_arch_post_irq_ack_notifier_list_update(struct kvm *kvm)\n{\n\tif (!ioapic_in_kernel(kvm))\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_make_scan_ioapic_request",
          "args": [
            "kvm"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_make_scan_ioapic_request",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "8034-8037",
          "snippet": "void kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nvoid kvm_make_scan_ioapic_request(struct kvm *kvm)\n{\n\tkvm_make_all_cpus_request(kvm, KVM_REQ_SCAN_IOAPIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioapic_in_kernel",
          "args": [
            "kvm"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_in_kernel",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.h",
          "lines": "109-116",
          "snippet": "static inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}",
          "includes": [
            "#include <kvm/iodev.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <kvm/iodev.h>\n#include <linux/kvm_host.h>\n\nstatic inline int ioapic_in_kernel(struct kvm *kvm)\n{\n\tint mode = kvm->arch.irqchip_mode;\n\n\t/* Matches smp_wmb() when setting irqchip_mode */\n\tsmp_rmb();\n\treturn mode == KVM_IRQCHIP_KERNEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nvoid kvm_arch_post_irq_ack_notifier_list_update(struct kvm *kvm)\n{\n\tif (!ioapic_in_kernel(kvm))\n\t\treturn;\n\tkvm_make_scan_ioapic_request(kvm);\n}"
  },
  {
    "function_name": "kvm_ioapic_scan_entry",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "282-311",
    "snippet": "void kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\tint index;\n\n\tspin_lock(&ioapic->lock);\n\n\t/* Make sure we see any missing RTC EOI */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map))\n\t\t__set_bit(dest_map->vectors[vcpu->vcpu_id],\n\t\t\t  ioapic_handled_vectors);\n\n\tfor (index = 0; index < IOAPIC_NUM_PINS; index++) {\n\t\te = &ioapic->redirtbl[index];\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||\n\t\t    kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||\n\t\t    index == RTC_GSI) {\n\t\t\tu16 dm = kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);\n\n\t\t\tif (kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t\te->fields.dest_id, dm) ||\n\t\t\t    kvm_apic_pending_eoi(vcpu, e->fields.vector))\n\t\t\t\t__set_bit(e->fields.vector,\n\t\t\t\t\t  ioapic_handled_vectors);\n\t\t}\n\t}\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "e->fields.vector",
            "ioapic_handled_vectors"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_pending_eoi",
          "args": [
            "vcpu",
            "e->fields.vector"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_pending_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "78-84",
          "snippet": "bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "NULL",
            "APIC_DEST_NOSHORT",
            "e->fields.dest_id",
            "dm"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "808-830",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_irq_dest_mode",
          "args": [
            "!!e->fields.dest_mode"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_irq_has_notifier",
          "args": [
            "ioapic->kvm",
            "KVM_IRQCHIP_IOAPIC",
            "index"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "dest_map->vectors[vcpu->vcpu_id]",
            "ioapic_handled_vectors"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vcpu->vcpu_id",
            "dest_map->map"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_ioapic_scan_entry(struct kvm_vcpu *vcpu, ulong *ioapic_handled_vectors)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\tint index;\n\n\tspin_lock(&ioapic->lock);\n\n\t/* Make sure we see any missing RTC EOI */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map))\n\t\t__set_bit(dest_map->vectors[vcpu->vcpu_id],\n\t\t\t  ioapic_handled_vectors);\n\n\tfor (index = 0; index < IOAPIC_NUM_PINS; index++) {\n\t\te = &ioapic->redirtbl[index];\n\t\tif (e->fields.trig_mode == IOAPIC_LEVEL_TRIG ||\n\t\t    kvm_irq_has_notifier(ioapic->kvm, KVM_IRQCHIP_IOAPIC, index) ||\n\t\t    index == RTC_GSI) {\n\t\t\tu16 dm = kvm_lapic_irq_dest_mode(!!e->fields.dest_mode);\n\n\t\t\tif (kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t\te->fields.dest_id, dm) ||\n\t\t\t    kvm_apic_pending_eoi(vcpu, e->fields.vector))\n\t\t\t\t__set_bit(e->fields.vector,\n\t\t\t\t\t  ioapic_handled_vectors);\n\t\t}\n\t}\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "kvm_ioapic_inject_all",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "270-279",
    "snippet": "static void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)\n{\n\tu32 idx;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tfor_each_set_bit(idx, &irr, IOAPIC_NUM_PINS)\n\t\tioapic_set_irq(ioapic, idx, 1, true);\n\n\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rtc_eoi_tracking_restore_all",
          "args": [
            "ioapic"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rtc_eoi_tracking_restore_all",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "149-160",
          "snippet": "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioapic_set_irq",
          "args": [
            "ioapic",
            "idx",
            "1",
            "true"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_set_irq",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "210-268",
          "snippet": "static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * AMD SVM AVIC accelerate EOI write and do not trap,\n\t * in-kernel IOAPIC will not be able to receive the EOI.\n\t * In this case, we do lazy update of the pending EOI when\n\t * trying to set IOAPIC irq.\n\t */\n\tif (kvm_apicv_activated(ioapic->kvm))\n\t\tioapic_lazy_update_eoi(ioapic, irq);\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * to masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge) {\n\t\tioapic->irr_delivered &= ~mask;\n\t\tif (old_irr == ioapic->irr) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * AMD SVM AVIC accelerate EOI write and do not trap,\n\t * in-kernel IOAPIC will not be able to receive the EOI.\n\t * In this case, we do lazy update of the pending EOI when\n\t * trying to set IOAPIC irq.\n\t */\n\tif (kvm_apicv_activated(ioapic->kvm))\n\t\tioapic_lazy_update_eoi(ioapic, irq);\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * to masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge) {\n\t\tioapic->irr_delivered &= ~mask;\n\t\tif (old_irr == ioapic->irr) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_set_bit",
          "args": [
            "idx",
            "&irr",
            "IOAPIC_NUM_PINS"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_irq_eoi_tracking_reset",
          "args": [
            "ioapic"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_irq_eoi_tracking_reset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "96-100",
          "snippet": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_inject_all(struct kvm_ioapic *ioapic, unsigned long irr)\n{\n\tu32 idx;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tfor_each_set_bit(idx, &irr, IOAPIC_NUM_PINS)\n\t\tioapic_set_irq(ioapic, idx, 1, true);\n\n\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}"
  },
  {
    "function_name": "ioapic_set_irq",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "210-268",
    "snippet": "static int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * AMD SVM AVIC accelerate EOI write and do not trap,\n\t * in-kernel IOAPIC will not be able to receive the EOI.\n\t * In this case, we do lazy update of the pending EOI when\n\t * trying to set IOAPIC irq.\n\t */\n\tif (kvm_apicv_activated(ioapic->kvm))\n\t\tioapic_lazy_update_eoi(ioapic, irq);\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * to masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge) {\n\t\tioapic->irr_delivered &= ~mask;\n\t\tif (old_irr == ioapic->irr) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_kvm_ioapic_set_irq",
          "args": [
            "entry.bits",
            "irq",
            "ret == 0"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioapic_service",
          "args": [
            "ioapic",
            "irq",
            "line_status"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_service",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "416-457",
          "snippet": "static int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask ||\n\t    (entry->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t    entry->fields.remote_irr))\n\t\treturn -1;\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = APIC_DEST_NOSHORT;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_service(struct kvm_ioapic *ioapic, int irq, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\tstruct kvm_lapic_irq irqe;\n\tint ret;\n\n\tif (entry->fields.mask ||\n\t    (entry->fields.trig_mode == IOAPIC_LEVEL_TRIG &&\n\t    entry->fields.remote_irr))\n\t\treturn -1;\n\n\tirqe.dest_id = entry->fields.dest_id;\n\tirqe.vector = entry->fields.vector;\n\tirqe.dest_mode = kvm_lapic_irq_dest_mode(!!entry->fields.dest_mode);\n\tirqe.trig_mode = entry->fields.trig_mode;\n\tirqe.delivery_mode = entry->fields.delivery_mode << 8;\n\tirqe.level = 1;\n\tirqe.shorthand = APIC_DEST_NOSHORT;\n\tirqe.msi_redir_hint = false;\n\n\tif (irqe.trig_mode == IOAPIC_EDGE_TRIG)\n\t\tioapic->irr_delivered |= 1 << irq;\n\n\tif (irq == RTC_GSI && line_status) {\n\t\t/*\n\t\t * pending_eoi cannot ever become negative (see\n\t\t * rtc_status_pending_eoi_check_valid) and the caller\n\t\t * ensures that it is only called if it is >= zero, namely\n\t\t * if rtc_irq_check_coalesced returns false).\n\t\t */\n\t\tBUG_ON(ioapic->rtc_status.pending_eoi != 0);\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe,\n\t\t\t\t\t       &ioapic->rtc_status.dest_map);\n\t\tioapic->rtc_status.pending_eoi = (ret < 0 ? 0 : ret);\n\t} else\n\t\tret = kvm_irq_delivery_to_apic(ioapic->kvm, NULL, &irqe, NULL);\n\n\tif (ret && irqe.trig_mode == IOAPIC_LEVEL_TRIG)\n\t\tentry->fields.remote_irr = 1;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtc_irq_check_coalesced",
          "args": [
            "ioapic"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_irq_check_coalesced",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "177-183",
          "snippet": "static bool rtc_irq_check_coalesced(struct kvm_ioapic *ioapic)\n{\n\tif (ioapic->rtc_status.pending_eoi > 0)\n\t\treturn true; /* coalesced */\n\n\treturn false;\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic bool rtc_irq_check_coalesced(struct kvm_ioapic *ioapic)\n{\n\tif (ioapic->rtc_status.pending_eoi > 0)\n\t\treturn true; /* coalesced */\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ioapic_lazy_update_eoi",
          "args": [
            "ioapic",
            "irq"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "ioapic_lazy_update_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "185-208",
          "snippet": "static void ioapic_lazy_update_eoi(struct kvm_ioapic *ioapic, int irq)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm) {\n\t\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t entry->fields.dest_id,\n\t\t\t\t\t entry->fields.dest_mode) ||\n\t\t    kvm_apic_pending_eoi(vcpu, entry->fields.vector))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If no longer has pending EOI in LAPICs, update\n\t\t * EOI for this vetor.\n\t\t */\n\t\trtc_irq_eoi(ioapic, vcpu, entry->fields.vector);\n\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic,\n\t\t\t\t\t  entry->fields.trig_mode,\n\t\t\t\t\t  irq);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void ioapic_lazy_update_eoi(struct kvm_ioapic *ioapic, int irq)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm) {\n\t\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t entry->fields.dest_id,\n\t\t\t\t\t entry->fields.dest_mode) ||\n\t\t    kvm_apic_pending_eoi(vcpu, entry->fields.vector))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If no longer has pending EOI in LAPICs, update\n\t\t * EOI for this vetor.\n\t\t */\n\t\trtc_irq_eoi(ioapic, vcpu, entry->fields.vector);\n\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic,\n\t\t\t\t\t  entry->fields.trig_mode,\n\t\t\t\t\t  irq);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apicv_activated",
          "args": [
            "ioapic->kvm"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apicv_activated",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/x86.c",
          "lines": "7495-7498",
          "snippet": "bool kvm_apicv_activated(struct kvm *kvm)\n{\n\treturn (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <clocksource/hyperv_timer.h>",
            "#include <asm/emulate_prefix.h>",
            "#include <asm/intel_pt.h>",
            "#include <asm/hypervisor.h>",
            "#include <asm/mshyperv.h>",
            "#include <asm/irq_remapping.h>",
            "#include <asm/div64.h>",
            "#include <asm/pvclock.h>",
            "#include <asm/fpu/internal.h> /* Ugh! */",
            "#include <linux/kernel_stat.h>",
            "#include <asm/mce.h>",
            "#include <asm/desc.h>",
            "#include <asm/msr.h>",
            "#include <asm/debugreg.h>",
            "#include <trace/events/kvm.h>",
            "#include <linux/mem_encrypt.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/irqbypass.h>",
            "#include <linux/kvm_irqfd.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/pci.h>",
            "#include <linux/hash.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/intel-iommu.h>",
            "#include <linux/iommu.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mman.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/export.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/fs.h>",
            "#include <linux/kvm.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/clocksource.h>",
            "#include \"lapic.h\"",
            "#include \"hyperv.h\"",
            "#include \"pmu.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"kvm_emulate.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include \"tss.h\"",
            "#include \"i8254.h\"",
            "#include \"mmu.h\"",
            "#include \"irq.h\"",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <clocksource/hyperv_timer.h>\n#include <asm/emulate_prefix.h>\n#include <asm/intel_pt.h>\n#include <asm/hypervisor.h>\n#include <asm/mshyperv.h>\n#include <asm/irq_remapping.h>\n#include <asm/div64.h>\n#include <asm/pvclock.h>\n#include <asm/fpu/internal.h> /* Ugh! */\n#include <linux/kernel_stat.h>\n#include <asm/mce.h>\n#include <asm/desc.h>\n#include <asm/msr.h>\n#include <asm/debugreg.h>\n#include <trace/events/kvm.h>\n#include <linux/mem_encrypt.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/stat.h>\n#include <linux/irqbypass.h>\n#include <linux/kvm_irqfd.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/pci.h>\n#include <linux/hash.h>\n#include <linux/uaccess.h>\n#include <linux/perf_event.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/user-return-notifier.h>\n#include <linux/cpufreq.h>\n#include <linux/intel-iommu.h>\n#include <linux/iommu.h>\n#include <linux/highmem.h>\n#include <linux/mman.h>\n#include <linux/moduleparam.h>\n#include <linux/export.h>\n#include <linux/vmalloc.h>\n#include <linux/fs.h>\n#include <linux/kvm.h>\n#include <linux/interrupt.h>\n#include <linux/clocksource.h>\n#include \"lapic.h\"\n#include \"hyperv.h\"\n#include \"pmu.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"kvm_emulate.h\"\n#include \"kvm_cache_regs.h\"\n#include \"tss.h\"\n#include \"i8254.h\"\n#include \"mmu.h\"\n#include \"irq.h\"\n#include <linux/kvm_host.h>\n\nbool kvm_apicv_activated(struct kvm *kvm)\n{\n\treturn (READ_ONCE(kvm->arch.apicv_inhibit_reasons) == 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic int ioapic_service(struct kvm_ioapic *vioapic, int irq,\n\t\tbool line_status);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic int ioapic_set_irq(struct kvm_ioapic *ioapic, unsigned int irq,\n\t\tint irq_level, bool line_status)\n{\n\tunion kvm_ioapic_redirect_entry entry;\n\tu32 mask = 1 << irq;\n\tu32 old_irr;\n\tint edge, ret;\n\n\tentry = ioapic->redirtbl[irq];\n\tedge = (entry.fields.trig_mode == IOAPIC_EDGE_TRIG);\n\n\tif (!irq_level) {\n\t\tioapic->irr &= ~mask;\n\t\tret = 1;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * AMD SVM AVIC accelerate EOI write and do not trap,\n\t * in-kernel IOAPIC will not be able to receive the EOI.\n\t * In this case, we do lazy update of the pending EOI when\n\t * trying to set IOAPIC irq.\n\t */\n\tif (kvm_apicv_activated(ioapic->kvm))\n\t\tioapic_lazy_update_eoi(ioapic, irq);\n\n\t/*\n\t * Return 0 for coalesced interrupts; for edge-triggered interrupts,\n\t * this only happens if a previous edge has not been delivered due\n\t * to masking.  For level interrupts, the remote_irr field tells\n\t * us if the interrupt is waiting for an EOI.\n\t *\n\t * RTC is special: it is edge-triggered, but userspace likes to know\n\t * if it has been already ack-ed via EOI because coalesced RTC\n\t * interrupts lead to time drift in Windows guests.  So we track\n\t * EOI manually for the RTC interrupt.\n\t */\n\tif (irq == RTC_GSI && line_status &&\n\t\trtc_irq_check_coalesced(ioapic)) {\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\told_irr = ioapic->irr;\n\tioapic->irr |= mask;\n\tif (edge) {\n\t\tioapic->irr_delivered &= ~mask;\n\t\tif (old_irr == ioapic->irr) {\n\t\t\tret = 0;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = ioapic_service(ioapic, irq, line_status);\n\nout:\n\ttrace_kvm_ioapic_set_irq(entry.bits, irq, ret == 0);\n\treturn ret;\n}"
  },
  {
    "function_name": "ioapic_lazy_update_eoi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "185-208",
    "snippet": "static void ioapic_lazy_update_eoi(struct kvm_ioapic *ioapic, int irq)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm) {\n\t\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t entry->fields.dest_id,\n\t\t\t\t\t entry->fields.dest_mode) ||\n\t\t    kvm_apic_pending_eoi(vcpu, entry->fields.vector))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If no longer has pending EOI in LAPICs, update\n\t\t * EOI for this vetor.\n\t\t */\n\t\trtc_irq_eoi(ioapic, vcpu, entry->fields.vector);\n\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic,\n\t\t\t\t\t  entry->fields.trig_mode,\n\t\t\t\t\t  irq);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_ioapic_update_eoi_one",
          "args": [
            "vcpu",
            "ioapic",
            "entry->fields.trig_mode",
            "irq"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_ioapic_update_eoi_one",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "505-551",
          "snippet": "static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];\n\n\t/*\n\t * We are dropping lock while calling ack notifiers because ack\n\t * notifier callbacks for assigned devices call into IOAPIC\n\t * recursively. Since remote_irr is cleared only after call\n\t * to notifiers if the same vector will be delivered while lock\n\t * is dropped it will be put into irr and will be delivered\n\t * after ack notifier returns.\n\t */\n\tspin_unlock(&ioapic->lock);\n\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, pin);\n\tspin_lock(&ioapic->lock);\n\n\tif (trigger_mode != IOAPIC_LEVEL_TRIG ||\n\t    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)\n\t\treturn;\n\n\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\tent->fields.remote_irr = 0;\n\tif (!ent->fields.mask && (ioapic->irr & (1 << pin))) {\n\t\t++ioapic->irq_eoi[pin];\n\t\tif (ioapic->irq_eoi[pin] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {\n\t\t\t/*\n\t\t\t * Real hardware does not deliver the interrupt\n\t\t\t * immediately during eoi broadcast, and this\n\t\t\t * lets a buggy guest make slow progress\n\t\t\t * even if it does not correctly handle a\n\t\t\t * level-triggered interrupt.  Emulate this\n\t\t\t * behavior if we detect an interrupt storm.\n\t\t\t */\n\t\t\tschedule_delayed_work(&ioapic->eoi_inject, HZ / 100);\n\t\t\tioapic->irq_eoi[pin] = 0;\n\t\t\ttrace_kvm_ioapic_delayed_eoi_inj(ent->bits);\n\t\t} else {\n\t\t\tioapic_service(ioapic, pin, false);\n\t\t}\n\t} else {\n\t\tioapic->irq_eoi[pin] = 0;\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [
            "#define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000"
          ],
          "globals_used": [
            "static void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin);",
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\n#define IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT 10000\n\nstatic void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin);\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_ioapic_update_eoi_one(struct kvm_vcpu *vcpu,\n\t\t\t\t      struct kvm_ioapic *ioapic,\n\t\t\t\t      int trigger_mode,\n\t\t\t\t      int pin)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\tunion kvm_ioapic_redirect_entry *ent = &ioapic->redirtbl[pin];\n\n\t/*\n\t * We are dropping lock while calling ack notifiers because ack\n\t * notifier callbacks for assigned devices call into IOAPIC\n\t * recursively. Since remote_irr is cleared only after call\n\t * to notifiers if the same vector will be delivered while lock\n\t * is dropped it will be put into irr and will be delivered\n\t * after ack notifier returns.\n\t */\n\tspin_unlock(&ioapic->lock);\n\tkvm_notify_acked_irq(ioapic->kvm, KVM_IRQCHIP_IOAPIC, pin);\n\tspin_lock(&ioapic->lock);\n\n\tif (trigger_mode != IOAPIC_LEVEL_TRIG ||\n\t    kvm_lapic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI)\n\t\treturn;\n\n\tASSERT(ent->fields.trig_mode == IOAPIC_LEVEL_TRIG);\n\tent->fields.remote_irr = 0;\n\tif (!ent->fields.mask && (ioapic->irr & (1 << pin))) {\n\t\t++ioapic->irq_eoi[pin];\n\t\tif (ioapic->irq_eoi[pin] == IOAPIC_SUCCESSIVE_IRQ_MAX_COUNT) {\n\t\t\t/*\n\t\t\t * Real hardware does not deliver the interrupt\n\t\t\t * immediately during eoi broadcast, and this\n\t\t\t * lets a buggy guest make slow progress\n\t\t\t * even if it does not correctly handle a\n\t\t\t * level-triggered interrupt.  Emulate this\n\t\t\t * behavior if we detect an interrupt storm.\n\t\t\t */\n\t\t\tschedule_delayed_work(&ioapic->eoi_inject, HZ / 100);\n\t\t\tioapic->irq_eoi[pin] = 0;\n\t\t\ttrace_kvm_ioapic_delayed_eoi_inj(ent->bits);\n\t\t} else {\n\t\t\tioapic_service(ioapic, pin, false);\n\t\t}\n\t} else {\n\t\tioapic->irq_eoi[pin] = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtc_irq_eoi",
          "args": [
            "ioapic",
            "vcpu",
            "entry->fields.vector"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_irq_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "162-175",
          "snippet": "static void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu,\n\t\t\tint vector)\n{\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\n\t/* RTC special handling */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map) &&\n\t    (vector == dest_map->vectors[vcpu->vcpu_id]) &&\n\t    (test_and_clear_bit(vcpu->vcpu_id,\n\t\t\t\tioapic->rtc_status.dest_map.map))) {\n\t\t--ioapic->rtc_status.pending_eoi;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu,\n\t\t\tint vector)\n{\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\n\t/* RTC special handling */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map) &&\n\t    (vector == dest_map->vectors[vcpu->vcpu_id]) &&\n\t    (test_and_clear_bit(vcpu->vcpu_id,\n\t\t\t\tioapic->rtc_status.dest_map.map))) {\n\t\t--ioapic->rtc_status.pending_eoi;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_pending_eoi",
          "args": [
            "vcpu",
            "entry->fields.vector"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_pending_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "78-84",
          "snippet": "bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "NULL",
            "APIC_DEST_NOSHORT",
            "entry->fields.dest_id",
            "entry->fields.dest_mode"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "808-830",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "ioapic->kvm"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void ioapic_lazy_update_eoi(struct kvm_ioapic *ioapic, int irq)\n{\n\tint i;\n\tstruct kvm_vcpu *vcpu;\n\tunion kvm_ioapic_redirect_entry *entry = &ioapic->redirtbl[irq];\n\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm) {\n\t\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t\t entry->fields.dest_id,\n\t\t\t\t\t entry->fields.dest_mode) ||\n\t\t    kvm_apic_pending_eoi(vcpu, entry->fields.vector))\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If no longer has pending EOI in LAPICs, update\n\t\t * EOI for this vetor.\n\t\t */\n\t\trtc_irq_eoi(ioapic, vcpu, entry->fields.vector);\n\t\tkvm_ioapic_update_eoi_one(vcpu, ioapic,\n\t\t\t\t\t  entry->fields.trig_mode,\n\t\t\t\t\t  irq);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "rtc_irq_check_coalesced",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "177-183",
    "snippet": "static bool rtc_irq_check_coalesced(struct kvm_ioapic *ioapic)\n{\n\tif (ioapic->rtc_status.pending_eoi > 0)\n\t\treturn true; /* coalesced */\n\n\treturn false;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic bool rtc_irq_check_coalesced(struct kvm_ioapic *ioapic)\n{\n\tif (ioapic->rtc_status.pending_eoi > 0)\n\t\treturn true; /* coalesced */\n\n\treturn false;\n}"
  },
  {
    "function_name": "rtc_irq_eoi",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "162-175",
    "snippet": "static void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu,\n\t\t\tint vector)\n{\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\n\t/* RTC special handling */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map) &&\n\t    (vector == dest_map->vectors[vcpu->vcpu_id]) &&\n\t    (test_and_clear_bit(vcpu->vcpu_id,\n\t\t\t\tioapic->rtc_status.dest_map.map))) {\n\t\t--ioapic->rtc_status.pending_eoi;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_status_pending_eoi_check_valid",
          "args": [
            "ioapic"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_status_pending_eoi_check_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "104-108",
          "snippet": "static void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_and_clear_bit",
          "args": [
            "vcpu->vcpu_id",
            "ioapic->rtc_status.dest_map.map"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vcpu->vcpu_id",
            "dest_map->map"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi(struct kvm_ioapic *ioapic, struct kvm_vcpu *vcpu,\n\t\t\tint vector)\n{\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\n\t/* RTC special handling */\n\tif (test_bit(vcpu->vcpu_id, dest_map->map) &&\n\t    (vector == dest_map->vectors[vcpu->vcpu_id]) &&\n\t    (test_and_clear_bit(vcpu->vcpu_id,\n\t\t\t\tioapic->rtc_status.dest_map.map))) {\n\t\t--ioapic->rtc_status.pending_eoi;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}"
  },
  {
    "function_name": "kvm_rtc_eoi_tracking_restore_all",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "149-160",
    "snippet": "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__rtc_irq_eoi_tracking_restore_one",
          "args": [
            "vcpu"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "__rtc_irq_eoi_tracking_restore_one",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "110-138",
          "snippet": "static void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t e->fields.dest_id,\n\t\t\t\t kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, dest_map->map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\tdest_map->vectors[vcpu->vcpu_id] = e->fields.vector;\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, dest_map->map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t e->fields.dest_id,\n\t\t\t\t kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, dest_map->map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\tdest_map->vectors[vcpu->vcpu_id] = e->fields.vector;\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, dest_map->map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_for_each_vcpu",
          "args": [
            "i",
            "vcpu",
            "ioapic->kvm"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rtc_irq_eoi_tracking_reset",
          "args": [
            "ioapic"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_irq_eoi_tracking_reset",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "96-100",
          "snippet": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}"
  },
  {
    "function_name": "kvm_rtc_eoi_tracking_restore_one",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "140-147",
    "snippet": "void kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__rtc_irq_eoi_tracking_restore_one(vcpu);\n\tspin_unlock(&ioapic->lock);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__rtc_irq_eoi_tracking_restore_one",
          "args": [
            "vcpu"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "__rtc_irq_eoi_tracking_restore_one",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "110-138",
          "snippet": "static void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t e->fields.dest_id,\n\t\t\t\t kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, dest_map->map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\tdest_map->vectors[vcpu->vcpu_id] = e->fields.vector;\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, dest_map->map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t e->fields.dest_id,\n\t\t\t\t kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, dest_map->map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\tdest_map->vectors[vcpu->vcpu_id] = e->fields.vector;\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, dest_map->map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&ioapic->lock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nvoid kvm_rtc_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\n\tspin_lock(&ioapic->lock);\n\t__rtc_irq_eoi_tracking_restore_one(vcpu);\n\tspin_unlock(&ioapic->lock);\n}"
  },
  {
    "function_name": "__rtc_irq_eoi_tracking_restore_one",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "110-138",
    "snippet": "static void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t e->fields.dest_id,\n\t\t\t\t kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, dest_map->map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\tdest_map->vectors[vcpu->vcpu_id] = e->fields.vector;\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, dest_map->map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rtc_status_pending_eoi_check_valid",
          "args": [
            "ioapic"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "rtc_status_pending_eoi_check_valid",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "104-108",
          "snippet": "static void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "vcpu->vcpu_id",
            "dest_map->map"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "vcpu->vcpu_id",
            "dest_map->map"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "vcpu->vcpu_id",
            "dest_map->map"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvm_apic_pending_eoi",
          "args": [
            "vcpu",
            "e->fields.vector"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_pending_eoi",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "78-84",
          "snippet": "bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector)\n{\n\tstruct kvm_lapic *apic = vcpu->arch.apic;\n\n\treturn apic_test_vector(vector, apic->regs + APIC_ISR) ||\n\t\tapic_test_vector(vector, apic->regs + APIC_IRR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_apic_match_dest",
          "args": [
            "vcpu",
            "NULL",
            "APIC_DEST_NOSHORT",
            "e->fields.dest_id",
            "kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_apic_match_dest",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/lapic.c",
          "lines": "808-830",
          "snippet": "bool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"hyperv.h\"",
            "#include \"cpuid.h\"",
            "#include \"x86.h\"",
            "#include \"trace.h\"",
            "#include \"irq.h\"",
            "#include \"kvm_cache_regs.h\"",
            "#include <linux/jump_label.h>",
            "#include <linux/atomic.h>",
            "#include <asm/delay.h>",
            "#include <asm/apicdef.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/msr.h>",
            "#include <asm/processor.h>",
            "#include <linux/slab.h>",
            "#include <linux/math64.h>",
            "#include <linux/export.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void cancel_hv_timer(struct kvm_lapic *apic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"hyperv.h\"\n#include \"cpuid.h\"\n#include \"x86.h\"\n#include \"trace.h\"\n#include \"irq.h\"\n#include \"kvm_cache_regs.h\"\n#include <linux/jump_label.h>\n#include <linux/atomic.h>\n#include <asm/delay.h>\n#include <asm/apicdef.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/msr.h>\n#include <asm/processor.h>\n#include <linux/slab.h>\n#include <linux/math64.h>\n#include <linux/export.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void cancel_hv_timer(struct kvm_lapic *apic);\n\nbool kvm_apic_match_dest(struct kvm_vcpu *vcpu, struct kvm_lapic *source,\n\t\t\t   int shorthand, unsigned int dest, int dest_mode)\n{\n\tstruct kvm_lapic *target = vcpu->arch.apic;\n\tu32 mda = kvm_apic_mda(vcpu, dest, source, target);\n\n\tASSERT(target);\n\tswitch (shorthand) {\n\tcase APIC_DEST_NOSHORT:\n\t\tif (dest_mode == APIC_DEST_PHYSICAL)\n\t\t\treturn kvm_apic_match_physical_addr(target, mda);\n\t\telse\n\t\t\treturn kvm_apic_match_logical_addr(target, mda);\n\tcase APIC_DEST_SELF:\n\t\treturn target == source;\n\tcase APIC_DEST_ALLINC:\n\t\treturn true;\n\tcase APIC_DEST_ALLBUT:\n\t\treturn target != source;\n\tdefault:\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kvm_lapic_irq_dest_mode",
          "args": [
            "!!e->fields.dest_mode"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void __rtc_irq_eoi_tracking_restore_one(struct kvm_vcpu *vcpu)\n{\n\tbool new_val, old_val;\n\tstruct kvm_ioapic *ioapic = vcpu->kvm->arch.vioapic;\n\tstruct dest_map *dest_map = &ioapic->rtc_status.dest_map;\n\tunion kvm_ioapic_redirect_entry *e;\n\n\te = &ioapic->redirtbl[RTC_GSI];\n\tif (!kvm_apic_match_dest(vcpu, NULL, APIC_DEST_NOSHORT,\n\t\t\t\t e->fields.dest_id,\n\t\t\t\t kvm_lapic_irq_dest_mode(!!e->fields.dest_mode)))\n\t\treturn;\n\n\tnew_val = kvm_apic_pending_eoi(vcpu, e->fields.vector);\n\told_val = test_bit(vcpu->vcpu_id, dest_map->map);\n\n\tif (new_val == old_val)\n\t\treturn;\n\n\tif (new_val) {\n\t\t__set_bit(vcpu->vcpu_id, dest_map->map);\n\t\tdest_map->vectors[vcpu->vcpu_id] = e->fields.vector;\n\t\tioapic->rtc_status.pending_eoi++;\n\t} else {\n\t\t__clear_bit(vcpu->vcpu_id, dest_map->map);\n\t\tioapic->rtc_status.pending_eoi--;\n\t\trtc_status_pending_eoi_check_valid(ioapic);\n\t}\n}"
  },
  {
    "function_name": "rtc_status_pending_eoi_check_valid",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "104-108",
    "snippet": "static void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvm_rtc_eoi_tracking_restore_all",
          "args": [
            "ioapic"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "kvm_rtc_eoi_tracking_restore_all",
          "container": null,
          "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
          "lines": "149-160",
          "snippet": "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}",
          "includes": [
            "#include \"irq.h\"",
            "#include \"lapic.h\"",
            "#include \"ioapic.h\"",
            "#include <trace/events/kvm.h>",
            "#include <asm/current.h>",
            "#include <asm/page.h>",
            "#include <asm/processor.h>",
            "#include <linux/nospec.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/io.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/smp.h>",
            "#include <linux/highmem.h>",
            "#include <linux/mm.h>",
            "#include <linux/kvm.h>",
            "#include <linux/kvm_host.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic)\n{\n\tstruct kvm_vcpu *vcpu;\n\tint i;\n\n\tif (RTC_GSI >= IOAPIC_NUM_PINS)\n\t\treturn;\n\n\trtc_irq_eoi_tracking_reset(ioapic);\n\tkvm_for_each_vcpu(i, vcpu, ioapic->kvm)\n\t    __rtc_irq_eoi_tracking_restore_one(vcpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ioapic->rtc_status.pending_eoi < 0"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_status_pending_eoi_check_valid(struct kvm_ioapic *ioapic)\n{\n\tif (WARN_ON(ioapic->rtc_status.pending_eoi < 0))\n\t\tkvm_rtc_eoi_tracking_restore_all(ioapic);\n}"
  },
  {
    "function_name": "rtc_irq_eoi_tracking_reset",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "96-100",
    "snippet": "static void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "ioapic->rtc_status.dest_map.map",
            "KVM_MAX_VCPU_ID"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic void rtc_irq_eoi_tracking_reset(struct kvm_ioapic *ioapic)\n{\n\tioapic->rtc_status.pending_eoi = 0;\n\tbitmap_zero(ioapic->rtc_status.dest_map.map, KVM_MAX_VCPU_ID);\n}"
  },
  {
    "function_name": "ioapic_read_indirect",
    "container": null,
    "file": "output_repos_c_ICV/CVE-2021-3656/repo/arch/x86/kvm/ioapic.c",
    "lines": "57-94",
    "snippet": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content = ~0ULL;\n\n\t\t\tif (redir_index < IOAPIC_NUM_PINS) {\n\t\t\t\tu32 index = array_index_nospec(\n\t\t\t\t\tredir_index, IOAPIC_NUM_PINS);\n\n\t\t\t\tredir_content = ioapic->redirtbl[index].bits;\n\t\t\t}\n\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"irq.h\"",
      "#include \"lapic.h\"",
      "#include \"ioapic.h\"",
      "#include <trace/events/kvm.h>",
      "#include <asm/current.h>",
      "#include <asm/page.h>",
      "#include <asm/processor.h>",
      "#include <linux/nospec.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>",
      "#include <linux/io.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/smp.h>",
      "#include <linux/highmem.h>",
      "#include <linux/mm.h>",
      "#include <linux/kvm.h>",
      "#include <linux/kvm_host.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "redir_index",
            "IOAPIC_NUM_PINS"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"irq.h\"\n#include \"lapic.h\"\n#include \"ioapic.h\"\n#include <trace/events/kvm.h>\n#include <asm/current.h>\n#include <asm/page.h>\n#include <asm/processor.h>\n#include <linux/nospec.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n#include <linux/hrtimer.h>\n#include <linux/smp.h>\n#include <linux/highmem.h>\n#include <linux/mm.h>\n#include <linux/kvm.h>\n#include <linux/kvm_host.h>\n\nstatic void kvm_rtc_eoi_tracking_restore_all(struct kvm_ioapic *ioapic);\n\nstatic unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content = ~0ULL;\n\n\t\t\tif (redir_index < IOAPIC_NUM_PINS) {\n\t\t\t\tu32 index = array_index_nospec(\n\t\t\t\t\tredir_index, IOAPIC_NUM_PINS);\n\n\t\t\t\tredir_content = ioapic->redirtbl[index].bits;\n\t\t\t}\n\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}"
  }
]