[
  {
    "function_name": "virCPUppc64DriverGetModels",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "778-808",
    "snippet": "static int\nvirCPUppc64DriverGetModels(char ***models)\n{\n    struct ppc64_map *map;\n    size_t i;\n    int ret = -1;\n\n    if (!(map = ppc64LoadMap()))\n        goto error;\n\n    if (models) {\n        if (VIR_ALLOC_N(*models, map->nmodels + 1) < 0)\n            goto error;\n\n        for (i = 0; i < map->nmodels; i++)\n            (*models)[i] = g_strdup(map->models[i]->name);\n    }\n\n    ret = map->nmodels;\n\n cleanup:\n    ppc64MapFree(map);\n    return ret;\n\n error:\n    if (models) {\n        virStringListFree(*models);\n        *models = NULL;\n    }\n    goto cleanup;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStringListFree",
          "args": [
            "*models"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "virStringListFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "306-314",
          "snippet": "void virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nvoid virStringListFree(char **strings)\n{\n    char **tmp = strings;\n    while (tmp && *tmp) {\n        VIR_FREE(*tmp);\n        tmp++;\n    }\n    VIR_FREE(strings);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64MapFree",
          "args": [
            "map"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64MapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "254-271",
          "snippet": "static void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "map->models[i]->name"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "*models",
            "map->nmodels + 1"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64LoadMap",
          "args": [],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64LoadMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "391-407",
          "snippet": "static struct ppc64_map *\nppc64LoadMap(void)\n{\n    struct ppc64_map *map;\n\n    if (VIR_ALLOC(map) < 0)\n        goto error;\n\n    if (cpuMapLoad(\"ppc64\", ppc64VendorParse, NULL, ppc64ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    ppc64MapFree(map);\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_map *\nppc64LoadMap(void)\n{\n    struct ppc64_map *map;\n\n    if (VIR_ALLOC(map) < 0)\n        goto error;\n\n    if (cpuMapLoad(\"ppc64\", ppc64VendorParse, NULL, ppc64ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    ppc64MapFree(map);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUppc64DriverGetModels(char ***models)\n{\n    struct ppc64_map *map;\n    size_t i;\n    int ret = -1;\n\n    if (!(map = ppc64LoadMap()))\n        goto error;\n\n    if (models) {\n        if (VIR_ALLOC_N(*models, map->nmodels + 1) < 0)\n            goto error;\n\n        for (i = 0; i < map->nmodels; i++)\n            (*models)[i] = g_strdup(map->models[i]->name);\n    }\n\n    ret = map->nmodels;\n\n cleanup:\n    ppc64MapFree(map);\n    return ret;\n\n error:\n    if (models) {\n        virStringListFree(*models);\n        *models = NULL;\n    }\n    goto cleanup;\n}"
  },
  {
    "function_name": "virCPUppc64Baseline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "685-776",
    "snippet": "static virCPUDefPtr\nvirCPUppc64Baseline(virCPUDefPtr *cpus,\n                    unsigned int ncpus,\n                    virDomainCapsCPUModelsPtr models G_GNUC_UNUSED,\n                    const char **features G_GNUC_UNUSED,\n                    bool migratable G_GNUC_UNUSED)\n{\n    struct ppc64_map *map;\n    const struct ppc64_model *model;\n    const struct ppc64_vendor *vendor = NULL;\n    virCPUDefPtr cpu = NULL;\n    size_t i;\n\n    if (!(map = ppc64LoadMap()))\n        goto error;\n\n    if (!(model = ppc64ModelFind(map, cpus[0]->model))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU model %s\"), cpus[0]->model);\n        goto error;\n    }\n\n    for (i = 0; i < ncpus; i++) {\n        const struct ppc64_vendor *vnd;\n\n        /* Hosts running old (<= 1.2.18) versions of libvirt will report\n         * strings like 'power7+' or 'power8e' instead of proper CPU model\n         * names in the capabilities XML; moreover, they lack information\n         * about some proper CPU models like 'POWER8'.\n         * This implies two things:\n         *   1) baseline among such hosts never worked\n         *   2) while a few models, eg. 'POWER8_v1.0', could work on both\n         *      old and new versions of libvirt, the information we have\n         *      here is not enough to pick such a model\n         * Hence we just compare models by name to decide whether or not\n         * two hosts are compatible */\n        if (STRNEQ(cpus[i]->model, model->name)) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"CPUs are incompatible\"));\n            goto error;\n        }\n\n        if (!cpus[i]->vendor)\n            continue;\n\n        if (!(vnd = ppc64VendorFind(map, cpus[i]->vendor))) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Unknown CPU vendor %s\"), cpus[i]->vendor);\n            goto error;\n        }\n\n        if (model->vendor) {\n            if (model->vendor != vnd) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"CPU vendor %s of model %s differs from \"\n                                 \"vendor %s\"),\n                               model->vendor->name, model->name,\n                               vnd->name);\n                goto error;\n            }\n        } else if (vendor) {\n            if (vendor != vnd) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"CPU vendors do not match\"));\n                goto error;\n            }\n        } else {\n            vendor = vnd;\n        }\n    }\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model->name);\n\n    if (vendor)\n        cpu->vendor = g_strdup(vendor->name);\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    cpu->match = VIR_CPU_MATCH_EXACT;\n    cpu->fallback = VIR_CPU_FALLBACK_FORBID;\n\n cleanup:\n    ppc64MapFree(map);\n\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    cpu = NULL;\n    goto cleanup;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "cpu"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64MapFree",
          "args": [
            "map"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64MapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "254-271",
          "snippet": "static void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "vendor->name"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"CPU vendors do not match\")"
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"CPU vendor %s of model %s differs from \"\n                                 \"vendor %s\")",
            "model->vendor->name",
            "model->name",
            "vnd->name"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Unknown CPU vendor %s\")",
            "cpus[i]->vendor"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64VendorFind",
          "args": [
            "map",
            "cpus[i]->vendor"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64VendorFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "154-166",
          "snippet": "static struct ppc64_vendor *\nppc64VendorFind(const struct ppc64_map *map,\n                const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_vendor *\nppc64VendorFind(const struct ppc64_map *map,\n                const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "\"%s\"",
            "_(\"CPUs are incompatible\")"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "cpus[i]->model",
            "model->name"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown CPU model %s\")",
            "cpus[0]->model"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64ModelFind",
          "args": [
            "map",
            "cpus[0]->model"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64ModelFindPVR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "215-231",
          "snippet": "static struct ppc64_model *\nppc64ModelFindPVR(const struct ppc64_map *map,\n                  uint32_t pvr)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < map->nmodels; i++) {\n        struct ppc64_model *model = map->models[i];\n        for (j = 0; j < model->data.len; j++) {\n            if ((pvr & model->data.pvr[j].mask) == model->data.pvr[j].value)\n                return model;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_model *\nppc64ModelFindPVR(const struct ppc64_map *map,\n                  uint32_t pvr)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < map->nmodels; i++) {\n        struct ppc64_model *model = map->models[i];\n        for (j = 0; j < model->data.len; j++) {\n            if ((pvr & model->data.pvr[j].mask) == model->data.pvr[j].value)\n                return model;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64LoadMap",
          "args": [],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64LoadMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "391-407",
          "snippet": "static struct ppc64_map *\nppc64LoadMap(void)\n{\n    struct ppc64_map *map;\n\n    if (VIR_ALLOC(map) < 0)\n        goto error;\n\n    if (cpuMapLoad(\"ppc64\", ppc64VendorParse, NULL, ppc64ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    ppc64MapFree(map);\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_map *\nppc64LoadMap(void)\n{\n    struct ppc64_map *map;\n\n    if (VIR_ALLOC(map) < 0)\n        goto error;\n\n    if (cpuMapLoad(\"ppc64\", ppc64VendorParse, NULL, ppc64ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    ppc64MapFree(map);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUDefPtr\nvirCPUppc64Baseline(virCPUDefPtr *cpus,\n                    unsigned int ncpus,\n                    virDomainCapsCPUModelsPtr models G_GNUC_UNUSED,\n                    const char **features G_GNUC_UNUSED,\n                    bool migratable G_GNUC_UNUSED)\n{\n    struct ppc64_map *map;\n    const struct ppc64_model *model;\n    const struct ppc64_vendor *vendor = NULL;\n    virCPUDefPtr cpu = NULL;\n    size_t i;\n\n    if (!(map = ppc64LoadMap()))\n        goto error;\n\n    if (!(model = ppc64ModelFind(map, cpus[0]->model))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU model %s\"), cpus[0]->model);\n        goto error;\n    }\n\n    for (i = 0; i < ncpus; i++) {\n        const struct ppc64_vendor *vnd;\n\n        /* Hosts running old (<= 1.2.18) versions of libvirt will report\n         * strings like 'power7+' or 'power8e' instead of proper CPU model\n         * names in the capabilities XML; moreover, they lack information\n         * about some proper CPU models like 'POWER8'.\n         * This implies two things:\n         *   1) baseline among such hosts never worked\n         *   2) while a few models, eg. 'POWER8_v1.0', could work on both\n         *      old and new versions of libvirt, the information we have\n         *      here is not enough to pick such a model\n         * Hence we just compare models by name to decide whether or not\n         * two hosts are compatible */\n        if (STRNEQ(cpus[i]->model, model->name)) {\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"CPUs are incompatible\"));\n            goto error;\n        }\n\n        if (!cpus[i]->vendor)\n            continue;\n\n        if (!(vnd = ppc64VendorFind(map, cpus[i]->vendor))) {\n            virReportError(VIR_ERR_OPERATION_FAILED,\n                           _(\"Unknown CPU vendor %s\"), cpus[i]->vendor);\n            goto error;\n        }\n\n        if (model->vendor) {\n            if (model->vendor != vnd) {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"CPU vendor %s of model %s differs from \"\n                                 \"vendor %s\"),\n                               model->vendor->name, model->name,\n                               vnd->name);\n                goto error;\n            }\n        } else if (vendor) {\n            if (vendor != vnd) {\n                virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                               _(\"CPU vendors do not match\"));\n                goto error;\n            }\n        } else {\n            vendor = vnd;\n        }\n    }\n\n    cpu = virCPUDefNew();\n\n    cpu->model = g_strdup(model->name);\n\n    if (vendor)\n        cpu->vendor = g_strdup(vendor->name);\n\n    cpu->type = VIR_CPU_TYPE_GUEST;\n    cpu->match = VIR_CPU_MATCH_EXACT;\n    cpu->fallback = VIR_CPU_FALLBACK_FORBID;\n\n cleanup:\n    ppc64MapFree(map);\n\n    return cpu;\n\n error:\n    virCPUDefFree(cpu);\n    cpu = NULL;\n    goto cleanup;\n}"
  },
  {
    "function_name": "virCPUppc64Update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "667-683",
    "snippet": "static int\nvirCPUppc64Update(virCPUDefPtr guest,\n                  const virCPUDef *host G_GNUC_UNUSED)\n{\n    /*\n     * - host-passthrough doesn't even get here\n     * - host-model is used for host CPU running in a compatibility mode and\n     *   it needs to remain unchanged\n     * - custom doesn't support any optional features, there's nothing to\n     *   update\n     */\n\n    if (guest->mode == VIR_CPU_MODE_CUSTOM)\n        guest->match = VIR_CPU_MATCH_EXACT;\n\n    return 0;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUppc64Update(virCPUDefPtr guest,\n                  const virCPUDef *host G_GNUC_UNUSED)\n{\n    /*\n     * - host-passthrough doesn't even get here\n     * - host-model is used for host CPU running in a compatibility mode and\n     *   it needs to remain unchanged\n     * - custom doesn't support any optional features, there's nothing to\n     *   update\n     */\n\n    if (guest->mode == VIR_CPU_MODE_CUSTOM)\n        guest->match = VIR_CPU_MATCH_EXACT;\n\n    return 0;\n}"
  },
  {
    "function_name": "virCPUppc64GetHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "635-664",
    "snippet": "static int\nvirCPUppc64GetHost(virCPUDefPtr cpu,\n                   virDomainCapsCPUModelsPtr models)\n{\n    virCPUDataPtr cpuData = NULL;\n    virCPUppc64Data *data;\n    int ret = -1;\n\n    if (!(cpuData = virCPUDataNew(archs[0])))\n        goto cleanup;\n\n    data = &cpuData->data.ppc64;\n\n    if (VIR_ALLOC_N(data->pvr, 1) < 0)\n        goto cleanup;\n\n    data->len = 1;\n\n#if defined(__powerpc__) || defined(__powerpc64__)\n    asm(\"mfpvr %0\"\n        : \"=r\" (data->pvr[0].value));\n#endif\n    data->pvr[0].mask = 0xfffffffful;\n\n    ret = ppc64DriverDecode(cpu, cpuData, models);\n\n cleanup:\n    virCPUppc64DataFree(cpuData);\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const virArch archs[] = { VIR_ARCH_PPC64, VIR_ARCH_PPC64LE };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUppc64DataFree",
          "args": [
            "cpuData"
          ],
          "line": 662
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUppc64DataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "624-632",
          "snippet": "static void\nvirCPUppc64DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    ppc64DataClear(&data->data.ppc64);\n    VIR_FREE(data);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUppc64DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    ppc64DataClear(&data->data.ppc64);\n    VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64DriverDecode",
          "args": [
            "cpu",
            "cpuData",
            "models"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64DriverDecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "586-622",
          "snippet": "static int\nppc64DriverDecode(virCPUDefPtr cpu,\n                  const virCPUData *data,\n                  virDomainCapsCPUModelsPtr models)\n{\n    int ret = -1;\n    struct ppc64_map *map;\n    const struct ppc64_model *model;\n\n    if (!data || !(map = ppc64LoadMap()))\n        return -1;\n\n    if (!(model = ppc64ModelFindPVR(map, data->data.ppc64.pvr[0].value))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Cannot find CPU model with PVR 0x%08x\"),\n                       data->data.ppc64.pvr[0].value);\n        goto cleanup;\n    }\n\n    if (!virCPUModelIsAllowed(model->name, models)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"CPU model %s is not supported by hypervisor\"),\n                       model->name);\n        goto cleanup;\n    }\n\n    cpu->model = g_strdup(model->name);\n    if (model->vendor)\n        cpu->vendor = g_strdup(model->vendor->name);\n\n    ret = 0;\n\n cleanup:\n    ppc64MapFree(map);\n\n    return ret;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nppc64DriverDecode(virCPUDefPtr cpu,\n                  const virCPUData *data,\n                  virDomainCapsCPUModelsPtr models)\n{\n    int ret = -1;\n    struct ppc64_map *map;\n    const struct ppc64_model *model;\n\n    if (!data || !(map = ppc64LoadMap()))\n        return -1;\n\n    if (!(model = ppc64ModelFindPVR(map, data->data.ppc64.pvr[0].value))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Cannot find CPU model with PVR 0x%08x\"),\n                       data->data.ppc64.pvr[0].value);\n        goto cleanup;\n    }\n\n    if (!virCPUModelIsAllowed(model->name, models)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"CPU model %s is not supported by hypervisor\"),\n                       model->name);\n        goto cleanup;\n    }\n\n    cpu->model = g_strdup(model->name);\n    if (model->vendor)\n        cpu->vendor = g_strdup(model->vendor->name);\n\n    ret = 0;\n\n cleanup:\n    ppc64MapFree(map);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "data->pvr",
            "1"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDataNew",
          "args": [
            "archs[0]"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "290-301",
          "snippet": "virCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic const virArch archs[] = { VIR_ARCH_PPC64, VIR_ARCH_PPC64LE };\n\nstatic int\nvirCPUppc64GetHost(virCPUDefPtr cpu,\n                   virDomainCapsCPUModelsPtr models)\n{\n    virCPUDataPtr cpuData = NULL;\n    virCPUppc64Data *data;\n    int ret = -1;\n\n    if (!(cpuData = virCPUDataNew(archs[0])))\n        goto cleanup;\n\n    data = &cpuData->data.ppc64;\n\n    if (VIR_ALLOC_N(data->pvr, 1) < 0)\n        goto cleanup;\n\n    data->len = 1;\n\n#if defined(__powerpc__) || defined(__powerpc64__)\n    asm(\"mfpvr %0\"\n        : \"=r\" (data->pvr[0].value));\n#endif\n    data->pvr[0].mask = 0xfffffffful;\n\n    ret = ppc64DriverDecode(cpu, cpuData, models);\n\n cleanup:\n    virCPUppc64DataFree(cpuData);\n    return ret;\n}"
  },
  {
    "function_name": "virCPUppc64DataFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "624-632",
    "snippet": "static void\nvirCPUppc64DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    ppc64DataClear(&data->data.ppc64);\n    VIR_FREE(data);\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64DataClear",
          "args": [
            "&data->data.ppc64"
          ],
          "line": 630
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64DataClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "117-124",
          "snippet": "static void\nppc64DataClear(virCPUppc64Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->pvr);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64DataClear(virCPUppc64Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->pvr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nvirCPUppc64DataFree(virCPUDataPtr data)\n{\n    if (!data)\n        return;\n\n    ppc64DataClear(&data->data.ppc64);\n    VIR_FREE(data);\n}"
  },
  {
    "function_name": "ppc64DriverDecode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "586-622",
    "snippet": "static int\nppc64DriverDecode(virCPUDefPtr cpu,\n                  const virCPUData *data,\n                  virDomainCapsCPUModelsPtr models)\n{\n    int ret = -1;\n    struct ppc64_map *map;\n    const struct ppc64_model *model;\n\n    if (!data || !(map = ppc64LoadMap()))\n        return -1;\n\n    if (!(model = ppc64ModelFindPVR(map, data->data.ppc64.pvr[0].value))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Cannot find CPU model with PVR 0x%08x\"),\n                       data->data.ppc64.pvr[0].value);\n        goto cleanup;\n    }\n\n    if (!virCPUModelIsAllowed(model->name, models)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"CPU model %s is not supported by hypervisor\"),\n                       model->name);\n        goto cleanup;\n    }\n\n    cpu->model = g_strdup(model->name);\n    if (model->vendor)\n        cpu->vendor = g_strdup(model->vendor->name);\n\n    ret = 0;\n\n cleanup:\n    ppc64MapFree(map);\n\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc64MapFree",
          "args": [
            "map"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64MapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "254-271",
          "snippet": "static void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "model->vendor->name"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CONFIG_UNSUPPORTED",
            "_(\"CPU model %s is not supported by hypervisor\")",
            "model->name"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUModelIsAllowed",
          "args": [
            "model->name",
            "models"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUModelIsAllowed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "823-831",
          "snippet": "bool\nvirCPUModelIsAllowed(const char *model,\n                     virDomainCapsCPUModelsPtr models)\n{\n    if (!models)\n        return true;\n\n    return !!virDomainCapsCPUModelsGet(models, model);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nbool\nvirCPUModelIsAllowed(const char *model,\n                     virDomainCapsCPUModelsPtr models)\n{\n    if (!models)\n        return true;\n\n    return !!virDomainCapsCPUModelsGet(models, model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_OPERATION_FAILED",
            "_(\"Cannot find CPU model with PVR 0x%08x\")",
            "data->data.ppc64.pvr[0].value"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64ModelFindPVR",
          "args": [
            "map",
            "data->data.ppc64.pvr[0].value"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64ModelFindPVR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "215-231",
          "snippet": "static struct ppc64_model *\nppc64ModelFindPVR(const struct ppc64_map *map,\n                  uint32_t pvr)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < map->nmodels; i++) {\n        struct ppc64_model *model = map->models[i];\n        for (j = 0; j < model->data.len; j++) {\n            if ((pvr & model->data.pvr[j].mask) == model->data.pvr[j].value)\n                return model;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_model *\nppc64ModelFindPVR(const struct ppc64_map *map,\n                  uint32_t pvr)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < map->nmodels; i++) {\n        struct ppc64_model *model = map->models[i];\n        for (j = 0; j < model->data.len; j++) {\n            if ((pvr & model->data.pvr[j].mask) == model->data.pvr[j].value)\n                return model;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64LoadMap",
          "args": [],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64LoadMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "391-407",
          "snippet": "static struct ppc64_map *\nppc64LoadMap(void)\n{\n    struct ppc64_map *map;\n\n    if (VIR_ALLOC(map) < 0)\n        goto error;\n\n    if (cpuMapLoad(\"ppc64\", ppc64VendorParse, NULL, ppc64ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    ppc64MapFree(map);\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_map *\nppc64LoadMap(void)\n{\n    struct ppc64_map *map;\n\n    if (VIR_ALLOC(map) < 0)\n        goto error;\n\n    if (cpuMapLoad(\"ppc64\", ppc64VendorParse, NULL, ppc64ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    ppc64MapFree(map);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nppc64DriverDecode(virCPUDefPtr cpu,\n                  const virCPUData *data,\n                  virDomainCapsCPUModelsPtr models)\n{\n    int ret = -1;\n    struct ppc64_map *map;\n    const struct ppc64_model *model;\n\n    if (!data || !(map = ppc64LoadMap()))\n        return -1;\n\n    if (!(model = ppc64ModelFindPVR(map, data->data.ppc64.pvr[0].value))) {\n        virReportError(VIR_ERR_OPERATION_FAILED,\n                       _(\"Cannot find CPU model with PVR 0x%08x\"),\n                       data->data.ppc64.pvr[0].value);\n        goto cleanup;\n    }\n\n    if (!virCPUModelIsAllowed(model->name, models)) {\n        virReportError(VIR_ERR_CONFIG_UNSUPPORTED,\n                       _(\"CPU model %s is not supported by hypervisor\"),\n                       model->name);\n        goto cleanup;\n    }\n\n    cpu->model = g_strdup(model->name);\n    if (model->vendor)\n        cpu->vendor = g_strdup(model->vendor->name);\n\n    ret = 0;\n\n cleanup:\n    ppc64MapFree(map);\n\n    return ret;\n}"
  },
  {
    "function_name": "virCPUppc64Compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "552-584",
    "snippet": "static virCPUCompareResult\nvirCPUppc64Compare(virCPUDefPtr host,\n                   virCPUDefPtr cpu,\n                   bool failIncompatible)\n{\n    virCPUCompareResult ret;\n    char *message = NULL;\n\n    if (!host || !host->model) {\n        if (failIncompatible) {\n            virReportError(VIR_ERR_CPU_INCOMPATIBLE, \"%s\",\n                           _(\"unknown host CPU\"));\n        } else {\n            VIR_WARN(\"unknown host CPU\");\n            ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        }\n        return -1;\n    }\n\n    ret = ppc64Compute(host, cpu, NULL, &message);\n\n    if (failIncompatible && ret == VIR_CPU_COMPARE_INCOMPATIBLE) {\n        ret = VIR_CPU_COMPARE_ERROR;\n        if (message) {\n            virReportError(VIR_ERR_CPU_INCOMPATIBLE, \"%s\", message);\n        } else {\n            virReportError(VIR_ERR_CPU_INCOMPATIBLE, NULL);\n        }\n    }\n    VIR_FREE(message);\n\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "message"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CPU_INCOMPATIBLE",
            "NULL"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CPU_INCOMPATIBLE",
            "\"%s\"",
            "message"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64Compute",
          "args": [
            "host",
            "cpu",
            "NULL",
            "&message"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64Compute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "426-550",
          "snippet": "static virCPUCompareResult\nppc64Compute(virCPUDefPtr host,\n             const virCPUDef *other,\n             virCPUDataPtr *guestData,\n             char **message)\n{\n    struct ppc64_map *map = NULL;\n    struct ppc64_model *host_model = NULL;\n    struct ppc64_model *guest_model = NULL;\n    virCPUDefPtr cpu = NULL;\n    virCPUCompareResult ret = VIR_CPU_COMPARE_ERROR;\n    virArch arch;\n    size_t i;\n\n    /* Ensure existing configurations are handled correctly */\n    if (!(cpu = virCPUDefCopy(other)) ||\n        virCPUppc64ConvertLegacy(cpu) < 0)\n        goto cleanup;\n\n    if (cpu->arch != VIR_ARCH_NONE) {\n        bool found = false;\n\n        for (i = 0; i < G_N_ELEMENTS(archs); i++) {\n            if (archs[i] == cpu->arch) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            VIR_DEBUG(\"CPU arch %s does not match host arch\",\n                      virArchToString(cpu->arch));\n            if (message)\n                *message = g_strdup_printf(_(\"CPU arch %s does not match host arch\"),\n                                           virArchToString(cpu->arch));\n\n            ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n            goto cleanup;\n        }\n        arch = cpu->arch;\n    } else {\n        arch = host->arch;\n    }\n\n    if (cpu->vendor &&\n        (!host->vendor || STRNEQ(cpu->vendor, host->vendor))) {\n        VIR_DEBUG(\"host CPU vendor does not match required CPU vendor %s\",\n                  cpu->vendor);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU vendor does not match required \"\n                                         \"CPU vendor %s\"),\n                                       cpu->vendor);\n        }\n\n        ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        goto cleanup;\n    }\n\n    if (!(map = ppc64LoadMap()))\n        goto cleanup;\n\n    /* Host CPU information */\n    if (!(host_model = ppc64ModelFromCPU(host, map)))\n        goto cleanup;\n\n    if (cpu->type == VIR_CPU_TYPE_GUEST) {\n        /* Guest CPU information */\n        virCPUCompareResult tmp;\n        switch (cpu->mode) {\n        case VIR_CPU_MODE_HOST_MODEL:\n            /* host-model only:\n             * we need to take compatibility modes into account */\n            tmp = ppc64CheckCompatibilityMode(host->model, cpu->model);\n            if (tmp != VIR_CPU_COMPARE_IDENTICAL) {\n                ret = tmp;\n                goto cleanup;\n            }\n            G_GNUC_FALLTHROUGH;\n\n        case VIR_CPU_MODE_HOST_PASSTHROUGH:\n            /* host-model and host-passthrough:\n             * the guest CPU is the same as the host */\n            guest_model = ppc64ModelCopy(host_model);\n            break;\n\n        case VIR_CPU_MODE_CUSTOM:\n            /* custom:\n             * look up guest CPU information */\n            guest_model = ppc64ModelFromCPU(cpu, map);\n            break;\n        }\n    } else {\n        /* Other host CPU information */\n        guest_model = ppc64ModelFromCPU(cpu, map);\n    }\n\n    if (!guest_model)\n        goto cleanup;\n\n    if (STRNEQ(guest_model->name, host_model->name)) {\n        VIR_DEBUG(\"host CPU model does not match required CPU model %s\",\n                  guest_model->name);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU model does not match required \"\n                                         \"CPU model %s\"),\n                                       guest_model->name);\n        }\n\n        ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        goto cleanup;\n    }\n\n    if (guestData)\n        if (!(*guestData = ppc64MakeCPUData(arch, &guest_model->data)))\n            goto cleanup;\n\n    ret = VIR_CPU_COMPARE_IDENTICAL;\n\n cleanup:\n    virCPUDefFree(cpu);\n    ppc64MapFree(map);\n    ppc64ModelFree(host_model);\n    ppc64ModelFree(guest_model);\n    return ret;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const virArch archs[] = { VIR_ARCH_PPC64, VIR_ARCH_PPC64LE };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic const virArch archs[] = { VIR_ARCH_PPC64, VIR_ARCH_PPC64LE };\n\nstatic virCPUCompareResult\nppc64Compute(virCPUDefPtr host,\n             const virCPUDef *other,\n             virCPUDataPtr *guestData,\n             char **message)\n{\n    struct ppc64_map *map = NULL;\n    struct ppc64_model *host_model = NULL;\n    struct ppc64_model *guest_model = NULL;\n    virCPUDefPtr cpu = NULL;\n    virCPUCompareResult ret = VIR_CPU_COMPARE_ERROR;\n    virArch arch;\n    size_t i;\n\n    /* Ensure existing configurations are handled correctly */\n    if (!(cpu = virCPUDefCopy(other)) ||\n        virCPUppc64ConvertLegacy(cpu) < 0)\n        goto cleanup;\n\n    if (cpu->arch != VIR_ARCH_NONE) {\n        bool found = false;\n\n        for (i = 0; i < G_N_ELEMENTS(archs); i++) {\n            if (archs[i] == cpu->arch) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            VIR_DEBUG(\"CPU arch %s does not match host arch\",\n                      virArchToString(cpu->arch));\n            if (message)\n                *message = g_strdup_printf(_(\"CPU arch %s does not match host arch\"),\n                                           virArchToString(cpu->arch));\n\n            ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n            goto cleanup;\n        }\n        arch = cpu->arch;\n    } else {\n        arch = host->arch;\n    }\n\n    if (cpu->vendor &&\n        (!host->vendor || STRNEQ(cpu->vendor, host->vendor))) {\n        VIR_DEBUG(\"host CPU vendor does not match required CPU vendor %s\",\n                  cpu->vendor);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU vendor does not match required \"\n                                         \"CPU vendor %s\"),\n                                       cpu->vendor);\n        }\n\n        ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        goto cleanup;\n    }\n\n    if (!(map = ppc64LoadMap()))\n        goto cleanup;\n\n    /* Host CPU information */\n    if (!(host_model = ppc64ModelFromCPU(host, map)))\n        goto cleanup;\n\n    if (cpu->type == VIR_CPU_TYPE_GUEST) {\n        /* Guest CPU information */\n        virCPUCompareResult tmp;\n        switch (cpu->mode) {\n        case VIR_CPU_MODE_HOST_MODEL:\n            /* host-model only:\n             * we need to take compatibility modes into account */\n            tmp = ppc64CheckCompatibilityMode(host->model, cpu->model);\n            if (tmp != VIR_CPU_COMPARE_IDENTICAL) {\n                ret = tmp;\n                goto cleanup;\n            }\n            G_GNUC_FALLTHROUGH;\n\n        case VIR_CPU_MODE_HOST_PASSTHROUGH:\n            /* host-model and host-passthrough:\n             * the guest CPU is the same as the host */\n            guest_model = ppc64ModelCopy(host_model);\n            break;\n\n        case VIR_CPU_MODE_CUSTOM:\n            /* custom:\n             * look up guest CPU information */\n            guest_model = ppc64ModelFromCPU(cpu, map);\n            break;\n        }\n    } else {\n        /* Other host CPU information */\n        guest_model = ppc64ModelFromCPU(cpu, map);\n    }\n\n    if (!guest_model)\n        goto cleanup;\n\n    if (STRNEQ(guest_model->name, host_model->name)) {\n        VIR_DEBUG(\"host CPU model does not match required CPU model %s\",\n                  guest_model->name);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU model does not match required \"\n                                         \"CPU model %s\"),\n                                       guest_model->name);\n        }\n\n        ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        goto cleanup;\n    }\n\n    if (guestData)\n        if (!(*guestData = ppc64MakeCPUData(arch, &guest_model->data)))\n            goto cleanup;\n\n    ret = VIR_CPU_COMPARE_IDENTICAL;\n\n cleanup:\n    virCPUDefFree(cpu);\n    ppc64MapFree(map);\n    ppc64ModelFree(host_model);\n    ppc64ModelFree(guest_model);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"unknown host CPU\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_CPU_INCOMPATIBLE",
            "\"%s\"",
            "_(\"unknown host CPU\")"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"unknown host CPU\""
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUCompareResult\nvirCPUppc64Compare(virCPUDefPtr host,\n                   virCPUDefPtr cpu,\n                   bool failIncompatible)\n{\n    virCPUCompareResult ret;\n    char *message = NULL;\n\n    if (!host || !host->model) {\n        if (failIncompatible) {\n            virReportError(VIR_ERR_CPU_INCOMPATIBLE, \"%s\",\n                           _(\"unknown host CPU\"));\n        } else {\n            VIR_WARN(\"unknown host CPU\");\n            ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        }\n        return -1;\n    }\n\n    ret = ppc64Compute(host, cpu, NULL, &message);\n\n    if (failIncompatible && ret == VIR_CPU_COMPARE_INCOMPATIBLE) {\n        ret = VIR_CPU_COMPARE_ERROR;\n        if (message) {\n            virReportError(VIR_ERR_CPU_INCOMPATIBLE, \"%s\", message);\n        } else {\n            virReportError(VIR_ERR_CPU_INCOMPATIBLE, NULL);\n        }\n    }\n    VIR_FREE(message);\n\n    return ret;\n}"
  },
  {
    "function_name": "ppc64Compute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "426-550",
    "snippet": "static virCPUCompareResult\nppc64Compute(virCPUDefPtr host,\n             const virCPUDef *other,\n             virCPUDataPtr *guestData,\n             char **message)\n{\n    struct ppc64_map *map = NULL;\n    struct ppc64_model *host_model = NULL;\n    struct ppc64_model *guest_model = NULL;\n    virCPUDefPtr cpu = NULL;\n    virCPUCompareResult ret = VIR_CPU_COMPARE_ERROR;\n    virArch arch;\n    size_t i;\n\n    /* Ensure existing configurations are handled correctly */\n    if (!(cpu = virCPUDefCopy(other)) ||\n        virCPUppc64ConvertLegacy(cpu) < 0)\n        goto cleanup;\n\n    if (cpu->arch != VIR_ARCH_NONE) {\n        bool found = false;\n\n        for (i = 0; i < G_N_ELEMENTS(archs); i++) {\n            if (archs[i] == cpu->arch) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            VIR_DEBUG(\"CPU arch %s does not match host arch\",\n                      virArchToString(cpu->arch));\n            if (message)\n                *message = g_strdup_printf(_(\"CPU arch %s does not match host arch\"),\n                                           virArchToString(cpu->arch));\n\n            ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n            goto cleanup;\n        }\n        arch = cpu->arch;\n    } else {\n        arch = host->arch;\n    }\n\n    if (cpu->vendor &&\n        (!host->vendor || STRNEQ(cpu->vendor, host->vendor))) {\n        VIR_DEBUG(\"host CPU vendor does not match required CPU vendor %s\",\n                  cpu->vendor);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU vendor does not match required \"\n                                         \"CPU vendor %s\"),\n                                       cpu->vendor);\n        }\n\n        ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        goto cleanup;\n    }\n\n    if (!(map = ppc64LoadMap()))\n        goto cleanup;\n\n    /* Host CPU information */\n    if (!(host_model = ppc64ModelFromCPU(host, map)))\n        goto cleanup;\n\n    if (cpu->type == VIR_CPU_TYPE_GUEST) {\n        /* Guest CPU information */\n        virCPUCompareResult tmp;\n        switch (cpu->mode) {\n        case VIR_CPU_MODE_HOST_MODEL:\n            /* host-model only:\n             * we need to take compatibility modes into account */\n            tmp = ppc64CheckCompatibilityMode(host->model, cpu->model);\n            if (tmp != VIR_CPU_COMPARE_IDENTICAL) {\n                ret = tmp;\n                goto cleanup;\n            }\n            G_GNUC_FALLTHROUGH;\n\n        case VIR_CPU_MODE_HOST_PASSTHROUGH:\n            /* host-model and host-passthrough:\n             * the guest CPU is the same as the host */\n            guest_model = ppc64ModelCopy(host_model);\n            break;\n\n        case VIR_CPU_MODE_CUSTOM:\n            /* custom:\n             * look up guest CPU information */\n            guest_model = ppc64ModelFromCPU(cpu, map);\n            break;\n        }\n    } else {\n        /* Other host CPU information */\n        guest_model = ppc64ModelFromCPU(cpu, map);\n    }\n\n    if (!guest_model)\n        goto cleanup;\n\n    if (STRNEQ(guest_model->name, host_model->name)) {\n        VIR_DEBUG(\"host CPU model does not match required CPU model %s\",\n                  guest_model->name);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU model does not match required \"\n                                         \"CPU model %s\"),\n                                       guest_model->name);\n        }\n\n        ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        goto cleanup;\n    }\n\n    if (guestData)\n        if (!(*guestData = ppc64MakeCPUData(arch, &guest_model->data)))\n            goto cleanup;\n\n    ret = VIR_CPU_COMPARE_IDENTICAL;\n\n cleanup:\n    virCPUDefFree(cpu);\n    ppc64MapFree(map);\n    ppc64ModelFree(host_model);\n    ppc64ModelFree(guest_model);\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const virArch archs[] = { VIR_ARCH_PPC64, VIR_ARCH_PPC64LE };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc64ModelFree",
          "args": [
            "guest_model"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "168-177",
          "snippet": "static void\nppc64ModelFree(struct ppc64_model *model)\n{\n    if (!model)\n        return;\n\n    ppc64DataClear(&model->data);\n    VIR_FREE(model->name);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64ModelFree(struct ppc64_model *model)\n{\n    if (!model)\n        return;\n\n    ppc64DataClear(&model->data);\n    VIR_FREE(model->name);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64MapFree",
          "args": [
            "map"
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64MapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "254-271",
          "snippet": "static void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "cpu"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64MakeCPUData",
          "args": [
            "arch",
            "&guest_model->data"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64MakeCPUData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "409-424",
          "snippet": "static virCPUDataPtr\nppc64MakeCPUData(virArch arch,\n                 virCPUppc64Data *data)\n{\n    virCPUDataPtr cpuData;\n\n    if (VIR_ALLOC(cpuData) < 0)\n        return NULL;\n\n    cpuData->arch = arch;\n\n    if (ppc64DataCopy(&cpuData->data.ppc64, data) < 0)\n        VIR_FREE(cpuData);\n\n    return cpuData;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUDataPtr\nppc64MakeCPUData(virArch arch,\n                 virCPUppc64Data *data)\n{\n    virCPUDataPtr cpuData;\n\n    if (VIR_ALLOC(cpuData) < 0)\n        return NULL;\n\n    cpuData->arch = arch;\n\n    if (ppc64DataCopy(&cpuData->data.ppc64, data) < 0)\n        VIR_FREE(cpuData);\n\n    return cpuData;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "_(\"host CPU model does not match required \"\n                                         \"CPU model %s\")",
            "guest_model->name"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"host CPU model does not match required CPU model %s\"",
            "guest_model->name"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "guest_model->name",
            "host_model->name"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64ModelFromCPU",
          "args": [
            "cpu",
            "map"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64ModelFromCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "233-252",
          "snippet": "static struct ppc64_model *\nppc64ModelFromCPU(const virCPUDef *cpu,\n                  const struct ppc64_map *map)\n{\n    struct ppc64_model *model;\n\n    if (!cpu->model) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"no CPU model specified\"));\n        return NULL;\n    }\n\n    if (!(model = ppc64ModelFind(map, cpu->model))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU model %s\"), cpu->model);\n        return NULL;\n    }\n\n    return ppc64ModelCopy(model);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_model *\nppc64ModelFromCPU(const virCPUDef *cpu,\n                  const struct ppc64_map *map)\n{\n    struct ppc64_model *model;\n\n    if (!cpu->model) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"no CPU model specified\"));\n        return NULL;\n    }\n\n    if (!(model = ppc64ModelFind(map, cpu->model))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU model %s\"), cpu->model);\n        return NULL;\n    }\n\n    return ppc64ModelCopy(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64ModelCopy",
          "args": [
            "host_model"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64ModelCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "179-199",
          "snippet": "static struct ppc64_model *\nppc64ModelCopy(const struct ppc64_model *model)\n{\n    struct ppc64_model *copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        goto error;\n\n    copy->name = g_strdup(model->name);\n\n    if (ppc64DataCopy(&copy->data, &model->data) < 0)\n        goto error;\n\n    copy->vendor = model->vendor;\n\n    return copy;\n\n error:\n    ppc64ModelFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_model *\nppc64ModelCopy(const struct ppc64_model *model)\n{\n    struct ppc64_model *copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        goto error;\n\n    copy->name = g_strdup(model->name);\n\n    if (ppc64DataCopy(&copy->data, &model->data) < 0)\n        goto error;\n\n    copy->vendor = model->vendor;\n\n    return copy;\n\n error:\n    ppc64ModelFree(copy);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64CheckCompatibilityMode",
          "args": [
            "host->model",
            "cpu->model"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64CheckCompatibilityMode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "77-115",
          "snippet": "static virCPUCompareResult\nppc64CheckCompatibilityMode(const char *host_model,\n                            const char *compat_mode)\n{\n    int host;\n    int compat;\n    char *tmp;\n\n    if (!compat_mode)\n        return VIR_CPU_COMPARE_IDENTICAL;\n\n    /* Valid host CPUs: POWER6, POWER7, POWER8, POWER9 */\n    if (!STRPREFIX(host_model, \"POWER\") ||\n        !(tmp = (char *) host_model + strlen(\"POWER\")) ||\n        virStrToLong_i(tmp, NULL, 10, &host) < 0 ||\n        host < 6 || host > 9) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"Host CPU does not support compatibility modes\"));\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    /* Valid compatibility modes: power6, power7, power8, power9 */\n    if (!STRPREFIX(compat_mode, \"power\") ||\n        !(tmp = (char *) compat_mode + strlen(\"power\")) ||\n        virStrToLong_i(tmp, NULL, 10, &compat) < 0 ||\n        compat < 6 || compat > 9) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown compatibility mode %s\"),\n                       compat_mode);\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    /* Version check */\n    if (compat > host)\n        return VIR_CPU_COMPARE_INCOMPATIBLE;\n\n    return VIR_CPU_COMPARE_IDENTICAL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUCompareResult\nppc64CheckCompatibilityMode(const char *host_model,\n                            const char *compat_mode)\n{\n    int host;\n    int compat;\n    char *tmp;\n\n    if (!compat_mode)\n        return VIR_CPU_COMPARE_IDENTICAL;\n\n    /* Valid host CPUs: POWER6, POWER7, POWER8, POWER9 */\n    if (!STRPREFIX(host_model, \"POWER\") ||\n        !(tmp = (char *) host_model + strlen(\"POWER\")) ||\n        virStrToLong_i(tmp, NULL, 10, &host) < 0 ||\n        host < 6 || host > 9) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"Host CPU does not support compatibility modes\"));\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    /* Valid compatibility modes: power6, power7, power8, power9 */\n    if (!STRPREFIX(compat_mode, \"power\") ||\n        !(tmp = (char *) compat_mode + strlen(\"power\")) ||\n        virStrToLong_i(tmp, NULL, 10, &compat) < 0 ||\n        compat < 6 || compat > 9) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown compatibility mode %s\"),\n                       compat_mode);\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    /* Version check */\n    if (compat > host)\n        return VIR_CPU_COMPARE_INCOMPATIBLE;\n\n    return VIR_CPU_COMPARE_IDENTICAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64LoadMap",
          "args": [],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64LoadMap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "391-407",
          "snippet": "static struct ppc64_map *\nppc64LoadMap(void)\n{\n    struct ppc64_map *map;\n\n    if (VIR_ALLOC(map) < 0)\n        goto error;\n\n    if (cpuMapLoad(\"ppc64\", ppc64VendorParse, NULL, ppc64ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    ppc64MapFree(map);\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_map *\nppc64LoadMap(void)\n{\n    struct ppc64_map *map;\n\n    if (VIR_ALLOC(map) < 0)\n        goto error;\n\n    if (cpuMapLoad(\"ppc64\", ppc64VendorParse, NULL, ppc64ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    ppc64MapFree(map);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"host CPU vendor does not match required CPU vendor %s\"",
            "cpu->vendor"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "cpu->vendor",
            "host->vendor"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virArchToString",
          "args": [
            "cpu->arch"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "virArchToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "126-132",
          "snippet": "const char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nstatic const struct virArchData {\n    const char *name;\n    unsigned int wordsize;\n    virArchEndian endian;\n} virArchData[] = {\n    { \"none\",          0, VIR_ARCH_LITTLE_ENDIAN },\n    { \"alpha\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"armv6l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7l\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"armv7b\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"aarch64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"cris\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"i686\",         32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ia64\",         64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"lm32\",         32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"m68k\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblaze\",   32, VIR_ARCH_BIG_ENDIAN },\n    { \"microblazeel\", 32, VIR_ARCH_LITTLE_ENDIAN},\n    { \"mips\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"mipsel\",       32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"mips64\",       64, VIR_ARCH_BIG_ENDIAN },\n    { \"mips64el\",     64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"openrisc\",     32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc\",       32, VIR_ARCH_BIG_ENDIAN },\n    { \"parisc64\",     64, VIR_ARCH_BIG_ENDIAN },\n\n    { \"ppc\",          32, VIR_ARCH_BIG_ENDIAN },\n    { \"ppcle\",        32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppc64\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"ppc64le\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"ppcemb\",       32, VIR_ARCH_BIG_ENDIAN },\n\n    { \"riscv32\",      32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"riscv64\",      64, VIR_ARCH_LITTLE_ENDIAN },\n    { \"s390\",         32, VIR_ARCH_BIG_ENDIAN },\n    { \"s390x\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sh4\",          32, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"sh4eb\",        64, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc\",        32, VIR_ARCH_BIG_ENDIAN },\n    { \"sparc64\",      64, VIR_ARCH_BIG_ENDIAN },\n    { \"unicore32\",    32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"x86_64\",       64, VIR_ARCH_LITTLE_ENDIAN },\n\n    { \"xtensa\",       32, VIR_ARCH_LITTLE_ENDIAN },\n    { \"xtensaeb\",     32, VIR_ARCH_BIG_ENDIAN },\n};\n\nconst char *virArchToString(virArch arch)\n{\n    if (arch >= VIR_ARCH_LAST)\n        arch = VIR_ARCH_NONE;\n\n    return virArchData[arch].name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"CPU arch %s does not match host arch\"",
            "virArchToString(cpu->arch)"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "archs"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUppc64ConvertLegacy",
          "args": [
            "cpu"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUppc64ConvertLegacy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "60-72",
          "snippet": "static int\nvirCPUppc64ConvertLegacy(virCPUDefPtr cpu)\n{\n    if (cpu->model &&\n        (STREQ(cpu->model, \"POWER7_v2.1\") ||\n         STREQ(cpu->model, \"POWER7_v2.3\") ||\n         STREQ(cpu->model, \"POWER7+_v2.1\") ||\n         STREQ(cpu->model, \"POWER8_v1.0\"))) {\n        cpu->model[strlen(\"POWERx\")] = 0;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUppc64ConvertLegacy(virCPUDefPtr cpu)\n{\n    if (cpu->model &&\n        (STREQ(cpu->model, \"POWER7_v2.1\") ||\n         STREQ(cpu->model, \"POWER7_v2.3\") ||\n         STREQ(cpu->model, \"POWER7+_v2.1\") ||\n         STREQ(cpu->model, \"POWER8_v1.0\"))) {\n        cpu->model[strlen(\"POWERx\")] = 0;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefCopy",
          "args": [
            "other"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "269-285",
          "snippet": "virCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr\nvirCPUDefCopy(const virCPUDef *cpu)\n{\n    virCPUDefPtr copy;\n\n    if (!(copy = virCPUDefCopyWithoutModel(cpu)))\n        return NULL;\n\n    if (virCPUDefCopyModel(copy, cpu, false) < 0)\n        goto error;\n\n    return copy;\n\n error:\n    virCPUDefFree(copy);\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic const virArch archs[] = { VIR_ARCH_PPC64, VIR_ARCH_PPC64LE };\n\nstatic virCPUCompareResult\nppc64Compute(virCPUDefPtr host,\n             const virCPUDef *other,\n             virCPUDataPtr *guestData,\n             char **message)\n{\n    struct ppc64_map *map = NULL;\n    struct ppc64_model *host_model = NULL;\n    struct ppc64_model *guest_model = NULL;\n    virCPUDefPtr cpu = NULL;\n    virCPUCompareResult ret = VIR_CPU_COMPARE_ERROR;\n    virArch arch;\n    size_t i;\n\n    /* Ensure existing configurations are handled correctly */\n    if (!(cpu = virCPUDefCopy(other)) ||\n        virCPUppc64ConvertLegacy(cpu) < 0)\n        goto cleanup;\n\n    if (cpu->arch != VIR_ARCH_NONE) {\n        bool found = false;\n\n        for (i = 0; i < G_N_ELEMENTS(archs); i++) {\n            if (archs[i] == cpu->arch) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            VIR_DEBUG(\"CPU arch %s does not match host arch\",\n                      virArchToString(cpu->arch));\n            if (message)\n                *message = g_strdup_printf(_(\"CPU arch %s does not match host arch\"),\n                                           virArchToString(cpu->arch));\n\n            ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n            goto cleanup;\n        }\n        arch = cpu->arch;\n    } else {\n        arch = host->arch;\n    }\n\n    if (cpu->vendor &&\n        (!host->vendor || STRNEQ(cpu->vendor, host->vendor))) {\n        VIR_DEBUG(\"host CPU vendor does not match required CPU vendor %s\",\n                  cpu->vendor);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU vendor does not match required \"\n                                         \"CPU vendor %s\"),\n                                       cpu->vendor);\n        }\n\n        ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        goto cleanup;\n    }\n\n    if (!(map = ppc64LoadMap()))\n        goto cleanup;\n\n    /* Host CPU information */\n    if (!(host_model = ppc64ModelFromCPU(host, map)))\n        goto cleanup;\n\n    if (cpu->type == VIR_CPU_TYPE_GUEST) {\n        /* Guest CPU information */\n        virCPUCompareResult tmp;\n        switch (cpu->mode) {\n        case VIR_CPU_MODE_HOST_MODEL:\n            /* host-model only:\n             * we need to take compatibility modes into account */\n            tmp = ppc64CheckCompatibilityMode(host->model, cpu->model);\n            if (tmp != VIR_CPU_COMPARE_IDENTICAL) {\n                ret = tmp;\n                goto cleanup;\n            }\n            G_GNUC_FALLTHROUGH;\n\n        case VIR_CPU_MODE_HOST_PASSTHROUGH:\n            /* host-model and host-passthrough:\n             * the guest CPU is the same as the host */\n            guest_model = ppc64ModelCopy(host_model);\n            break;\n\n        case VIR_CPU_MODE_CUSTOM:\n            /* custom:\n             * look up guest CPU information */\n            guest_model = ppc64ModelFromCPU(cpu, map);\n            break;\n        }\n    } else {\n        /* Other host CPU information */\n        guest_model = ppc64ModelFromCPU(cpu, map);\n    }\n\n    if (!guest_model)\n        goto cleanup;\n\n    if (STRNEQ(guest_model->name, host_model->name)) {\n        VIR_DEBUG(\"host CPU model does not match required CPU model %s\",\n                  guest_model->name);\n        if (message) {\n            *message = g_strdup_printf(_(\"host CPU model does not match required \"\n                                         \"CPU model %s\"),\n                                       guest_model->name);\n        }\n\n        ret = VIR_CPU_COMPARE_INCOMPATIBLE;\n        goto cleanup;\n    }\n\n    if (guestData)\n        if (!(*guestData = ppc64MakeCPUData(arch, &guest_model->data)))\n            goto cleanup;\n\n    ret = VIR_CPU_COMPARE_IDENTICAL;\n\n cleanup:\n    virCPUDefFree(cpu);\n    ppc64MapFree(map);\n    ppc64ModelFree(host_model);\n    ppc64ModelFree(guest_model);\n    return ret;\n}"
  },
  {
    "function_name": "ppc64MakeCPUData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "409-424",
    "snippet": "static virCPUDataPtr\nppc64MakeCPUData(virArch arch,\n                 virCPUppc64Data *data)\n{\n    virCPUDataPtr cpuData;\n\n    if (VIR_ALLOC(cpuData) < 0)\n        return NULL;\n\n    cpuData->arch = arch;\n\n    if (ppc64DataCopy(&cpuData->data.ppc64, data) < 0)\n        VIR_FREE(cpuData);\n\n    return cpuData;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpuData"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64DataCopy",
          "args": [
            "&cpuData->data.ppc64",
            "data"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64DataCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "126-142",
          "snippet": "static int\nppc64DataCopy(virCPUppc64Data *dst, const virCPUppc64Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->pvr, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n\n    for (i = 0; i < src->len; i++) {\n        dst->pvr[i].value = src->pvr[i].value;\n        dst->pvr[i].mask = src->pvr[i].mask;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nppc64DataCopy(virCPUppc64Data *dst, const virCPUppc64Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->pvr, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n\n    for (i = 0; i < src->len; i++) {\n        dst->pvr[i].value = src->pvr[i].value;\n        dst->pvr[i].mask = src->pvr[i].mask;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "cpuData"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUDataPtr\nppc64MakeCPUData(virArch arch,\n                 virCPUppc64Data *data)\n{\n    virCPUDataPtr cpuData;\n\n    if (VIR_ALLOC(cpuData) < 0)\n        return NULL;\n\n    cpuData->arch = arch;\n\n    if (ppc64DataCopy(&cpuData->data.ppc64, data) < 0)\n        VIR_FREE(cpuData);\n\n    return cpuData;\n}"
  },
  {
    "function_name": "ppc64LoadMap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "391-407",
    "snippet": "static struct ppc64_map *\nppc64LoadMap(void)\n{\n    struct ppc64_map *map;\n\n    if (VIR_ALLOC(map) < 0)\n        goto error;\n\n    if (cpuMapLoad(\"ppc64\", ppc64VendorParse, NULL, ppc64ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    ppc64MapFree(map);\n    return NULL;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc64MapFree",
          "args": [
            "map"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64MapFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "254-271",
          "snippet": "static void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpuMapLoad",
          "args": [
            "\"ppc64\"",
            "ppc64VendorParse",
            "NULL",
            "ppc64ModelParse",
            "map"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "cpuMapLoad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_map.c",
          "lines": "174-236",
          "snippet": "int cpuMapLoad(const char *arch,\n               cpuMapLoadCallback vendorCB,\n               cpuMapLoadCallback featureCB,\n               cpuMapLoadCallback modelCB,\n               void *data)\n{\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xpath = NULL;\n    int ret = -1;\n    char *mapfile;\n\n    if (!(mapfile = virFileFindResource(\"index.xml\",\n                                        abs_top_srcdir \"/src/cpu_map\",\n                                        PKGDATADIR \"/cpu_map\")))\n        return -1;\n\n    VIR_DEBUG(\"Loading '%s' CPU map from %s\", NULLSTR(arch), mapfile);\n\n    if (arch == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"undefined hardware architecture\"));\n        goto cleanup;\n    }\n\n    if (!(xml = virXMLParseFileCtxt(mapfile, &ctxt)))\n        goto cleanup;\n\n    virBufferAsprintf(&buf, \"./arch[@name='%s']\", arch);\n\n    xpath = virBufferContentAndReset(&buf);\n\n    ctxt->node = xmlDocGetRootElement(xml);\n\n    if ((ctxt->node = virXPathNode(xpath, ctxt)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot find CPU map for %s architecture\"), arch);\n        goto cleanup;\n    }\n\n    if (loadData(mapfile, ctxt, \"vendor\", vendorCB, data) < 0)\n        goto cleanup;\n\n    if (loadData(mapfile, ctxt, \"feature\", featureCB, data) < 0)\n        goto cleanup;\n\n    if (loadData(mapfile, ctxt, \"model\", modelCB, data) < 0)\n        goto cleanup;\n\n    if (loadIncludes(ctxt, vendorCB, featureCB, modelCB, data) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(xml);\n    VIR_FREE(xpath);\n    VIR_FREE(mapfile);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"configmake.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"configmake.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nint cpuMapLoad(const char *arch,\n               cpuMapLoadCallback vendorCB,\n               cpuMapLoadCallback featureCB,\n               cpuMapLoadCallback modelCB,\n               void *data)\n{\n    xmlDocPtr xml = NULL;\n    xmlXPathContextPtr ctxt = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    char *xpath = NULL;\n    int ret = -1;\n    char *mapfile;\n\n    if (!(mapfile = virFileFindResource(\"index.xml\",\n                                        abs_top_srcdir \"/src/cpu_map\",\n                                        PKGDATADIR \"/cpu_map\")))\n        return -1;\n\n    VIR_DEBUG(\"Loading '%s' CPU map from %s\", NULLSTR(arch), mapfile);\n\n    if (arch == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"undefined hardware architecture\"));\n        goto cleanup;\n    }\n\n    if (!(xml = virXMLParseFileCtxt(mapfile, &ctxt)))\n        goto cleanup;\n\n    virBufferAsprintf(&buf, \"./arch[@name='%s']\", arch);\n\n    xpath = virBufferContentAndReset(&buf);\n\n    ctxt->node = xmlDocGetRootElement(xml);\n\n    if ((ctxt->node = virXPathNode(xpath, ctxt)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"cannot find CPU map for %s architecture\"), arch);\n        goto cleanup;\n    }\n\n    if (loadData(mapfile, ctxt, \"vendor\", vendorCB, data) < 0)\n        goto cleanup;\n\n    if (loadData(mapfile, ctxt, \"feature\", featureCB, data) < 0)\n        goto cleanup;\n\n    if (loadData(mapfile, ctxt, \"model\", modelCB, data) < 0)\n        goto cleanup;\n\n    if (loadIncludes(ctxt, vendorCB, featureCB, modelCB, data) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    xmlXPathFreeContext(ctxt);\n    xmlFreeDoc(xml);\n    VIR_FREE(xpath);\n    VIR_FREE(mapfile);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "map"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_map *\nppc64LoadMap(void)\n{\n    struct ppc64_map *map;\n\n    if (VIR_ALLOC(map) < 0)\n        goto error;\n\n    if (cpuMapLoad(\"ppc64\", ppc64VendorParse, NULL, ppc64ModelParse, map) < 0)\n        goto error;\n\n    return map;\n\n error:\n    ppc64MapFree(map);\n    return NULL;\n}"
  },
  {
    "function_name": "ppc64ModelParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "304-388",
    "snippet": "static int\nppc64ModelParse(xmlXPathContextPtr ctxt,\n                const char *name,\n                void *data)\n{\n    struct ppc64_map *map = data;\n    struct ppc64_model *model;\n    xmlNodePtr *nodes = NULL;\n    char *vendor = NULL;\n    unsigned long pvr;\n    size_t i;\n    int n;\n    int ret = -1;\n\n    if (VIR_ALLOC(model) < 0)\n        goto cleanup;\n\n    model->name = g_strdup(name);\n\n    if (ppc64ModelFind(map, model->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU model %s already defined\"), model->name);\n        goto cleanup;\n    }\n\n    if (virXPathBoolean(\"boolean(./vendor)\", ctxt)) {\n        vendor = virXPathString(\"string(./vendor/@name)\", ctxt);\n        if (!vendor) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid vendor element in CPU model %s\"),\n                           model->name);\n            goto cleanup;\n        }\n\n        if (!(model->vendor = ppc64VendorFind(map, vendor))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown vendor %s referenced by CPU model %s\"),\n                           vendor, model->name);\n            goto cleanup;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./pvr\", ctxt, &nodes)) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing PVR information for CPU model %s\"),\n                       model->name);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(model->data.pvr, n) < 0)\n        goto cleanup;\n\n    model->data.len = n;\n\n    for (i = 0; i < n; i++) {\n        ctxt->node = nodes[i];\n\n        if (virXPathULongHex(\"string(./@value)\", ctxt, &pvr) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Missing or invalid PVR value in CPU model %s\"),\n                           model->name);\n            goto cleanup;\n        }\n        model->data.pvr[i].value = pvr;\n\n        if (virXPathULongHex(\"string(./@mask)\", ctxt, &pvr) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Missing or invalid PVR mask in CPU model %s\"),\n                           model->name);\n            goto cleanup;\n        }\n        model->data.pvr[i].mask = pvr;\n    }\n\n    if (VIR_APPEND_ELEMENT(map->models, map->nmodels, model) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    ppc64ModelFree(model);\n    VIR_FREE(vendor);\n    VIR_FREE(nodes);\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nodes"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vendor"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64ModelFree",
          "args": [
            "model"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "168-177",
          "snippet": "static void\nppc64ModelFree(struct ppc64_model *model)\n{\n    if (!model)\n        return;\n\n    ppc64DataClear(&model->data);\n    VIR_FREE(model->name);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64ModelFree(struct ppc64_model *model)\n{\n    if (!model)\n        return;\n\n    ppc64DataClear(&model->data);\n    VIR_FREE(model->name);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "map->models",
            "map->nmodels",
            "model"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing or invalid PVR mask in CPU model %s\")",
            "model->name"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Missing or invalid PVR mask in CPU model %s\""
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathULongHex",
          "args": [
            "\"string(./@mask)\"",
            "ctxt",
            "&pvr"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathULongHex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "378-384",
          "snippet": "int\nvirXPathULongHex(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 unsigned long *value)\n{\n    return virXPathULongBase(xpath, ctxt, 16, value);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathULongHex(const char *xpath,\n                 xmlXPathContextPtr ctxt,\n                 unsigned long *value)\n{\n    return virXPathULongBase(xpath, ctxt, 16, value);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing or invalid PVR value in CPU model %s\")",
            "model->name"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "model->data.pvr",
            "n"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Missing PVR information for CPU model %s\")",
            "model->name"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathNodeSet",
          "args": [
            "\"./pvr\"",
            "ctxt",
            "&nodes"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathNodeSet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "647-694",
          "snippet": "int\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathNodeSet(const char *xpath,\n                xmlXPathContextPtr ctxt,\n                xmlNodePtr **list)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathNodeSet()\"));\n        return -1;\n    }\n\n    if (list != NULL)\n        *list = NULL;\n\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if (obj == NULL)\n        return 0;\n\n    if (obj->type != XPATH_NODESET) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Incorrect xpath '%s'\"), xpath);\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n\n    if ((obj->nodesetval == NULL)  || (obj->nodesetval->nodeNr < 0)) {\n        xmlXPathFreeObject(obj);\n        return 0;\n    }\n\n    ret = obj->nodesetval->nodeNr;\n    if (list != NULL && ret) {\n        if (VIR_ALLOC_N(*list, ret) < 0) {\n            ret = -1;\n        } else {\n            memcpy(*list, obj->nodesetval->nodeTab,\n                   ret * sizeof(xmlNodePtr));\n        }\n    }\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown vendor %s referenced by CPU model %s\")",
            "vendor",
            "model->name"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64VendorFind",
          "args": [
            "map",
            "vendor"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64VendorFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "154-166",
          "snippet": "static struct ppc64_vendor *\nppc64VendorFind(const struct ppc64_map *map,\n                const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_vendor *\nppc64VendorFind(const struct ppc64_map *map,\n                const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid vendor element in CPU model %s\")",
            "model->name"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virXPathString",
          "args": [
            "\"string(./vendor/@name)\"",
            "ctxt"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "72-96",
          "snippet": "char *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nchar *\nvirXPathString(const char *xpath,\n               xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    char *ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathString()\"));\n        return NULL;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_STRING) ||\n        (obj->stringval == NULL) || (obj->stringval[0] == 0)) {\n        xmlXPathFreeObject(obj);\n        return NULL;\n    }\n    ret = g_strdup((char *)obj->stringval);\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virXPathBoolean",
          "args": [
            "\"boolean(./vendor)\"",
            "ctxt"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "virXPathBoolean",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virxml.c",
          "lines": "571-596",
          "snippet": "int\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virxml.h\"",
            "#include \"virerror.h\"",
            "#include <libxml/xpathInternals.h>",
            "#include <sys/stat.h>",
            "#include <math.h>               /* for isnan() */",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virxml.h\"\n#include \"virerror.h\"\n#include <libxml/xpathInternals.h>\n#include <sys/stat.h>\n#include <math.h>               /* for isnan() */\n#include <stdarg.h>\n#include <config.h>\n\nint\nvirXPathBoolean(const char *xpath,\n                xmlXPathContextPtr ctxt)\n{\n    xmlXPathObjectPtr obj;\n    xmlNodePtr relnode;\n    int ret;\n\n    if ((ctxt == NULL) || (xpath == NULL)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\", _(\"Invalid parameter to virXPathBoolean()\"));\n        return -1;\n    }\n    relnode = ctxt->node;\n    obj = xmlXPathEval(BAD_CAST xpath, ctxt);\n    ctxt->node = relnode;\n    if ((obj == NULL) || (obj->type != XPATH_BOOLEAN) ||\n        (obj->boolval < 0) || (obj->boolval > 1)) {\n        xmlXPathFreeObject(obj);\n        return -1;\n    }\n    ret = obj->boolval;\n\n    xmlXPathFreeObject(obj);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"CPU model %s already defined\")",
            "model->name"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64ModelFind",
          "args": [
            "map",
            "model->name"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64ModelFindPVR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "215-231",
          "snippet": "static struct ppc64_model *\nppc64ModelFindPVR(const struct ppc64_map *map,\n                  uint32_t pvr)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < map->nmodels; i++) {\n        struct ppc64_model *model = map->models[i];\n        for (j = 0; j < model->data.len; j++) {\n            if ((pvr & model->data.pvr[j].mask) == model->data.pvr[j].value)\n                return model;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_model *\nppc64ModelFindPVR(const struct ppc64_map *map,\n                  uint32_t pvr)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < map->nmodels; i++) {\n        struct ppc64_model *model = map->models[i];\n        for (j = 0; j < model->data.len; j++) {\n            if ((pvr & model->data.pvr[j].mask) == model->data.pvr[j].value)\n                return model;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "model"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nppc64ModelParse(xmlXPathContextPtr ctxt,\n                const char *name,\n                void *data)\n{\n    struct ppc64_map *map = data;\n    struct ppc64_model *model;\n    xmlNodePtr *nodes = NULL;\n    char *vendor = NULL;\n    unsigned long pvr;\n    size_t i;\n    int n;\n    int ret = -1;\n\n    if (VIR_ALLOC(model) < 0)\n        goto cleanup;\n\n    model->name = g_strdup(name);\n\n    if (ppc64ModelFind(map, model->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU model %s already defined\"), model->name);\n        goto cleanup;\n    }\n\n    if (virXPathBoolean(\"boolean(./vendor)\", ctxt)) {\n        vendor = virXPathString(\"string(./vendor/@name)\", ctxt);\n        if (!vendor) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Invalid vendor element in CPU model %s\"),\n                           model->name);\n            goto cleanup;\n        }\n\n        if (!(model->vendor = ppc64VendorFind(map, vendor))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unknown vendor %s referenced by CPU model %s\"),\n                           vendor, model->name);\n            goto cleanup;\n        }\n    }\n\n    if ((n = virXPathNodeSet(\"./pvr\", ctxt, &nodes)) <= 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Missing PVR information for CPU model %s\"),\n                       model->name);\n        goto cleanup;\n    }\n\n    if (VIR_ALLOC_N(model->data.pvr, n) < 0)\n        goto cleanup;\n\n    model->data.len = n;\n\n    for (i = 0; i < n; i++) {\n        ctxt->node = nodes[i];\n\n        if (virXPathULongHex(\"string(./@value)\", ctxt, &pvr) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Missing or invalid PVR value in CPU model %s\"),\n                           model->name);\n            goto cleanup;\n        }\n        model->data.pvr[i].value = pvr;\n\n        if (virXPathULongHex(\"string(./@mask)\", ctxt, &pvr) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Missing or invalid PVR mask in CPU model %s\"),\n                           model->name);\n            goto cleanup;\n        }\n        model->data.pvr[i].mask = pvr;\n    }\n\n    if (VIR_APPEND_ELEMENT(map->models, map->nmodels, model) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    ppc64ModelFree(model);\n    VIR_FREE(vendor);\n    VIR_FREE(nodes);\n    return ret;\n}"
  },
  {
    "function_name": "ppc64VendorParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "273-301",
    "snippet": "static int\nppc64VendorParse(xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                 const char *name,\n                 void *data)\n{\n    struct ppc64_map *map = data;\n    struct ppc64_vendor *vendor;\n    int ret = -1;\n\n    if (VIR_ALLOC(vendor) < 0)\n        return -1;\n\n    vendor->name = g_strdup(name);\n\n    if (ppc64VendorFind(map, vendor->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU vendor %s already defined\"), vendor->name);\n        goto cleanup;\n    }\n\n    if (VIR_APPEND_ELEMENT(map->vendors, map->nvendors, vendor) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    ppc64VendorFree(vendor);\n    return ret;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc64VendorFree",
          "args": [
            "vendor"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64VendorFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "144-152",
          "snippet": "static void\nppc64VendorFree(struct ppc64_vendor *vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64VendorFree(struct ppc64_vendor *vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "map->vendors",
            "map->nvendors",
            "vendor"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"CPU vendor %s already defined\")",
            "vendor->name"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"CPU vendor %s already defined\""
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64VendorFind",
          "args": [
            "map",
            "vendor->name"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64VendorFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "154-166",
          "snippet": "static struct ppc64_vendor *\nppc64VendorFind(const struct ppc64_map *map,\n                const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_vendor *\nppc64VendorFind(const struct ppc64_map *map,\n                const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "vendor"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nppc64VendorParse(xmlXPathContextPtr ctxt G_GNUC_UNUSED,\n                 const char *name,\n                 void *data)\n{\n    struct ppc64_map *map = data;\n    struct ppc64_vendor *vendor;\n    int ret = -1;\n\n    if (VIR_ALLOC(vendor) < 0)\n        return -1;\n\n    vendor->name = g_strdup(name);\n\n    if (ppc64VendorFind(map, vendor->name)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"CPU vendor %s already defined\"), vendor->name);\n        goto cleanup;\n    }\n\n    if (VIR_APPEND_ELEMENT(map->vendors, map->nvendors, vendor) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    ppc64VendorFree(vendor);\n    return ret;\n}"
  },
  {
    "function_name": "ppc64MapFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "254-271",
    "snippet": "static void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "map"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "map->vendors"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64VendorFree",
          "args": [
            "map->vendors[i]"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64VendorFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "144-152",
          "snippet": "static void\nppc64VendorFree(struct ppc64_vendor *vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64VendorFree(struct ppc64_vendor *vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "map->models"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64ModelFree",
          "args": [
            "map->models[i]"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "168-177",
          "snippet": "static void\nppc64ModelFree(struct ppc64_model *model)\n{\n    if (!model)\n        return;\n\n    ppc64DataClear(&model->data);\n    VIR_FREE(model->name);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64ModelFree(struct ppc64_model *model)\n{\n    if (!model)\n        return;\n\n    ppc64DataClear(&model->data);\n    VIR_FREE(model->name);\n    VIR_FREE(model);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64MapFree(struct ppc64_map *map)\n{\n    size_t i;\n\n    if (!map)\n        return;\n\n    for (i = 0; i < map->nmodels; i++)\n        ppc64ModelFree(map->models[i]);\n    VIR_FREE(map->models);\n\n    for (i = 0; i < map->nvendors; i++)\n        ppc64VendorFree(map->vendors[i]);\n    VIR_FREE(map->vendors);\n\n    VIR_FREE(map);\n}"
  },
  {
    "function_name": "ppc64ModelFromCPU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "233-252",
    "snippet": "static struct ppc64_model *\nppc64ModelFromCPU(const virCPUDef *cpu,\n                  const struct ppc64_map *map)\n{\n    struct ppc64_model *model;\n\n    if (!cpu->model) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"no CPU model specified\"));\n        return NULL;\n    }\n\n    if (!(model = ppc64ModelFind(map, cpu->model))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU model %s\"), cpu->model);\n        return NULL;\n    }\n\n    return ppc64ModelCopy(model);\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc64ModelCopy",
          "args": [
            "model"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64ModelCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "179-199",
          "snippet": "static struct ppc64_model *\nppc64ModelCopy(const struct ppc64_model *model)\n{\n    struct ppc64_model *copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        goto error;\n\n    copy->name = g_strdup(model->name);\n\n    if (ppc64DataCopy(&copy->data, &model->data) < 0)\n        goto error;\n\n    copy->vendor = model->vendor;\n\n    return copy;\n\n error:\n    ppc64ModelFree(copy);\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_model *\nppc64ModelCopy(const struct ppc64_model *model)\n{\n    struct ppc64_model *copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        goto error;\n\n    copy->name = g_strdup(model->name);\n\n    if (ppc64DataCopy(&copy->data, &model->data) < 0)\n        goto error;\n\n    copy->vendor = model->vendor;\n\n    return copy;\n\n error:\n    ppc64ModelFree(copy);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown CPU model %s\")",
            "cpu->model"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown CPU model %s\""
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64ModelFind",
          "args": [
            "map",
            "cpu->model"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64ModelFindPVR",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "215-231",
          "snippet": "static struct ppc64_model *\nppc64ModelFindPVR(const struct ppc64_map *map,\n                  uint32_t pvr)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < map->nmodels; i++) {\n        struct ppc64_model *model = map->models[i];\n        for (j = 0; j < model->data.len; j++) {\n            if ((pvr & model->data.pvr[j].mask) == model->data.pvr[j].value)\n                return model;\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_model *\nppc64ModelFindPVR(const struct ppc64_map *map,\n                  uint32_t pvr)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < map->nmodels; i++) {\n        struct ppc64_model *model = map->models[i];\n        for (j = 0; j < model->data.len; j++) {\n            if ((pvr & model->data.pvr[j].mask) == model->data.pvr[j].value)\n                return model;\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INVALID_ARG",
            "\"%s\"",
            "_(\"no CPU model specified\")"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_model *\nppc64ModelFromCPU(const virCPUDef *cpu,\n                  const struct ppc64_map *map)\n{\n    struct ppc64_model *model;\n\n    if (!cpu->model) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"no CPU model specified\"));\n        return NULL;\n    }\n\n    if (!(model = ppc64ModelFind(map, cpu->model))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown CPU model %s\"), cpu->model);\n        return NULL;\n    }\n\n    return ppc64ModelCopy(model);\n}"
  },
  {
    "function_name": "ppc64ModelFindPVR",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "215-231",
    "snippet": "static struct ppc64_model *\nppc64ModelFindPVR(const struct ppc64_map *map,\n                  uint32_t pvr)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < map->nmodels; i++) {\n        struct ppc64_model *model = map->models[i];\n        for (j = 0; j < model->data.len; j++) {\n            if ((pvr & model->data.pvr[j].mask) == model->data.pvr[j].value)\n                return model;\n        }\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_model *\nppc64ModelFindPVR(const struct ppc64_map *map,\n                  uint32_t pvr)\n{\n    size_t i;\n    size_t j;\n\n    for (i = 0; i < map->nmodels; i++) {\n        struct ppc64_model *model = map->models[i];\n        for (j = 0; j < model->data.len; j++) {\n            if ((pvr & model->data.pvr[j].mask) == model->data.pvr[j].value)\n                return model;\n        }\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "ppc64ModelFind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "201-213",
    "snippet": "static struct ppc64_model *\nppc64ModelFind(const struct ppc64_map *map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "map->models[i]->name",
            "name"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_model *\nppc64ModelFind(const struct ppc64_map *map,\n               const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nmodels; i++) {\n        if (STREQ(map->models[i]->name, name))\n            return map->models[i];\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "ppc64ModelCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "179-199",
    "snippet": "static struct ppc64_model *\nppc64ModelCopy(const struct ppc64_model *model)\n{\n    struct ppc64_model *copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        goto error;\n\n    copy->name = g_strdup(model->name);\n\n    if (ppc64DataCopy(&copy->data, &model->data) < 0)\n        goto error;\n\n    copy->vendor = model->vendor;\n\n    return copy;\n\n error:\n    ppc64ModelFree(copy);\n    return NULL;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ppc64ModelFree",
          "args": [
            "copy"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64ModelFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "168-177",
          "snippet": "static void\nppc64ModelFree(struct ppc64_model *model)\n{\n    if (!model)\n        return;\n\n    ppc64DataClear(&model->data);\n    VIR_FREE(model->name);\n    VIR_FREE(model);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64ModelFree(struct ppc64_model *model)\n{\n    if (!model)\n        return;\n\n    ppc64DataClear(&model->data);\n    VIR_FREE(model->name);\n    VIR_FREE(model);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ppc64DataCopy",
          "args": [
            "&copy->data",
            "&model->data"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64DataCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "126-142",
          "snippet": "static int\nppc64DataCopy(virCPUppc64Data *dst, const virCPUppc64Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->pvr, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n\n    for (i = 0; i < src->len; i++) {\n        dst->pvr[i].value = src->pvr[i].value;\n        dst->pvr[i].mask = src->pvr[i].mask;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nppc64DataCopy(virCPUppc64Data *dst, const virCPUppc64Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->pvr, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n\n    for (i = 0; i < src->len; i++) {\n        dst->pvr[i].value = src->pvr[i].value;\n        dst->pvr[i].mask = src->pvr[i].mask;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "model->name"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "copy"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_model *\nppc64ModelCopy(const struct ppc64_model *model)\n{\n    struct ppc64_model *copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        goto error;\n\n    copy->name = g_strdup(model->name);\n\n    if (ppc64DataCopy(&copy->data, &model->data) < 0)\n        goto error;\n\n    copy->vendor = model->vendor;\n\n    return copy;\n\n error:\n    ppc64ModelFree(copy);\n    return NULL;\n}"
  },
  {
    "function_name": "ppc64ModelFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "168-177",
    "snippet": "static void\nppc64ModelFree(struct ppc64_model *model)\n{\n    if (!model)\n        return;\n\n    ppc64DataClear(&model->data);\n    VIR_FREE(model->name);\n    VIR_FREE(model);\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "model"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "model->name"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppc64DataClear",
          "args": [
            "&model->data"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "ppc64DataClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
          "lines": "117-124",
          "snippet": "static void\nppc64DataClear(virCPUppc64Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->pvr);\n}",
          "includes": [
            "#include \"virbuffer.h\"",
            "#include \"cpu_map.h\"",
            "#include \"virstring.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64DataClear(virCPUppc64Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->pvr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64ModelFree(struct ppc64_model *model)\n{\n    if (!model)\n        return;\n\n    ppc64DataClear(&model->data);\n    VIR_FREE(model->name);\n    VIR_FREE(model);\n}"
  },
  {
    "function_name": "ppc64VendorFind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "154-166",
    "snippet": "static struct ppc64_vendor *\nppc64VendorFind(const struct ppc64_map *map,\n                const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "map->vendors[i]->name",
            "name"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic struct ppc64_vendor *\nppc64VendorFind(const struct ppc64_map *map,\n                const char *name)\n{\n    size_t i;\n\n    for (i = 0; i < map->nvendors; i++) {\n        if (STREQ(map->vendors[i]->name, name))\n            return map->vendors[i];\n    }\n\n    return NULL;\n}"
  },
  {
    "function_name": "ppc64VendorFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "144-152",
    "snippet": "static void\nppc64VendorFree(struct ppc64_vendor *vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vendor"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vendor->name"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64VendorFree(struct ppc64_vendor *vendor)\n{\n    if (!vendor)\n        return;\n\n    VIR_FREE(vendor->name);\n    VIR_FREE(vendor);\n}"
  },
  {
    "function_name": "ppc64DataCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "126-142",
    "snippet": "static int\nppc64DataCopy(virCPUppc64Data *dst, const virCPUppc64Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->pvr, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n\n    for (i = 0; i < src->len; i++) {\n        dst->pvr[i].value = src->pvr[i].value;\n        dst->pvr[i].mask = src->pvr[i].mask;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "dst->pvr",
            "src->len"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nppc64DataCopy(virCPUppc64Data *dst, const virCPUppc64Data *src)\n{\n    size_t i;\n\n    if (VIR_ALLOC_N(dst->pvr, src->len) < 0)\n        return -1;\n\n    dst->len = src->len;\n\n    for (i = 0; i < src->len; i++) {\n        dst->pvr[i].value = src->pvr[i].value;\n        dst->pvr[i].mask = src->pvr[i].mask;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "ppc64DataClear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "117-124",
    "snippet": "static void\nppc64DataClear(virCPUppc64Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->pvr);\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "data->pvr"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic void\nppc64DataClear(virCPUppc64Data *data)\n{\n    if (!data)\n        return;\n\n    VIR_FREE(data->pvr);\n}"
  },
  {
    "function_name": "ppc64CheckCompatibilityMode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "77-115",
    "snippet": "static virCPUCompareResult\nppc64CheckCompatibilityMode(const char *host_model,\n                            const char *compat_mode)\n{\n    int host;\n    int compat;\n    char *tmp;\n\n    if (!compat_mode)\n        return VIR_CPU_COMPARE_IDENTICAL;\n\n    /* Valid host CPUs: POWER6, POWER7, POWER8, POWER9 */\n    if (!STRPREFIX(host_model, \"POWER\") ||\n        !(tmp = (char *) host_model + strlen(\"POWER\")) ||\n        virStrToLong_i(tmp, NULL, 10, &host) < 0 ||\n        host < 6 || host > 9) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"Host CPU does not support compatibility modes\"));\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    /* Valid compatibility modes: power6, power7, power8, power9 */\n    if (!STRPREFIX(compat_mode, \"power\") ||\n        !(tmp = (char *) compat_mode + strlen(\"power\")) ||\n        virStrToLong_i(tmp, NULL, 10, &compat) < 0 ||\n        compat < 6 || compat > 9) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown compatibility mode %s\"),\n                       compat_mode);\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    /* Version check */\n    if (compat > host)\n        return VIR_CPU_COMPARE_INCOMPATIBLE;\n\n    return VIR_CPU_COMPARE_IDENTICAL;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown compatibility mode %s\")",
            "compat_mode"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown compatibility mode %s\""
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_i",
          "args": [
            "tmp",
            "NULL",
            "10",
            "&compat"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_i",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "391-407",
          "snippet": "int\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_i(char const *s, char **end_ptr, int base, int *result)\n{\n    long int val;\n    char *p;\n    int err;\n\n    errno = 0;\n    val = strtol(s, &p, base); /* exempt from syntax-check */\n    err = (errno || (!end_ptr && *p) || p == s || (int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"power\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "compat_mode",
            "\"power\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Host CPU does not support compatibility modes\")"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"POWER\""
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "host_model",
            "\"POWER\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic virCPUCompareResult\nppc64CheckCompatibilityMode(const char *host_model,\n                            const char *compat_mode)\n{\n    int host;\n    int compat;\n    char *tmp;\n\n    if (!compat_mode)\n        return VIR_CPU_COMPARE_IDENTICAL;\n\n    /* Valid host CPUs: POWER6, POWER7, POWER8, POWER9 */\n    if (!STRPREFIX(host_model, \"POWER\") ||\n        !(tmp = (char *) host_model + strlen(\"POWER\")) ||\n        virStrToLong_i(tmp, NULL, 10, &host) < 0 ||\n        host < 6 || host > 9) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"Host CPU does not support compatibility modes\"));\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    /* Valid compatibility modes: power6, power7, power8, power9 */\n    if (!STRPREFIX(compat_mode, \"power\") ||\n        !(tmp = (char *) compat_mode + strlen(\"power\")) ||\n        virStrToLong_i(tmp, NULL, 10, &compat) < 0 ||\n        compat < 6 || compat > 9) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown compatibility mode %s\"),\n                       compat_mode);\n        return VIR_CPU_COMPARE_ERROR;\n    }\n\n    /* Version check */\n    if (compat > host)\n        return VIR_CPU_COMPARE_INCOMPATIBLE;\n\n    return VIR_CPU_COMPARE_IDENTICAL;\n}"
  },
  {
    "function_name": "virCPUppc64ConvertLegacy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_ppc64.c",
    "lines": "60-72",
    "snippet": "static int\nvirCPUppc64ConvertLegacy(virCPUDefPtr cpu)\n{\n    if (cpu->model &&\n        (STREQ(cpu->model, \"POWER7_v2.1\") ||\n         STREQ(cpu->model, \"POWER7_v2.3\") ||\n         STREQ(cpu->model, \"POWER7+_v2.1\") ||\n         STREQ(cpu->model, \"POWER8_v1.0\"))) {\n        cpu->model[strlen(\"POWERx\")] = 0;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virbuffer.h\"",
      "#include \"cpu_map.h\"",
      "#include \"virstring.h\"",
      "#include \"cpu.h\"",
      "#include \"viralloc.h\"",
      "#include \"virlog.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"POWERx\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "cpu->model",
            "\"POWER8_v1.0\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "cpu->model",
            "\"POWER7+_v2.1\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "cpu->model",
            "\"POWER7_v2.3\""
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "cpu->model",
            "\"POWER7_v2.1\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"virbuffer.h\"\n#include \"cpu_map.h\"\n#include \"virstring.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUppc64ConvertLegacy(virCPUDefPtr cpu)\n{\n    if (cpu->model &&\n        (STREQ(cpu->model, \"POWER7_v2.1\") ||\n         STREQ(cpu->model, \"POWER7_v2.3\") ||\n         STREQ(cpu->model, \"POWER7+_v2.1\") ||\n         STREQ(cpu->model, \"POWER8_v1.0\"))) {\n        cpu->model[strlen(\"POWERx\")] = 0;\n    }\n\n    return 0;\n}"
  }
]