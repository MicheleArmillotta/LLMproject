[
  {
    "function_name": "libxlDomainGetEmulatorType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "777-806",
    "snippet": "int\nlibxlDomainGetEmulatorType(const virDomainDef *def)\n{\n    int ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN;\n    virCommandPtr cmd = NULL;\n    char *output = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->emulator) {\n            if (!virFileExists(def->emulator))\n                goto cleanup;\n\n            cmd = virCommandNew(def->emulator);\n\n            virCommandAddArgList(cmd, \"-help\", NULL);\n            virCommandSetOutputBuffer(cmd, &output);\n\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n\n            if (strstr(output, LIBXL_QEMU_DM_STR))\n                ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL;\n        }\n    }\n\n cleanup:\n    VIR_FREE(output);\n    virCommandFree(cmd);\n    return ret;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define LIBXL_QEMU_DM_STR  \"Options specific to the Xen version:\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCommandFree",
          "args": [
            "cmd"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2992-3047",
          "snippet": "void\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandFree(virCommandPtr cmd)\n{\n    size_t i;\n    if (!cmd)\n        return;\n\n    for (i = 0; i < cmd->npassfd; i++) {\n        if (cmd->passfd[i].flags & VIR_COMMAND_PASS_FD_CLOSE_PARENT)\n            VIR_FORCE_CLOSE(cmd->passfd[i].fd);\n    }\n    cmd->npassfd = 0;\n    VIR_FREE(cmd->passfd);\n\n    if (cmd->asyncioThread) {\n        virThreadJoin(cmd->asyncioThread);\n        VIR_FREE(cmd->asyncioThread);\n    }\n    VIR_FREE(cmd->inbuf);\n    VIR_FORCE_CLOSE(cmd->outfd);\n    VIR_FORCE_CLOSE(cmd->errfd);\n\n    for (i = 0; i < cmd->nargs; i++)\n        VIR_FREE(cmd->args[i]);\n    VIR_FREE(cmd->args);\n\n    for (i = 0; i < cmd->nenv; i++)\n        VIR_FREE(cmd->env[i]);\n    VIR_FREE(cmd->env);\n\n    VIR_FREE(cmd->pwd);\n\n    if (cmd->handshake) {\n        /* The other 2 fds in these arrays are closed\n         * due to use with virCommandPassFD\n         */\n        VIR_FORCE_CLOSE(cmd->handshakeWait[0]);\n        VIR_FORCE_CLOSE(cmd->handshakeNotify[1]);\n    }\n\n    VIR_FREE(cmd->pidfile);\n\n    if (cmd->reap)\n        virCommandAbort(cmd);\n\n#if defined(WITH_SECDRIVER_SELINUX)\n    VIR_FREE(cmd->seLinuxLabel);\n#endif\n#if defined(WITH_SECDRIVER_APPARMOR)\n    VIR_FREE(cmd->appArmorProfile);\n#endif\n\n    virCommandFreeSendBuffers(cmd);\n\n    VIR_FREE(cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "output"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "output",
            "LIBXL_QEMU_DM_STR"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCommandRun",
          "args": [
            "cmd",
            "NULL"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandRunAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2931-2937",
          "snippet": "int\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nint\nvirCommandRunAsync(virCommandPtr cmd G_GNUC_UNUSED, pid_t *pid G_GNUC_UNUSED)\n{\n    virReportSystemError(ENOSYS, \"%s\",\n                         _(\"Executing new processes is not supported on Win32 platform\"));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandSetOutputBuffer",
          "args": [
            "cmd",
            "&output"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandSetOutputBuffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1869-1884",
          "snippet": "void\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandSetOutputBuffer(virCommandPtr cmd, char **outbuf)\n{\n    *outbuf = NULL;\n    if (!cmd || cmd->has_error)\n        return;\n\n    if (cmd->outfdptr) {\n        cmd->has_error = -1;\n        VIR_DEBUG(\"cannot specify output twice\");\n        return;\n    }\n\n    cmd->outbuf = outbuf;\n    cmd->outfdptr = &cmd->outfd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandAddArgList",
          "args": [
            "cmd",
            "\"-help\"",
            "NULL"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandAddArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "1655-1684",
          "snippet": "void\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvoid\nvirCommandAddArgList(virCommandPtr cmd, ...)\n{\n    va_list list;\n    int narg = 0;\n\n    if (!cmd || cmd->has_error)\n        return;\n\n    va_start(list, cmd);\n    while (va_arg(list, const char *) != NULL)\n        narg++;\n    va_end(list);\n\n    /* narg plus trailing NULL. */\n    if (VIR_RESIZE_N(cmd->args, cmd->maxargs, cmd->nargs, narg + 1) < 0) {\n        cmd->has_error = ENOMEM;\n        return;\n    }\n\n    va_start(list, cmd);\n    while (1) {\n        char *arg = va_arg(list, char *);\n        if (!arg)\n            break;\n        arg = g_strdup(arg);\n        cmd->args[cmd->nargs++] = arg;\n    }\n    va_end(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandNew",
          "args": [
            "def->emulator"
          ],
          "line": 789
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandNewArgList",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "969-980",
          "snippet": "virCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nvirCommandPtr\nvirCommandNewArgList(const char *binary, ...)\n{\n    virCommandPtr cmd;\n    va_list list;\n\n    va_start(list, binary);\n    cmd = virCommandNewVAList(binary, list);\n    va_end(list);\n\n    return cmd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "def->emulator"
          ],
          "line": 786
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\n#define LIBXL_QEMU_DM_STR  \"Options specific to the Xen version:\"\n\nint\nlibxlDomainGetEmulatorType(const virDomainDef *def)\n{\n    int ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN;\n    virCommandPtr cmd = NULL;\n    char *output = NULL;\n\n    if (def->os.type == VIR_DOMAIN_OSTYPE_HVM) {\n        if (def->emulator) {\n            if (!virFileExists(def->emulator))\n                goto cleanup;\n\n            cmd = virCommandNew(def->emulator);\n\n            virCommandAddArgList(cmd, \"-help\", NULL);\n            virCommandSetOutputBuffer(cmd, &output);\n\n            if (virCommandRun(cmd, NULL) < 0)\n                goto cleanup;\n\n            if (strstr(output, LIBXL_QEMU_DM_STR))\n                ret = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL;\n        }\n    }\n\n cleanup:\n    VIR_FREE(output);\n    virCommandFree(cmd);\n    return ret;\n}"
  },
  {
    "function_name": "libxlMakeDomainCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "742-773",
    "snippet": "int\nlibxlMakeDomainCapabilities(virDomainCapsPtr domCaps,\n                            virFirmwarePtr *firmwares,\n                            size_t nfirmwares)\n{\n    virDomainCapsOSPtr os = &domCaps->os;\n    virDomainCapsDeviceDiskPtr disk = &domCaps->disk;\n    virDomainCapsDeviceGraphicsPtr graphics = &domCaps->graphics;\n    virDomainCapsDeviceVideoPtr video = &domCaps->video;\n    virDomainCapsDeviceHostdevPtr hostdev = &domCaps->hostdev;\n\n    if (STREQ(domCaps->machine, \"xenfv\"))\n        domCaps->maxvcpus = HVM_MAX_VCPUS;\n    else\n        domCaps->maxvcpus = PV_MAX_VCPUS;\n\n    if (libxlMakeDomainOSCaps(domCaps->machine, os, firmwares, nfirmwares) < 0 ||\n        libxlMakeDomainDeviceDiskCaps(disk) < 0 ||\n        libxlMakeDomainDeviceGraphicsCaps(graphics) < 0 ||\n        libxlMakeDomainDeviceVideoCaps(video) < 0)\n        return -1;\n    if (STRNEQ(domCaps->machine, \"xenpvh\") &&\n        libxlMakeDomainDeviceHostdevCaps(hostdev) < 0)\n        return -1;\n\n    domCaps->features[VIR_DOMAIN_CAPS_FEATURE_IOTHREADS] = VIR_TRISTATE_BOOL_NO;\n    domCaps->features[VIR_DOMAIN_CAPS_FEATURE_VMCOREINFO] = VIR_TRISTATE_BOOL_NO;\n    domCaps->features[VIR_DOMAIN_CAPS_FEATURE_GENID] = VIR_TRISTATE_BOOL_NO;\n    domCaps->gic.supported = VIR_TRISTATE_BOOL_NO;\n\n    return 0;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PV_MAX_VCPUS  512",
      "#define HVM_MAX_VCPUS 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxlMakeDomainDeviceHostdevCaps",
          "args": [
            "hostdev"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeDomainDeviceHostdevCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "668-702",
          "snippet": "static int\nlibxlMakeDomainDeviceHostdevCaps(virDomainCapsDeviceHostdevPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->mode.report = true;\n    dev->startupPolicy.report = true;\n    dev->subsysType.report = true;\n    dev->capsType.report = true;\n    dev->pciBackend.report = true;\n\n    /* VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES is for containers only */\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->mode,\n                             VIR_DOMAIN_HOSTDEV_MODE_SUBSYS);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->startupPolicy,\n                             VIR_DOMAIN_STARTUP_POLICY_DEFAULT,\n                             VIR_DOMAIN_STARTUP_POLICY_MANDATORY,\n                             VIR_DOMAIN_STARTUP_POLICY_REQUISITE,\n                             VIR_DOMAIN_STARTUP_POLICY_OPTIONAL);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->subsysType,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI);\n\n    if (libxlCapsHasPVUSB())\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->subsysType,\n                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB);\n\n    /* No virDomainHostdevCapsType for libxl */\n    virDomainCapsEnumClear(&dev->capsType);\n\n    virDomainCapsEnumClear(&dev->pciBackend);\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->pciBackend,\n                             VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN);\n    return 0;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomainDeviceHostdevCaps(virDomainCapsDeviceHostdevPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->mode.report = true;\n    dev->startupPolicy.report = true;\n    dev->subsysType.report = true;\n    dev->capsType.report = true;\n    dev->pciBackend.report = true;\n\n    /* VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES is for containers only */\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->mode,\n                             VIR_DOMAIN_HOSTDEV_MODE_SUBSYS);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->startupPolicy,\n                             VIR_DOMAIN_STARTUP_POLICY_DEFAULT,\n                             VIR_DOMAIN_STARTUP_POLICY_MANDATORY,\n                             VIR_DOMAIN_STARTUP_POLICY_REQUISITE,\n                             VIR_DOMAIN_STARTUP_POLICY_OPTIONAL);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->subsysType,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI);\n\n    if (libxlCapsHasPVUSB())\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->subsysType,\n                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB);\n\n    /* No virDomainHostdevCapsType for libxl */\n    virDomainCapsEnumClear(&dev->capsType);\n\n    virDomainCapsEnumClear(&dev->pciBackend);\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->pciBackend,\n                             VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ",
          "args": [
            "domCaps->machine",
            "\"xenpvh\""
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlMakeDomainDeviceVideoCaps",
          "args": [
            "video"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeDomainDeviceVideoCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "645-657",
          "snippet": "static int\nlibxlMakeDomainDeviceVideoCaps(virDomainCapsDeviceVideoPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->modelType.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType,\n                             VIR_DOMAIN_VIDEO_TYPE_VGA,\n                             VIR_DOMAIN_VIDEO_TYPE_CIRRUS,\n                             VIR_DOMAIN_VIDEO_TYPE_XEN);\n\n    return 0;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomainDeviceVideoCaps(virDomainCapsDeviceVideoPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->modelType.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType,\n                             VIR_DOMAIN_VIDEO_TYPE_VGA,\n                             VIR_DOMAIN_VIDEO_TYPE_CIRRUS,\n                             VIR_DOMAIN_VIDEO_TYPE_XEN);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeDomainDeviceGraphicsCaps",
          "args": [
            "graphics"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeDomainDeviceGraphicsCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "631-643",
          "snippet": "static int\nlibxlMakeDomainDeviceGraphicsCaps(virDomainCapsDeviceGraphicsPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->type.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->type,\n                             VIR_DOMAIN_GRAPHICS_TYPE_SDL,\n                             VIR_DOMAIN_GRAPHICS_TYPE_VNC,\n                             VIR_DOMAIN_GRAPHICS_TYPE_SPICE);\n\n    return 0;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomainDeviceGraphicsCaps(virDomainCapsDeviceGraphicsPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->type.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->type,\n                             VIR_DOMAIN_GRAPHICS_TYPE_SDL,\n                             VIR_DOMAIN_GRAPHICS_TYPE_VNC,\n                             VIR_DOMAIN_GRAPHICS_TYPE_SPICE);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeDomainDeviceDiskCaps",
          "args": [
            "disk"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeDomainDeviceDiskCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "611-629",
          "snippet": "static int\nlibxlMakeDomainDeviceDiskCaps(virDomainCapsDeviceDiskPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->diskDevice.report = true;\n    dev->bus.report = true;\n    dev->model.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->diskDevice,\n                             VIR_DOMAIN_DISK_DEVICE_DISK,\n                             VIR_DOMAIN_DISK_DEVICE_CDROM);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->bus,\n                             VIR_DOMAIN_DISK_BUS_IDE,\n                             VIR_DOMAIN_DISK_BUS_SCSI,\n                             VIR_DOMAIN_DISK_BUS_XEN);\n\n    return 0;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomainDeviceDiskCaps(virDomainCapsDeviceDiskPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->diskDevice.report = true;\n    dev->bus.report = true;\n    dev->model.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->diskDevice,\n                             VIR_DOMAIN_DISK_DEVICE_DISK,\n                             VIR_DOMAIN_DISK_DEVICE_CDROM);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->bus,\n                             VIR_DOMAIN_DISK_BUS_IDE,\n                             VIR_DOMAIN_DISK_BUS_SCSI,\n                             VIR_DOMAIN_DISK_BUS_XEN);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlMakeDomainOSCaps",
          "args": [
            "domCaps->machine",
            "os",
            "firmwares",
            "nfirmwares"
          ],
          "line": 758
        },
        "resolved": true,
        "details": {
          "function_name": "libxlMakeDomainOSCaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "576-609",
          "snippet": "static int\nlibxlMakeDomainOSCaps(const char *machine,\n                      virDomainCapsOSPtr os,\n                      virFirmwarePtr *firmwares,\n                      size_t nfirmwares)\n{\n    virDomainCapsLoaderPtr capsLoader = &os->loader;\n    size_t i;\n\n    os->supported = VIR_TRISTATE_BOOL_YES;\n    capsLoader->supported = VIR_TRISTATE_BOOL_NO;\n    capsLoader->type.report = true;\n    capsLoader->readonly.report = true;\n\n    if (STREQ(machine, \"xenpv\") || STREQ(machine, \"xenpvh\"))\n        return 0;\n\n    capsLoader->supported = VIR_TRISTATE_BOOL_YES;\n    if (VIR_ALLOC_N(capsLoader->values.values, nfirmwares) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        capsLoader->values.values[capsLoader->values.nvalues] = g_strdup(firmwares[i]->name);\n        capsLoader->values.nvalues++;\n    }\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_ROM,\n                             VIR_DOMAIN_LOADER_TYPE_PFLASH);\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->readonly,\n                             VIR_TRISTATE_BOOL_YES);\n\n    return 0;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomainOSCaps(const char *machine,\n                      virDomainCapsOSPtr os,\n                      virFirmwarePtr *firmwares,\n                      size_t nfirmwares)\n{\n    virDomainCapsLoaderPtr capsLoader = &os->loader;\n    size_t i;\n\n    os->supported = VIR_TRISTATE_BOOL_YES;\n    capsLoader->supported = VIR_TRISTATE_BOOL_NO;\n    capsLoader->type.report = true;\n    capsLoader->readonly.report = true;\n\n    if (STREQ(machine, \"xenpv\") || STREQ(machine, \"xenpvh\"))\n        return 0;\n\n    capsLoader->supported = VIR_TRISTATE_BOOL_YES;\n    if (VIR_ALLOC_N(capsLoader->values.values, nfirmwares) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        capsLoader->values.values[capsLoader->values.nvalues] = g_strdup(firmwares[i]->name);\n        capsLoader->values.nvalues++;\n    }\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_ROM,\n                             VIR_DOMAIN_LOADER_TYPE_PFLASH);\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->readonly,\n                             VIR_TRISTATE_BOOL_YES);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "domCaps->machine",
            "\"xenfv\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\n#define PV_MAX_VCPUS  512\n#define HVM_MAX_VCPUS 128\n\nint\nlibxlMakeDomainCapabilities(virDomainCapsPtr domCaps,\n                            virFirmwarePtr *firmwares,\n                            size_t nfirmwares)\n{\n    virDomainCapsOSPtr os = &domCaps->os;\n    virDomainCapsDeviceDiskPtr disk = &domCaps->disk;\n    virDomainCapsDeviceGraphicsPtr graphics = &domCaps->graphics;\n    virDomainCapsDeviceVideoPtr video = &domCaps->video;\n    virDomainCapsDeviceHostdevPtr hostdev = &domCaps->hostdev;\n\n    if (STREQ(domCaps->machine, \"xenfv\"))\n        domCaps->maxvcpus = HVM_MAX_VCPUS;\n    else\n        domCaps->maxvcpus = PV_MAX_VCPUS;\n\n    if (libxlMakeDomainOSCaps(domCaps->machine, os, firmwares, nfirmwares) < 0 ||\n        libxlMakeDomainDeviceDiskCaps(disk) < 0 ||\n        libxlMakeDomainDeviceGraphicsCaps(graphics) < 0 ||\n        libxlMakeDomainDeviceVideoCaps(video) < 0)\n        return -1;\n    if (STRNEQ(domCaps->machine, \"xenpvh\") &&\n        libxlMakeDomainDeviceHostdevCaps(hostdev) < 0)\n        return -1;\n\n    domCaps->features[VIR_DOMAIN_CAPS_FEATURE_IOTHREADS] = VIR_TRISTATE_BOOL_NO;\n    domCaps->features[VIR_DOMAIN_CAPS_FEATURE_VMCOREINFO] = VIR_TRISTATE_BOOL_NO;\n    domCaps->features[VIR_DOMAIN_CAPS_FEATURE_GENID] = VIR_TRISTATE_BOOL_NO;\n    domCaps->gic.supported = VIR_TRISTATE_BOOL_NO;\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeCapabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "704-730",
    "snippet": "virCapsPtr\nlibxlMakeCapabilities(libxl_ctx *ctx)\n{\n    virCapsPtr caps;\n\n#ifdef LIBXL_HAVE_NO_SUSPEND_RESUME\n    if ((caps = virCapabilitiesNew(virArchFromHost(), false, false)) == NULL)\n#else\n    if ((caps = virCapabilitiesNew(virArchFromHost(), true, true)) == NULL)\n#endif\n        return NULL;\n\n    if (libxlCapsInitHost(ctx, caps) < 0)\n        goto error;\n\n    if (libxlCapsInitNuma(ctx, caps) < 0)\n        goto error;\n\n    if (libxlCapsInitGuests(ctx, caps) < 0)\n        goto error;\n\n    return caps;\n\n error:\n    virObjectUnref(caps);\n    return NULL;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "caps"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlCapsInitGuests",
          "args": [
            "ctx",
            "caps"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "libxlCapsInitGuests",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "372-574",
          "snippet": "static int\nlibxlCapsInitGuests(libxl_ctx *ctx, virCapsPtr caps)\n{\n    const libxl_version_info *ver_info;\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autoptr(GMatchInfo) info = NULL;\n    char *str, *token;\n    char *saveptr = NULL;\n    size_t i;\n\n    struct guest_arch guest_archs[32];\n    int nr_guest_archs = 0;\n\n    memset(guest_archs, 0, sizeof(guest_archs));\n\n    if ((ver_info = libxl_get_version_info(ctx)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get version info from libxenlight\"));\n        return -1;\n    }\n\n    if (!ver_info->capabilities) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get capabilities from libxenlight\"));\n        return -1;\n    }\n\n    regex = g_regex_new(XEN_CAP_REGEX, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    /* Format of capabilities string is documented in the code in\n     * xen-unstable.hg/xen/arch/.../setup.c.\n     *\n     * It is a space-separated list of supported guest architectures.\n     *\n     * For x86:\n     *    TYP-VER-ARCH[p]\n     *    ^   ^   ^    ^\n     *    |   |   |    +-- PAE supported\n     *    |   |   +------- x86_32 or x86_64\n     *    |   +----------- the version of Xen, eg. \"3.0\"\n     *    +--------------- \"xen\" or \"hvm\" for para or full virt respectively\n     *\n     * For IA64:\n     *    TYP-VER-ARCH[be]\n     *    ^   ^   ^    ^\n     *    |   |   |    +-- Big-endian supported\n     *    |   |   +------- always \"ia64\"\n     *    |   +----------- the version of Xen, eg. \"3.0\"\n     *    +--------------- \"xen\" or \"hvm\" for para or full virt respectively\n     */\n\n    /* Split capabilities string into tokens. strtok_r is OK here because\n     * we \"own\" the buffer.  Parse out the features from each token.\n     */\n    for (str = ver_info->capabilities, nr_guest_archs = 0;\n         nr_guest_archs < sizeof(guest_archs) / sizeof(guest_archs[0])\n                 && (token = strtok_r(str, \" \", &saveptr)) != NULL;\n         str = NULL) {\n        if (g_regex_match(regex, token, 0, &info)) {\n            g_autofree char *modestr = g_match_info_fetch(info, 1);\n            g_autofree char *archstr = g_match_info_fetch(info, 2);\n            g_autofree char *suffixstr = g_match_info_fetch(info, 3);\n            int hvm = STRPREFIX(modestr, \"hvm\");\n            virArch arch;\n            int pae = 0, nonpae = 0, ia64_be = 0;\n\n            if (STRPREFIX(archstr, \"x86_32\")) {\n                arch = VIR_ARCH_I686;\n                if (suffixstr != NULL && STRPREFIX(suffixstr, \"p\"))\n                    pae = 1;\n                else\n                    nonpae = 1;\n            } else if (STRPREFIX(archstr, \"x86_64\")) {\n                arch = VIR_ARCH_X86_64;\n            } else if (STRPREFIX(archstr, \"ia64\")) {\n                arch = VIR_ARCH_ITANIUM;\n                if (suffixstr != NULL && STRPREFIX(suffixstr, \"be\"))\n                    ia64_be = 1;\n            } else if (STRPREFIX(archstr, \"powerpc64\")) {\n                arch = VIR_ARCH_PPC64;\n            } else if (STRPREFIX(archstr, \"armv7l\")) {\n                arch = VIR_ARCH_ARMV7L;\n            } else if (STRPREFIX(archstr, \"aarch64\")) {\n                arch = VIR_ARCH_AARCH64;\n            } else {\n                continue;\n            }\n\n            /* Search for existing matching (model,hvm) tuple */\n            for (i = 0; i < nr_guest_archs; i++) {\n                if ((guest_archs[i].arch == arch) &&\n                    guest_archs[i].hvm == hvm)\n                    break;\n            }\n\n            /* Too many arch flavours - highly unlikely ! */\n            if (i >= G_N_ELEMENTS(guest_archs))\n                continue;\n            /* Didn't find a match, so create a new one */\n            if (i == nr_guest_archs)\n                nr_guest_archs++;\n\n            guest_archs[i].arch = arch;\n            guest_archs[i].hvm = hvm;\n\n            /* Careful not to overwrite a previous positive\n               setting with a negative one here - some archs\n               can do both pae & non-pae, but Xen reports\n               separately capabilities so we're merging archs */\n            if (pae)\n                guest_archs[i].pae = pae;\n            if (nonpae)\n                guest_archs[i].nonpae = nonpae;\n            if (ia64_be)\n                guest_archs[i].ia64_be = ia64_be;\n\n            /*\n             * Xen 4.10 introduced support for the PVH guest type, which\n             * requires hardware virtualization support similar to the\n             * HVM guest type. Add a PVH guest type for each new HVM\n             * guest type.\n             */\n#ifdef HAVE_XEN_PVH\n            if (hvm && i == nr_guest_archs-1) {\n                /* Ensure we have not exhausted the guest_archs array */\n                if (nr_guest_archs >= G_N_ELEMENTS(guest_archs))\n                    continue;\n                i = nr_guest_archs;\n                nr_guest_archs++;\n\n                guest_archs[i].arch = arch;\n                guest_archs[i].hvm = 0;\n                guest_archs[i].pvh = 1;\n            }\n#endif\n        }\n    }\n\n    for (i = 0; i < nr_guest_archs; ++i) {\n        virCapsGuestPtr guest;\n        char const *const xen_machines[] = {\n            guest_archs[i].hvm ? \"xenfv\" :\n                (guest_archs[i].pvh ? \"xenpvh\" : \"xenpv\")};\n        virCapsGuestMachinePtr *machines;\n\n        if ((machines = virCapabilitiesAllocMachines(xen_machines, 1)) == NULL)\n            return -1;\n\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             guest_archs[i].hvm ? VIR_DOMAIN_OSTYPE_HVM :\n                                                (guest_archs[i].pvh ? VIR_DOMAIN_OSTYPE_XENPVH :\n                                                 VIR_DOMAIN_OSTYPE_XEN),\n                                             guest_archs[i].arch,\n                                             LIBXL_EXECBIN_DIR \"/qemu-system-i386\",\n                                             (guest_archs[i].hvm ?\n                                              LIBXL_FIRMWARE_DIR \"/hvmloader\" :\n                                              NULL),\n                                             1,\n                                             machines)) == NULL) {\n            virCapabilitiesFreeMachines(machines, 1);\n            return -1;\n        }\n        machines = NULL;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_XEN,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL)\n            return -1;\n\n        if (guest_archs[i].pae)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_PAE);\n\n        if (guest_archs[i].nonpae)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE);\n\n        if (guest_archs[i].ia64_be)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE);\n\n        if (guest_archs[i].hvm) {\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_ACPI,\n                                                     true, true);\n\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_APIC,\n                                                     true, false);\n        }\n\n        if (guest_archs[i].hvm || guest_archs[i].pvh) {\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_HAP,\n                                                     true, true);\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define XEN_CAP_REGEX \"(xen|hvm)-[[:digit:]]+\\\\.[[:digit:]]+-(aarch64|armv7l|x86_32|x86_64|ia64|powerpc64)(p|be)?\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\n#define XEN_CAP_REGEX \"(xen|hvm)-[[:digit:]]+\\\\.[[:digit:]]+-(aarch64|armv7l|x86_32|x86_64|ia64|powerpc64)(p|be)?\"\n\nstatic int\nlibxlCapsInitGuests(libxl_ctx *ctx, virCapsPtr caps)\n{\n    const libxl_version_info *ver_info;\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autoptr(GMatchInfo) info = NULL;\n    char *str, *token;\n    char *saveptr = NULL;\n    size_t i;\n\n    struct guest_arch guest_archs[32];\n    int nr_guest_archs = 0;\n\n    memset(guest_archs, 0, sizeof(guest_archs));\n\n    if ((ver_info = libxl_get_version_info(ctx)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get version info from libxenlight\"));\n        return -1;\n    }\n\n    if (!ver_info->capabilities) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get capabilities from libxenlight\"));\n        return -1;\n    }\n\n    regex = g_regex_new(XEN_CAP_REGEX, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    /* Format of capabilities string is documented in the code in\n     * xen-unstable.hg/xen/arch/.../setup.c.\n     *\n     * It is a space-separated list of supported guest architectures.\n     *\n     * For x86:\n     *    TYP-VER-ARCH[p]\n     *    ^   ^   ^    ^\n     *    |   |   |    +-- PAE supported\n     *    |   |   +------- x86_32 or x86_64\n     *    |   +----------- the version of Xen, eg. \"3.0\"\n     *    +--------------- \"xen\" or \"hvm\" for para or full virt respectively\n     *\n     * For IA64:\n     *    TYP-VER-ARCH[be]\n     *    ^   ^   ^    ^\n     *    |   |   |    +-- Big-endian supported\n     *    |   |   +------- always \"ia64\"\n     *    |   +----------- the version of Xen, eg. \"3.0\"\n     *    +--------------- \"xen\" or \"hvm\" for para or full virt respectively\n     */\n\n    /* Split capabilities string into tokens. strtok_r is OK here because\n     * we \"own\" the buffer.  Parse out the features from each token.\n     */\n    for (str = ver_info->capabilities, nr_guest_archs = 0;\n         nr_guest_archs < sizeof(guest_archs) / sizeof(guest_archs[0])\n                 && (token = strtok_r(str, \" \", &saveptr)) != NULL;\n         str = NULL) {\n        if (g_regex_match(regex, token, 0, &info)) {\n            g_autofree char *modestr = g_match_info_fetch(info, 1);\n            g_autofree char *archstr = g_match_info_fetch(info, 2);\n            g_autofree char *suffixstr = g_match_info_fetch(info, 3);\n            int hvm = STRPREFIX(modestr, \"hvm\");\n            virArch arch;\n            int pae = 0, nonpae = 0, ia64_be = 0;\n\n            if (STRPREFIX(archstr, \"x86_32\")) {\n                arch = VIR_ARCH_I686;\n                if (suffixstr != NULL && STRPREFIX(suffixstr, \"p\"))\n                    pae = 1;\n                else\n                    nonpae = 1;\n            } else if (STRPREFIX(archstr, \"x86_64\")) {\n                arch = VIR_ARCH_X86_64;\n            } else if (STRPREFIX(archstr, \"ia64\")) {\n                arch = VIR_ARCH_ITANIUM;\n                if (suffixstr != NULL && STRPREFIX(suffixstr, \"be\"))\n                    ia64_be = 1;\n            } else if (STRPREFIX(archstr, \"powerpc64\")) {\n                arch = VIR_ARCH_PPC64;\n            } else if (STRPREFIX(archstr, \"armv7l\")) {\n                arch = VIR_ARCH_ARMV7L;\n            } else if (STRPREFIX(archstr, \"aarch64\")) {\n                arch = VIR_ARCH_AARCH64;\n            } else {\n                continue;\n            }\n\n            /* Search for existing matching (model,hvm) tuple */\n            for (i = 0; i < nr_guest_archs; i++) {\n                if ((guest_archs[i].arch == arch) &&\n                    guest_archs[i].hvm == hvm)\n                    break;\n            }\n\n            /* Too many arch flavours - highly unlikely ! */\n            if (i >= G_N_ELEMENTS(guest_archs))\n                continue;\n            /* Didn't find a match, so create a new one */\n            if (i == nr_guest_archs)\n                nr_guest_archs++;\n\n            guest_archs[i].arch = arch;\n            guest_archs[i].hvm = hvm;\n\n            /* Careful not to overwrite a previous positive\n               setting with a negative one here - some archs\n               can do both pae & non-pae, but Xen reports\n               separately capabilities so we're merging archs */\n            if (pae)\n                guest_archs[i].pae = pae;\n            if (nonpae)\n                guest_archs[i].nonpae = nonpae;\n            if (ia64_be)\n                guest_archs[i].ia64_be = ia64_be;\n\n            /*\n             * Xen 4.10 introduced support for the PVH guest type, which\n             * requires hardware virtualization support similar to the\n             * HVM guest type. Add a PVH guest type for each new HVM\n             * guest type.\n             */\n#ifdef HAVE_XEN_PVH\n            if (hvm && i == nr_guest_archs-1) {\n                /* Ensure we have not exhausted the guest_archs array */\n                if (nr_guest_archs >= G_N_ELEMENTS(guest_archs))\n                    continue;\n                i = nr_guest_archs;\n                nr_guest_archs++;\n\n                guest_archs[i].arch = arch;\n                guest_archs[i].hvm = 0;\n                guest_archs[i].pvh = 1;\n            }\n#endif\n        }\n    }\n\n    for (i = 0; i < nr_guest_archs; ++i) {\n        virCapsGuestPtr guest;\n        char const *const xen_machines[] = {\n            guest_archs[i].hvm ? \"xenfv\" :\n                (guest_archs[i].pvh ? \"xenpvh\" : \"xenpv\")};\n        virCapsGuestMachinePtr *machines;\n\n        if ((machines = virCapabilitiesAllocMachines(xen_machines, 1)) == NULL)\n            return -1;\n\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             guest_archs[i].hvm ? VIR_DOMAIN_OSTYPE_HVM :\n                                                (guest_archs[i].pvh ? VIR_DOMAIN_OSTYPE_XENPVH :\n                                                 VIR_DOMAIN_OSTYPE_XEN),\n                                             guest_archs[i].arch,\n                                             LIBXL_EXECBIN_DIR \"/qemu-system-i386\",\n                                             (guest_archs[i].hvm ?\n                                              LIBXL_FIRMWARE_DIR \"/hvmloader\" :\n                                              NULL),\n                                             1,\n                                             machines)) == NULL) {\n            virCapabilitiesFreeMachines(machines, 1);\n            return -1;\n        }\n        machines = NULL;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_XEN,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL)\n            return -1;\n\n        if (guest_archs[i].pae)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_PAE);\n\n        if (guest_archs[i].nonpae)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE);\n\n        if (guest_archs[i].ia64_be)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE);\n\n        if (guest_archs[i].hvm) {\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_ACPI,\n                                                     true, true);\n\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_APIC,\n                                                     true, false);\n        }\n\n        if (guest_archs[i].hvm || guest_archs[i].pvh) {\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_HAP,\n                                                     true, true);\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlCapsInitNuma",
          "args": [
            "ctx",
            "caps"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "libxlCapsInitNuma",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "246-370",
          "snippet": "static int\nlibxlCapsInitNuma(libxl_ctx *ctx, virCapsPtr caps)\n{\n    libxl_numainfo *numa_info = NULL;\n    libxl_cputopology *cpu_topo = NULL;\n    int nr_nodes = 0, nr_cpus = 0, nr_siblings = 0;\n    virCapsHostNUMACellCPUPtr *cpus = NULL;\n    virCapsHostNUMACellSiblingInfoPtr siblings = NULL;\n    int *nr_cpus_node = NULL;\n    size_t i;\n    int ret = -1;\n\n    /* Let's try to fetch all the topology information */\n    numa_info = libxl_get_numainfo(ctx, &nr_nodes);\n    if (numa_info == NULL || nr_nodes == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxl_get_numainfo failed\"));\n        goto cleanup;\n    } else {\n        cpu_topo = libxl_get_cpu_topology(ctx, &nr_cpus);\n        if (cpu_topo == NULL || nr_cpus == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"libxl_get_cpu_topology failed\"));\n            goto cleanup;\n        }\n    }\n\n    if (VIR_ALLOC_N(cpus, nr_nodes) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(nr_cpus_node, nr_nodes) < 0)\n        goto cleanup;\n\n    /* For each node, prepare a list of CPUs belonging to that node */\n    for (i = 0; i < nr_cpus; i++) {\n        int node = cpu_topo[i].node;\n\n        if (cpu_topo[i].core == LIBXL_CPUTOPOLOGY_INVALID_ENTRY)\n            continue;\n\n        nr_cpus_node[node]++;\n\n        if (nr_cpus_node[node] == 1) {\n            if (VIR_ALLOC(cpus[node]) < 0)\n                goto cleanup;\n        } else {\n            if (VIR_REALLOC_N(cpus[node], nr_cpus_node[node]) < 0)\n                goto cleanup;\n        }\n\n        /* Mapping between what libxl tells and what libvirt wants */\n        cpus[node][nr_cpus_node[node]-1].id = i;\n        cpus[node][nr_cpus_node[node]-1].socket_id = cpu_topo[i].socket;\n        cpus[node][nr_cpus_node[node]-1].core_id = cpu_topo[i].core;\n        /* Allocate the siblings maps. We will be filling them later */\n        cpus[node][nr_cpus_node[node]-1].siblings = virBitmapNew(nr_cpus);\n        if (!cpus[node][nr_cpus_node[node]-1].siblings) {\n            virReportOOMError();\n            goto cleanup;\n        }\n    }\n\n    /* Let's now populate the siblings bitmaps */\n    for (i = 0; i < nr_cpus; i++) {\n        int node = cpu_topo[i].node;\n        size_t j;\n\n        if (cpu_topo[i].core == LIBXL_CPUTOPOLOGY_INVALID_ENTRY)\n            continue;\n\n        for (j = 0; j < nr_cpus_node[node]; j++) {\n            if (cpus[node][j].socket_id == cpu_topo[i].socket &&\n                cpus[node][j].core_id == cpu_topo[i].core)\n                ignore_value(virBitmapSetBit(cpus[node][j].siblings, i));\n        }\n    }\n\n    caps->host.numa = virCapabilitiesHostNUMANew();\n    for (i = 0; i < nr_nodes; i++) {\n        if (numa_info[i].size == LIBXL_NUMAINFO_INVALID_ENTRY)\n            continue;\n\n        nr_siblings = numa_info[i].num_dists;\n        if (nr_siblings) {\n            size_t j;\n\n            if (VIR_ALLOC_N(siblings, nr_siblings) < 0)\n                goto cleanup;\n\n            for (j = 0; j < nr_siblings; j++) {\n                siblings[j].node = j;\n                siblings[j].distance = numa_info[i].dists[j];\n            }\n        }\n\n        virCapabilitiesHostNUMAAddCell(caps->host.numa, i,\n                                       numa_info[i].size / 1024,\n                                       nr_cpus_node[i], cpus[i],\n                                       nr_siblings, siblings,\n                                       0, NULL);\n\n        /* This is safe, as the CPU list is now stored in the NUMA cell */\n        cpus[i] = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        for (i = 0; cpus && i < nr_nodes; i++)\n            VIR_FREE(cpus[i]);\n        if (caps->host.numa) {\n            virCapabilitiesHostNUMAUnref(caps->host.numa);\n            caps->host.numa = NULL;\n        }\n        VIR_FREE(siblings);\n    }\n\n    VIR_FREE(cpus);\n    VIR_FREE(nr_cpus_node);\n    libxl_cputopology_list_free(cpu_topo, nr_cpus);\n    libxl_numainfo_list_free(numa_info, nr_nodes);\n\n    return ret;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlCapsInitNuma(libxl_ctx *ctx, virCapsPtr caps)\n{\n    libxl_numainfo *numa_info = NULL;\n    libxl_cputopology *cpu_topo = NULL;\n    int nr_nodes = 0, nr_cpus = 0, nr_siblings = 0;\n    virCapsHostNUMACellCPUPtr *cpus = NULL;\n    virCapsHostNUMACellSiblingInfoPtr siblings = NULL;\n    int *nr_cpus_node = NULL;\n    size_t i;\n    int ret = -1;\n\n    /* Let's try to fetch all the topology information */\n    numa_info = libxl_get_numainfo(ctx, &nr_nodes);\n    if (numa_info == NULL || nr_nodes == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxl_get_numainfo failed\"));\n        goto cleanup;\n    } else {\n        cpu_topo = libxl_get_cpu_topology(ctx, &nr_cpus);\n        if (cpu_topo == NULL || nr_cpus == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"libxl_get_cpu_topology failed\"));\n            goto cleanup;\n        }\n    }\n\n    if (VIR_ALLOC_N(cpus, nr_nodes) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(nr_cpus_node, nr_nodes) < 0)\n        goto cleanup;\n\n    /* For each node, prepare a list of CPUs belonging to that node */\n    for (i = 0; i < nr_cpus; i++) {\n        int node = cpu_topo[i].node;\n\n        if (cpu_topo[i].core == LIBXL_CPUTOPOLOGY_INVALID_ENTRY)\n            continue;\n\n        nr_cpus_node[node]++;\n\n        if (nr_cpus_node[node] == 1) {\n            if (VIR_ALLOC(cpus[node]) < 0)\n                goto cleanup;\n        } else {\n            if (VIR_REALLOC_N(cpus[node], nr_cpus_node[node]) < 0)\n                goto cleanup;\n        }\n\n        /* Mapping between what libxl tells and what libvirt wants */\n        cpus[node][nr_cpus_node[node]-1].id = i;\n        cpus[node][nr_cpus_node[node]-1].socket_id = cpu_topo[i].socket;\n        cpus[node][nr_cpus_node[node]-1].core_id = cpu_topo[i].core;\n        /* Allocate the siblings maps. We will be filling them later */\n        cpus[node][nr_cpus_node[node]-1].siblings = virBitmapNew(nr_cpus);\n        if (!cpus[node][nr_cpus_node[node]-1].siblings) {\n            virReportOOMError();\n            goto cleanup;\n        }\n    }\n\n    /* Let's now populate the siblings bitmaps */\n    for (i = 0; i < nr_cpus; i++) {\n        int node = cpu_topo[i].node;\n        size_t j;\n\n        if (cpu_topo[i].core == LIBXL_CPUTOPOLOGY_INVALID_ENTRY)\n            continue;\n\n        for (j = 0; j < nr_cpus_node[node]; j++) {\n            if (cpus[node][j].socket_id == cpu_topo[i].socket &&\n                cpus[node][j].core_id == cpu_topo[i].core)\n                ignore_value(virBitmapSetBit(cpus[node][j].siblings, i));\n        }\n    }\n\n    caps->host.numa = virCapabilitiesHostNUMANew();\n    for (i = 0; i < nr_nodes; i++) {\n        if (numa_info[i].size == LIBXL_NUMAINFO_INVALID_ENTRY)\n            continue;\n\n        nr_siblings = numa_info[i].num_dists;\n        if (nr_siblings) {\n            size_t j;\n\n            if (VIR_ALLOC_N(siblings, nr_siblings) < 0)\n                goto cleanup;\n\n            for (j = 0; j < nr_siblings; j++) {\n                siblings[j].node = j;\n                siblings[j].distance = numa_info[i].dists[j];\n            }\n        }\n\n        virCapabilitiesHostNUMAAddCell(caps->host.numa, i,\n                                       numa_info[i].size / 1024,\n                                       nr_cpus_node[i], cpus[i],\n                                       nr_siblings, siblings,\n                                       0, NULL);\n\n        /* This is safe, as the CPU list is now stored in the NUMA cell */\n        cpus[i] = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        for (i = 0; cpus && i < nr_nodes; i++)\n            VIR_FREE(cpus[i]);\n        if (caps->host.numa) {\n            virCapabilitiesHostNUMAUnref(caps->host.numa);\n            caps->host.numa = NULL;\n        }\n        VIR_FREE(siblings);\n    }\n\n    VIR_FREE(cpus);\n    VIR_FREE(nr_cpus_node);\n    libxl_cputopology_list_free(cpu_topo, nr_cpus);\n    libxl_numainfo_list_free(numa_info, nr_nodes);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlCapsInitHost",
          "args": [
            "ctx",
            "caps"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "libxlCapsInitHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "211-244",
          "snippet": "static int\nlibxlCapsInitHost(libxl_ctx *ctx, virCapsPtr caps)\n{\n    const libxl_version_info *ver_info;\n    enum libxlHwcapVersion version;\n    libxl_physinfo phy_info;\n    int ret = -1;\n\n    libxl_physinfo_init(&phy_info);\n    if (libxl_get_physinfo(ctx, &phy_info) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get node physical info from libxenlight\"));\n        goto cleanup;\n    }\n\n    if ((ver_info = libxl_get_version_info(ctx)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get version info from libxenlight\"));\n        goto cleanup;\n    }\n\n    version = (ver_info->xen_version_minor >= 7);\n    if (libxlCapsInitCPU(caps, &phy_info, version) < 0)\n        goto cleanup;\n\n    if (virCapabilitiesSetNetPrefix(caps, LIBXL_GENERATED_PREFIX_XEN) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    libxl_physinfo_dispose(&phy_info);\n    return ret;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlCapsInitHost(libxl_ctx *ctx, virCapsPtr caps)\n{\n    const libxl_version_info *ver_info;\n    enum libxlHwcapVersion version;\n    libxl_physinfo phy_info;\n    int ret = -1;\n\n    libxl_physinfo_init(&phy_info);\n    if (libxl_get_physinfo(ctx, &phy_info) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get node physical info from libxenlight\"));\n        goto cleanup;\n    }\n\n    if ((ver_info = libxl_get_version_info(ctx)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get version info from libxenlight\"));\n        goto cleanup;\n    }\n\n    version = (ver_info->xen_version_minor >= 7);\n    if (libxlCapsInitCPU(caps, &phy_info, version) < 0)\n        goto cleanup;\n\n    if (virCapabilitiesSetNetPrefix(caps, LIBXL_GENERATED_PREFIX_XEN) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    libxl_physinfo_dispose(&phy_info);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesNew",
          "args": [
            "virArchFromHost()",
            "true",
            "true"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "78-96",
          "snippet": "virCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virCapsClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virCapsClass;\n\nvirCapsPtr\nvirCapabilitiesNew(virArch hostarch,\n                   bool offlineMigrate,\n                   bool liveMigrate)\n{\n    virCapsPtr caps;\n\n    if (virCapabilitiesInitialize() < 0)\n        return NULL;\n\n    if (!(caps = virObjectNew(virCapsClass)))\n        return NULL;\n\n    caps->host.arch = hostarch;\n    caps->host.offlineMigrate = offlineMigrate;\n    caps->host.liveMigrate = liveMigrate;\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virArchFromHost",
          "args": [],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "virArchFromHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virarch.c",
          "lines": "206-235",
          "snippet": "virArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}",
          "includes": [
            "#include \"virarch.h\"",
            "#include \"virlog.h\"",
            "# include <sys/utsname.h>",
            "# include <windows.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virarch.h\"\n#include \"virlog.h\"\n# include <sys/utsname.h>\n# include <windows.h>\n#include <config.h>\n\nvirArch virArchFromHost(void)\n{\n    struct utsname ut;\n    virArch arch;\n\n    uname(&ut);\n\n    /* Some special cases we need to handle first\n     * for non-canonical names */\n    if (strlen(ut.machine) == 4 &&\n        ut.machine[0] == 'i' &&\n        ut.machine[2] == '8' &&\n        ut.machine[3] == '6' &&\n        ut.machine[4] == '\\0') {\n        arch = VIR_ARCH_I686;\n    } else if (STREQ(ut.machine, \"amd64\")) {\n        arch = VIR_ARCH_X86_64;\n    } else {\n        /* Otherwise assume the canonical name */\n        if ((arch = virArchFromString(ut.machine)) == VIR_ARCH_NONE) {\n            VIR_WARN(\"Unknown host arch %s, report to libvir-list@redhat.com\",\n                     ut.machine);\n        }\n    }\n\n    VIR_DEBUG(\"Mapped %s to %d (%s)\",\n              ut.machine, arch, virArchToString(arch));\n\n    return arch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nvirCapsPtr\nlibxlMakeCapabilities(libxl_ctx *ctx)\n{\n    virCapsPtr caps;\n\n#ifdef LIBXL_HAVE_NO_SUSPEND_RESUME\n    if ((caps = virCapabilitiesNew(virArchFromHost(), false, false)) == NULL)\n#else\n    if ((caps = virCapabilitiesNew(virArchFromHost(), true, true)) == NULL)\n#endif\n        return NULL;\n\n    if (libxlCapsInitHost(ctx, caps) < 0)\n        goto error;\n\n    if (libxlCapsInitNuma(ctx, caps) < 0)\n        goto error;\n\n    if (libxlCapsInitGuests(ctx, caps) < 0)\n        goto error;\n\n    return caps;\n\n error:\n    virObjectUnref(caps);\n    return NULL;\n}"
  },
  {
    "function_name": "libxlMakeDomainDeviceHostdevCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "668-702",
    "snippet": "static int\nlibxlMakeDomainDeviceHostdevCaps(virDomainCapsDeviceHostdevPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->mode.report = true;\n    dev->startupPolicy.report = true;\n    dev->subsysType.report = true;\n    dev->capsType.report = true;\n    dev->pciBackend.report = true;\n\n    /* VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES is for containers only */\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->mode,\n                             VIR_DOMAIN_HOSTDEV_MODE_SUBSYS);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->startupPolicy,\n                             VIR_DOMAIN_STARTUP_POLICY_DEFAULT,\n                             VIR_DOMAIN_STARTUP_POLICY_MANDATORY,\n                             VIR_DOMAIN_STARTUP_POLICY_REQUISITE,\n                             VIR_DOMAIN_STARTUP_POLICY_OPTIONAL);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->subsysType,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI);\n\n    if (libxlCapsHasPVUSB())\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->subsysType,\n                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB);\n\n    /* No virDomainHostdevCapsType for libxl */\n    virDomainCapsEnumClear(&dev->capsType);\n\n    virDomainCapsEnumClear(&dev->pciBackend);\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->pciBackend,\n                             VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN);\n    return 0;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->pciBackend",
            "VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainCapsEnumClear",
          "args": [
            "&dev->pciBackend"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainCapsEnumClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_capabilities.c",
          "lines": "270-274",
          "snippet": "void\nvirDomainCapsEnumClear(virDomainCapsEnumPtr capsEnum)\n{\n    capsEnum->values = 0;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"device_conf.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"domain_conf.h\"\n#include \"domain_capabilities.h\"\n#include \"device_conf.h\"\n#include <config.h>\n\nvoid\nvirDomainCapsEnumClear(virDomainCapsEnumPtr capsEnum)\n{\n    capsEnum->values = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->subsysType",
            "VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxlCapsHasPVUSB",
          "args": [],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "libxlCapsHasPVUSB",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "659-666",
          "snippet": "bool libxlCapsHasPVUSB(void)\n{\n#ifdef LIBXL_HAVE_PVUSB\n    return true;\n#else\n    return false;\n#endif\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nbool libxlCapsHasPVUSB(void)\n{\n#ifdef LIBXL_HAVE_PVUSB\n    return true;\n#else\n    return false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->subsysType",
            "VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->startupPolicy",
            "VIR_DOMAIN_STARTUP_POLICY_DEFAULT",
            "VIR_DOMAIN_STARTUP_POLICY_MANDATORY",
            "VIR_DOMAIN_STARTUP_POLICY_REQUISITE",
            "VIR_DOMAIN_STARTUP_POLICY_OPTIONAL"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->mode",
            "VIR_DOMAIN_HOSTDEV_MODE_SUBSYS"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomainDeviceHostdevCaps(virDomainCapsDeviceHostdevPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->mode.report = true;\n    dev->startupPolicy.report = true;\n    dev->subsysType.report = true;\n    dev->capsType.report = true;\n    dev->pciBackend.report = true;\n\n    /* VIR_DOMAIN_HOSTDEV_MODE_CAPABILITIES is for containers only */\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->mode,\n                             VIR_DOMAIN_HOSTDEV_MODE_SUBSYS);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->startupPolicy,\n                             VIR_DOMAIN_STARTUP_POLICY_DEFAULT,\n                             VIR_DOMAIN_STARTUP_POLICY_MANDATORY,\n                             VIR_DOMAIN_STARTUP_POLICY_REQUISITE,\n                             VIR_DOMAIN_STARTUP_POLICY_OPTIONAL);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->subsysType,\n                             VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_PCI);\n\n    if (libxlCapsHasPVUSB())\n        VIR_DOMAIN_CAPS_ENUM_SET(dev->subsysType,\n                                 VIR_DOMAIN_HOSTDEV_SUBSYS_TYPE_USB);\n\n    /* No virDomainHostdevCapsType for libxl */\n    virDomainCapsEnumClear(&dev->capsType);\n\n    virDomainCapsEnumClear(&dev->pciBackend);\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->pciBackend,\n                             VIR_DOMAIN_HOSTDEV_PCI_BACKEND_XEN);\n    return 0;\n}"
  },
  {
    "function_name": "libxlCapsHasPVUSB",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "659-666",
    "snippet": "bool libxlCapsHasPVUSB(void)\n{\n#ifdef LIBXL_HAVE_PVUSB\n    return true;\n#else\n    return false;\n#endif\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nbool libxlCapsHasPVUSB(void)\n{\n#ifdef LIBXL_HAVE_PVUSB\n    return true;\n#else\n    return false;\n#endif\n}"
  },
  {
    "function_name": "libxlMakeDomainDeviceVideoCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "645-657",
    "snippet": "static int\nlibxlMakeDomainDeviceVideoCaps(virDomainCapsDeviceVideoPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->modelType.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType,\n                             VIR_DOMAIN_VIDEO_TYPE_VGA,\n                             VIR_DOMAIN_VIDEO_TYPE_CIRRUS,\n                             VIR_DOMAIN_VIDEO_TYPE_XEN);\n\n    return 0;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->modelType",
            "VIR_DOMAIN_VIDEO_TYPE_VGA",
            "VIR_DOMAIN_VIDEO_TYPE_CIRRUS",
            "VIR_DOMAIN_VIDEO_TYPE_XEN"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomainDeviceVideoCaps(virDomainCapsDeviceVideoPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->modelType.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->modelType,\n                             VIR_DOMAIN_VIDEO_TYPE_VGA,\n                             VIR_DOMAIN_VIDEO_TYPE_CIRRUS,\n                             VIR_DOMAIN_VIDEO_TYPE_XEN);\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeDomainDeviceGraphicsCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "631-643",
    "snippet": "static int\nlibxlMakeDomainDeviceGraphicsCaps(virDomainCapsDeviceGraphicsPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->type.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->type,\n                             VIR_DOMAIN_GRAPHICS_TYPE_SDL,\n                             VIR_DOMAIN_GRAPHICS_TYPE_VNC,\n                             VIR_DOMAIN_GRAPHICS_TYPE_SPICE);\n\n    return 0;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->type",
            "VIR_DOMAIN_GRAPHICS_TYPE_SDL",
            "VIR_DOMAIN_GRAPHICS_TYPE_VNC",
            "VIR_DOMAIN_GRAPHICS_TYPE_SPICE"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomainDeviceGraphicsCaps(virDomainCapsDeviceGraphicsPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->type.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->type,\n                             VIR_DOMAIN_GRAPHICS_TYPE_SDL,\n                             VIR_DOMAIN_GRAPHICS_TYPE_VNC,\n                             VIR_DOMAIN_GRAPHICS_TYPE_SPICE);\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeDomainDeviceDiskCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "611-629",
    "snippet": "static int\nlibxlMakeDomainDeviceDiskCaps(virDomainCapsDeviceDiskPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->diskDevice.report = true;\n    dev->bus.report = true;\n    dev->model.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->diskDevice,\n                             VIR_DOMAIN_DISK_DEVICE_DISK,\n                             VIR_DOMAIN_DISK_DEVICE_CDROM);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->bus,\n                             VIR_DOMAIN_DISK_BUS_IDE,\n                             VIR_DOMAIN_DISK_BUS_SCSI,\n                             VIR_DOMAIN_DISK_BUS_XEN);\n\n    return 0;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->bus",
            "VIR_DOMAIN_DISK_BUS_IDE",
            "VIR_DOMAIN_DISK_BUS_SCSI",
            "VIR_DOMAIN_DISK_BUS_XEN"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "dev->diskDevice",
            "VIR_DOMAIN_DISK_DEVICE_DISK",
            "VIR_DOMAIN_DISK_DEVICE_CDROM"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomainDeviceDiskCaps(virDomainCapsDeviceDiskPtr dev)\n{\n    dev->supported = VIR_TRISTATE_BOOL_YES;\n    dev->diskDevice.report = true;\n    dev->bus.report = true;\n    dev->model.report = true;\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->diskDevice,\n                             VIR_DOMAIN_DISK_DEVICE_DISK,\n                             VIR_DOMAIN_DISK_DEVICE_CDROM);\n\n    VIR_DOMAIN_CAPS_ENUM_SET(dev->bus,\n                             VIR_DOMAIN_DISK_BUS_IDE,\n                             VIR_DOMAIN_DISK_BUS_SCSI,\n                             VIR_DOMAIN_DISK_BUS_XEN);\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlMakeDomainOSCaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "576-609",
    "snippet": "static int\nlibxlMakeDomainOSCaps(const char *machine,\n                      virDomainCapsOSPtr os,\n                      virFirmwarePtr *firmwares,\n                      size_t nfirmwares)\n{\n    virDomainCapsLoaderPtr capsLoader = &os->loader;\n    size_t i;\n\n    os->supported = VIR_TRISTATE_BOOL_YES;\n    capsLoader->supported = VIR_TRISTATE_BOOL_NO;\n    capsLoader->type.report = true;\n    capsLoader->readonly.report = true;\n\n    if (STREQ(machine, \"xenpv\") || STREQ(machine, \"xenpvh\"))\n        return 0;\n\n    capsLoader->supported = VIR_TRISTATE_BOOL_YES;\n    if (VIR_ALLOC_N(capsLoader->values.values, nfirmwares) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        capsLoader->values.values[capsLoader->values.nvalues] = g_strdup(firmwares[i]->name);\n        capsLoader->values.nvalues++;\n    }\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_ROM,\n                             VIR_DOMAIN_LOADER_TYPE_PFLASH);\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->readonly,\n                             VIR_TRISTATE_BOOL_YES);\n\n    return 0;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "capsLoader->readonly",
            "VIR_TRISTATE_BOOL_YES"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DOMAIN_CAPS_ENUM_SET",
          "args": [
            "capsLoader->type",
            "VIR_DOMAIN_LOADER_TYPE_ROM",
            "VIR_DOMAIN_LOADER_TYPE_PFLASH"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "firmwares[i]->name"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "capsLoader->values.values",
            "nfirmwares"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "machine",
            "\"xenpvh\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "machine",
            "\"xenpv\""
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlMakeDomainOSCaps(const char *machine,\n                      virDomainCapsOSPtr os,\n                      virFirmwarePtr *firmwares,\n                      size_t nfirmwares)\n{\n    virDomainCapsLoaderPtr capsLoader = &os->loader;\n    size_t i;\n\n    os->supported = VIR_TRISTATE_BOOL_YES;\n    capsLoader->supported = VIR_TRISTATE_BOOL_NO;\n    capsLoader->type.report = true;\n    capsLoader->readonly.report = true;\n\n    if (STREQ(machine, \"xenpv\") || STREQ(machine, \"xenpvh\"))\n        return 0;\n\n    capsLoader->supported = VIR_TRISTATE_BOOL_YES;\n    if (VIR_ALLOC_N(capsLoader->values.values, nfirmwares) < 0)\n        return -1;\n\n    for (i = 0; i < nfirmwares; i++) {\n        capsLoader->values.values[capsLoader->values.nvalues] = g_strdup(firmwares[i]->name);\n        capsLoader->values.nvalues++;\n    }\n\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->type,\n                             VIR_DOMAIN_LOADER_TYPE_ROM,\n                             VIR_DOMAIN_LOADER_TYPE_PFLASH);\n    VIR_DOMAIN_CAPS_ENUM_SET(capsLoader->readonly,\n                             VIR_TRISTATE_BOOL_YES);\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlCapsInitGuests",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "372-574",
    "snippet": "static int\nlibxlCapsInitGuests(libxl_ctx *ctx, virCapsPtr caps)\n{\n    const libxl_version_info *ver_info;\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autoptr(GMatchInfo) info = NULL;\n    char *str, *token;\n    char *saveptr = NULL;\n    size_t i;\n\n    struct guest_arch guest_archs[32];\n    int nr_guest_archs = 0;\n\n    memset(guest_archs, 0, sizeof(guest_archs));\n\n    if ((ver_info = libxl_get_version_info(ctx)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get version info from libxenlight\"));\n        return -1;\n    }\n\n    if (!ver_info->capabilities) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get capabilities from libxenlight\"));\n        return -1;\n    }\n\n    regex = g_regex_new(XEN_CAP_REGEX, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    /* Format of capabilities string is documented in the code in\n     * xen-unstable.hg/xen/arch/.../setup.c.\n     *\n     * It is a space-separated list of supported guest architectures.\n     *\n     * For x86:\n     *    TYP-VER-ARCH[p]\n     *    ^   ^   ^    ^\n     *    |   |   |    +-- PAE supported\n     *    |   |   +------- x86_32 or x86_64\n     *    |   +----------- the version of Xen, eg. \"3.0\"\n     *    +--------------- \"xen\" or \"hvm\" for para or full virt respectively\n     *\n     * For IA64:\n     *    TYP-VER-ARCH[be]\n     *    ^   ^   ^    ^\n     *    |   |   |    +-- Big-endian supported\n     *    |   |   +------- always \"ia64\"\n     *    |   +----------- the version of Xen, eg. \"3.0\"\n     *    +--------------- \"xen\" or \"hvm\" for para or full virt respectively\n     */\n\n    /* Split capabilities string into tokens. strtok_r is OK here because\n     * we \"own\" the buffer.  Parse out the features from each token.\n     */\n    for (str = ver_info->capabilities, nr_guest_archs = 0;\n         nr_guest_archs < sizeof(guest_archs) / sizeof(guest_archs[0])\n                 && (token = strtok_r(str, \" \", &saveptr)) != NULL;\n         str = NULL) {\n        if (g_regex_match(regex, token, 0, &info)) {\n            g_autofree char *modestr = g_match_info_fetch(info, 1);\n            g_autofree char *archstr = g_match_info_fetch(info, 2);\n            g_autofree char *suffixstr = g_match_info_fetch(info, 3);\n            int hvm = STRPREFIX(modestr, \"hvm\");\n            virArch arch;\n            int pae = 0, nonpae = 0, ia64_be = 0;\n\n            if (STRPREFIX(archstr, \"x86_32\")) {\n                arch = VIR_ARCH_I686;\n                if (suffixstr != NULL && STRPREFIX(suffixstr, \"p\"))\n                    pae = 1;\n                else\n                    nonpae = 1;\n            } else if (STRPREFIX(archstr, \"x86_64\")) {\n                arch = VIR_ARCH_X86_64;\n            } else if (STRPREFIX(archstr, \"ia64\")) {\n                arch = VIR_ARCH_ITANIUM;\n                if (suffixstr != NULL && STRPREFIX(suffixstr, \"be\"))\n                    ia64_be = 1;\n            } else if (STRPREFIX(archstr, \"powerpc64\")) {\n                arch = VIR_ARCH_PPC64;\n            } else if (STRPREFIX(archstr, \"armv7l\")) {\n                arch = VIR_ARCH_ARMV7L;\n            } else if (STRPREFIX(archstr, \"aarch64\")) {\n                arch = VIR_ARCH_AARCH64;\n            } else {\n                continue;\n            }\n\n            /* Search for existing matching (model,hvm) tuple */\n            for (i = 0; i < nr_guest_archs; i++) {\n                if ((guest_archs[i].arch == arch) &&\n                    guest_archs[i].hvm == hvm)\n                    break;\n            }\n\n            /* Too many arch flavours - highly unlikely ! */\n            if (i >= G_N_ELEMENTS(guest_archs))\n                continue;\n            /* Didn't find a match, so create a new one */\n            if (i == nr_guest_archs)\n                nr_guest_archs++;\n\n            guest_archs[i].arch = arch;\n            guest_archs[i].hvm = hvm;\n\n            /* Careful not to overwrite a previous positive\n               setting with a negative one here - some archs\n               can do both pae & non-pae, but Xen reports\n               separately capabilities so we're merging archs */\n            if (pae)\n                guest_archs[i].pae = pae;\n            if (nonpae)\n                guest_archs[i].nonpae = nonpae;\n            if (ia64_be)\n                guest_archs[i].ia64_be = ia64_be;\n\n            /*\n             * Xen 4.10 introduced support for the PVH guest type, which\n             * requires hardware virtualization support similar to the\n             * HVM guest type. Add a PVH guest type for each new HVM\n             * guest type.\n             */\n#ifdef HAVE_XEN_PVH\n            if (hvm && i == nr_guest_archs-1) {\n                /* Ensure we have not exhausted the guest_archs array */\n                if (nr_guest_archs >= G_N_ELEMENTS(guest_archs))\n                    continue;\n                i = nr_guest_archs;\n                nr_guest_archs++;\n\n                guest_archs[i].arch = arch;\n                guest_archs[i].hvm = 0;\n                guest_archs[i].pvh = 1;\n            }\n#endif\n        }\n    }\n\n    for (i = 0; i < nr_guest_archs; ++i) {\n        virCapsGuestPtr guest;\n        char const *const xen_machines[] = {\n            guest_archs[i].hvm ? \"xenfv\" :\n                (guest_archs[i].pvh ? \"xenpvh\" : \"xenpv\")};\n        virCapsGuestMachinePtr *machines;\n\n        if ((machines = virCapabilitiesAllocMachines(xen_machines, 1)) == NULL)\n            return -1;\n\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             guest_archs[i].hvm ? VIR_DOMAIN_OSTYPE_HVM :\n                                                (guest_archs[i].pvh ? VIR_DOMAIN_OSTYPE_XENPVH :\n                                                 VIR_DOMAIN_OSTYPE_XEN),\n                                             guest_archs[i].arch,\n                                             LIBXL_EXECBIN_DIR \"/qemu-system-i386\",\n                                             (guest_archs[i].hvm ?\n                                              LIBXL_FIRMWARE_DIR \"/hvmloader\" :\n                                              NULL),\n                                             1,\n                                             machines)) == NULL) {\n            virCapabilitiesFreeMachines(machines, 1);\n            return -1;\n        }\n        machines = NULL;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_XEN,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL)\n            return -1;\n\n        if (guest_archs[i].pae)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_PAE);\n\n        if (guest_archs[i].nonpae)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE);\n\n        if (guest_archs[i].ia64_be)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE);\n\n        if (guest_archs[i].hvm) {\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_ACPI,\n                                                     true, true);\n\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_APIC,\n                                                     true, false);\n        }\n\n        if (guest_archs[i].hvm || guest_archs[i].pvh) {\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_HAP,\n                                                     true, true);\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define XEN_CAP_REGEX \"(xen|hvm)-[[:digit:]]+\\\\.[[:digit:]]+-(aarch64|armv7l|x86_32|x86_64|ia64|powerpc64)(p|be)?\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestFeatureWithToggle",
          "args": [
            "guest",
            "VIR_CAPS_GUEST_FEATURE_TYPE_HAP",
            "true",
            "true"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestFeatureWithToggle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "578-585",
          "snippet": "void\nvirCapabilitiesAddGuestFeatureWithToggle(virCapsGuestPtr guest,\n                                         virCapsGuestFeatureType feature,\n                                         bool defaultOn,\n                                         bool toggle)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, defaultOn, toggle);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesAddGuestFeatureWithToggle(virCapsGuestPtr guest,\n                                         virCapsGuestFeatureType feature,\n                                         bool defaultOn,\n                                         bool toggle)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, defaultOn, toggle);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestFeature",
          "args": [
            "guest",
            "VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "561-566",
          "snippet": "void\nvirCapabilitiesAddGuestFeature(virCapsGuestPtr guest,\n                               virCapsGuestFeatureType feature)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, false, false);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesAddGuestFeature(virCapsGuestPtr guest,\n                               virCapsGuestFeatureType feature)\n{\n    virCapabilitiesAddGuestFeatureInternal(guest, feature, false, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuestDomain",
          "args": [
            "guest",
            "VIR_DOMAIN_VIRT_XEN",
            "NULL",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuestDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "485-518",
          "snippet": "virCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestDomainPtr\nvirCapabilitiesAddGuestDomain(virCapsGuestPtr guest,\n                              int hvtype,\n                              const char *emulator,\n                              const char *loader,\n                              int nmachines,\n                              virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestDomainPtr dom;\n\n    if (VIR_ALLOC(dom) < 0)\n        goto error;\n\n    dom->type = hvtype;\n    dom->info.emulator = g_strdup(emulator);\n    dom->info.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(guest->arch.domains, guest->arch.ndomains_max,\n                     guest->arch.ndomains, 1) < 0)\n        goto error;\n    guest->arch.domains[guest->arch.ndomains] = dom;\n    guest->arch.ndomains++;\n\n    if (nmachines) {\n        dom->info.nmachines = nmachines;\n        dom->info.machines = machines;\n    }\n\n    return dom;\n\n error:\n    virCapabilitiesFreeGuestDomain(dom);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesFreeMachines",
          "args": [
            "machines",
            "1"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesFreeMachines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "405-417",
          "snippet": "void\nvirCapabilitiesFreeMachines(virCapsGuestMachinePtr *machines,\n                            int nmachines)\n{\n    size_t i;\n    if (!machines)\n        return;\n    for (i = 0; i < nmachines && machines[i]; i++) {\n        virCapabilitiesFreeGuestMachine(machines[i]);\n        machines[i] = NULL;\n    }\n    VIR_FREE(machines);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesFreeMachines(virCapsGuestMachinePtr *machines,\n                            int nmachines)\n{\n    size_t i;\n    if (!machines)\n        return;\n    for (i = 0; i < nmachines && machines[i]; i++) {\n        virCapabilitiesFreeGuestMachine(machines[i]);\n        machines[i] = NULL;\n    }\n    VIR_FREE(machines);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddGuest",
          "args": [
            "caps",
            "guest_archs[i].hvm ? VIR_DOMAIN_OSTYPE_HVM :\n                                                (guest_archs[i].pvh ? VIR_DOMAIN_OSTYPE_XENPVH :\n                                                 VIR_DOMAIN_OSTYPE_XEN)",
            "guest_archs[i].arch",
            "LIBXL_EXECBIN_DIR \"/qemu-system-i386\"",
            "(guest_archs[i].hvm ?\n                                              LIBXL_FIRMWARE_DIR \"/hvmloader\" :\n                                              NULL)",
            "1",
            "machines"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddGuest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "434-470",
          "snippet": "virCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestPtr\nvirCapabilitiesAddGuest(virCapsPtr caps,\n                        int ostype,\n                        virArch arch,\n                        const char *emulator,\n                        const char *loader,\n                        int nmachines,\n                        virCapsGuestMachinePtr *machines)\n{\n    virCapsGuestPtr guest;\n\n    if (VIR_ALLOC(guest) < 0)\n        goto error;\n\n    guest->ostype = ostype;\n    guest->arch.id = arch;\n    guest->arch.wordsize = virArchGetWordSize(arch);\n\n    guest->arch.defaultInfo.emulator = g_strdup(emulator);\n    guest->arch.defaultInfo.loader = g_strdup(loader);\n\n    if (VIR_RESIZE_N(caps->guests, caps->nguests_max,\n                     caps->nguests, 1) < 0)\n        goto error;\n    caps->guests[caps->nguests++] = guest;\n\n    if (nmachines) {\n        guest->arch.defaultInfo.nmachines = nmachines;\n        guest->arch.defaultInfo.machines = machines;\n    }\n\n    return guest;\n\n error:\n    virCapabilitiesFreeGuest(guest);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAllocMachines",
          "args": [
            "xen_machines",
            "1"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAllocMachines",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "379-397",
          "snippet": "virCapsGuestMachinePtr *\nvirCapabilitiesAllocMachines(const char *const *names, int nnames)\n{\n    virCapsGuestMachinePtr *machines;\n    size_t i;\n\n    if (VIR_ALLOC_N(machines, nnames) < 0)\n        return NULL;\n\n    for (i = 0; i < nnames; i++) {\n        if (VIR_ALLOC(machines[i]) < 0) {\n            virCapabilitiesFreeMachines(machines, nnames);\n            return NULL;\n        }\n        machines[i]->name = g_strdup(names[i]);\n    }\n\n    return machines;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsGuestMachinePtr *\nvirCapabilitiesAllocMachines(const char *const *names, int nnames)\n{\n    virCapsGuestMachinePtr *machines;\n    size_t i;\n\n    if (VIR_ALLOC_N(machines, nnames) < 0)\n        return NULL;\n\n    for (i = 0; i < nnames; i++) {\n        if (VIR_ALLOC(machines[i]) < 0) {\n            virCapabilitiesFreeMachines(machines, nnames);\n            return NULL;\n        }\n        machines[i]->name = g_strdup(names[i]);\n    }\n\n    return machines;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "guest_archs"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "guest_archs"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "archstr",
            "\"aarch64\""
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "archstr",
            "\"armv7l\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "archstr",
            "\"powerpc64\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "suffixstr",
            "\"be\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "archstr",
            "\"ia64\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "archstr",
            "\"x86_64\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "suffixstr",
            "\"p\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "archstr",
            "\"x86_32\""
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "modestr",
            "\"hvm\""
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_match_info_fetch",
          "args": [
            "info",
            "3"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_match_info_fetch",
          "args": [
            "info",
            "2"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_match_info_fetch",
          "args": [
            "info",
            "1"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_regex_match",
          "args": [
            "regex",
            "token",
            "0",
            "&info"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "str",
            "\" \"",
            "&saveptr"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to compile regex %s\")",
            "err->message"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to compile regex %s\""
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_regex_new",
          "args": [
            "XEN_CAP_REGEX",
            "0",
            "0",
            "&err"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to get capabilities from libxenlight\")"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to get version info from libxenlight\")"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_get_version_info",
          "args": [
            "ctx"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "guest_archs",
            "0",
            "sizeof(guest_archs)"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\n#define XEN_CAP_REGEX \"(xen|hvm)-[[:digit:]]+\\\\.[[:digit:]]+-(aarch64|armv7l|x86_32|x86_64|ia64|powerpc64)(p|be)?\"\n\nstatic int\nlibxlCapsInitGuests(libxl_ctx *ctx, virCapsPtr caps)\n{\n    const libxl_version_info *ver_info;\n    g_autoptr(GRegex) regex = NULL;\n    g_autoptr(GError) err = NULL;\n    g_autoptr(GMatchInfo) info = NULL;\n    char *str, *token;\n    char *saveptr = NULL;\n    size_t i;\n\n    struct guest_arch guest_archs[32];\n    int nr_guest_archs = 0;\n\n    memset(guest_archs, 0, sizeof(guest_archs));\n\n    if ((ver_info = libxl_get_version_info(ctx)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get version info from libxenlight\"));\n        return -1;\n    }\n\n    if (!ver_info->capabilities) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get capabilities from libxenlight\"));\n        return -1;\n    }\n\n    regex = g_regex_new(XEN_CAP_REGEX, 0, 0, &err);\n    if (!regex) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to compile regex %s\"), err->message);\n        return -1;\n    }\n\n    /* Format of capabilities string is documented in the code in\n     * xen-unstable.hg/xen/arch/.../setup.c.\n     *\n     * It is a space-separated list of supported guest architectures.\n     *\n     * For x86:\n     *    TYP-VER-ARCH[p]\n     *    ^   ^   ^    ^\n     *    |   |   |    +-- PAE supported\n     *    |   |   +------- x86_32 or x86_64\n     *    |   +----------- the version of Xen, eg. \"3.0\"\n     *    +--------------- \"xen\" or \"hvm\" for para or full virt respectively\n     *\n     * For IA64:\n     *    TYP-VER-ARCH[be]\n     *    ^   ^   ^    ^\n     *    |   |   |    +-- Big-endian supported\n     *    |   |   +------- always \"ia64\"\n     *    |   +----------- the version of Xen, eg. \"3.0\"\n     *    +--------------- \"xen\" or \"hvm\" for para or full virt respectively\n     */\n\n    /* Split capabilities string into tokens. strtok_r is OK here because\n     * we \"own\" the buffer.  Parse out the features from each token.\n     */\n    for (str = ver_info->capabilities, nr_guest_archs = 0;\n         nr_guest_archs < sizeof(guest_archs) / sizeof(guest_archs[0])\n                 && (token = strtok_r(str, \" \", &saveptr)) != NULL;\n         str = NULL) {\n        if (g_regex_match(regex, token, 0, &info)) {\n            g_autofree char *modestr = g_match_info_fetch(info, 1);\n            g_autofree char *archstr = g_match_info_fetch(info, 2);\n            g_autofree char *suffixstr = g_match_info_fetch(info, 3);\n            int hvm = STRPREFIX(modestr, \"hvm\");\n            virArch arch;\n            int pae = 0, nonpae = 0, ia64_be = 0;\n\n            if (STRPREFIX(archstr, \"x86_32\")) {\n                arch = VIR_ARCH_I686;\n                if (suffixstr != NULL && STRPREFIX(suffixstr, \"p\"))\n                    pae = 1;\n                else\n                    nonpae = 1;\n            } else if (STRPREFIX(archstr, \"x86_64\")) {\n                arch = VIR_ARCH_X86_64;\n            } else if (STRPREFIX(archstr, \"ia64\")) {\n                arch = VIR_ARCH_ITANIUM;\n                if (suffixstr != NULL && STRPREFIX(suffixstr, \"be\"))\n                    ia64_be = 1;\n            } else if (STRPREFIX(archstr, \"powerpc64\")) {\n                arch = VIR_ARCH_PPC64;\n            } else if (STRPREFIX(archstr, \"armv7l\")) {\n                arch = VIR_ARCH_ARMV7L;\n            } else if (STRPREFIX(archstr, \"aarch64\")) {\n                arch = VIR_ARCH_AARCH64;\n            } else {\n                continue;\n            }\n\n            /* Search for existing matching (model,hvm) tuple */\n            for (i = 0; i < nr_guest_archs; i++) {\n                if ((guest_archs[i].arch == arch) &&\n                    guest_archs[i].hvm == hvm)\n                    break;\n            }\n\n            /* Too many arch flavours - highly unlikely ! */\n            if (i >= G_N_ELEMENTS(guest_archs))\n                continue;\n            /* Didn't find a match, so create a new one */\n            if (i == nr_guest_archs)\n                nr_guest_archs++;\n\n            guest_archs[i].arch = arch;\n            guest_archs[i].hvm = hvm;\n\n            /* Careful not to overwrite a previous positive\n               setting with a negative one here - some archs\n               can do both pae & non-pae, but Xen reports\n               separately capabilities so we're merging archs */\n            if (pae)\n                guest_archs[i].pae = pae;\n            if (nonpae)\n                guest_archs[i].nonpae = nonpae;\n            if (ia64_be)\n                guest_archs[i].ia64_be = ia64_be;\n\n            /*\n             * Xen 4.10 introduced support for the PVH guest type, which\n             * requires hardware virtualization support similar to the\n             * HVM guest type. Add a PVH guest type for each new HVM\n             * guest type.\n             */\n#ifdef HAVE_XEN_PVH\n            if (hvm && i == nr_guest_archs-1) {\n                /* Ensure we have not exhausted the guest_archs array */\n                if (nr_guest_archs >= G_N_ELEMENTS(guest_archs))\n                    continue;\n                i = nr_guest_archs;\n                nr_guest_archs++;\n\n                guest_archs[i].arch = arch;\n                guest_archs[i].hvm = 0;\n                guest_archs[i].pvh = 1;\n            }\n#endif\n        }\n    }\n\n    for (i = 0; i < nr_guest_archs; ++i) {\n        virCapsGuestPtr guest;\n        char const *const xen_machines[] = {\n            guest_archs[i].hvm ? \"xenfv\" :\n                (guest_archs[i].pvh ? \"xenpvh\" : \"xenpv\")};\n        virCapsGuestMachinePtr *machines;\n\n        if ((machines = virCapabilitiesAllocMachines(xen_machines, 1)) == NULL)\n            return -1;\n\n        if ((guest = virCapabilitiesAddGuest(caps,\n                                             guest_archs[i].hvm ? VIR_DOMAIN_OSTYPE_HVM :\n                                                (guest_archs[i].pvh ? VIR_DOMAIN_OSTYPE_XENPVH :\n                                                 VIR_DOMAIN_OSTYPE_XEN),\n                                             guest_archs[i].arch,\n                                             LIBXL_EXECBIN_DIR \"/qemu-system-i386\",\n                                             (guest_archs[i].hvm ?\n                                              LIBXL_FIRMWARE_DIR \"/hvmloader\" :\n                                              NULL),\n                                             1,\n                                             machines)) == NULL) {\n            virCapabilitiesFreeMachines(machines, 1);\n            return -1;\n        }\n        machines = NULL;\n\n        if (virCapabilitiesAddGuestDomain(guest,\n                                          VIR_DOMAIN_VIRT_XEN,\n                                          NULL,\n                                          NULL,\n                                          0,\n                                          NULL) == NULL)\n            return -1;\n\n        if (guest_archs[i].pae)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_PAE);\n\n        if (guest_archs[i].nonpae)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_NONPAE);\n\n        if (guest_archs[i].ia64_be)\n            virCapabilitiesAddGuestFeature(guest, VIR_CAPS_GUEST_FEATURE_TYPE_IA64_BE);\n\n        if (guest_archs[i].hvm) {\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_ACPI,\n                                                     true, true);\n\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_APIC,\n                                                     true, false);\n        }\n\n        if (guest_archs[i].hvm || guest_archs[i].pvh) {\n            virCapabilitiesAddGuestFeatureWithToggle(guest, VIR_CAPS_GUEST_FEATURE_TYPE_HAP,\n                                                     true, true);\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "libxlCapsInitNuma",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "246-370",
    "snippet": "static int\nlibxlCapsInitNuma(libxl_ctx *ctx, virCapsPtr caps)\n{\n    libxl_numainfo *numa_info = NULL;\n    libxl_cputopology *cpu_topo = NULL;\n    int nr_nodes = 0, nr_cpus = 0, nr_siblings = 0;\n    virCapsHostNUMACellCPUPtr *cpus = NULL;\n    virCapsHostNUMACellSiblingInfoPtr siblings = NULL;\n    int *nr_cpus_node = NULL;\n    size_t i;\n    int ret = -1;\n\n    /* Let's try to fetch all the topology information */\n    numa_info = libxl_get_numainfo(ctx, &nr_nodes);\n    if (numa_info == NULL || nr_nodes == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxl_get_numainfo failed\"));\n        goto cleanup;\n    } else {\n        cpu_topo = libxl_get_cpu_topology(ctx, &nr_cpus);\n        if (cpu_topo == NULL || nr_cpus == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"libxl_get_cpu_topology failed\"));\n            goto cleanup;\n        }\n    }\n\n    if (VIR_ALLOC_N(cpus, nr_nodes) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(nr_cpus_node, nr_nodes) < 0)\n        goto cleanup;\n\n    /* For each node, prepare a list of CPUs belonging to that node */\n    for (i = 0; i < nr_cpus; i++) {\n        int node = cpu_topo[i].node;\n\n        if (cpu_topo[i].core == LIBXL_CPUTOPOLOGY_INVALID_ENTRY)\n            continue;\n\n        nr_cpus_node[node]++;\n\n        if (nr_cpus_node[node] == 1) {\n            if (VIR_ALLOC(cpus[node]) < 0)\n                goto cleanup;\n        } else {\n            if (VIR_REALLOC_N(cpus[node], nr_cpus_node[node]) < 0)\n                goto cleanup;\n        }\n\n        /* Mapping between what libxl tells and what libvirt wants */\n        cpus[node][nr_cpus_node[node]-1].id = i;\n        cpus[node][nr_cpus_node[node]-1].socket_id = cpu_topo[i].socket;\n        cpus[node][nr_cpus_node[node]-1].core_id = cpu_topo[i].core;\n        /* Allocate the siblings maps. We will be filling them later */\n        cpus[node][nr_cpus_node[node]-1].siblings = virBitmapNew(nr_cpus);\n        if (!cpus[node][nr_cpus_node[node]-1].siblings) {\n            virReportOOMError();\n            goto cleanup;\n        }\n    }\n\n    /* Let's now populate the siblings bitmaps */\n    for (i = 0; i < nr_cpus; i++) {\n        int node = cpu_topo[i].node;\n        size_t j;\n\n        if (cpu_topo[i].core == LIBXL_CPUTOPOLOGY_INVALID_ENTRY)\n            continue;\n\n        for (j = 0; j < nr_cpus_node[node]; j++) {\n            if (cpus[node][j].socket_id == cpu_topo[i].socket &&\n                cpus[node][j].core_id == cpu_topo[i].core)\n                ignore_value(virBitmapSetBit(cpus[node][j].siblings, i));\n        }\n    }\n\n    caps->host.numa = virCapabilitiesHostNUMANew();\n    for (i = 0; i < nr_nodes; i++) {\n        if (numa_info[i].size == LIBXL_NUMAINFO_INVALID_ENTRY)\n            continue;\n\n        nr_siblings = numa_info[i].num_dists;\n        if (nr_siblings) {\n            size_t j;\n\n            if (VIR_ALLOC_N(siblings, nr_siblings) < 0)\n                goto cleanup;\n\n            for (j = 0; j < nr_siblings; j++) {\n                siblings[j].node = j;\n                siblings[j].distance = numa_info[i].dists[j];\n            }\n        }\n\n        virCapabilitiesHostNUMAAddCell(caps->host.numa, i,\n                                       numa_info[i].size / 1024,\n                                       nr_cpus_node[i], cpus[i],\n                                       nr_siblings, siblings,\n                                       0, NULL);\n\n        /* This is safe, as the CPU list is now stored in the NUMA cell */\n        cpus[i] = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        for (i = 0; cpus && i < nr_nodes; i++)\n            VIR_FREE(cpus[i]);\n        if (caps->host.numa) {\n            virCapabilitiesHostNUMAUnref(caps->host.numa);\n            caps->host.numa = NULL;\n        }\n        VIR_FREE(siblings);\n    }\n\n    VIR_FREE(cpus);\n    VIR_FREE(nr_cpus_node);\n    libxl_cputopology_list_free(cpu_topo, nr_cpus);\n    libxl_numainfo_list_free(numa_info, nr_nodes);\n\n    return ret;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxl_numainfo_list_free",
          "args": [
            "numa_info",
            "nr_nodes"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_cputopology_list_free",
          "args": [
            "cpu_topo",
            "nr_cpus"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "nr_cpus_node"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpus"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "siblings"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMAUnref",
          "args": [
            "caps->host.numa"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMAUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "184-195",
          "snippet": "void\nvirCapabilitiesHostNUMAUnref(virCapsHostNUMAPtr caps)\n{\n    if (!caps)\n        return;\n\n    if (g_atomic_int_dec_and_test(&caps->refs)) {\n        g_ptr_array_unref(caps->cells);\n\n        VIR_FREE(caps);\n    }\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesHostNUMAUnref(virCapsHostNUMAPtr caps)\n{\n    if (!caps)\n        return;\n\n    if (g_atomic_int_dec_and_test(&caps->refs)) {\n        g_ptr_array_unref(caps->cells);\n\n        VIR_FREE(caps);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "cpus[i]"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMAAddCell",
          "args": [
            "caps->host.numa",
            "i",
            "numa_info[i].size / 1024",
            "nr_cpus_node[i]",
            "cpus[i]",
            "nr_siblings",
            "siblings",
            "0",
            "NULL"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMAAddCell",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "346-369",
          "snippet": "void\nvirCapabilitiesHostNUMAAddCell(virCapsHostNUMAPtr caps,\n                               int num,\n                               unsigned long long mem,\n                               int ncpus,\n                               virCapsHostNUMACellCPUPtr cpus,\n                               int nsiblings,\n                               virCapsHostNUMACellSiblingInfoPtr siblings,\n                               int npageinfo,\n                               virCapsHostNUMACellPageInfoPtr pageinfo)\n{\n    virCapsHostNUMACellPtr cell = g_new0(virCapsHostNUMACell, 1);\n\n    cell->num = num;\n    cell->mem = mem;\n    cell->ncpus = ncpus;\n    cell->cpus = cpus;\n    cell->nsiblings = nsiblings;\n    cell->siblings = siblings;\n    cell->npageinfo = npageinfo;\n    cell->pageinfo = pageinfo;\n\n    g_ptr_array_add(caps->cells, cell);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvoid\nvirCapabilitiesHostNUMAAddCell(virCapsHostNUMAPtr caps,\n                               int num,\n                               unsigned long long mem,\n                               int ncpus,\n                               virCapsHostNUMACellCPUPtr cpus,\n                               int nsiblings,\n                               virCapsHostNUMACellSiblingInfoPtr siblings,\n                               int npageinfo,\n                               virCapsHostNUMACellPageInfoPtr pageinfo)\n{\n    virCapsHostNUMACellPtr cell = g_new0(virCapsHostNUMACell, 1);\n\n    cell->num = num;\n    cell->mem = mem;\n    cell->ncpus = ncpus;\n    cell->cpus = cpus;\n    cell->nsiblings = nsiblings;\n    cell->siblings = siblings;\n    cell->npageinfo = npageinfo;\n    cell->pageinfo = pageinfo;\n\n    g_ptr_array_add(caps->cells, cell);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "siblings",
            "nr_siblings"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesHostNUMANew",
          "args": [],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesHostNUMANewHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "1714-1734",
          "snippet": "virCapsHostNUMAPtr\nvirCapabilitiesHostNUMANewHost(void)\n{\n    virCapsHostNUMAPtr caps = virCapabilitiesHostNUMANew();\n\n    if (virNumaIsAvailable()) {\n        if (virCapabilitiesHostNUMAInitReal(caps) == 0)\n            return caps;\n\n        virCapabilitiesHostNUMAUnref(caps);\n        caps = virCapabilitiesHostNUMANew();\n        VIR_WARN(\"Failed to query host NUMA topology, faking single NUMA node\");\n    }\n\n    if (virCapabilitiesHostNUMAInitFake(caps) < 0) {\n        virCapabilitiesHostNUMAUnref(caps);\n        return NULL;\n    }\n\n    return caps;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nvirCapsHostNUMAPtr\nvirCapabilitiesHostNUMANewHost(void)\n{\n    virCapsHostNUMAPtr caps = virCapabilitiesHostNUMANew();\n\n    if (virNumaIsAvailable()) {\n        if (virCapabilitiesHostNUMAInitReal(caps) == 0)\n            return caps;\n\n        virCapabilitiesHostNUMAUnref(caps);\n        caps = virCapabilitiesHostNUMANew();\n        VIR_WARN(\"Failed to query host NUMA topology, faking single NUMA node\");\n    }\n\n    if (virCapabilitiesHostNUMAInitFake(caps) < 0) {\n        virCapabilitiesHostNUMAUnref(caps);\n        return NULL;\n    }\n\n    return caps;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "virBitmapSetBit(cpus[node][j].siblings, i)"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapSetBit",
          "args": [
            "cpus[node][j].siblings",
            "i"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapSetBitExpand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "222-231",
          "snippet": "int\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nint\nvirBitmapSetBitExpand(virBitmapPtr bitmap,\n                      size_t b)\n{\n    if (bitmap->nbits <= b && virBitmapExpand(bitmap, b) < 0)\n        return -1;\n\n    bitmap->map[VIR_BITMAP_UNIT_OFFSET(b)] |= VIR_BITMAP_BIT(b);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBitmapNew",
          "args": [
            "nr_cpus"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "virBitmapNewString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virbitmap.c",
          "lines": "1144-1168",
          "snippet": "virBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}",
          "includes": [
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbitmap.h\"",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virbitmap.h\"\n#include <sys/types.h>\n#include <config.h>\n\nvirBitmapPtr\nvirBitmapNewString(const char *string)\n{\n    virBitmapPtr bitmap;\n    size_t i = 0;\n    size_t len = strlen(string);\n\n    if (strspn(string, \"0123456789abcdefABCDEF\") != len) {\n        virReportError(VIR_ERR_INVALID_ARG,\n                       _(\"Invalid hexadecimal string '%s'\"), string);\n        return NULL;\n    }\n\n    bitmap = virBitmapNew(len * 4);\n    if (!bitmap)\n        return NULL;\n\n    for (i = 0; i < len; i++) {\n        unsigned long nibble = g_ascii_xdigit_value(string[len - i - 1]);\n        nibble <<= VIR_BITMAP_BIT_OFFSET(i * 4);\n        bitmap->map[VIR_BITMAP_UNIT_OFFSET(i * 4)] |= nibble;\n    }\n\n    return bitmap;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_REALLOC_N",
          "args": [
            "cpus[node]",
            "nr_cpus_node[node]"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "cpus[node]"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "nr_cpus_node",
            "nr_nodes"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC_N",
          "args": [
            "cpus",
            "nr_nodes"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libxl_get_cpu_topology failed\")"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"libxl_get_cpu_topology failed\""
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_get_cpu_topology",
          "args": [
            "ctx",
            "&nr_cpus"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"libxl_get_numainfo failed\")"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_get_numainfo",
          "args": [
            "ctx",
            "&nr_nodes"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlCapsInitNuma(libxl_ctx *ctx, virCapsPtr caps)\n{\n    libxl_numainfo *numa_info = NULL;\n    libxl_cputopology *cpu_topo = NULL;\n    int nr_nodes = 0, nr_cpus = 0, nr_siblings = 0;\n    virCapsHostNUMACellCPUPtr *cpus = NULL;\n    virCapsHostNUMACellSiblingInfoPtr siblings = NULL;\n    int *nr_cpus_node = NULL;\n    size_t i;\n    int ret = -1;\n\n    /* Let's try to fetch all the topology information */\n    numa_info = libxl_get_numainfo(ctx, &nr_nodes);\n    if (numa_info == NULL || nr_nodes == 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"libxl_get_numainfo failed\"));\n        goto cleanup;\n    } else {\n        cpu_topo = libxl_get_cpu_topology(ctx, &nr_cpus);\n        if (cpu_topo == NULL || nr_cpus == 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"libxl_get_cpu_topology failed\"));\n            goto cleanup;\n        }\n    }\n\n    if (VIR_ALLOC_N(cpus, nr_nodes) < 0)\n        goto cleanup;\n\n    if (VIR_ALLOC_N(nr_cpus_node, nr_nodes) < 0)\n        goto cleanup;\n\n    /* For each node, prepare a list of CPUs belonging to that node */\n    for (i = 0; i < nr_cpus; i++) {\n        int node = cpu_topo[i].node;\n\n        if (cpu_topo[i].core == LIBXL_CPUTOPOLOGY_INVALID_ENTRY)\n            continue;\n\n        nr_cpus_node[node]++;\n\n        if (nr_cpus_node[node] == 1) {\n            if (VIR_ALLOC(cpus[node]) < 0)\n                goto cleanup;\n        } else {\n            if (VIR_REALLOC_N(cpus[node], nr_cpus_node[node]) < 0)\n                goto cleanup;\n        }\n\n        /* Mapping between what libxl tells and what libvirt wants */\n        cpus[node][nr_cpus_node[node]-1].id = i;\n        cpus[node][nr_cpus_node[node]-1].socket_id = cpu_topo[i].socket;\n        cpus[node][nr_cpus_node[node]-1].core_id = cpu_topo[i].core;\n        /* Allocate the siblings maps. We will be filling them later */\n        cpus[node][nr_cpus_node[node]-1].siblings = virBitmapNew(nr_cpus);\n        if (!cpus[node][nr_cpus_node[node]-1].siblings) {\n            virReportOOMError();\n            goto cleanup;\n        }\n    }\n\n    /* Let's now populate the siblings bitmaps */\n    for (i = 0; i < nr_cpus; i++) {\n        int node = cpu_topo[i].node;\n        size_t j;\n\n        if (cpu_topo[i].core == LIBXL_CPUTOPOLOGY_INVALID_ENTRY)\n            continue;\n\n        for (j = 0; j < nr_cpus_node[node]; j++) {\n            if (cpus[node][j].socket_id == cpu_topo[i].socket &&\n                cpus[node][j].core_id == cpu_topo[i].core)\n                ignore_value(virBitmapSetBit(cpus[node][j].siblings, i));\n        }\n    }\n\n    caps->host.numa = virCapabilitiesHostNUMANew();\n    for (i = 0; i < nr_nodes; i++) {\n        if (numa_info[i].size == LIBXL_NUMAINFO_INVALID_ENTRY)\n            continue;\n\n        nr_siblings = numa_info[i].num_dists;\n        if (nr_siblings) {\n            size_t j;\n\n            if (VIR_ALLOC_N(siblings, nr_siblings) < 0)\n                goto cleanup;\n\n            for (j = 0; j < nr_siblings; j++) {\n                siblings[j].node = j;\n                siblings[j].distance = numa_info[i].dists[j];\n            }\n        }\n\n        virCapabilitiesHostNUMAAddCell(caps->host.numa, i,\n                                       numa_info[i].size / 1024,\n                                       nr_cpus_node[i], cpus[i],\n                                       nr_siblings, siblings,\n                                       0, NULL);\n\n        /* This is safe, as the CPU list is now stored in the NUMA cell */\n        cpus[i] = NULL;\n    }\n\n    ret = 0;\n\n cleanup:\n    if (ret != 0) {\n        for (i = 0; cpus && i < nr_nodes; i++)\n            VIR_FREE(cpus[i]);\n        if (caps->host.numa) {\n            virCapabilitiesHostNUMAUnref(caps->host.numa);\n            caps->host.numa = NULL;\n        }\n        VIR_FREE(siblings);\n    }\n\n    VIR_FREE(cpus);\n    VIR_FREE(nr_cpus_node);\n    libxl_cputopology_list_free(cpu_topo, nr_cpus);\n    libxl_numainfo_list_free(numa_info, nr_nodes);\n\n    return ret;\n}"
  },
  {
    "function_name": "libxlCapsInitHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "211-244",
    "snippet": "static int\nlibxlCapsInitHost(libxl_ctx *ctx, virCapsPtr caps)\n{\n    const libxl_version_info *ver_info;\n    enum libxlHwcapVersion version;\n    libxl_physinfo phy_info;\n    int ret = -1;\n\n    libxl_physinfo_init(&phy_info);\n    if (libxl_get_physinfo(ctx, &phy_info) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get node physical info from libxenlight\"));\n        goto cleanup;\n    }\n\n    if ((ver_info = libxl_get_version_info(ctx)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get version info from libxenlight\"));\n        goto cleanup;\n    }\n\n    version = (ver_info->xen_version_minor >= 7);\n    if (libxlCapsInitCPU(caps, &phy_info, version) < 0)\n        goto cleanup;\n\n    if (virCapabilitiesSetNetPrefix(caps, LIBXL_GENERATED_PREFIX_XEN) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    libxl_physinfo_dispose(&phy_info);\n    return ret;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "libxl_physinfo_dispose",
          "args": [
            "&phy_info"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCapabilitiesSetNetPrefix",
          "args": [
            "caps",
            "LIBXL_GENERATED_PREFIX_XEN"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesSetNetPrefix",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "321-328",
          "snippet": "int\nvirCapabilitiesSetNetPrefix(virCapsPtr caps,\n                            const char *prefix)\n{\n    caps->host.netprefix = g_strdup(prefix);\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesSetNetPrefix(virCapsPtr caps,\n                            const char *prefix)\n{\n    caps->host.netprefix = g_strdup(prefix);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlCapsInitCPU",
          "args": [
            "caps",
            "&phy_info",
            "version"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "libxlCapsInitCPU",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "158-209",
          "snippet": "static int\nlibxlCapsInitCPU(virCapsPtr caps, libxl_physinfo *phy_info,\n                 enum libxlHwcapVersion version)\n{\n    virCPUDataPtr data = NULL;\n    virCPUDefPtr cpu = NULL;\n    int ret = -1;\n    int host_pae;\n    int host_lm;\n\n    /* On ARM hw_cap vector is zeroed out but not on x86 */\n    if (!phy_info->hw_cap[0])\n        return 0;\n\n    cpu = virCPUDefNew();\n\n    host_pae = phy_info->hw_cap[0] & LIBXL_X86_FEATURE_PAE_MASK;\n    if (host_pae &&\n        virCapabilitiesAddHostFeature(caps, \"pae\") < 0)\n        goto error;\n\n    host_lm = (phy_info->hw_cap[version > LIBXL_HWCAP_V0 ? 2 : 1]\n                & LIBXL_X86_FEATURE_LM_MASK);\n    if (host_lm)\n        cpu->arch = VIR_ARCH_X86_64;\n    else\n        cpu->arch = VIR_ARCH_I686;\n\n    cpu->type = VIR_CPU_TYPE_HOST;\n    cpu->cores = phy_info->cores_per_socket;\n    cpu->threads = phy_info->threads_per_core;\n    cpu->dies = 1;\n    cpu->sockets = phy_info->nr_cpus / (cpu->cores * cpu->threads);\n    caps->host.cpu = cpu;\n\n    ret = 0;\n\n    if (!(data = libxlCapsNodeData(cpu, phy_info->hw_cap, version)) ||\n        cpuDecode(cpu, data, NULL) < 0) {\n        VIR_WARN(\"Failed to initialize host cpu features\");\n        goto error;\n    }\n\n cleanup:\n    virCPUDataFree(data);\n\n    return ret;\n\n error:\n    virCPUDefFree(cpu);\n    goto cleanup;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define LIBXL_X86_FEATURE_LM_MASK  (1 << 29)",
            "#define LIBXL_X86_FEATURE_PAE_MASK (1 << 6)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\n#define LIBXL_X86_FEATURE_LM_MASK  (1 << 29)\n#define LIBXL_X86_FEATURE_PAE_MASK (1 << 6)\n\nstatic int\nlibxlCapsInitCPU(virCapsPtr caps, libxl_physinfo *phy_info,\n                 enum libxlHwcapVersion version)\n{\n    virCPUDataPtr data = NULL;\n    virCPUDefPtr cpu = NULL;\n    int ret = -1;\n    int host_pae;\n    int host_lm;\n\n    /* On ARM hw_cap vector is zeroed out but not on x86 */\n    if (!phy_info->hw_cap[0])\n        return 0;\n\n    cpu = virCPUDefNew();\n\n    host_pae = phy_info->hw_cap[0] & LIBXL_X86_FEATURE_PAE_MASK;\n    if (host_pae &&\n        virCapabilitiesAddHostFeature(caps, \"pae\") < 0)\n        goto error;\n\n    host_lm = (phy_info->hw_cap[version > LIBXL_HWCAP_V0 ? 2 : 1]\n                & LIBXL_X86_FEATURE_LM_MASK);\n    if (host_lm)\n        cpu->arch = VIR_ARCH_X86_64;\n    else\n        cpu->arch = VIR_ARCH_I686;\n\n    cpu->type = VIR_CPU_TYPE_HOST;\n    cpu->cores = phy_info->cores_per_socket;\n    cpu->threads = phy_info->threads_per_core;\n    cpu->dies = 1;\n    cpu->sockets = phy_info->nr_cpus / (cpu->cores * cpu->threads);\n    caps->host.cpu = cpu;\n\n    ret = 0;\n\n    if (!(data = libxlCapsNodeData(cpu, phy_info->hw_cap, version)) ||\n        cpuDecode(cpu, data, NULL) < 0) {\n        VIR_WARN(\"Failed to initialize host cpu features\");\n        goto error;\n    }\n\n cleanup:\n    virCPUDataFree(data);\n\n    return ret;\n\n error:\n    virCPUDefFree(cpu);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to get version info from libxenlight\")"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to get version info from libxenlight\""
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "libvirt_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_logger.c",
          "lines": "125-130",
          "snippet": "static void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}",
          "includes": [
            "#include \"util/virtime.h\"",
            "#include \"util/virstring.h\"",
            "#include \"util/virhash.h\"",
            "#include \"util/virfile.h\"",
            "#include \"util/virerror.h\"",
            "#include \"util/viralloc.h\"",
            "#include \"libxl_logger.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"util/virtime.h\"\n#include \"util/virstring.h\"\n#include \"util/virhash.h\"\n#include \"util/virfile.h\"\n#include \"util/virerror.h\"\n#include \"util/viralloc.h\"\n#include \"libxl_logger.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic void\nlibvirt_destroy(xentoollog_logger *logger_in)\n{\n    xentoollog_logger_libvirt *lg = (xentoollog_logger_libvirt*)logger_in;\n    VIR_FREE(lg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxl_get_version_info",
          "args": [
            "ctx"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Failed to get node physical info from libxenlight\")"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_get_physinfo",
          "args": [
            "ctx",
            "&phy_info"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "libxl_physinfo_init",
          "args": [
            "&phy_info"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlCapsInitHost(libxl_ctx *ctx, virCapsPtr caps)\n{\n    const libxl_version_info *ver_info;\n    enum libxlHwcapVersion version;\n    libxl_physinfo phy_info;\n    int ret = -1;\n\n    libxl_physinfo_init(&phy_info);\n    if (libxl_get_physinfo(ctx, &phy_info) != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get node physical info from libxenlight\"));\n        goto cleanup;\n    }\n\n    if ((ver_info = libxl_get_version_info(ctx)) == NULL) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to get version info from libxenlight\"));\n        goto cleanup;\n    }\n\n    version = (ver_info->xen_version_minor >= 7);\n    if (libxlCapsInitCPU(caps, &phy_info, version) < 0)\n        goto cleanup;\n\n    if (virCapabilitiesSetNetPrefix(caps, LIBXL_GENERATED_PREFIX_XEN) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    libxl_physinfo_dispose(&phy_info);\n    return ret;\n}"
  },
  {
    "function_name": "libxlCapsInitCPU",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "158-209",
    "snippet": "static int\nlibxlCapsInitCPU(virCapsPtr caps, libxl_physinfo *phy_info,\n                 enum libxlHwcapVersion version)\n{\n    virCPUDataPtr data = NULL;\n    virCPUDefPtr cpu = NULL;\n    int ret = -1;\n    int host_pae;\n    int host_lm;\n\n    /* On ARM hw_cap vector is zeroed out but not on x86 */\n    if (!phy_info->hw_cap[0])\n        return 0;\n\n    cpu = virCPUDefNew();\n\n    host_pae = phy_info->hw_cap[0] & LIBXL_X86_FEATURE_PAE_MASK;\n    if (host_pae &&\n        virCapabilitiesAddHostFeature(caps, \"pae\") < 0)\n        goto error;\n\n    host_lm = (phy_info->hw_cap[version > LIBXL_HWCAP_V0 ? 2 : 1]\n                & LIBXL_X86_FEATURE_LM_MASK);\n    if (host_lm)\n        cpu->arch = VIR_ARCH_X86_64;\n    else\n        cpu->arch = VIR_ARCH_I686;\n\n    cpu->type = VIR_CPU_TYPE_HOST;\n    cpu->cores = phy_info->cores_per_socket;\n    cpu->threads = phy_info->threads_per_core;\n    cpu->dies = 1;\n    cpu->sockets = phy_info->nr_cpus / (cpu->cores * cpu->threads);\n    caps->host.cpu = cpu;\n\n    ret = 0;\n\n    if (!(data = libxlCapsNodeData(cpu, phy_info->hw_cap, version)) ||\n        cpuDecode(cpu, data, NULL) < 0) {\n        VIR_WARN(\"Failed to initialize host cpu features\");\n        goto error;\n    }\n\n cleanup:\n    virCPUDataFree(data);\n\n    return ret;\n\n error:\n    virCPUDefFree(cpu);\n    goto cleanup;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define LIBXL_X86_FEATURE_LM_MASK  (1 << 29)",
      "#define LIBXL_X86_FEATURE_PAE_MASK (1 << 6)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDefFree",
          "args": [
            "cpu"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "120-132",
          "snippet": "void\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid\nvirCPUDefFree(virCPUDefPtr def)\n{\n    if (!def)\n        return;\n\n    if (g_atomic_int_dec_and_test(&def->refs)) {\n        virCPUDefFreeModel(def);\n        VIR_FREE(def->cache);\n        VIR_FREE(def->tsc);\n        VIR_FREE(def);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDataFree",
          "args": [
            "data"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "313-327",
          "snippet": "void\nvirCPUDataFree(virCPUDataPtr data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!data)\n        return;\n\n    if ((driver = cpuGetSubDriver(data->arch)) && driver->dataFree)\n        driver->dataFree(data);\n    else\n        VIR_FREE(data);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvoid\nvirCPUDataFree(virCPUDataPtr data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!data)\n        return;\n\n    if ((driver = cpuGetSubDriver(data->arch)) && driver->dataFree)\n        driver->dataFree(data);\n    else\n        VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to initialize host cpu features\""
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpuDecode",
          "args": [
            "cpu",
            "data",
            "NULL"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "cpuDecode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "193-225",
          "snippet": "int\ncpuDecode(virCPUDefPtr cpu,\n          const virCPUData *data,\n          virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"cpu=%p, data=%p, models=%p\", cpu, data, models);\n    if (models) {\n        size_t i;\n        for (i = 0; i < models->nmodels; i++)\n            VIR_DEBUG(\"models[%zu]=%s\", i, models->models[i].name);\n    }\n\n    if (cpu->type > VIR_CPU_TYPE_GUEST ||\n        cpu->mode != VIR_CPU_MODE_CUSTOM) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid CPU definition stub\"));\n        return -1;\n    }\n\n    if ((driver = cpuGetSubDriver(data->arch)) == NULL)\n        return -1;\n\n    if (driver->decode == NULL) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot decode CPU data for %s architecture\"),\n                       virArchToString(cpu->arch));\n        return -1;\n    }\n\n    return driver->decode(cpu, data, models);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nint\ncpuDecode(virCPUDefPtr cpu,\n          const virCPUData *data,\n          virDomainCapsCPUModelsPtr models)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"cpu=%p, data=%p, models=%p\", cpu, data, models);\n    if (models) {\n        size_t i;\n        for (i = 0; i < models->nmodels; i++)\n            VIR_DEBUG(\"models[%zu]=%s\", i, models->models[i].name);\n    }\n\n    if (cpu->type > VIR_CPU_TYPE_GUEST ||\n        cpu->mode != VIR_CPU_MODE_CUSTOM) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"invalid CPU definition stub\"));\n        return -1;\n    }\n\n    if ((driver = cpuGetSubDriver(data->arch)) == NULL)\n        return -1;\n\n    if (driver->decode == NULL) {\n        virReportError(VIR_ERR_NO_SUPPORT,\n                       _(\"cannot decode CPU data for %s architecture\"),\n                       virArchToString(cpu->arch));\n        return -1;\n    }\n\n    return driver->decode(cpu, data, models);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlCapsNodeData",
          "args": [
            "cpu",
            "phy_info->hw_cap",
            "version"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "libxlCapsNodeData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "110-151",
          "snippet": "static virCPUDataPtr\nlibxlCapsNodeData(virCPUDefPtr cpu, libxl_hwcap hwcap,\n                  enum libxlHwcapVersion version)\n{\n    ssize_t ncaps;\n    virCPUDataPtr cpudata = NULL;\n    virCPUx86CPUID cpuid[] = {\n        { .eax_in = 0x00000001,\n          .edx = hwcap[0] },\n        { .eax_in = 0x00000001,\n          .ecx = (version > LIBXL_HWCAP_V0 ? hwcap[1] : hwcap[4]) },\n        { .eax_in = 0x80000001,\n          .edx = (version > LIBXL_HWCAP_V0 ? hwcap[2] : hwcap[1]) },\n        { .eax_in = 0x80000001,\n          .ecx = (version > LIBXL_HWCAP_V0 ? hwcap[3] : hwcap[6]) },\n        { .eax_in = 0x00000007,\n          .ebx = (version > LIBXL_HWCAP_V0 ? hwcap[5] : hwcap[7]) },\n    };\n    virCPUx86CPUID cpuid_ver1[] = {\n        { .eax_in = 0x0000000D, .ecx_in = 1U, .eax = hwcap[4] },\n        { .eax_in = 0x00000007, .ecx_in = 0U, .ecx = hwcap[6] },\n        { .eax_in = 0x80000007, .ecx_in = 0U, .edx = hwcap[7] },\n    };\n\n    if (!(cpudata = virCPUDataNew(cpu->arch)))\n        goto error;\n\n    ncaps = G_N_ELEMENTS(cpuid);\n    if (libxlCapsAddCPUID(cpudata, cpuid, ncaps) < 0)\n        goto error;\n\n    ncaps = G_N_ELEMENTS(cpuid_ver1);\n    if (version > LIBXL_HWCAP_V0 &&\n        libxlCapsAddCPUID(cpudata, cpuid_ver1, ncaps) < 0)\n        goto error;\n\n    return cpudata;\n\n error:\n    virCPUDataFree(cpudata);\n    return NULL;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic virCPUDataPtr\nlibxlCapsNodeData(virCPUDefPtr cpu, libxl_hwcap hwcap,\n                  enum libxlHwcapVersion version)\n{\n    ssize_t ncaps;\n    virCPUDataPtr cpudata = NULL;\n    virCPUx86CPUID cpuid[] = {\n        { .eax_in = 0x00000001,\n          .edx = hwcap[0] },\n        { .eax_in = 0x00000001,\n          .ecx = (version > LIBXL_HWCAP_V0 ? hwcap[1] : hwcap[4]) },\n        { .eax_in = 0x80000001,\n          .edx = (version > LIBXL_HWCAP_V0 ? hwcap[2] : hwcap[1]) },\n        { .eax_in = 0x80000001,\n          .ecx = (version > LIBXL_HWCAP_V0 ? hwcap[3] : hwcap[6]) },\n        { .eax_in = 0x00000007,\n          .ebx = (version > LIBXL_HWCAP_V0 ? hwcap[5] : hwcap[7]) },\n    };\n    virCPUx86CPUID cpuid_ver1[] = {\n        { .eax_in = 0x0000000D, .ecx_in = 1U, .eax = hwcap[4] },\n        { .eax_in = 0x00000007, .ecx_in = 0U, .ecx = hwcap[6] },\n        { .eax_in = 0x80000007, .ecx_in = 0U, .edx = hwcap[7] },\n    };\n\n    if (!(cpudata = virCPUDataNew(cpu->arch)))\n        goto error;\n\n    ncaps = G_N_ELEMENTS(cpuid);\n    if (libxlCapsAddCPUID(cpudata, cpuid, ncaps) < 0)\n        goto error;\n\n    ncaps = G_N_ELEMENTS(cpuid_ver1);\n    if (version > LIBXL_HWCAP_V0 &&\n        libxlCapsAddCPUID(cpudata, cpuid_ver1, ncaps) < 0)\n        goto error;\n\n    return cpudata;\n\n error:\n    virCPUDataFree(cpudata);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCapabilitiesAddHostFeature",
          "args": [
            "caps",
            "\"pae\""
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "virCapabilitiesAddHostFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/capabilities.c",
          "lines": "279-291",
          "snippet": "int\nvirCapabilitiesAddHostFeature(virCapsPtr caps,\n                              const char *name)\n{\n    if (VIR_RESIZE_N(caps->host.features, caps->host.nfeatures_max,\n                     caps->host.nfeatures, 1) < 0)\n        return -1;\n\n    caps->host.features[caps->host.nfeatures] = g_strdup(name);\n    caps->host.nfeatures++;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virenum.h\"",
            "#include \"viruuid.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virnuma.h\"",
            "#include \"virlog.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virarch.h\"",
            "#include \"viralloc.h\"",
            "#include \"storage_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"capabilities.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virenum.h\"\n#include \"viruuid.h\"\n#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virnuma.h\"\n#include \"virlog.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"virarch.h\"\n#include \"viralloc.h\"\n#include \"storage_conf.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"capabilities.h\"\n#include <unistd.h>\n#include <config.h>\n\nint\nvirCapabilitiesAddHostFeature(virCapsPtr caps,\n                              const char *name)\n{\n    if (VIR_RESIZE_N(caps->host.features, caps->host.nfeatures_max,\n                     caps->host.nfeatures, 1) < 0)\n        return -1;\n\n    caps->host.features[caps->host.nfeatures] = g_strdup(name);\n    caps->host.nfeatures++;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCPUDefNew",
          "args": [],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDefNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/cpu_conf.c",
          "lines": "85-90",
          "snippet": "virCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu_conf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"domain_conf.h\"\n#include \"cpu_conf.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvirCPUDefPtr virCPUDefNew(void)\n{\n    virCPUDefPtr cpu = g_new0(virCPUDef, 1);\n    cpu->refs = 1;\n    return cpu;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\n#define LIBXL_X86_FEATURE_LM_MASK  (1 << 29)\n#define LIBXL_X86_FEATURE_PAE_MASK (1 << 6)\n\nstatic int\nlibxlCapsInitCPU(virCapsPtr caps, libxl_physinfo *phy_info,\n                 enum libxlHwcapVersion version)\n{\n    virCPUDataPtr data = NULL;\n    virCPUDefPtr cpu = NULL;\n    int ret = -1;\n    int host_pae;\n    int host_lm;\n\n    /* On ARM hw_cap vector is zeroed out but not on x86 */\n    if (!phy_info->hw_cap[0])\n        return 0;\n\n    cpu = virCPUDefNew();\n\n    host_pae = phy_info->hw_cap[0] & LIBXL_X86_FEATURE_PAE_MASK;\n    if (host_pae &&\n        virCapabilitiesAddHostFeature(caps, \"pae\") < 0)\n        goto error;\n\n    host_lm = (phy_info->hw_cap[version > LIBXL_HWCAP_V0 ? 2 : 1]\n                & LIBXL_X86_FEATURE_LM_MASK);\n    if (host_lm)\n        cpu->arch = VIR_ARCH_X86_64;\n    else\n        cpu->arch = VIR_ARCH_I686;\n\n    cpu->type = VIR_CPU_TYPE_HOST;\n    cpu->cores = phy_info->cores_per_socket;\n    cpu->threads = phy_info->threads_per_core;\n    cpu->dies = 1;\n    cpu->sockets = phy_info->nr_cpus / (cpu->cores * cpu->threads);\n    caps->host.cpu = cpu;\n\n    ret = 0;\n\n    if (!(data = libxlCapsNodeData(cpu, phy_info->hw_cap, version)) ||\n        cpuDecode(cpu, data, NULL) < 0) {\n        VIR_WARN(\"Failed to initialize host cpu features\");\n        goto error;\n    }\n\n cleanup:\n    virCPUDataFree(data);\n\n    return ret;\n\n error:\n    virCPUDefFree(cpu);\n    goto cleanup;\n}"
  },
  {
    "function_name": "libxlCapsNodeData",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "110-151",
    "snippet": "static virCPUDataPtr\nlibxlCapsNodeData(virCPUDefPtr cpu, libxl_hwcap hwcap,\n                  enum libxlHwcapVersion version)\n{\n    ssize_t ncaps;\n    virCPUDataPtr cpudata = NULL;\n    virCPUx86CPUID cpuid[] = {\n        { .eax_in = 0x00000001,\n          .edx = hwcap[0] },\n        { .eax_in = 0x00000001,\n          .ecx = (version > LIBXL_HWCAP_V0 ? hwcap[1] : hwcap[4]) },\n        { .eax_in = 0x80000001,\n          .edx = (version > LIBXL_HWCAP_V0 ? hwcap[2] : hwcap[1]) },\n        { .eax_in = 0x80000001,\n          .ecx = (version > LIBXL_HWCAP_V0 ? hwcap[3] : hwcap[6]) },\n        { .eax_in = 0x00000007,\n          .ebx = (version > LIBXL_HWCAP_V0 ? hwcap[5] : hwcap[7]) },\n    };\n    virCPUx86CPUID cpuid_ver1[] = {\n        { .eax_in = 0x0000000D, .ecx_in = 1U, .eax = hwcap[4] },\n        { .eax_in = 0x00000007, .ecx_in = 0U, .ecx = hwcap[6] },\n        { .eax_in = 0x80000007, .ecx_in = 0U, .edx = hwcap[7] },\n    };\n\n    if (!(cpudata = virCPUDataNew(cpu->arch)))\n        goto error;\n\n    ncaps = G_N_ELEMENTS(cpuid);\n    if (libxlCapsAddCPUID(cpudata, cpuid, ncaps) < 0)\n        goto error;\n\n    ncaps = G_N_ELEMENTS(cpuid_ver1);\n    if (version > LIBXL_HWCAP_V0 &&\n        libxlCapsAddCPUID(cpudata, cpuid_ver1, ncaps) < 0)\n        goto error;\n\n    return cpudata;\n\n error:\n    virCPUDataFree(cpudata);\n    return NULL;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virCPUDataFree",
          "args": [
            "cpudata"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "313-327",
          "snippet": "void\nvirCPUDataFree(virCPUDataPtr data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!data)\n        return;\n\n    if ((driver = cpuGetSubDriver(data->arch)) && driver->dataFree)\n        driver->dataFree(data);\n    else\n        VIR_FREE(data);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvoid\nvirCPUDataFree(virCPUDataPtr data)\n{\n    struct cpuArchDriver *driver;\n\n    VIR_DEBUG(\"data=%p\", data);\n\n    if (!data)\n        return;\n\n    if ((driver = cpuGetSubDriver(data->arch)) && driver->dataFree)\n        driver->dataFree(data);\n    else\n        VIR_FREE(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "libxlCapsAddCPUID",
          "args": [
            "cpudata",
            "cpuid_ver1",
            "ncaps"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "libxlCapsAddCPUID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
          "lines": "65-83",
          "snippet": "static int\nlibxlCapsAddCPUID(virCPUDataPtr data, virCPUx86CPUID *cpuid, ssize_t ncaps)\n{\n    virCPUx86DataItem item = { 0 };\n    size_t i;\n\n    item.type = VIR_CPU_X86_DATA_CPUID;\n    for (i = 0; i < ncaps; i++) {\n        item.data.cpuid = cpuid[i];\n\n        if (virCPUx86DataAdd(data, &item) < 0) {\n            VIR_DEBUG(\"Failed to add CPUID(%x,%x)\",\n                      cpuid[i].eax_in, cpuid[i].ecx_in);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"cpu/cpu_x86_data.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"libxl_capabilities.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"capabilities.h\"",
            "#include \"domain_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"internal.h\"",
            "#include <libxl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlCapsAddCPUID(virCPUDataPtr data, virCPUx86CPUID *cpuid, ssize_t ncaps)\n{\n    virCPUx86DataItem item = { 0 };\n    size_t i;\n\n    item.type = VIR_CPU_X86_DATA_CPUID;\n    for (i = 0; i < ncaps; i++) {\n        item.data.cpuid = cpuid[i];\n\n        if (virCPUx86DataAdd(data, &item) < 0) {\n            VIR_DEBUG(\"Failed to add CPUID(%x,%x)\",\n                      cpuid[i].eax_in, cpuid[i].ecx_in);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "cpuid_ver1"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "cpuid"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUDataNew",
          "args": [
            "cpu->arch"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu.c",
          "lines": "290-301",
          "snippet": "virCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"capabilities.h\"",
            "#include \"cpu_arm.h\"",
            "#include \"cpu_s390.h\"",
            "#include \"cpu_ppc64.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"capabilities.h\"\n#include \"cpu_arm.h\"\n#include \"cpu_s390.h\"\n#include \"cpu_ppc64.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nvirCPUDataPtr\nvirCPUDataNew(virArch arch)\n{\n    virCPUDataPtr data;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    data->arch = arch;\n\n    return data;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic virCPUDataPtr\nlibxlCapsNodeData(virCPUDefPtr cpu, libxl_hwcap hwcap,\n                  enum libxlHwcapVersion version)\n{\n    ssize_t ncaps;\n    virCPUDataPtr cpudata = NULL;\n    virCPUx86CPUID cpuid[] = {\n        { .eax_in = 0x00000001,\n          .edx = hwcap[0] },\n        { .eax_in = 0x00000001,\n          .ecx = (version > LIBXL_HWCAP_V0 ? hwcap[1] : hwcap[4]) },\n        { .eax_in = 0x80000001,\n          .edx = (version > LIBXL_HWCAP_V0 ? hwcap[2] : hwcap[1]) },\n        { .eax_in = 0x80000001,\n          .ecx = (version > LIBXL_HWCAP_V0 ? hwcap[3] : hwcap[6]) },\n        { .eax_in = 0x00000007,\n          .ebx = (version > LIBXL_HWCAP_V0 ? hwcap[5] : hwcap[7]) },\n    };\n    virCPUx86CPUID cpuid_ver1[] = {\n        { .eax_in = 0x0000000D, .ecx_in = 1U, .eax = hwcap[4] },\n        { .eax_in = 0x00000007, .ecx_in = 0U, .ecx = hwcap[6] },\n        { .eax_in = 0x80000007, .ecx_in = 0U, .edx = hwcap[7] },\n    };\n\n    if (!(cpudata = virCPUDataNew(cpu->arch)))\n        goto error;\n\n    ncaps = G_N_ELEMENTS(cpuid);\n    if (libxlCapsAddCPUID(cpudata, cpuid, ncaps) < 0)\n        goto error;\n\n    ncaps = G_N_ELEMENTS(cpuid_ver1);\n    if (version > LIBXL_HWCAP_V0 &&\n        libxlCapsAddCPUID(cpudata, cpuid_ver1, ncaps) < 0)\n        goto error;\n\n    return cpudata;\n\n error:\n    virCPUDataFree(cpudata);\n    return NULL;\n}"
  },
  {
    "function_name": "libxlCapsAddCPUID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/libxl/libxl_capabilities.c",
    "lines": "65-83",
    "snippet": "static int\nlibxlCapsAddCPUID(virCPUDataPtr data, virCPUx86CPUID *cpuid, ssize_t ncaps)\n{\n    virCPUx86DataItem item = { 0 };\n    size_t i;\n\n    item.type = VIR_CPU_X86_DATA_CPUID;\n    for (i = 0; i < ncaps; i++) {\n        item.data.cpuid = cpuid[i];\n\n        if (virCPUx86DataAdd(data, &item) < 0) {\n            VIR_DEBUG(\"Failed to add CPUID(%x,%x)\",\n                      cpuid[i].eax_in, cpuid[i].ecx_in);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"cpu/cpu_x86_data.h\"",
      "#include \"cpu/cpu_x86.h\"",
      "#include \"libxl_capabilities.h\"",
      "#include \"vircommand.h\"",
      "#include \"domain_capabilities.h\"",
      "#include \"capabilities.h\"",
      "#include \"domain_conf.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virlog.h\"",
      "#include \"internal.h\"",
      "#include <libxl.h>",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Failed to add CPUID(%x,%x)\"",
            "cpuid[i].eax_in",
            "cpuid[i].ecx_in"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virCPUx86DataAdd",
          "args": [
            "data",
            "&item"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "virCPUx86DataAddFeature",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/cpu/cpu_x86.c",
          "lines": "3348-3367",
          "snippet": "static int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virhostcpu.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virbuffer.h\"",
            "#include \"cpu_x86.h\"",
            "#include \"cpu_map.h\"",
            "#include \"cpu.h\"",
            "#include \"viralloc.h\"",
            "#include \"virlog.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virhostcpu.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virbuffer.h\"\n#include \"cpu_x86.h\"\n#include \"cpu_map.h\"\n#include \"cpu.h\"\n#include \"viralloc.h\"\n#include \"virlog.h\"\n#include <config.h>\n\nstatic int\nvirCPUx86DataAddFeature(virCPUDataPtr cpuData,\n                        const char *name)\n{\n    virCPUx86FeaturePtr feature;\n    virCPUx86MapPtr map;\n\n    if (!(map = virCPUx86GetMap()))\n        return -1;\n\n    /* ignore unknown features */\n    if (!(feature = x86FeatureFind(map, name)) &&\n        !(feature = x86FeatureFindInternal(name)))\n        return 0;\n\n    if (x86DataAdd(&cpuData->data.x86, &feature->data) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"cpu/cpu_x86_data.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"libxl_capabilities.h\"\n#include \"vircommand.h\"\n#include \"domain_capabilities.h\"\n#include \"capabilities.h\"\n#include \"domain_conf.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"internal.h\"\n#include <libxl.h>\n#include <config.h>\n\nstatic int\nlibxlCapsAddCPUID(virCPUDataPtr data, virCPUx86CPUID *cpuid, ssize_t ncaps)\n{\n    virCPUx86DataItem item = { 0 };\n    size_t i;\n\n    item.type = VIR_CPU_X86_DATA_CPUID;\n    for (i = 0; i < ncaps; i++) {\n        item.data.cpuid = cpuid[i];\n\n        if (virCPUx86DataAdd(data, &item) < 0) {\n            VIR_DEBUG(\"Failed to add CPUID(%x,%x)\",\n                      cpuid[i].eax_in, cpuid[i].ecx_in);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  }
]