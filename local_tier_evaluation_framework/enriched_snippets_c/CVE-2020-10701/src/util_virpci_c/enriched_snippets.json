[
  {
    "function_name": "virPCIDeviceAddressFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2851-2855",
    "snippet": "void\nvirPCIDeviceAddressFree(virPCIDeviceAddressPtr address)\n{\n    VIR_FREE(address);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "address"
          ],
          "line": 2854
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceAddressFree(virPCIDeviceAddressPtr address)\n{\n    VIR_FREE(address);\n}"
  },
  {
    "function_name": "virPCIEDeviceInfoFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2840-2849",
    "snippet": "void\nvirPCIEDeviceInfoFree(virPCIEDeviceInfoPtr dev)\n{\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->link_cap);\n    VIR_FREE(dev->link_sta);\n    VIR_FREE(dev);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dev"
          ],
          "line": 2848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dev->link_sta"
          ],
          "line": 2847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dev->link_cap"
          ],
          "line": 2846
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIEDeviceInfoFree(virPCIEDeviceInfoPtr dev)\n{\n    if (!dev)\n        return;\n\n    VIR_FREE(dev->link_cap);\n    VIR_FREE(dev->link_sta);\n    VIR_FREE(dev);\n}"
  },
  {
    "function_name": "virPCIGetHeaderType",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2812-2837",
    "snippet": "int virPCIGetHeaderType(virPCIDevicePtr dev, int *hdrType)\n{\n    int fd;\n    uint8_t type;\n\n    *hdrType = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    type = virPCIDeviceRead8(dev, fd, PCI_HEADER_TYPE);\n\n    virPCIDeviceConfigClose(dev, fd);\n\n    type &= PCI_HEADER_TYPE_MASK;\n    if (type >= VIR_PCI_HEADER_LAST) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown PCI header type '%d' for device '%s'\"),\n                       type, dev->name);\n        return -1;\n    }\n\n    *hdrType = type;\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_HEADER_TYPE_MASK   0x7f",
      "#define PCI_HEADER_TYPE         0x0e    /* Header type */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown PCI header type '%d' for device '%s'\")",
            "type",
            "dev->name"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown PCI header type '%d' for device '%s'\""
          ],
          "line": 2829
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceConfigClose",
          "args": [
            "dev",
            "fd"
          ],
          "line": 2824
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "320-327",
          "snippet": "static void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead8",
          "args": [
            "dev",
            "fd",
            "PCI_HEADER_TYPE"
          ],
          "line": 2822
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "348-354",
          "snippet": "static uint8_t\nvirPCIDeviceRead8(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf;\n    virPCIDeviceRead(dev, cfgfd, pos, &buf, sizeof(buf));\n    return buf;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint8_t\nvirPCIDeviceRead8(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf;\n    virPCIDeviceRead(dev, cfgfd, pos, &buf, sizeof(buf));\n    return buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceConfigOpen",
          "args": [
            "dev"
          ],
          "line": 2819
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigOpenWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "314-318",
          "snippet": "static int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_HEADER_TYPE_MASK   0x7f\n#define PCI_HEADER_TYPE         0x0e    /* Header type */\n\nint virPCIGetHeaderType(virPCIDevicePtr dev, int *hdrType)\n{\n    int fd;\n    uint8_t type;\n\n    *hdrType = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    type = virPCIDeviceRead8(dev, fd, PCI_HEADER_TYPE);\n\n    virPCIDeviceConfigClose(dev, fd);\n\n    type &= PCI_HEADER_TYPE_MASK;\n    if (type >= VIR_PCI_HEADER_LAST) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown PCI header type '%d' for device '%s'\"),\n                       type, dev->name);\n        return -1;\n    }\n\n    *hdrType = type;\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceGetLinkCapSta",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2769-2809",
    "snippet": "int\nvirPCIDeviceGetLinkCapSta(virPCIDevicePtr dev,\n                          int *cap_port,\n                          unsigned int *cap_speed,\n                          unsigned int *cap_width,\n                          unsigned int *sta_speed,\n                          unsigned int *sta_width)\n{\n    uint32_t t;\n    int fd;\n    int ret = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    if (!dev->pcie_cap_pos) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"pci device %s is not a PCI-Express device\"),\n                       dev->name);\n        goto cleanup;\n    }\n\n    t = virPCIDeviceRead32(dev, fd, dev->pcie_cap_pos + PCI_EXP_LNKCAP);\n\n    *cap_port = t >> 24;\n    *cap_speed = t & PCI_EXP_LNKCAP_SPEED;\n    *cap_width = (t & PCI_EXP_LNKCAP_WIDTH) >> 4;\n\n    t = virPCIDeviceRead16(dev, fd, dev->pcie_cap_pos + PCI_EXP_LNKSTA);\n\n    *sta_speed = t & PCI_EXP_LNKSTA_SPEED;\n    *sta_width = (t & PCI_EXP_LNKSTA_WIDTH) >> 4;\n    ret = 0;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_EXP_LNKSTA_WIDTH    0x03f0  /* Negotiated Link Width */",
      "#define PCI_EXP_LNKSTA_SPEED    0x000f  /* Negotiated Link Speed */",
      "#define PCI_EXP_LNKSTA          0x12    /* Link Status */",
      "#define PCI_EXP_LNKCAP_WIDTH    0x003f0 /* Maximum Link Width */",
      "#define PCI_EXP_LNKCAP_SPEED    0x0000f /* Maximum Link Speed */",
      "#define PCI_EXP_LNKCAP          0xc     /* Link Capabilities */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceConfigClose",
          "args": [
            "dev",
            "fd"
          ],
          "line": 2807
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "320-327",
          "snippet": "static void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead16",
          "args": [
            "dev",
            "fd",
            "dev->pcie_cap_pos + PCI_EXP_LNKSTA"
          ],
          "line": 2800
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "356-362",
          "snippet": "static uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead32",
          "args": [
            "dev",
            "fd",
            "dev->pcie_cap_pos + PCI_EXP_LNKCAP"
          ],
          "line": 2794
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "364-370",
          "snippet": "static uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"pci device %s is not a PCI-Express device\")",
            "dev->name"
          ],
          "line": 2788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"pci device %s is not a PCI-Express device\""
          ],
          "line": 2789
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceInit",
          "args": [
            "dev",
            "fd"
          ],
          "line": 2784
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "893-907",
          "snippet": "static int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_CAP_ID_EXP          0x10    /* PCI Express */",
            "#define PCI_CAP_ID_PM           0x01    /* Power Management */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_CAP_ID_EXP          0x10    /* PCI Express */\n#define PCI_CAP_ID_PM           0x01    /* Power Management */\n\nstatic int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceConfigOpen",
          "args": [
            "dev"
          ],
          "line": 2781
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigOpenWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "314-318",
          "snippet": "static int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_EXP_LNKSTA_WIDTH    0x03f0  /* Negotiated Link Width */\n#define PCI_EXP_LNKSTA_SPEED    0x000f  /* Negotiated Link Speed */\n#define PCI_EXP_LNKSTA          0x12    /* Link Status */\n#define PCI_EXP_LNKCAP_WIDTH    0x003f0 /* Maximum Link Width */\n#define PCI_EXP_LNKCAP_SPEED    0x0000f /* Maximum Link Speed */\n#define PCI_EXP_LNKCAP          0xc     /* Link Capabilities */\n\nint\nvirPCIDeviceGetLinkCapSta(virPCIDevicePtr dev,\n                          int *cap_port,\n                          unsigned int *cap_speed,\n                          unsigned int *cap_width,\n                          unsigned int *sta_speed,\n                          unsigned int *sta_width)\n{\n    uint32_t t;\n    int fd;\n    int ret = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    if (!dev->pcie_cap_pos) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"pci device %s is not a PCI-Express device\"),\n                       dev->name);\n        goto cleanup;\n    }\n\n    t = virPCIDeviceRead32(dev, fd, dev->pcie_cap_pos + PCI_EXP_LNKCAP);\n\n    *cap_port = t >> 24;\n    *cap_speed = t & PCI_EXP_LNKCAP_SPEED;\n    *cap_width = (t & PCI_EXP_LNKCAP_WIDTH) >> 4;\n\n    t = virPCIDeviceRead16(dev, fd, dev->pcie_cap_pos + PCI_EXP_LNKSTA);\n\n    *sta_speed = t & PCI_EXP_LNKSTA_SPEED;\n    *sta_width = (t & PCI_EXP_LNKSTA_WIDTH) >> 4;\n    ret = 0;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceHasPCIExpressLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2746-2767",
    "snippet": "int\nvirPCIDeviceHasPCIExpressLink(virPCIDevicePtr dev)\n{\n    int fd;\n    int ret = -1;\n    uint16_t cap, type;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    cap = virPCIDeviceRead16(dev, fd, dev->pcie_cap_pos + PCI_CAP_FLAGS);\n    type = (cap & PCI_EXP_FLAGS_TYPE) >> 4;\n\n    ret = type != PCI_EXP_TYPE_ROOT_INT_EP && type != PCI_EXP_TYPE_ROOT_EC;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_EXP_TYPE_ROOT_EC 0xa        /* Root Complex Event Collector */",
      "#define PCI_EXP_TYPE_ROOT_INT_EP 0x9    /* Root Complex Integrated Endpoint */",
      "#define PCI_EXP_FLAGS_TYPE      0x00f0",
      "#define PCI_CAP_FLAGS           2       /* Capability defined flags (16 bits) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceConfigClose",
          "args": [
            "dev",
            "fd"
          ],
          "line": 2765
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "320-327",
          "snippet": "static void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead16",
          "args": [
            "dev",
            "fd",
            "dev->pcie_cap_pos + PCI_CAP_FLAGS"
          ],
          "line": 2759
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "356-362",
          "snippet": "static uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceInit",
          "args": [
            "dev",
            "fd"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "893-907",
          "snippet": "static int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_CAP_ID_EXP          0x10    /* PCI Express */",
            "#define PCI_CAP_ID_PM           0x01    /* Power Management */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_CAP_ID_EXP          0x10    /* PCI Express */\n#define PCI_CAP_ID_PM           0x01    /* Power Management */\n\nstatic int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceConfigOpen",
          "args": [
            "dev"
          ],
          "line": 2753
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigOpenWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "314-318",
          "snippet": "static int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_EXP_TYPE_ROOT_EC 0xa        /* Root Complex Event Collector */\n#define PCI_EXP_TYPE_ROOT_INT_EP 0x9    /* Root Complex Integrated Endpoint */\n#define PCI_EXP_FLAGS_TYPE      0x00f0\n#define PCI_CAP_FLAGS           2       /* Capability defined flags (16 bits) */\n\nint\nvirPCIDeviceHasPCIExpressLink(virPCIDevicePtr dev)\n{\n    int fd;\n    int ret = -1;\n    uint16_t cap, type;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    cap = virPCIDeviceRead16(dev, fd, dev->pcie_cap_pos + PCI_CAP_FLAGS);\n    type = (cap & PCI_EXP_FLAGS_TYPE) >> 4;\n\n    ret = type != PCI_EXP_TYPE_ROOT_INT_EP && type != PCI_EXP_TYPE_ROOT_EC;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceIsPCIExpress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2727-2744",
    "snippet": "int\nvirPCIDeviceIsPCIExpress(virPCIDevicePtr dev)\n{\n    int fd;\n    int ret = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    ret = dev->pcie_cap_pos != 0;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceConfigClose",
          "args": [
            "dev",
            "fd"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "320-327",
          "snippet": "static void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceInit",
          "args": [
            "dev",
            "fd"
          ],
          "line": 2736
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "893-907",
          "snippet": "static int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_CAP_ID_EXP          0x10    /* PCI Express */",
            "#define PCI_CAP_ID_PM           0x01    /* Power Management */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_CAP_ID_EXP          0x10    /* PCI Express */\n#define PCI_CAP_ID_PM           0x01    /* Power Management */\n\nstatic int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceConfigOpen",
          "args": [
            "dev"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigOpenWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "314-318",
          "snippet": "static int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceIsPCIExpress(virPCIDevicePtr dev)\n{\n    int fd;\n    int ret = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return ret;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    ret = dev->pcie_cap_pos != 0;\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIGetMdevTypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2718-2724",
    "snippet": "ssize_t\nvirPCIGetMdevTypes(const char *sysfspath G_GNUC_UNUSED,\n                   virMediatedDeviceTypePtr **types G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 2722
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nssize_t\nvirPCIGetMdevTypes(const char *sysfspath G_GNUC_UNUSED,\n                   virMediatedDeviceTypePtr **types G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virPCIGetVirtualFunctionInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2707-2715",
    "snippet": "int\nvirPCIGetVirtualFunctionInfo(const char *vf_sysfs_device_path G_GNUC_UNUSED,\n                             int pfNetDevIdx G_GNUC_UNUSED,\n                             char **pfname G_GNUC_UNUSED,\n                             int *vf_index G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 2713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 2713
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetVirtualFunctionInfo(const char *vf_sysfs_device_path G_GNUC_UNUSED,\n                             int pfNetDevIdx G_GNUC_UNUSED,\n                             char **pfname G_GNUC_UNUSED,\n                             int *vf_index G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virPCIGetNetName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2697-2705",
    "snippet": "int\nvirPCIGetNetName(const char *device_link_sysfs_path G_GNUC_UNUSED,\n                 size_t idx G_GNUC_UNUSED,\n                 char *physPortID G_GNUC_UNUSED,\n                 char **netname G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetNetName(const char *device_link_sysfs_path G_GNUC_UNUSED,\n                 size_t idx G_GNUC_UNUSED,\n                 char *physPortID G_GNUC_UNUSED,\n                 char **netname G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virPCIDeviceAddressGetSysfsFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2689-2695",
    "snippet": "int\nvirPCIDeviceAddressGetSysfsFile(virPCIDeviceAddressPtr dev G_GNUC_UNUSED,\n                                char **pci_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 2693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressGetSysfsFile(virPCIDeviceAddressPtr dev G_GNUC_UNUSED,\n                                char **pci_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virPCIGetSysfsFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2681-2687",
    "snippet": "int\nvirPCIGetSysfsFile(char *virPCIDeviceName G_GNUC_UNUSED,\n                   char **pci_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetSysfsFile(char *virPCIDeviceName G_GNUC_UNUSED,\n                   char **pci_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virPCIGetVirtualFunctionIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2671-2679",
    "snippet": "int\nvirPCIGetVirtualFunctionIndex(const char *pf_sysfs_device_link G_GNUC_UNUSED,\n                              const char *vf_sysfs_device_link G_GNUC_UNUSED,\n                              int *vf_index G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 2676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 2676
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetVirtualFunctionIndex(const char *pf_sysfs_device_link G_GNUC_UNUSED,\n                              const char *vf_sysfs_device_link G_GNUC_UNUSED,\n                              int *vf_index G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n\n}"
  },
  {
    "function_name": "virPCIIsVirtualFunction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2664-2669",
    "snippet": "int\nvirPCIIsVirtualFunction(const char *vf_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIIsVirtualFunction(const char *vf_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virPCIGetVirtualFunctions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2654-2662",
    "snippet": "int\nvirPCIGetVirtualFunctions(const char *sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr **virtual_functions G_GNUC_UNUSED,\n                          size_t *num_virtual_functions G_GNUC_UNUSED,\n                          unsigned int *max_virtual_functions G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetVirtualFunctions(const char *sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr **virtual_functions G_GNUC_UNUSED,\n                          size_t *num_virtual_functions G_GNUC_UNUSED,\n                          unsigned int *max_virtual_functions G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virPCIGetPhysicalFunction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2646-2652",
    "snippet": "int\nvirPCIGetPhysicalFunction(const char *vf_sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr *pf G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 2650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 2650
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetPhysicalFunction(const char *vf_sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr *pf G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
  },
  {
    "function_name": "virPCIGetDeviceAddressFromSysfsLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2638-2643",
    "snippet": "virPCIDeviceAddressPtr\nvirPCIGetDeviceAddressFromSysfsLink(const char *device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return NULL;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(unsupported)"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "unsupported"
          ],
          "line": 2641
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDeviceAddressPtr\nvirPCIGetDeviceAddressFromSysfsLink(const char *device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return NULL;\n}"
  },
  {
    "function_name": "virPCIGetMdevTypes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2585-2633",
    "snippet": "ssize_t\nvirPCIGetMdevTypes(const char *sysfspath,\n                   virMediatedDeviceTypePtr **types)\n{\n    ssize_t ret = -1;\n    int dirret = -1;\n    DIR *dir = NULL;\n    struct dirent *entry;\n    g_autofree char *types_path = NULL;\n    g_autoptr(virMediatedDeviceType) mdev_type = NULL;\n    virMediatedDeviceTypePtr *mdev_types = NULL;\n    size_t ntypes = 0;\n    size_t i;\n\n    types_path = g_strdup_printf(\"%s/mdev_supported_types\", sysfspath);\n\n    if ((dirret = virDirOpenIfExists(&dir, types_path)) < 0)\n        goto cleanup;\n\n    if (dirret == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    while ((dirret = virDirRead(dir, &entry, types_path)) > 0) {\n        g_autofree char *tmppath = NULL;\n        /* append the type id to the path and read the attributes from there */\n        tmppath = g_strdup_printf(\"%s/%s\", types_path, entry->d_name);\n\n        if (virMediatedDeviceTypeReadAttrs(tmppath, &mdev_type) < 0)\n            goto cleanup;\n\n        if (VIR_APPEND_ELEMENT(mdev_types, ntypes, mdev_type) < 0)\n            goto cleanup;\n    }\n\n    if (dirret < 0)\n        goto cleanup;\n\n    *types = g_steal_pointer(&mdev_types);\n    ret = ntypes;\n    ntypes = 0;\n cleanup:\n    for (i = 0; i < ntypes; i++)\n        virMediatedDeviceTypeFree(mdev_types[i]);\n    VIR_FREE(mdev_types);\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dir"
          ],
          "line": 2631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mdev_types"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceTypeFree",
          "args": [
            "mdev_types[i]"
          ],
          "line": 2629
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceTypeFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "475-485",
          "snippet": "void\nvirMediatedDeviceTypeFree(virMediatedDeviceTypePtr type)\n{\n    if (!type)\n        return;\n\n    VIR_FREE(type->id);\n    VIR_FREE(type->name);\n    VIR_FREE(type->device_api);\n    VIR_FREE(type);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nvoid\nvirMediatedDeviceTypeFree(virMediatedDeviceTypePtr type)\n{\n    if (!type)\n        return;\n\n    VIR_FREE(type->id);\n    VIR_FREE(type->name);\n    VIR_FREE(type->device_api);\n    VIR_FREE(type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&mdev_types"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "mdev_types",
            "ntypes",
            "mdev_type"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virMediatedDeviceTypeReadAttrs",
          "args": [
            "tmppath",
            "&mdev_type"
          ],
          "line": 2614
        },
        "resolved": true,
        "details": {
          "function_name": "virMediatedDeviceTypeReadAttrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virmdev.c",
          "lines": "488-520",
          "snippet": "int\nvirMediatedDeviceTypeReadAttrs(const char *sysfspath,\n                               virMediatedDeviceTypePtr *type)\n{\n    g_autoptr(virMediatedDeviceType) tmp = NULL;\n\n#define MDEV_GET_SYSFS_ATTR(attr, dst, cb, optional) \\\n    do { \\\n        int rc; \\\n        if ((rc = cb(dst, \"%s/%s\", sysfspath, attr)) < 0) { \\\n            if (rc != -2 || !optional) \\\n                return -1; \\\n        } \\\n    } while (0)\n\n    if (VIR_ALLOC(tmp) < 0)\n        return -1;\n\n    tmp->id = g_path_get_basename(sysfspath);\n\n    /* @name sysfs attribute is optional, so getting ENOENT is fine */\n    MDEV_GET_SYSFS_ATTR(\"name\", &tmp->name, virFileReadValueString, true);\n    MDEV_GET_SYSFS_ATTR(\"device_api\", &tmp->device_api,\n                        virFileReadValueString, false);\n    MDEV_GET_SYSFS_ATTR(\"available_instances\", &tmp->available_instances,\n                        virFileReadValueUint, false);\n\n#undef MDEV_GET_SYSFS_ATTR\n\n    *type = g_steal_pointer(&tmp);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"virmdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"virmdev.h\"\n#include <config.h>\n\nint\nvirMediatedDeviceTypeReadAttrs(const char *sysfspath,\n                               virMediatedDeviceTypePtr *type)\n{\n    g_autoptr(virMediatedDeviceType) tmp = NULL;\n\n#define MDEV_GET_SYSFS_ATTR(attr, dst, cb, optional) \\\n    do { \\\n        int rc; \\\n        if ((rc = cb(dst, \"%s/%s\", sysfspath, attr)) < 0) { \\\n            if (rc != -2 || !optional) \\\n                return -1; \\\n        } \\\n    } while (0)\n\n    if (VIR_ALLOC(tmp) < 0)\n        return -1;\n\n    tmp->id = g_path_get_basename(sysfspath);\n\n    /* @name sysfs attribute is optional, so getting ENOENT is fine */\n    MDEV_GET_SYSFS_ATTR(\"name\", &tmp->name, virFileReadValueString, true);\n    MDEV_GET_SYSFS_ATTR(\"device_api\", &tmp->device_api,\n                        virFileReadValueString, false);\n    MDEV_GET_SYSFS_ATTR(\"available_instances\", &tmp->available_instances,\n                        virFileReadValueUint, false);\n\n#undef MDEV_GET_SYSFS_ATTR\n\n    *type = g_steal_pointer(&tmp);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s\"",
            "types_path",
            "entry->d_name"
          ],
          "line": 2612
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dir",
            "&entry",
            "types_path"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpenIfExists",
          "args": [
            "&dir",
            "types_path"
          ],
          "line": 2601
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenIfExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2898-2902",
          "snippet": "int\nvirDirOpenIfExists(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, true, false);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenIfExists(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, true, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nssize_t\nvirPCIGetMdevTypes(const char *sysfspath,\n                   virMediatedDeviceTypePtr **types)\n{\n    ssize_t ret = -1;\n    int dirret = -1;\n    DIR *dir = NULL;\n    struct dirent *entry;\n    g_autofree char *types_path = NULL;\n    g_autoptr(virMediatedDeviceType) mdev_type = NULL;\n    virMediatedDeviceTypePtr *mdev_types = NULL;\n    size_t ntypes = 0;\n    size_t i;\n\n    types_path = g_strdup_printf(\"%s/mdev_supported_types\", sysfspath);\n\n    if ((dirret = virDirOpenIfExists(&dir, types_path)) < 0)\n        goto cleanup;\n\n    if (dirret == 0) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    while ((dirret = virDirRead(dir, &entry, types_path)) > 0) {\n        g_autofree char *tmppath = NULL;\n        /* append the type id to the path and read the attributes from there */\n        tmppath = g_strdup_printf(\"%s/%s\", types_path, entry->d_name);\n\n        if (virMediatedDeviceTypeReadAttrs(tmppath, &mdev_type) < 0)\n            goto cleanup;\n\n        if (VIR_APPEND_ELEMENT(mdev_types, ntypes, mdev_type) < 0)\n            goto cleanup;\n    }\n\n    if (dirret < 0)\n        goto cleanup;\n\n    *types = g_steal_pointer(&mdev_types);\n    ret = ntypes;\n    ntypes = 0;\n cleanup:\n    for (i = 0; i < ntypes; i++)\n        virMediatedDeviceTypeFree(mdev_types[i]);\n    VIR_FREE(mdev_types);\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIGetVirtualFunctionInfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2516-2582",
    "snippet": "int\nvirPCIGetVirtualFunctionInfo(const char *vf_sysfs_device_path,\n                             int pfNetDevIdx,\n                             char **pfname,\n                             int *vf_index)\n{\n    virPCIDeviceAddressPtr pf_config_address = NULL;\n    g_autofree char *pf_sysfs_device_path = NULL;\n    g_autofree char *vfname = NULL;\n    g_autofree char *vfPhysPortID = NULL;\n    int ret = -1;\n\n    if (virPCIGetPhysicalFunction(vf_sysfs_device_path, &pf_config_address) < 0)\n        goto cleanup;\n\n    if (!pf_config_address)\n        goto cleanup;\n\n    if (virPCIDeviceAddressGetSysfsFile(pf_config_address,\n                                        &pf_sysfs_device_path) < 0) {\n        goto cleanup;\n    }\n\n    if (virPCIGetVirtualFunctionIndex(pf_sysfs_device_path,\n                                      vf_sysfs_device_path, vf_index) < 0) {\n        goto cleanup;\n    }\n\n    /* If the caller hasn't asked for a specific pfNetDevIdx, and VF\n     * is bound to a netdev, learn that netdev's phys_port_id (if\n     * available). This can be used to disambiguate when the PF has\n     * multiple netdevs. If the VF isn't bound to a netdev, then we\n     * return netdev[pfNetDevIdx] on the PF, which may or may not be\n     * correct.\n     */\n    if (pfNetDevIdx == -1) {\n        if (virPCIGetNetName(vf_sysfs_device_path, 0, NULL, &vfname) < 0)\n            goto cleanup;\n\n        if (vfname) {\n            if (virNetDevGetPhysPortID(vfname, &vfPhysPortID) < 0)\n                goto cleanup;\n        }\n        pfNetDevIdx = 0;\n    }\n\n    if (virPCIGetNetName(pf_sysfs_device_path,\n                         pfNetDevIdx, vfPhysPortID, pfname) < 0) {\n        goto cleanup;\n    }\n\n    if (!*pfname) {\n        /* this shouldn't be possible. A VF can't exist unless its\n         * PF device is bound to a network driver\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"The PF device for VF %s has no network device name\"),\n                       vf_sysfs_device_path);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pf_config_address);\n\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "pf_config_address"
          ],
          "line": 2579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"The PF device for VF %s has no network device name\")",
            "vf_sysfs_device_path"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"The PF device for VF %s has no network device name\""
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIGetNetName",
          "args": [
            "pf_sysfs_device_path",
            "pfNetDevIdx",
            "vfPhysPortID",
            "pfname"
          ],
          "line": 2562
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetNetName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2697-2705",
          "snippet": "int\nvirPCIGetNetName(const char *device_link_sysfs_path G_GNUC_UNUSED,\n                 size_t idx G_GNUC_UNUSED,\n                 char *physPortID G_GNUC_UNUSED,\n                 char **netname G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetNetName(const char *device_link_sysfs_path G_GNUC_UNUSED,\n                 size_t idx G_GNUC_UNUSED,\n                 char *physPortID G_GNUC_UNUSED,\n                 char **netname G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetDevGetPhysPortID",
          "args": [
            "vfname",
            "&vfPhysPortID"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetPhysPortID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "1454-1463",
          "snippet": "int\nvirNetDevGetPhysPortID(const char *ifname G_GNUC_UNUSED,\n                       char **physPortID)\n{\n    /* this actually should never be called, and is just here to\n     * satisfy the linker.\n     */\n    *physPortID = NULL;\n    return 0;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevGetPhysPortID(const char *ifname G_GNUC_UNUSED,\n                       char **physPortID)\n{\n    /* this actually should never be called, and is just here to\n     * satisfy the linker.\n     */\n    *physPortID = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIGetVirtualFunctionIndex",
          "args": [
            "pf_sysfs_device_path",
            "vf_sysfs_device_path",
            "vf_index"
          ],
          "line": 2539
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetVirtualFunctionIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2671-2679",
          "snippet": "int\nvirPCIGetVirtualFunctionIndex(const char *pf_sysfs_device_link G_GNUC_UNUSED,\n                              const char *vf_sysfs_device_link G_GNUC_UNUSED,\n                              int *vf_index G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetVirtualFunctionIndex(const char *pf_sysfs_device_link G_GNUC_UNUSED,\n                              const char *vf_sysfs_device_link G_GNUC_UNUSED,\n                              int *vf_index G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressGetSysfsFile",
          "args": [
            "pf_config_address",
            "&pf_sysfs_device_path"
          ],
          "line": 2534
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressGetSysfsFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2689-2695",
          "snippet": "int\nvirPCIDeviceAddressGetSysfsFile(virPCIDeviceAddressPtr dev G_GNUC_UNUSED,\n                                char **pci_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressGetSysfsFile(virPCIDeviceAddressPtr dev G_GNUC_UNUSED,\n                                char **pci_sysfs_device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIGetPhysicalFunction",
          "args": [
            "vf_sysfs_device_path",
            "&pf_config_address"
          ],
          "line": 2528
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetPhysicalFunction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2646-2652",
          "snippet": "int\nvirPCIGetPhysicalFunction(const char *vf_sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr *pf G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetPhysicalFunction(const char *vf_sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr *pf G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetVirtualFunctionInfo(const char *vf_sysfs_device_path,\n                             int pfNetDevIdx,\n                             char **pfname,\n                             int *vf_index)\n{\n    virPCIDeviceAddressPtr pf_config_address = NULL;\n    g_autofree char *pf_sysfs_device_path = NULL;\n    g_autofree char *vfname = NULL;\n    g_autofree char *vfPhysPortID = NULL;\n    int ret = -1;\n\n    if (virPCIGetPhysicalFunction(vf_sysfs_device_path, &pf_config_address) < 0)\n        goto cleanup;\n\n    if (!pf_config_address)\n        goto cleanup;\n\n    if (virPCIDeviceAddressGetSysfsFile(pf_config_address,\n                                        &pf_sysfs_device_path) < 0) {\n        goto cleanup;\n    }\n\n    if (virPCIGetVirtualFunctionIndex(pf_sysfs_device_path,\n                                      vf_sysfs_device_path, vf_index) < 0) {\n        goto cleanup;\n    }\n\n    /* If the caller hasn't asked for a specific pfNetDevIdx, and VF\n     * is bound to a netdev, learn that netdev's phys_port_id (if\n     * available). This can be used to disambiguate when the PF has\n     * multiple netdevs. If the VF isn't bound to a netdev, then we\n     * return netdev[pfNetDevIdx] on the PF, which may or may not be\n     * correct.\n     */\n    if (pfNetDevIdx == -1) {\n        if (virPCIGetNetName(vf_sysfs_device_path, 0, NULL, &vfname) < 0)\n            goto cleanup;\n\n        if (vfname) {\n            if (virNetDevGetPhysPortID(vfname, &vfPhysPortID) < 0)\n                goto cleanup;\n        }\n        pfNetDevIdx = 0;\n    }\n\n    if (virPCIGetNetName(pf_sysfs_device_path,\n                         pfNetDevIdx, vfPhysPortID, pfname) < 0) {\n        goto cleanup;\n    }\n\n    if (!*pfname) {\n        /* this shouldn't be possible. A VF can't exist unless its\n         * PF device is bound to a network driver\n         */\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"The PF device for VF %s has no network device name\"),\n                       vf_sysfs_device_path);\n        goto cleanup;\n    }\n\n    ret = 0;\n cleanup:\n    VIR_FREE(pf_config_address);\n\n    return ret;\n}"
  },
  {
    "function_name": "virPCIGetNetName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2430-2514",
    "snippet": "int\nvirPCIGetNetName(const char *device_link_sysfs_path,\n                 size_t idx,\n                 char *physPortID,\n                 char **netname)\n{\n    g_autofree char *pcidev_sysfs_net_path = NULL;\n    g_autofree char *firstEntryName = NULL;\n    g_autofree char *thisPhysPortID = NULL;\n    int ret = -1;\n    DIR *dir = NULL;\n    struct dirent *entry = NULL;\n    size_t i = 0;\n\n    *netname = NULL;\n\n    if (virBuildPath(&pcidev_sysfs_net_path, device_link_sysfs_path,\n                     \"net\") == -1) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (virDirOpenQuiet(&dir, pcidev_sysfs_net_path) < 0) {\n        /* this *isn't* an error - caller needs to check for netname == NULL */\n        ret = 0;\n        goto cleanup;\n    }\n\n    while (virDirRead(dir, &entry, pcidev_sysfs_net_path) > 0) {\n        /* if the caller sent a physPortID, compare it to the\n         * physportID of this netdev. If not, look for entry[idx].\n         */\n        if (physPortID) {\n            if (virNetDevGetPhysPortID(entry->d_name, &thisPhysPortID) < 0)\n                goto cleanup;\n\n            /* if this one doesn't match, keep looking */\n            if (STRNEQ_NULLABLE(physPortID, thisPhysPortID)) {\n                VIR_FREE(thisPhysPortID);\n                /* save the first entry we find to use as a failsafe\n                 * in case we don't match the phys_port_id. This is\n                 * needed because some NIC drivers (e.g. i40e)\n                 * implement phys_port_id for PFs, but not for VFs\n                 */\n                if (!firstEntryName)\n                    firstEntryName = g_strdup(entry->d_name);\n\n                continue;\n            }\n        } else {\n            if (i++ < idx)\n                continue;\n        }\n\n        *netname = g_strdup(entry->d_name);\n\n        ret = 0;\n        break;\n    }\n\n    if (ret < 0) {\n        if (physPortID) {\n            if (firstEntryName) {\n                /* we didn't match the provided phys_port_id, but this\n                 * is probably because phys_port_id isn't implemented\n                 * for this NIC driver, so just return the first\n                 * (probably only) netname we found.\n                 */\n                *netname = firstEntryName;\n                firstEntryName = NULL;\n                ret = 0;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find network device with \"\n                                 \"phys_port_id '%s' under PCI device at %s\"),\n                               physPortID, device_link_sysfs_path);\n            }\n        } else {\n            ret = 0; /* no netdev at the given index is *not* an error */\n        }\n    }\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dir"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Could not find network device with \"\n                                 \"phys_port_id '%s' under PCI device at %s\")",
            "physPortID",
            "device_link_sysfs_path"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Could not find network device with \"\n                                 \"phys_port_id '%s' under PCI device at %s\""
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "thisPhysPortID"
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "physPortID",
            "thisPhysPortID"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetDevGetPhysPortID",
          "args": [
            "entry->d_name",
            "&thisPhysPortID"
          ],
          "line": 2463
        },
        "resolved": true,
        "details": {
          "function_name": "virNetDevGetPhysPortID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virnetdev.c",
          "lines": "1454-1463",
          "snippet": "int\nvirNetDevGetPhysPortID(const char *ifname G_GNUC_UNUSED,\n                       char **physPortID)\n{\n    /* this actually should never be called, and is just here to\n     * satisfy the linker.\n     */\n    *physPortID = NULL;\n    return 0;\n}",
          "includes": [
            "# include <linux/devlink.h>",
            "# include <net/if_dl.h>",
            "# include <sys/sockio.h>",
            "# include <linux/ethtool.h>",
            "# include <linux/types.h>",
            "# include <linux/if_vlan.h>",
            "# include <linux/sockios.h>",
            "#include <fcntl.h>",
            "# include <sys/ioctl.h>",
            "#include \"virjson.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virpci.h\"",
            "#include \"vircommand.h\"",
            "#include \"virerror.h\"",
            "#include \"virfile.h\"",
            "#include \"virmacaddr.h\"",
            "#include \"virnetlink.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetdev.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <linux/devlink.h>\n# include <net/if_dl.h>\n# include <sys/sockio.h>\n# include <linux/ethtool.h>\n# include <linux/types.h>\n# include <linux/if_vlan.h>\n# include <linux/sockios.h>\n#include <fcntl.h>\n# include <sys/ioctl.h>\n#include \"virjson.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virpci.h\"\n#include \"vircommand.h\"\n#include \"virerror.h\"\n#include \"virfile.h\"\n#include \"virmacaddr.h\"\n#include \"virnetlink.h\"\n#include \"viralloc.h\"\n#include \"virnetdev.h\"\n#include <config.h>\n\nint\nvirNetDevGetPhysPortID(const char *ifname G_GNUC_UNUSED,\n                       char **physPortID)\n{\n    /* this actually should never be called, and is just here to\n     * satisfy the linker.\n     */\n    *physPortID = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dir",
            "&entry",
            "pcidev_sysfs_net_path"
          ],
          "line": 2458
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpenQuiet",
          "args": [
            "&dir",
            "pcidev_sysfs_net_path"
          ],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBuildPath",
          "args": [
            "&pcidev_sysfs_net_path",
            "device_link_sysfs_path",
            "\"net\""
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "virBuildPathInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1302-1327",
          "snippet": "int\nvirBuildPathInternal(char **path, ...)\n{\n    char *path_component = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    va_list ap;\n    int ret = 0;\n\n    va_start(ap, path);\n\n    path_component = va_arg(ap, char *);\n    virBufferAdd(&buf, path_component, -1);\n\n    while ((path_component = va_arg(ap, char *)) != NULL) {\n        virBufferAddChar(&buf, '/');\n        virBufferAdd(&buf, path_component, -1);\n    }\n\n    va_end(ap);\n\n    *path = virBufferContentAndReset(&buf);\n    if (*path == NULL)\n        ret = -1;\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirBuildPathInternal(char **path, ...)\n{\n    char *path_component = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    va_list ap;\n    int ret = 0;\n\n    va_start(ap, path);\n\n    path_component = va_arg(ap, char *);\n    virBufferAdd(&buf, path_component, -1);\n\n    while ((path_component = va_arg(ap, char *)) != NULL) {\n        virBufferAddChar(&buf, '/');\n        virBufferAdd(&buf, path_component, -1);\n    }\n\n    va_end(ap);\n\n    *path = virBufferContentAndReset(&buf);\n    if (*path == NULL)\n        ret = -1;\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetNetName(const char *device_link_sysfs_path,\n                 size_t idx,\n                 char *physPortID,\n                 char **netname)\n{\n    g_autofree char *pcidev_sysfs_net_path = NULL;\n    g_autofree char *firstEntryName = NULL;\n    g_autofree char *thisPhysPortID = NULL;\n    int ret = -1;\n    DIR *dir = NULL;\n    struct dirent *entry = NULL;\n    size_t i = 0;\n\n    *netname = NULL;\n\n    if (virBuildPath(&pcidev_sysfs_net_path, device_link_sysfs_path,\n                     \"net\") == -1) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if (virDirOpenQuiet(&dir, pcidev_sysfs_net_path) < 0) {\n        /* this *isn't* an error - caller needs to check for netname == NULL */\n        ret = 0;\n        goto cleanup;\n    }\n\n    while (virDirRead(dir, &entry, pcidev_sysfs_net_path) > 0) {\n        /* if the caller sent a physPortID, compare it to the\n         * physportID of this netdev. If not, look for entry[idx].\n         */\n        if (physPortID) {\n            if (virNetDevGetPhysPortID(entry->d_name, &thisPhysPortID) < 0)\n                goto cleanup;\n\n            /* if this one doesn't match, keep looking */\n            if (STRNEQ_NULLABLE(physPortID, thisPhysPortID)) {\n                VIR_FREE(thisPhysPortID);\n                /* save the first entry we find to use as a failsafe\n                 * in case we don't match the phys_port_id. This is\n                 * needed because some NIC drivers (e.g. i40e)\n                 * implement phys_port_id for PFs, but not for VFs\n                 */\n                if (!firstEntryName)\n                    firstEntryName = g_strdup(entry->d_name);\n\n                continue;\n            }\n        } else {\n            if (i++ < idx)\n                continue;\n        }\n\n        *netname = g_strdup(entry->d_name);\n\n        ret = 0;\n        break;\n    }\n\n    if (ret < 0) {\n        if (physPortID) {\n            if (firstEntryName) {\n                /* we didn't match the provided phys_port_id, but this\n                 * is probably because phys_port_id isn't implemented\n                 * for this NIC driver, so just return the first\n                 * (probably only) netname we found.\n                 */\n                *netname = firstEntryName;\n                firstEntryName = NULL;\n                ret = 0;\n            } else {\n                virReportError(VIR_ERR_INTERNAL_ERROR,\n                               _(\"Could not find network device with \"\n                                 \"phys_port_id '%s' under PCI device at %s\"),\n                               physPortID, device_link_sysfs_path);\n            }\n        } else {\n            ret = 0; /* no netdev at the given index is *not* an error */\n        }\n    }\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceAddressGetSysfsFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2409-2416",
    "snippet": "int\nvirPCIDeviceAddressGetSysfsFile(virPCIDeviceAddressPtr addr,\n                                char **pci_sysfs_device_link)\n{\n    *pci_sysfs_device_link = g_strdup_printf(PCI_SYSFS \"devices/\" VIR_PCI_DEVICE_ADDRESS_FMT, addr->domain,\n                                             addr->bus, addr->slot, addr->function);\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_SYSFS \"/sys/bus/pci/\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "PCI_SYSFS \"devices/\" VIR_PCI_DEVICE_ADDRESS_FMT",
            "addr->domain",
            "addr->bus",
            "addr->slot",
            "addr->function"
          ],
          "line": 2413
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nint\nvirPCIDeviceAddressGetSysfsFile(virPCIDeviceAddressPtr addr,\n                                char **pci_sysfs_device_link)\n{\n    *pci_sysfs_device_link = g_strdup_printf(PCI_SYSFS \"devices/\" VIR_PCI_DEVICE_ADDRESS_FMT, addr->domain,\n                                             addr->bus, addr->slot, addr->function);\n    return 0;\n}"
  },
  {
    "function_name": "virPCIGetSysfsFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2401-2407",
    "snippet": "int\nvirPCIGetSysfsFile(char *virPCIDeviceName, char **pci_sysfs_device_link)\n{\n    *pci_sysfs_device_link = g_strdup_printf(PCI_SYSFS \"devices/%s\",\n                                             virPCIDeviceName);\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_SYSFS \"/sys/bus/pci/\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "PCI_SYSFS \"devices/%s\"",
            "virPCIDeviceName"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nint\nvirPCIGetSysfsFile(char *virPCIDeviceName, char **pci_sysfs_device_link)\n{\n    *pci_sysfs_device_link = g_strdup_printf(PCI_SYSFS \"devices/%s\",\n                                             virPCIDeviceName);\n    return 0;\n}"
  },
  {
    "function_name": "virPCIGetVirtualFunctionIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2354-2395",
    "snippet": "int\nvirPCIGetVirtualFunctionIndex(const char *pf_sysfs_device_link,\n                              const char *vf_sysfs_device_link,\n                              int *vf_index)\n{\n    int ret = -1;\n    size_t i;\n    size_t num_virt_fns = 0;\n    unsigned int max_virt_fns = 0;\n    virPCIDeviceAddressPtr vf_bdf = NULL;\n    virPCIDeviceAddressPtr *virt_fns = NULL;\n\n    if (!(vf_bdf = virPCIGetDeviceAddressFromSysfsLink(vf_sysfs_device_link)))\n        return ret;\n\n    if (virPCIGetVirtualFunctions(pf_sysfs_device_link, &virt_fns,\n                                  &num_virt_fns, &max_virt_fns) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Error getting physical function's '%s' \"\n                         \"virtual_functions\"), pf_sysfs_device_link);\n        goto out;\n    }\n\n    for (i = 0; i < num_virt_fns; i++) {\n        if (virPCIDeviceAddressEqual(vf_bdf, virt_fns[i])) {\n            *vf_index = i;\n            ret = 0;\n            break;\n        }\n    }\n\n out:\n\n    /* free virtual functions */\n    for (i = 0; i < num_virt_fns; i++)\n        VIR_FREE(virt_fns[i]);\n\n    VIR_FREE(virt_fns);\n    VIR_FREE(vf_bdf);\n\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "vf_bdf"
          ],
          "line": 2392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virt_fns"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "virt_fns[i]"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressEqual",
          "args": [
            "vf_bdf",
            "virt_fns[i]"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressEqual",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1324-1335",
          "snippet": "bool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Error getting physical function's '%s' \"\n                         \"virtual_functions\")",
            "pf_sysfs_device_link"
          ],
          "line": 2371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Error getting physical function's '%s' \"\n                         \"virtual_functions\""
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIGetVirtualFunctions",
          "args": [
            "pf_sysfs_device_link",
            "&virt_fns",
            "&num_virt_fns",
            "&max_virt_fns"
          ],
          "line": 2369
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetVirtualFunctions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2654-2662",
          "snippet": "int\nvirPCIGetVirtualFunctions(const char *sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr **virtual_functions G_GNUC_UNUSED,\n                          size_t *num_virtual_functions G_GNUC_UNUSED,\n                          unsigned int *max_virtual_functions G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetVirtualFunctions(const char *sysfs_path G_GNUC_UNUSED,\n                          virPCIDeviceAddressPtr **virtual_functions G_GNUC_UNUSED,\n                          size_t *num_virtual_functions G_GNUC_UNUSED,\n                          unsigned int *max_virtual_functions G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIGetDeviceAddressFromSysfsLink",
          "args": [
            "vf_sysfs_device_link"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetDeviceAddressFromSysfsLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2638-2643",
          "snippet": "virPCIDeviceAddressPtr\nvirPCIGetDeviceAddressFromSysfsLink(const char *device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDeviceAddressPtr\nvirPCIGetDeviceAddressFromSysfsLink(const char *device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetVirtualFunctionIndex(const char *pf_sysfs_device_link,\n                              const char *vf_sysfs_device_link,\n                              int *vf_index)\n{\n    int ret = -1;\n    size_t i;\n    size_t num_virt_fns = 0;\n    unsigned int max_virt_fns = 0;\n    virPCIDeviceAddressPtr vf_bdf = NULL;\n    virPCIDeviceAddressPtr *virt_fns = NULL;\n\n    if (!(vf_bdf = virPCIGetDeviceAddressFromSysfsLink(vf_sysfs_device_link)))\n        return ret;\n\n    if (virPCIGetVirtualFunctions(pf_sysfs_device_link, &virt_fns,\n                                  &num_virt_fns, &max_virt_fns) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Error getting physical function's '%s' \"\n                         \"virtual_functions\"), pf_sysfs_device_link);\n        goto out;\n    }\n\n    for (i = 0; i < num_virt_fns; i++) {\n        if (virPCIDeviceAddressEqual(vf_bdf, virt_fns[i])) {\n            *vf_index = i;\n            ret = 0;\n            break;\n        }\n    }\n\n out:\n\n    /* free virtual functions */\n    for (i = 0; i < num_virt_fns; i++)\n        VIR_FREE(virt_fns[i]);\n\n    VIR_FREE(virt_fns);\n    VIR_FREE(vf_bdf);\n\n    return ret;\n}"
  },
  {
    "function_name": "virPCIIsVirtualFunction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2341-2349",
    "snippet": "int\nvirPCIIsVirtualFunction(const char *vf_sysfs_device_link)\n{\n    g_autofree char *vf_sysfs_physfn_link = NULL;\n\n    vf_sysfs_physfn_link = g_strdup_printf(\"%s/physfn\", vf_sysfs_device_link);\n\n    return virFileExists(vf_sysfs_physfn_link);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "vf_sysfs_physfn_link"
          ],
          "line": 2348
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/physfn\"",
            "vf_sysfs_device_link"
          ],
          "line": 2346
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIIsVirtualFunction(const char *vf_sysfs_device_link)\n{\n    g_autofree char *vf_sysfs_physfn_link = NULL;\n\n    vf_sysfs_physfn_link = g_strdup_printf(\"%s/physfn\", vf_sysfs_device_link);\n\n    return virFileExists(vf_sysfs_physfn_link);\n}"
  },
  {
    "function_name": "virPCIGetVirtualFunctions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2271-2335",
    "snippet": "int\nvirPCIGetVirtualFunctions(const char *sysfs_path,\n                          virPCIDeviceAddressPtr **virtual_functions,\n                          size_t *num_virtual_functions,\n                          unsigned int *max_virtual_functions)\n{\n    int ret = -1;\n    size_t i;\n    g_autofree char *totalvfs_file = NULL;\n    g_autofree char *totalvfs_str = NULL;\n    virPCIDeviceAddressPtr config_addr = NULL;\n\n    *virtual_functions = NULL;\n    *num_virtual_functions = 0;\n    *max_virtual_functions = 0;\n\n    totalvfs_file = g_strdup_printf(\"%s/sriov_totalvfs\", sysfs_path);\n    if (virFileExists(totalvfs_file)) {\n        char *end = NULL; /* so that terminating \\n doesn't create error */\n\n        if (virFileReadAll(totalvfs_file, 16, &totalvfs_str) < 0)\n            goto error;\n        if (virStrToLong_ui(totalvfs_str, &end, 10, max_virtual_functions) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unrecognized value in %s: %s\"),\n                           totalvfs_file, totalvfs_str);\n            goto error;\n        }\n    }\n\n    do {\n        g_autofree char *device_link = NULL;\n        /* look for virtfn%d links until one isn't found */\n        device_link = g_strdup_printf(\"%s/virtfn%zu\", sysfs_path,\n                                      *num_virtual_functions);\n\n        if (!virFileExists(device_link))\n            break;\n\n        if (!(config_addr = virPCIGetDeviceAddressFromSysfsLink(device_link))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get SRIOV function from device link '%s'\"),\n                           device_link);\n            goto error;\n        }\n\n        if (VIR_APPEND_ELEMENT(*virtual_functions, *num_virtual_functions,\n                               config_addr) < 0)\n            goto error;\n    } while (1);\n\n    VIR_DEBUG(\"Found %zu virtual functions for %s\",\n              *num_virtual_functions, sysfs_path);\n    ret = 0;\n cleanup:\n    VIR_FREE(config_addr);\n    return ret;\n\n error:\n    for (i = 0; i < *num_virtual_functions; i++)\n        VIR_FREE((*virtual_functions)[i]);\n    VIR_FREE(*virtual_functions);\n    *num_virtual_functions = 0;\n    goto cleanup;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*virtual_functions"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "(*virtual_functions)[i]"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "config_addr"
          ],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Found %zu virtual functions for %s\"",
            "*num_virtual_functions",
            "sysfs_path"
          ],
          "line": 2322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "*virtual_functions",
            "*num_virtual_functions",
            "config_addr"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to get SRIOV function from device link '%s'\")",
            "device_link"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to get SRIOV function from device link '%s'\""
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIGetDeviceAddressFromSysfsLink",
          "args": [
            "device_link"
          ],
          "line": 2310
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetDeviceAddressFromSysfsLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2638-2643",
          "snippet": "virPCIDeviceAddressPtr\nvirPCIGetDeviceAddressFromSysfsLink(const char *device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDeviceAddressPtr\nvirPCIGetDeviceAddressFromSysfsLink(const char *device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "device_link"
          ],
          "line": 2307
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unrecognized value in %s: %s\")",
            "totalvfs_file",
            "totalvfs_str"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "totalvfs_str",
            "&end",
            "10",
            "max_virtual_functions"
          ],
          "line": 2293
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "totalvfs_file",
            "16",
            "&totalvfs_str"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetVirtualFunctions(const char *sysfs_path,\n                          virPCIDeviceAddressPtr **virtual_functions,\n                          size_t *num_virtual_functions,\n                          unsigned int *max_virtual_functions)\n{\n    int ret = -1;\n    size_t i;\n    g_autofree char *totalvfs_file = NULL;\n    g_autofree char *totalvfs_str = NULL;\n    virPCIDeviceAddressPtr config_addr = NULL;\n\n    *virtual_functions = NULL;\n    *num_virtual_functions = 0;\n    *max_virtual_functions = 0;\n\n    totalvfs_file = g_strdup_printf(\"%s/sriov_totalvfs\", sysfs_path);\n    if (virFileExists(totalvfs_file)) {\n        char *end = NULL; /* so that terminating \\n doesn't create error */\n\n        if (virFileReadAll(totalvfs_file, 16, &totalvfs_str) < 0)\n            goto error;\n        if (virStrToLong_ui(totalvfs_str, &end, 10, max_virtual_functions) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Unrecognized value in %s: %s\"),\n                           totalvfs_file, totalvfs_str);\n            goto error;\n        }\n    }\n\n    do {\n        g_autofree char *device_link = NULL;\n        /* look for virtfn%d links until one isn't found */\n        device_link = g_strdup_printf(\"%s/virtfn%zu\", sysfs_path,\n                                      *num_virtual_functions);\n\n        if (!virFileExists(device_link))\n            break;\n\n        if (!(config_addr = virPCIGetDeviceAddressFromSysfsLink(device_link))) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to get SRIOV function from device link '%s'\"),\n                           device_link);\n            goto error;\n        }\n\n        if (VIR_APPEND_ELEMENT(*virtual_functions, *num_virtual_functions,\n                               config_addr) < 0)\n            goto error;\n    } while (1);\n\n    VIR_DEBUG(\"Found %zu virtual functions for %s\",\n              *num_virtual_functions, sysfs_path);\n    ret = 0;\n cleanup:\n    VIR_FREE(config_addr);\n    return ret;\n\n error:\n    for (i = 0; i < *num_virtual_functions; i++)\n        VIR_FREE((*virtual_functions)[i]);\n    VIR_FREE(*virtual_functions);\n    *num_virtual_functions = 0;\n    goto cleanup;\n}"
  },
  {
    "function_name": "virPCIGetPhysicalFunction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2245-2265",
    "snippet": "int\nvirPCIGetPhysicalFunction(const char *vf_sysfs_path,\n                          virPCIDeviceAddressPtr *pf)\n{\n    g_autofree char *device_link = NULL;\n\n    *pf = NULL;\n\n    if (virBuildPath(&device_link, vf_sysfs_path, \"physfn\") == -1) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if ((*pf = virPCIGetDeviceAddressFromSysfsLink(device_link))) {\n        VIR_DEBUG(\"PF for VF device '%s': \" VIR_PCI_DEVICE_ADDRESS_FMT,\n                  vf_sysfs_path,\n                  (*pf)->domain, (*pf)->bus, (*pf)->slot, (*pf)->function);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"PF for VF device '%s': \" VIR_PCI_DEVICE_ADDRESS_FMT",
            "vf_sysfs_path",
            "(*pf)->domain",
            "(*pf)->bus",
            "(*pf)->slot",
            "(*pf)->function"
          ],
          "line": 2259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIGetDeviceAddressFromSysfsLink",
          "args": [
            "device_link"
          ],
          "line": 2258
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetDeviceAddressFromSysfsLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2638-2643",
          "snippet": "virPCIDeviceAddressPtr\nvirPCIGetDeviceAddressFromSysfsLink(const char *device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDeviceAddressPtr\nvirPCIGetDeviceAddressFromSysfsLink(const char *device_link G_GNUC_UNUSED)\n{\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\", _(unsupported));\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportOOMError",
          "args": [],
          "line": 2254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virBuildPath",
          "args": [
            "&device_link",
            "vf_sysfs_path",
            "\"physfn\""
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "virBuildPathInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1302-1327",
          "snippet": "int\nvirBuildPathInternal(char **path, ...)\n{\n    char *path_component = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    va_list ap;\n    int ret = 0;\n\n    va_start(ap, path);\n\n    path_component = va_arg(ap, char *);\n    virBufferAdd(&buf, path_component, -1);\n\n    while ((path_component = va_arg(ap, char *)) != NULL) {\n        virBufferAddChar(&buf, '/');\n        virBufferAdd(&buf, path_component, -1);\n    }\n\n    va_end(ap);\n\n    *path = virBufferContentAndReset(&buf);\n    if (*path == NULL)\n        ret = -1;\n\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirBuildPathInternal(char **path, ...)\n{\n    char *path_component = NULL;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    va_list ap;\n    int ret = 0;\n\n    va_start(ap, path);\n\n    path_component = va_arg(ap, char *);\n    virBufferAdd(&buf, path_component, -1);\n\n    while ((path_component = va_arg(ap, char *)) != NULL) {\n        virBufferAddChar(&buf, '/');\n        virBufferAdd(&buf, path_component, -1);\n    }\n\n    va_end(ap);\n\n    *path = virBufferContentAndReset(&buf);\n    if (*path == NULL)\n        ret = -1;\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIGetPhysicalFunction(const char *vf_sysfs_path,\n                          virPCIDeviceAddressPtr *pf)\n{\n    g_autofree char *device_link = NULL;\n\n    *pf = NULL;\n\n    if (virBuildPath(&device_link, vf_sysfs_path, \"physfn\") == -1) {\n        virReportOOMError();\n        return -1;\n    }\n\n    if ((*pf = virPCIGetDeviceAddressFromSysfsLink(device_link))) {\n        VIR_DEBUG(\"PF for VF device '%s': \" VIR_PCI_DEVICE_ADDRESS_FMT,\n                  vf_sysfs_path,\n                  (*pf)->domain, (*pf)->bus, (*pf)->slot, (*pf)->function);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIGetDeviceAddressFromSysfsLink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2196-2229",
    "snippet": "virPCIDeviceAddressPtr\nvirPCIGetDeviceAddressFromSysfsLink(const char *device_link)\n{\n    virPCIDeviceAddressPtr bdf = NULL;\n    g_autofree char *config_address = NULL;\n    g_autofree char *device_path = NULL;\n\n    if (!virFileExists(device_link)) {\n        VIR_DEBUG(\"'%s' does not exist\", device_link);\n        return NULL;\n    }\n\n    device_path = virFileCanonicalizePath(device_link);\n    if (device_path == NULL) {\n        virReportSystemError(errno,\n                             _(\"Failed to resolve device link '%s'\"),\n                             device_link);\n        return NULL;\n    }\n\n    config_address = g_path_get_basename(device_path);\n    if (VIR_ALLOC(bdf) < 0)\n        return NULL;\n\n    if (virPCIDeviceAddressParse(config_address, bdf) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse PCI config address '%s'\"),\n                       config_address);\n        VIR_FREE(bdf);\n        return NULL;\n    }\n\n    return bdf;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "bdf"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to parse PCI config address '%s'\")",
            "config_address"
          ],
          "line": 2221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to parse PCI config address '%s'\""
          ],
          "line": 2222
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressParse",
          "args": [
            "config_address",
            "bdf"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2139-2166",
          "snippet": "int\nvirPCIDeviceAddressParse(char *address,\n                         virPCIDeviceAddressPtr bdf)\n{\n    char *p = NULL;\n\n    if ((address == NULL) || (logStrToLong_ui(address, &p, 16,\n                                              &bdf->domain) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->bus) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->slot) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->function) == -1)) {\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressParse(char *address,\n                         virPCIDeviceAddressPtr bdf)\n{\n    char *p = NULL;\n\n    if ((address == NULL) || (logStrToLong_ui(address, &p, 16,\n                                              &bdf->domain) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->bus) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->slot) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->function) == -1)) {\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "bdf"
          ],
          "line": 2217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "device_path"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to resolve device link '%s'\")",
            "device_link"
          ],
          "line": 2210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileCanonicalizePath",
          "args": [
            "device_link"
          ],
          "line": 2208
        },
        "resolved": true,
        "details": {
          "function_name": "virFileCanonicalizePath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "3299-3310",
          "snippet": "char *\nvirFileCanonicalizePath(const char *path)\n{\n#ifdef WIN32\n    /* Does not resolve symlinks, only expands . & .. & repeated /.\n     * It will never fail, so sanitize errno to indicate success */\n    errno = 0;\n    return g_canonicalize_filename(path, NULL);\n#else\n    return realpath(path, NULL); /* exempt from syntax-check */\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nchar *\nvirFileCanonicalizePath(const char *path)\n{\n#ifdef WIN32\n    /* Does not resolve symlinks, only expands . & .. & repeated /.\n     * It will never fail, so sanitize errno to indicate success */\n    errno = 0;\n    return g_canonicalize_filename(path, NULL);\n#else\n    return realpath(path, NULL); /* exempt from syntax-check */\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"'%s' does not exist\"",
            "device_link"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "device_link"
          ],
          "line": 2203
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDeviceAddressPtr\nvirPCIGetDeviceAddressFromSysfsLink(const char *device_link)\n{\n    virPCIDeviceAddressPtr bdf = NULL;\n    g_autofree char *config_address = NULL;\n    g_autofree char *device_path = NULL;\n\n    if (!virFileExists(device_link)) {\n        VIR_DEBUG(\"'%s' does not exist\", device_link);\n        return NULL;\n    }\n\n    device_path = virFileCanonicalizePath(device_link);\n    if (device_path == NULL) {\n        virReportSystemError(errno,\n                             _(\"Failed to resolve device link '%s'\"),\n                             device_link);\n        return NULL;\n    }\n\n    config_address = g_path_get_basename(device_path);\n    if (VIR_ALLOC(bdf) < 0)\n        return NULL;\n\n    if (virPCIDeviceAddressParse(config_address, bdf) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to parse PCI config address '%s'\"),\n                       config_address);\n        VIR_FREE(bdf);\n        return NULL;\n    }\n\n    return bdf;\n}"
  },
  {
    "function_name": "virZPCIDeviceAddressIsEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2188-2192",
    "snippet": "bool\nvirZPCIDeviceAddressIsEmpty(const virZPCIDeviceAddress *addr)\n{\n    return !(addr->uid || addr->fid);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirZPCIDeviceAddressIsEmpty(const virZPCIDeviceAddress *addr)\n{\n    return !(addr->uid || addr->fid);\n}"
  },
  {
    "function_name": "virZPCIDeviceAddressIsValid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2169-2186",
    "snippet": "bool\nvirZPCIDeviceAddressIsValid(virZPCIDeviceAddressPtr zpci)\n{\n    /* We don't need to check fid because fid covers\n     * all range of uint32 type.\n     */\n    if (zpci->uid > VIR_DOMAIN_DEVICE_ZPCI_MAX_UID ||\n        zpci->uid == 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid PCI address uid='0x%.4x', \"\n                         \"must be > 0x0000 and <= 0x%.4x\"),\n                       zpci->uid,\n                       VIR_DOMAIN_DEVICE_ZPCI_MAX_UID);\n        return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid PCI address uid='0x%.4x', \"\n                         \"must be > 0x0000 and <= 0x%.4x\")",
            "zpci->uid",
            "VIR_DOMAIN_DEVICE_ZPCI_MAX_UID"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid PCI address uid='0x%.4x', \"\n                         \"must be > 0x0000 and <= 0x%.4x\""
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirZPCIDeviceAddressIsValid(virZPCIDeviceAddressPtr zpci)\n{\n    /* We don't need to check fid because fid covers\n     * all range of uint32 type.\n     */\n    if (zpci->uid > VIR_DOMAIN_DEVICE_ZPCI_MAX_UID ||\n        zpci->uid == 0) {\n        virReportError(VIR_ERR_XML_ERROR,\n                       _(\"Invalid PCI address uid='0x%.4x', \"\n                         \"must be > 0x0000 and <= 0x%.4x\"),\n                       zpci->uid,\n                       VIR_DOMAIN_DEVICE_ZPCI_MAX_UID);\n        return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "virPCIDeviceAddressParse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2139-2166",
    "snippet": "int\nvirPCIDeviceAddressParse(char *address,\n                         virPCIDeviceAddressPtr bdf)\n{\n    char *p = NULL;\n\n    if ((address == NULL) || (logStrToLong_ui(address, &p, 16,\n                                              &bdf->domain) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->bus) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->slot) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->function) == -1)) {\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logStrToLong_ui",
          "args": [
            "p+1",
            "&p",
            "16",
            "&bdf->function"
          ],
          "line": 2160
        },
        "resolved": true,
        "details": {
          "function_name": "logStrToLong_ui",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2125-2137",
          "snippet": "static int\nlogStrToLong_ui(char const *s,\n                char **end_ptr,\n                int base,\n                unsigned int *result)\n{\n    int ret = 0;\n\n    ret = virStrToLong_ui(s, end_ptr, base, result);\n    if (ret != 0)\n        VIR_ERROR(_(\"Failed to convert '%s' to unsigned int\"), s);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nlogStrToLong_ui(char const *s,\n                char **end_ptr,\n                int base,\n                unsigned int *result)\n{\n    int ret = 0;\n\n    ret = virStrToLong_ui(s, end_ptr, base, result);\n    if (ret != 0)\n        VIR_ERROR(_(\"Failed to convert '%s' to unsigned int\"), s);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressParse(char *address,\n                         virPCIDeviceAddressPtr bdf)\n{\n    char *p = NULL;\n\n    if ((address == NULL) || (logStrToLong_ui(address, &p, 16,\n                                              &bdf->domain) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->bus) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->slot) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->function) == -1)) {\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "logStrToLong_ui",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2125-2137",
    "snippet": "static int\nlogStrToLong_ui(char const *s,\n                char **end_ptr,\n                int base,\n                unsigned int *result)\n{\n    int ret = 0;\n\n    ret = virStrToLong_ui(s, end_ptr, base, result);\n    if (ret != 0)\n        VIR_ERROR(_(\"Failed to convert '%s' to unsigned int\"), s);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_ERROR",
          "args": [
            "_(\"Failed to convert '%s' to unsigned int\")",
            "s"
          ],
          "line": 2135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to convert '%s' to unsigned int\""
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "s",
            "end_ptr",
            "base",
            "result"
          ],
          "line": 2133
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nlogStrToLong_ui(char const *s,\n                char **end_ptr,\n                int base,\n                unsigned int *result)\n{\n    int ret = 0;\n\n    ret = virStrToLong_ui(s, end_ptr, base, result);\n    if (ret != 0)\n        VIR_ERROR(_(\"Failed to convert '%s' to unsigned int\"), s);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceIsAssignable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2095-2123",
    "snippet": "int virPCIDeviceIsAssignable(virPCIDevicePtr dev,\n                             int strict_acs_check)\n{\n    int ret;\n\n    /* XXX This could be a great place to actually check that a non-managed\n     * device isn't in use, e.g. by checking that device is either un-bound\n     * or bound to a stub driver.\n     */\n\n    ret = virPCIDeviceIsBehindSwitchLackingACS(dev);\n    if (ret < 0)\n        return 0;\n\n    if (ret) {\n        if (!strict_acs_check) {\n            VIR_DEBUG(\"%s %s: strict ACS check disabled; device assignment allowed\",\n                      dev->id, dev->name);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Device %s is behind a switch lacking ACS and \"\n                             \"cannot be assigned\"),\n                           dev->name);\n            return 0;\n        }\n    }\n\n    return 1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Device %s is behind a switch lacking ACS and \"\n                             \"cannot be assigned\")",
            "dev->name"
          ],
          "line": 2114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Device %s is behind a switch lacking ACS and \"\n                             \"cannot be assigned\""
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: strict ACS check disabled; device assignment allowed\"",
            "dev->id",
            "dev->name"
          ],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceIsBehindSwitchLackingACS",
          "args": [
            "dev"
          ],
          "line": 2105
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceIsBehindSwitchLackingACS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2046-2093",
          "snippet": "static int\nvirPCIDeviceIsBehindSwitchLackingACS(virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) parent = NULL;\n\n    if (virPCIDeviceGetParent(dev, &parent) < 0)\n        return -1;\n    if (!parent) {\n        /* if we have no parent, and this is the root bus, ACS doesn't come\n         * into play since devices on the root bus can't P2P without going\n         * through the root IOMMU.\n         */\n        if (dev->address.bus == 0) {\n            return 0;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to find parent device for %s\"),\n                           dev->name);\n            return -1;\n        }\n    }\n\n    /* XXX we should rather fail when we can't find device's parent and\n     * stop the loop when we get to root instead of just stopping when no\n     * parent can be found\n     */\n    do {\n        g_autoptr(virPCIDevice) tmp = NULL;\n        int acs;\n        int ret;\n\n        acs = virPCIDeviceDownstreamLacksACS(parent);\n\n        if (acs) {\n            if (acs < 0)\n                return -1;\n            else\n                return 1;\n        }\n\n        tmp = parent;\n        ret = virPCIDeviceGetParent(parent, &parent);\n        if (ret < 0)\n            return -1;\n    } while (parent);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceIsBehindSwitchLackingACS(virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) parent = NULL;\n\n    if (virPCIDeviceGetParent(dev, &parent) < 0)\n        return -1;\n    if (!parent) {\n        /* if we have no parent, and this is the root bus, ACS doesn't come\n         * into play since devices on the root bus can't P2P without going\n         * through the root IOMMU.\n         */\n        if (dev->address.bus == 0) {\n            return 0;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to find parent device for %s\"),\n                           dev->name);\n            return -1;\n        }\n    }\n\n    /* XXX we should rather fail when we can't find device's parent and\n     * stop the loop when we get to root instead of just stopping when no\n     * parent can be found\n     */\n    do {\n        g_autoptr(virPCIDevice) tmp = NULL;\n        int acs;\n        int ret;\n\n        acs = virPCIDeviceDownstreamLacksACS(parent);\n\n        if (acs) {\n            if (acs < 0)\n                return -1;\n            else\n                return 1;\n        }\n\n        tmp = parent;\n        ret = virPCIDeviceGetParent(parent, &parent);\n        if (ret < 0)\n            return -1;\n    } while (parent);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint virPCIDeviceIsAssignable(virPCIDevicePtr dev,\n                             int strict_acs_check)\n{\n    int ret;\n\n    /* XXX This could be a great place to actually check that a non-managed\n     * device isn't in use, e.g. by checking that device is either un-bound\n     * or bound to a stub driver.\n     */\n\n    ret = virPCIDeviceIsBehindSwitchLackingACS(dev);\n    if (ret < 0)\n        return 0;\n\n    if (ret) {\n        if (!strict_acs_check) {\n            VIR_DEBUG(\"%s %s: strict ACS check disabled; device assignment allowed\",\n                      dev->id, dev->name);\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Device %s is behind a switch lacking ACS and \"\n                             \"cannot be assigned\"),\n                           dev->name);\n            return 0;\n        }\n    }\n\n    return 1;\n}"
  },
  {
    "function_name": "virPCIDeviceIsBehindSwitchLackingACS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "2046-2093",
    "snippet": "static int\nvirPCIDeviceIsBehindSwitchLackingACS(virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) parent = NULL;\n\n    if (virPCIDeviceGetParent(dev, &parent) < 0)\n        return -1;\n    if (!parent) {\n        /* if we have no parent, and this is the root bus, ACS doesn't come\n         * into play since devices on the root bus can't P2P without going\n         * through the root IOMMU.\n         */\n        if (dev->address.bus == 0) {\n            return 0;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to find parent device for %s\"),\n                           dev->name);\n            return -1;\n        }\n    }\n\n    /* XXX we should rather fail when we can't find device's parent and\n     * stop the loop when we get to root instead of just stopping when no\n     * parent can be found\n     */\n    do {\n        g_autoptr(virPCIDevice) tmp = NULL;\n        int acs;\n        int ret;\n\n        acs = virPCIDeviceDownstreamLacksACS(parent);\n\n        if (acs) {\n            if (acs < 0)\n                return -1;\n            else\n                return 1;\n        }\n\n        tmp = parent;\n        ret = virPCIDeviceGetParent(parent, &parent);\n        if (ret < 0)\n            return -1;\n    } while (parent);\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceGetParent",
          "args": [
            "parent",
            "&parent"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "754-767",
          "snippet": "static int\nvirPCIDeviceGetParent(virPCIDevicePtr dev, virPCIDevicePtr *parent)\n{\n    virPCIDevicePtr best = NULL;\n    int ret;\n\n    *parent = NULL;\n    ret = virPCIDeviceIterDevices(virPCIDeviceIsParent, dev, parent, &best);\n    if (ret == 1)\n        virPCIDeviceFree(best);\n    else if (ret == 0)\n        *parent = best;\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceGetParent(virPCIDevicePtr dev, virPCIDevicePtr *parent)\n{\n    virPCIDevicePtr best = NULL;\n    int ret;\n\n    *parent = NULL;\n    ret = virPCIDeviceIterDevices(virPCIDeviceIsParent, dev, parent, &best);\n    if (ret == 1)\n        virPCIDeviceFree(best);\n    else if (ret == 0)\n        *parent = best;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceDownstreamLacksACS",
          "args": [
            "parent"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceDownstreamLacksACS",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1997-2044",
          "snippet": "static int\nvirPCIDeviceDownstreamLacksACS(virPCIDevicePtr dev)\n{\n    uint16_t flags;\n    uint16_t ctrl;\n    unsigned int pos;\n    int fd;\n    int ret = 0;\n    uint16_t device_class;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    if (virPCIDeviceInit(dev, fd) < 0) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    if (virPCIDeviceReadClass(dev, &device_class) < 0)\n        goto cleanup;\n\n    pos = dev->pcie_cap_pos;\n    if (!pos || device_class != PCI_CLASS_BRIDGE_PCI)\n        goto cleanup;\n\n    flags = virPCIDeviceRead16(dev, fd, pos + PCI_EXP_FLAGS);\n    if (((flags & PCI_EXP_FLAGS_TYPE) >> 4) != PCI_EXP_TYPE_DOWNSTREAM)\n        goto cleanup;\n\n    pos = virPCIDeviceFindExtendedCapabilityOffset(dev, fd, PCI_EXT_CAP_ID_ACS);\n    if (!pos) {\n        VIR_DEBUG(\"%s %s: downstream port lacks ACS\", dev->id, dev->name);\n        ret = 1;\n        goto cleanup;\n    }\n\n    ctrl = virPCIDeviceRead16(dev, fd, pos + PCI_EXT_ACS_CTRL);\n    if ((ctrl & PCI_EXT_CAP_ACS_ENABLED) != PCI_EXT_CAP_ACS_ENABLED) {\n        VIR_DEBUG(\"%s %s: downstream port has ACS disabled\",\n                  dev->id, dev->name);\n        ret = 1;\n        goto cleanup;\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_EXT_CAP_ACS_ENABLED (PCI_EXT_CAP_ACS_SV | \\\n                                 PCI_EXT_CAP_ACS_RR | \\\n                                 PCI_EXT_CAP_ACS_CR | \\\n                                 PCI_EXT_CAP_ACS_UF)",
            "#define PCI_EXT_ACS_CTRL        0x06",
            "#define PCI_EXT_CAP_ID_ACS      0x000d",
            "#define PCI_EXP_TYPE_DOWNSTREAM 0x6",
            "#define PCI_EXP_FLAGS_TYPE      0x00f0",
            "#define PCI_EXP_FLAGS           0x2",
            "#define PCI_CLASS_BRIDGE_PCI    0x0604"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_EXT_CAP_ACS_ENABLED (PCI_EXT_CAP_ACS_SV | \\\n                                 PCI_EXT_CAP_ACS_RR | \\\n                                 PCI_EXT_CAP_ACS_CR | \\\n                                 PCI_EXT_CAP_ACS_UF)\n#define PCI_EXT_ACS_CTRL        0x06\n#define PCI_EXT_CAP_ID_ACS      0x000d\n#define PCI_EXP_TYPE_DOWNSTREAM 0x6\n#define PCI_EXP_FLAGS_TYPE      0x00f0\n#define PCI_EXP_FLAGS           0x2\n#define PCI_CLASS_BRIDGE_PCI    0x0604\n\nstatic int\nvirPCIDeviceDownstreamLacksACS(virPCIDevicePtr dev)\n{\n    uint16_t flags;\n    uint16_t ctrl;\n    unsigned int pos;\n    int fd;\n    int ret = 0;\n    uint16_t device_class;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    if (virPCIDeviceInit(dev, fd) < 0) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    if (virPCIDeviceReadClass(dev, &device_class) < 0)\n        goto cleanup;\n\n    pos = dev->pcie_cap_pos;\n    if (!pos || device_class != PCI_CLASS_BRIDGE_PCI)\n        goto cleanup;\n\n    flags = virPCIDeviceRead16(dev, fd, pos + PCI_EXP_FLAGS);\n    if (((flags & PCI_EXP_FLAGS_TYPE) >> 4) != PCI_EXP_TYPE_DOWNSTREAM)\n        goto cleanup;\n\n    pos = virPCIDeviceFindExtendedCapabilityOffset(dev, fd, PCI_EXT_CAP_ID_ACS);\n    if (!pos) {\n        VIR_DEBUG(\"%s %s: downstream port lacks ACS\", dev->id, dev->name);\n        ret = 1;\n        goto cleanup;\n    }\n\n    ctrl = virPCIDeviceRead16(dev, fd, pos + PCI_EXT_ACS_CTRL);\n    if ((ctrl & PCI_EXT_CAP_ACS_ENABLED) != PCI_EXT_CAP_ACS_ENABLED) {\n        VIR_DEBUG(\"%s %s: downstream port has ACS disabled\",\n                  dev->id, dev->name);\n        ret = 1;\n        goto cleanup;\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to find parent device for %s\")",
            "dev->name"
          ],
          "line": 2061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to find parent device for %s\""
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceIsBehindSwitchLackingACS(virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) parent = NULL;\n\n    if (virPCIDeviceGetParent(dev, &parent) < 0)\n        return -1;\n    if (!parent) {\n        /* if we have no parent, and this is the root bus, ACS doesn't come\n         * into play since devices on the root bus can't P2P without going\n         * through the root IOMMU.\n         */\n        if (dev->address.bus == 0) {\n            return 0;\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Failed to find parent device for %s\"),\n                           dev->name);\n            return -1;\n        }\n    }\n\n    /* XXX we should rather fail when we can't find device's parent and\n     * stop the loop when we get to root instead of just stopping when no\n     * parent can be found\n     */\n    do {\n        g_autoptr(virPCIDevice) tmp = NULL;\n        int acs;\n        int ret;\n\n        acs = virPCIDeviceDownstreamLacksACS(parent);\n\n        if (acs) {\n            if (acs < 0)\n                return -1;\n            else\n                return 1;\n        }\n\n        tmp = parent;\n        ret = virPCIDeviceGetParent(parent, &parent);\n        if (ret < 0)\n            return -1;\n    } while (parent);\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceDownstreamLacksACS",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1997-2044",
    "snippet": "static int\nvirPCIDeviceDownstreamLacksACS(virPCIDevicePtr dev)\n{\n    uint16_t flags;\n    uint16_t ctrl;\n    unsigned int pos;\n    int fd;\n    int ret = 0;\n    uint16_t device_class;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    if (virPCIDeviceInit(dev, fd) < 0) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    if (virPCIDeviceReadClass(dev, &device_class) < 0)\n        goto cleanup;\n\n    pos = dev->pcie_cap_pos;\n    if (!pos || device_class != PCI_CLASS_BRIDGE_PCI)\n        goto cleanup;\n\n    flags = virPCIDeviceRead16(dev, fd, pos + PCI_EXP_FLAGS);\n    if (((flags & PCI_EXP_FLAGS_TYPE) >> 4) != PCI_EXP_TYPE_DOWNSTREAM)\n        goto cleanup;\n\n    pos = virPCIDeviceFindExtendedCapabilityOffset(dev, fd, PCI_EXT_CAP_ID_ACS);\n    if (!pos) {\n        VIR_DEBUG(\"%s %s: downstream port lacks ACS\", dev->id, dev->name);\n        ret = 1;\n        goto cleanup;\n    }\n\n    ctrl = virPCIDeviceRead16(dev, fd, pos + PCI_EXT_ACS_CTRL);\n    if ((ctrl & PCI_EXT_CAP_ACS_ENABLED) != PCI_EXT_CAP_ACS_ENABLED) {\n        VIR_DEBUG(\"%s %s: downstream port has ACS disabled\",\n                  dev->id, dev->name);\n        ret = 1;\n        goto cleanup;\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_EXT_CAP_ACS_ENABLED (PCI_EXT_CAP_ACS_SV | \\\n                                 PCI_EXT_CAP_ACS_RR | \\\n                                 PCI_EXT_CAP_ACS_CR | \\\n                                 PCI_EXT_CAP_ACS_UF)",
      "#define PCI_EXT_ACS_CTRL        0x06",
      "#define PCI_EXT_CAP_ID_ACS      0x000d",
      "#define PCI_EXP_TYPE_DOWNSTREAM 0x6",
      "#define PCI_EXP_FLAGS_TYPE      0x00f0",
      "#define PCI_EXP_FLAGS           0x2",
      "#define PCI_CLASS_BRIDGE_PCI    0x0604"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceConfigClose",
          "args": [
            "dev",
            "fd"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "320-327",
          "snippet": "static void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: downstream port has ACS disabled\"",
            "dev->id",
            "dev->name"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead16",
          "args": [
            "dev",
            "fd",
            "pos + PCI_EXT_ACS_CTRL"
          ],
          "line": 2033
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "356-362",
          "snippet": "static uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: downstream port lacks ACS\"",
            "dev->id",
            "dev->name"
          ],
          "line": 2028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFindExtendedCapabilityOffset",
          "args": [
            "dev",
            "fd",
            "PCI_EXT_CAP_ID_ACS"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFindExtendedCapabilityOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "531-555",
          "snippet": "static unsigned int\nvirPCIDeviceFindExtendedCapabilityOffset(virPCIDevicePtr dev,\n                                         int cfgfd,\n                                         unsigned int capability)\n{\n    int ttl;\n    unsigned int pos;\n    uint32_t header;\n\n    /* minimum 8 bytes per capability */\n    ttl = (PCI_EXT_CAP_LIMIT - PCI_EXT_CAP_BASE) / 8;\n    pos = PCI_EXT_CAP_BASE;\n\n    while (ttl > 0 && pos >= PCI_EXT_CAP_BASE) {\n        header = virPCIDeviceRead32(dev, cfgfd, pos);\n\n        if ((header & PCI_EXT_CAP_ID_MASK) == capability)\n            return pos;\n\n        pos = (header >> PCI_EXT_CAP_OFFSET_SHIFT) & PCI_EXT_CAP_OFFSET_MASK;\n        ttl--;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_EXT_CAP_OFFSET_MASK   0x00000ffc",
            "#define PCI_EXT_CAP_OFFSET_SHIFT  20",
            "#define PCI_EXT_CAP_ID_MASK       0x0000ffff",
            "#define PCI_EXT_CAP_LIMIT         0x1000",
            "#define PCI_EXT_CAP_BASE          0x100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_EXT_CAP_OFFSET_MASK   0x00000ffc\n#define PCI_EXT_CAP_OFFSET_SHIFT  20\n#define PCI_EXT_CAP_ID_MASK       0x0000ffff\n#define PCI_EXT_CAP_LIMIT         0x1000\n#define PCI_EXT_CAP_BASE          0x100\n\nstatic unsigned int\nvirPCIDeviceFindExtendedCapabilityOffset(virPCIDevicePtr dev,\n                                         int cfgfd,\n                                         unsigned int capability)\n{\n    int ttl;\n    unsigned int pos;\n    uint32_t header;\n\n    /* minimum 8 bytes per capability */\n    ttl = (PCI_EXT_CAP_LIMIT - PCI_EXT_CAP_BASE) / 8;\n    pos = PCI_EXT_CAP_BASE;\n\n    while (ttl > 0 && pos >= PCI_EXT_CAP_BASE) {\n        header = virPCIDeviceRead32(dev, cfgfd, pos);\n\n        if ((header & PCI_EXT_CAP_ID_MASK) == capability)\n            return pos;\n\n        pos = (header >> PCI_EXT_CAP_OFFSET_SHIFT) & PCI_EXT_CAP_OFFSET_MASK;\n        ttl--;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceReadClass",
          "args": [
            "dev",
            "&device_class"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceReadClass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "372-396",
          "snippet": "static int\nvirPCIDeviceReadClass(virPCIDevicePtr dev, uint16_t *device_class)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *id_str = NULL;\n    unsigned int value;\n\n    if (!(path = virPCIFile(dev->name, \"class\")))\n        return -1;\n\n    /* class string is '0xNNNNNN\\n' ... i.e. 9 bytes */\n    if (virFileReadAll(path, 9, &id_str) < 0)\n        return -1;\n\n    id_str[8] = '\\0';\n    if (virStrToLong_ui(id_str, NULL, 16, &value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unusual value in %s/devices/%s/class: %s\"),\n                       PCI_SYSFS, dev->name, id_str);\n        return -1;\n    }\n\n    *device_class = (value >> 8) & 0xFFFF;\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic int\nvirPCIDeviceReadClass(virPCIDevicePtr dev, uint16_t *device_class)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *id_str = NULL;\n    unsigned int value;\n\n    if (!(path = virPCIFile(dev->name, \"class\")))\n        return -1;\n\n    /* class string is '0xNNNNNN\\n' ... i.e. 9 bytes */\n    if (virFileReadAll(path, 9, &id_str) < 0)\n        return -1;\n\n    id_str[8] = '\\0';\n    if (virStrToLong_ui(id_str, NULL, 16, &value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unusual value in %s/devices/%s/class: %s\"),\n                       PCI_SYSFS, dev->name, id_str);\n        return -1;\n    }\n\n    *device_class = (value >> 8) & 0xFFFF;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceInit",
          "args": [
            "dev",
            "fd"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "893-907",
          "snippet": "static int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_CAP_ID_EXP          0x10    /* PCI Express */",
            "#define PCI_CAP_ID_PM           0x01    /* Power Management */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_CAP_ID_EXP          0x10    /* PCI Express */\n#define PCI_CAP_ID_PM           0x01    /* Power Management */\n\nstatic int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceConfigOpen",
          "args": [
            "dev"
          ],
          "line": 2007
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigOpenWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "314-318",
          "snippet": "static int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_EXT_CAP_ACS_ENABLED (PCI_EXT_CAP_ACS_SV | \\\n                                 PCI_EXT_CAP_ACS_RR | \\\n                                 PCI_EXT_CAP_ACS_CR | \\\n                                 PCI_EXT_CAP_ACS_UF)\n#define PCI_EXT_ACS_CTRL        0x06\n#define PCI_EXT_CAP_ID_ACS      0x000d\n#define PCI_EXP_TYPE_DOWNSTREAM 0x6\n#define PCI_EXP_FLAGS_TYPE      0x00f0\n#define PCI_EXP_FLAGS           0x2\n#define PCI_CLASS_BRIDGE_PCI    0x0604\n\nstatic int\nvirPCIDeviceDownstreamLacksACS(virPCIDevicePtr dev)\n{\n    uint16_t flags;\n    uint16_t ctrl;\n    unsigned int pos;\n    int fd;\n    int ret = 0;\n    uint16_t device_class;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    if (virPCIDeviceInit(dev, fd) < 0) {\n        ret = -1;\n        goto cleanup;\n    }\n\n    if (virPCIDeviceReadClass(dev, &device_class) < 0)\n        goto cleanup;\n\n    pos = dev->pcie_cap_pos;\n    if (!pos || device_class != PCI_CLASS_BRIDGE_PCI)\n        goto cleanup;\n\n    flags = virPCIDeviceRead16(dev, fd, pos + PCI_EXP_FLAGS);\n    if (((flags & PCI_EXP_FLAGS_TYPE) >> 4) != PCI_EXP_TYPE_DOWNSTREAM)\n        goto cleanup;\n\n    pos = virPCIDeviceFindExtendedCapabilityOffset(dev, fd, PCI_EXT_CAP_ID_ACS);\n    if (!pos) {\n        VIR_DEBUG(\"%s %s: downstream port lacks ACS\", dev->id, dev->name);\n        ret = 1;\n        goto cleanup;\n    }\n\n    ctrl = virPCIDeviceRead16(dev, fd, pos + PCI_EXT_ACS_CTRL);\n    if ((ctrl & PCI_EXT_CAP_ACS_ENABLED) != PCI_EXT_CAP_ACS_ENABLED) {\n        VIR_DEBUG(\"%s %s: downstream port has ACS disabled\",\n                  dev->id, dev->name);\n        ret = 1;\n        goto cleanup;\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceGetIOMMUGroupDev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1971-1995",
    "snippet": "char *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"/dev/vfio/%s\"",
            "groupFile"
          ],
          "line": 1994
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "groupPath"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to resolve device %s iommu_group symlink %s\")",
            "dev->name",
            "devPath"
          ],
          "line": 1987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileResolveLink",
          "args": [
            "devPath",
            "&groupPath"
          ],
          "line": 1986
        },
        "resolved": true,
        "details": {
          "function_name": "virFileResolveLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1608-1612",
          "snippet": "int\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid device %s iommu_group file %s is not a symlink\")",
            "dev->name",
            "devPath"
          ],
          "line": 1981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileIsLink",
          "args": [
            "devPath"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1633-1649",
          "snippet": "int\nvirFileIsLink(const char *linkpath)\n{\n    GStatBuf st;\n\n    /* Still do this on Windows so we report\n     * errors like ENOENT, etc\n     */\n    if (g_lstat(linkpath, &st) < 0)\n        return -errno;\n\n#ifndef WIN32\n    return S_ISLNK(st.st_mode) != 0;\n#else /* WIN32 */\n    return 0;\n#endif /* WIN32 */\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileIsLink(const char *linkpath)\n{\n    GStatBuf st;\n\n    /* Still do this on Windows so we report\n     * errors like ENOENT, etc\n     */\n    if (g_lstat(linkpath, &st) < 0)\n        return -errno;\n\n#ifndef WIN32\n    return S_ISLNK(st.st_mode) != 0;\n#else /* WIN32 */\n    return 0;\n#endif /* WIN32 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIFile",
          "args": [
            "dev->name",
            "\"iommu_group\""
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "219-226",
          "snippet": "static char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}"
  },
  {
    "function_name": "virPCIDeviceAddressGetIOMMUGroupDev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1953-1965",
    "snippet": "char *\nvirPCIDeviceAddressGetIOMMUGroupDev(const virPCIDeviceAddress *devAddr)\n{\n    g_autoptr(virPCIDevice) pci = NULL;\n\n    if (!(pci = virPCIDeviceNew(devAddr->domain,\n                                devAddr->bus,\n                                devAddr->slot,\n                                devAddr->function)))\n        return NULL;\n\n    return virPCIDeviceGetIOMMUGroupDev(pci);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceGetIOMMUGroupDev",
          "args": [
            "pci"
          ],
          "line": 1964
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetIOMMUGroupDev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1971-1995",
          "snippet": "char *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceGetIOMMUGroupDev(virPCIDevicePtr dev)\n{\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupFile = NULL;\n\n    if (!(devPath = virPCIFile(dev->name, \"iommu_group\")))\n        return NULL;\n    if (virFileIsLink(devPath) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s iommu_group file %s is not a symlink\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       dev->name, devPath);\n        return NULL;\n    }\n    groupFile = g_path_get_basename(groupPath);\n\n    return g_strdup_printf(\"/dev/vfio/%s\", groupFile);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "devAddr->domain",
            "devAddr->bus",
            "devAddr->slot",
            "devAddr->function"
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressGetIOMMUGroupDev(const virPCIDeviceAddress *devAddr)\n{\n    g_autoptr(virPCIDevice) pci = NULL;\n\n    if (!(pci = virPCIDeviceNew(devAddr->domain,\n                                devAddr->bus,\n                                devAddr->slot,\n                                devAddr->function)))\n        return NULL;\n\n    return virPCIDeviceGetIOMMUGroupDev(pci);\n}"
  },
  {
    "function_name": "virPCIDeviceAddressGetIOMMUGroupNum",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1917-1950",
    "snippet": "int\nvirPCIDeviceAddressGetIOMMUGroupNum(virPCIDeviceAddressPtr addr)\n{\n    g_autofree char *devName = NULL;\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupNumStr = NULL;\n    unsigned int groupNum;\n\n    devName = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, addr->domain, addr->bus,\n                              addr->slot, addr->function);\n\n    if (!(devPath = virPCIFile(devName, \"iommu_group\")))\n        return -1;\n    if (virFileIsLink(devPath) != 1)\n        return -2;\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       devName, devPath);\n        return -1;\n    }\n\n    groupNumStr = g_path_get_basename(groupPath);\n    if (virStrToLong_ui(groupNumStr, NULL, 10, &groupNum) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"device %s iommu_group symlink %s has \"\n                         \"invalid group number %s\"),\n                       devName, groupPath, groupNumStr);\n        return -1;\n    }\n\n    return groupNum;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"device %s iommu_group symlink %s has \"\n                         \"invalid group number %s\")",
            "devName",
            "groupPath",
            "groupNumStr"
          ],
          "line": 1942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"device %s iommu_group symlink %s has \"\n                         \"invalid group number %s\""
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "groupNumStr",
            "NULL",
            "10",
            "&groupNum"
          ],
          "line": 1941
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "groupPath"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to resolve device %s iommu_group symlink %s\")",
            "devName",
            "devPath"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileResolveLink",
          "args": [
            "devPath",
            "&groupPath"
          ],
          "line": 1933
        },
        "resolved": true,
        "details": {
          "function_name": "virFileResolveLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1608-1612",
          "snippet": "int\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileIsLink",
          "args": [
            "devPath"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1633-1649",
          "snippet": "int\nvirFileIsLink(const char *linkpath)\n{\n    GStatBuf st;\n\n    /* Still do this on Windows so we report\n     * errors like ENOENT, etc\n     */\n    if (g_lstat(linkpath, &st) < 0)\n        return -errno;\n\n#ifndef WIN32\n    return S_ISLNK(st.st_mode) != 0;\n#else /* WIN32 */\n    return 0;\n#endif /* WIN32 */\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileIsLink(const char *linkpath)\n{\n    GStatBuf st;\n\n    /* Still do this on Windows so we report\n     * errors like ENOENT, etc\n     */\n    if (g_lstat(linkpath, &st) < 0)\n        return -errno;\n\n#ifndef WIN32\n    return S_ISLNK(st.st_mode) != 0;\n#else /* WIN32 */\n    return 0;\n#endif /* WIN32 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIFile",
          "args": [
            "devName",
            "\"iommu_group\""
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "219-226",
          "snippet": "static char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressGetIOMMUGroupNum(virPCIDeviceAddressPtr addr)\n{\n    g_autofree char *devName = NULL;\n    g_autofree char *devPath = NULL;\n    g_autofree char *groupPath = NULL;\n    g_autofree char *groupNumStr = NULL;\n    unsigned int groupNum;\n\n    devName = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, addr->domain, addr->bus,\n                              addr->slot, addr->function);\n\n    if (!(devPath = virPCIFile(devName, \"iommu_group\")))\n        return -1;\n    if (virFileIsLink(devPath) != 1)\n        return -2;\n    if (virFileResolveLink(devPath, &groupPath) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s iommu_group symlink %s\"),\n                       devName, devPath);\n        return -1;\n    }\n\n    groupNumStr = g_path_get_basename(groupPath);\n    if (virStrToLong_ui(groupNumStr, NULL, 10, &groupNum) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"device %s iommu_group symlink %s has \"\n                         \"invalid group number %s\"),\n                       devName, groupPath, groupNumStr);\n        return -1;\n    }\n\n    return groupNum;\n}"
  },
  {
    "function_name": "virPCIDeviceAddressGetIOMMUGroupAddresses",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1896-1910",
    "snippet": "int\nvirPCIDeviceAddressGetIOMMUGroupAddresses(virPCIDeviceAddressPtr devAddr,\n                                          virPCIDeviceAddressPtr **iommuGroupDevices,\n                                          size_t *nIommuGroupDevices)\n{\n    virPCIDeviceAddressList addrList = { iommuGroupDevices,\n                                         nIommuGroupDevices };\n\n    if (virPCIDeviceAddressIOMMUGroupIterate(devAddr,\n                                             virPCIGetIOMMUGroupAddressesAddOne,\n                                             &addrList) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceAddressIOMMUGroupIterate",
          "args": [
            "devAddr",
            "virPCIGetIOMMUGroupAddressesAddOne",
            "&addrList"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressIOMMUGroupIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1770-1811",
          "snippet": "int\nvirPCIDeviceAddressIOMMUGroupIterate(virPCIDeviceAddressPtr orig,\n                                     virPCIDeviceAddressActor actor,\n                                     void *opaque)\n{\n    g_autofree char *groupPath = NULL;\n    DIR *groupDir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    groupPath = g_strdup_printf(PCI_SYSFS \"devices/\" VIR_PCI_DEVICE_ADDRESS_FMT \"/iommu_group/devices\",\n                                orig->domain, orig->bus, orig->slot, orig->function);\n\n    if (virDirOpenQuiet(&groupDir, groupPath) < 0) {\n        /* just process the original device, nothing more */\n        ret = (actor)(orig, opaque);\n        goto cleanup;\n    }\n\n    while ((direrr = virDirRead(groupDir, &ent, groupPath)) > 0) {\n        virPCIDeviceAddress newDev;\n\n        if (virPCIDeviceAddressParse(ent->d_name, &newDev) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Found invalid device link '%s' in '%s'\"),\n                           ent->d_name, groupPath);\n            goto cleanup;\n        }\n\n        if ((actor)(&newDev, opaque) < 0)\n            goto cleanup;\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(groupDir);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nint\nvirPCIDeviceAddressIOMMUGroupIterate(virPCIDeviceAddressPtr orig,\n                                     virPCIDeviceAddressActor actor,\n                                     void *opaque)\n{\n    g_autofree char *groupPath = NULL;\n    DIR *groupDir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    groupPath = g_strdup_printf(PCI_SYSFS \"devices/\" VIR_PCI_DEVICE_ADDRESS_FMT \"/iommu_group/devices\",\n                                orig->domain, orig->bus, orig->slot, orig->function);\n\n    if (virDirOpenQuiet(&groupDir, groupPath) < 0) {\n        /* just process the original device, nothing more */\n        ret = (actor)(orig, opaque);\n        goto cleanup;\n    }\n\n    while ((direrr = virDirRead(groupDir, &ent, groupPath)) > 0) {\n        virPCIDeviceAddress newDev;\n\n        if (virPCIDeviceAddressParse(ent->d_name, &newDev) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Found invalid device link '%s' in '%s'\"),\n                           ent->d_name, groupPath);\n            goto cleanup;\n        }\n\n        if ((actor)(&newDev, opaque) < 0)\n            goto cleanup;\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(groupDir);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressGetIOMMUGroupAddresses(virPCIDeviceAddressPtr devAddr,\n                                          virPCIDeviceAddressPtr **iommuGroupDevices,\n                                          size_t *nIommuGroupDevices)\n{\n    virPCIDeviceAddressList addrList = { iommuGroupDevices,\n                                         nIommuGroupDevices };\n\n    if (virPCIDeviceAddressIOMMUGroupIterate(devAddr,\n                                             virPCIGetIOMMUGroupAddressesAddOne,\n                                             &addrList) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIGetIOMMUGroupAddressesAddOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1865-1886",
    "snippet": "static int\nvirPCIGetIOMMUGroupAddressesAddOne(virPCIDeviceAddressPtr newDevAddr, void *opaque)\n{\n    int ret = -1;\n    virPCIDeviceAddressListPtr addrList = opaque;\n    virPCIDeviceAddressPtr copyAddr;\n\n    /* make a copy to insert onto the list */\n    if (VIR_ALLOC(copyAddr) < 0)\n        goto cleanup;\n\n    *copyAddr = *newDevAddr;\n\n    if (VIR_APPEND_ELEMENT(*addrList->iommuGroupDevices,\n                           *addrList->nIommuGroupDevices, copyAddr) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(copyAddr);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "copyAddr"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "*addrList->iommuGroupDevices",
            "*addrList->nIommuGroupDevices",
            "copyAddr"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "copyAddr"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIGetIOMMUGroupAddressesAddOne(virPCIDeviceAddressPtr newDevAddr, void *opaque)\n{\n    int ret = -1;\n    virPCIDeviceAddressListPtr addrList = opaque;\n    virPCIDeviceAddressPtr copyAddr;\n\n    /* make a copy to insert onto the list */\n    if (VIR_ALLOC(copyAddr) < 0)\n        goto cleanup;\n\n    *copyAddr = *newDevAddr;\n\n    if (VIR_APPEND_ELEMENT(*addrList->iommuGroupDevices,\n                           *addrList->nIommuGroupDevices, copyAddr) < 0)\n        goto cleanup;\n\n    ret = 0;\n cleanup:\n    VIR_FREE(copyAddr);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceGetIOMMUGroupList",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1838-1856",
    "snippet": "virPCIDeviceListPtr\nvirPCIDeviceGetIOMMUGroupList(virPCIDevicePtr dev)\n{\n    virPCIDeviceListPtr groupList = virPCIDeviceListNew();\n\n    if (!groupList)\n        goto error;\n\n    if (virPCIDeviceAddressIOMMUGroupIterate(&(dev->address),\n                                             virPCIDeviceGetIOMMUGroupAddOne,\n                                             groupList) < 0)\n        goto error;\n\n    return groupList;\n\n error:\n    virObjectUnref(groupList);\n    return NULL;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "groupList"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressIOMMUGroupIterate",
          "args": [
            "&(dev->address)",
            "virPCIDeviceGetIOMMUGroupAddOne",
            "groupList"
          ],
          "line": 1846
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressIOMMUGroupIterate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1770-1811",
          "snippet": "int\nvirPCIDeviceAddressIOMMUGroupIterate(virPCIDeviceAddressPtr orig,\n                                     virPCIDeviceAddressActor actor,\n                                     void *opaque)\n{\n    g_autofree char *groupPath = NULL;\n    DIR *groupDir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    groupPath = g_strdup_printf(PCI_SYSFS \"devices/\" VIR_PCI_DEVICE_ADDRESS_FMT \"/iommu_group/devices\",\n                                orig->domain, orig->bus, orig->slot, orig->function);\n\n    if (virDirOpenQuiet(&groupDir, groupPath) < 0) {\n        /* just process the original device, nothing more */\n        ret = (actor)(orig, opaque);\n        goto cleanup;\n    }\n\n    while ((direrr = virDirRead(groupDir, &ent, groupPath)) > 0) {\n        virPCIDeviceAddress newDev;\n\n        if (virPCIDeviceAddressParse(ent->d_name, &newDev) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Found invalid device link '%s' in '%s'\"),\n                           ent->d_name, groupPath);\n            goto cleanup;\n        }\n\n        if ((actor)(&newDev, opaque) < 0)\n            goto cleanup;\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(groupDir);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nint\nvirPCIDeviceAddressIOMMUGroupIterate(virPCIDeviceAddressPtr orig,\n                                     virPCIDeviceAddressActor actor,\n                                     void *opaque)\n{\n    g_autofree char *groupPath = NULL;\n    DIR *groupDir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    groupPath = g_strdup_printf(PCI_SYSFS \"devices/\" VIR_PCI_DEVICE_ADDRESS_FMT \"/iommu_group/devices\",\n                                orig->domain, orig->bus, orig->slot, orig->function);\n\n    if (virDirOpenQuiet(&groupDir, groupPath) < 0) {\n        /* just process the original device, nothing more */\n        ret = (actor)(orig, opaque);\n        goto cleanup;\n    }\n\n    while ((direrr = virDirRead(groupDir, &ent, groupPath)) > 0) {\n        virPCIDeviceAddress newDev;\n\n        if (virPCIDeviceAddressParse(ent->d_name, &newDev) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Found invalid device link '%s' in '%s'\"),\n                           ent->d_name, groupPath);\n            goto cleanup;\n        }\n\n        if ((actor)(&newDev, opaque) < 0)\n            goto cleanup;\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(groupDir);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListNew",
          "args": [],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1566-1578",
          "snippet": "virPCIDeviceListPtr\nvirPCIDeviceListNew(void)\n{\n    virPCIDeviceListPtr list;\n\n    if (virPCIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virPCIDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virPCIDeviceListClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic virClassPtr virPCIDeviceListClass;\n\nvirPCIDeviceListPtr\nvirPCIDeviceListNew(void)\n{\n    virPCIDeviceListPtr list;\n\n    if (virPCIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virPCIDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDeviceListPtr\nvirPCIDeviceGetIOMMUGroupList(virPCIDevicePtr dev)\n{\n    virPCIDeviceListPtr groupList = virPCIDeviceListNew();\n\n    if (!groupList)\n        goto error;\n\n    if (virPCIDeviceAddressIOMMUGroupIterate(&(dev->address),\n                                             virPCIDeviceGetIOMMUGroupAddOne,\n                                             groupList) < 0)\n        goto error;\n\n    return groupList;\n\n error:\n    virObjectUnref(groupList);\n    return NULL;\n}"
  },
  {
    "function_name": "virPCIDeviceGetIOMMUGroupAddOne",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1814-1829",
    "snippet": "static int\nvirPCIDeviceGetIOMMUGroupAddOne(virPCIDeviceAddressPtr newDevAddr, void *opaque)\n{\n    virPCIDeviceListPtr groupList = opaque;\n    g_autoptr(virPCIDevice) newDev = NULL;\n\n    if (!(newDev = virPCIDeviceNew(newDevAddr->domain, newDevAddr->bus,\n                                   newDevAddr->slot, newDevAddr->function)))\n        return -1;\n\n    if (virPCIDeviceListAdd(groupList, newDev) < 0)\n        return -1;\n\n    newDev = NULL; /* it's now on the list */\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceListAdd",
          "args": [
            "groupList",
            "newDev"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListAddCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1609-1621",
          "snippet": "int\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "newDevAddr->domain",
            "newDevAddr->bus",
            "newDevAddr->slot",
            "newDevAddr->function"
          ],
          "line": 1820
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceGetIOMMUGroupAddOne(virPCIDeviceAddressPtr newDevAddr, void *opaque)\n{\n    virPCIDeviceListPtr groupList = opaque;\n    g_autoptr(virPCIDevice) newDev = NULL;\n\n    if (!(newDev = virPCIDeviceNew(newDevAddr->domain, newDevAddr->bus,\n                                   newDevAddr->slot, newDevAddr->function)))\n        return -1;\n\n    if (virPCIDeviceListAdd(groupList, newDev) < 0)\n        return -1;\n\n    newDev = NULL; /* it's now on the list */\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceAddressIOMMUGroupIterate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1770-1811",
    "snippet": "int\nvirPCIDeviceAddressIOMMUGroupIterate(virPCIDeviceAddressPtr orig,\n                                     virPCIDeviceAddressActor actor,\n                                     void *opaque)\n{\n    g_autofree char *groupPath = NULL;\n    DIR *groupDir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    groupPath = g_strdup_printf(PCI_SYSFS \"devices/\" VIR_PCI_DEVICE_ADDRESS_FMT \"/iommu_group/devices\",\n                                orig->domain, orig->bus, orig->slot, orig->function);\n\n    if (virDirOpenQuiet(&groupDir, groupPath) < 0) {\n        /* just process the original device, nothing more */\n        ret = (actor)(orig, opaque);\n        goto cleanup;\n    }\n\n    while ((direrr = virDirRead(groupDir, &ent, groupPath)) > 0) {\n        virPCIDeviceAddress newDev;\n\n        if (virPCIDeviceAddressParse(ent->d_name, &newDev) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Found invalid device link '%s' in '%s'\"),\n                           ent->d_name, groupPath);\n            goto cleanup;\n        }\n\n        if ((actor)(&newDev, opaque) < 0)\n            goto cleanup;\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(groupDir);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_SYSFS \"/sys/bus/pci/\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "groupDir"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "&newDev",
            "opaque"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Found invalid device link '%s' in '%s'\")",
            "ent->d_name",
            "groupPath"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Found invalid device link '%s' in '%s'\""
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressParse",
          "args": [
            "ent->d_name",
            "&newDev"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressParse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2139-2166",
          "snippet": "int\nvirPCIDeviceAddressParse(char *address,\n                         virPCIDeviceAddressPtr bdf)\n{\n    char *p = NULL;\n\n    if ((address == NULL) || (logStrToLong_ui(address, &p, 16,\n                                              &bdf->domain) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->bus) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->slot) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->function) == -1)) {\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceAddressParse(char *address,\n                         virPCIDeviceAddressPtr bdf)\n{\n    char *p = NULL;\n\n    if ((address == NULL) || (logStrToLong_ui(address, &p, 16,\n                                              &bdf->domain) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->bus) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->slot) == -1)) {\n        return -1;\n    }\n\n    if ((p == NULL) || (logStrToLong_ui(p+1, &p, 16,\n                                        &bdf->function) == -1)) {\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "groupDir",
            "&ent",
            "groupPath"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "orig",
            "opaque"
          ],
          "line": 1786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirOpenQuiet",
          "args": [
            "&groupDir",
            "groupPath"
          ],
          "line": 1784
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nint\nvirPCIDeviceAddressIOMMUGroupIterate(virPCIDeviceAddressPtr orig,\n                                     virPCIDeviceAddressActor actor,\n                                     void *opaque)\n{\n    g_autofree char *groupPath = NULL;\n    DIR *groupDir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    groupPath = g_strdup_printf(PCI_SYSFS \"devices/\" VIR_PCI_DEVICE_ADDRESS_FMT \"/iommu_group/devices\",\n                                orig->domain, orig->bus, orig->slot, orig->function);\n\n    if (virDirOpenQuiet(&groupDir, groupPath) < 0) {\n        /* just process the original device, nothing more */\n        ret = (actor)(orig, opaque);\n        goto cleanup;\n    }\n\n    while ((direrr = virDirRead(groupDir, &ent, groupPath)) > 0) {\n        virPCIDeviceAddress newDev;\n\n        if (virPCIDeviceAddressParse(ent->d_name, &newDev) < 0) {\n            virReportError(VIR_ERR_INTERNAL_ERROR,\n                           _(\"Found invalid device link '%s' in '%s'\"),\n                           ent->d_name, groupPath);\n            goto cleanup;\n        }\n\n        if ((actor)(&newDev, opaque) < 0)\n            goto cleanup;\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(groupDir);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceFileIterate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1720-1762",
    "snippet": "int virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dir"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "dev",
            "file",
            "opaque"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s\"",
            "pcidir",
            "ent->d_name"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ent->d_name",
            "\"reset\""
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ent->d_name",
            "\"device\""
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ent->d_name",
            "\"vendor\""
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ent->d_name",
            "\"rom\""
          ],
          "line": 1745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STRPREFIX",
          "args": [
            "ent->d_name",
            "\"resource\""
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STREQ",
          "args": [
            "ent->d_name",
            "\"config\""
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dir",
            "&ent",
            "pcidir"
          ],
          "line": 1737
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&dir",
            "pcidir"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint virPCIDeviceFileIterate(virPCIDevicePtr dev,\n                            virPCIDeviceFileActor actor,\n                            void *opaque)\n{\n    g_autofree char *pcidir = NULL;\n    DIR *dir = NULL;\n    int ret = -1;\n    struct dirent *ent;\n    int direrr;\n\n    pcidir = g_strdup_printf(\"/sys/bus/pci/devices/\" VIR_PCI_DEVICE_ADDRESS_FMT,\n                             dev->address.domain, dev->address.bus, dev->address.slot,\n                             dev->address.function);\n\n    if (virDirOpen(&dir, pcidir) < 0)\n        goto cleanup;\n\n    while ((direrr = virDirRead(dir, &ent, pcidir)) > 0) {\n        g_autofree char *file = NULL;\n        /* Device assignment requires:\n         *   $PCIDIR/config, $PCIDIR/resource, $PCIDIR/resourceNNN,\n         *   $PCIDIR/rom, $PCIDIR/reset, $PCIDIR/vendor, $PCIDIR/device\n         */\n        if (STREQ(ent->d_name, \"config\") ||\n            STRPREFIX(ent->d_name, \"resource\") ||\n            STREQ(ent->d_name, \"rom\") ||\n            STREQ(ent->d_name, \"vendor\") ||\n            STREQ(ent->d_name, \"device\") ||\n            STREQ(ent->d_name, \"reset\")) {\n            file = g_strdup_printf(\"%s/%s\", pcidir, ent->d_name);\n            if ((actor)(dev, file, opaque) < 0)\n                goto cleanup;\n        }\n    }\n    if (direrr < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceListFind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1708-1717",
    "snippet": "virPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceListFindIndex",
          "args": [
            "list",
            "dev"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFindIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1670-1684",
          "snippet": "int\nvirPCIDeviceListFindIndex(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == dev->address.domain &&\n            other->address.bus      == dev->address.bus    &&\n            other->address.slot     == dev->address.slot   &&\n            other->address.function == dev->address.function)\n            return i;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListFindIndex(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == dev->address.domain &&\n            other->address.bus      == dev->address.bus    &&\n            other->address.slot     == dev->address.slot   &&\n            other->address.function == dev->address.function)\n            return i;\n    }\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}"
  },
  {
    "function_name": "virPCIDeviceListFindByIDs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1687-1705",
    "snippet": "virPCIDevicePtr\nvirPCIDeviceListFindByIDs(virPCIDeviceListPtr list,\n                          unsigned int domain,\n                          unsigned int bus,\n                          unsigned int slot,\n                          unsigned int function)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == domain &&\n            other->address.bus      == bus    &&\n            other->address.slot     == slot   &&\n            other->address.function == function)\n            return list->devs[i];\n    }\n    return NULL;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFindByIDs(virPCIDeviceListPtr list,\n                          unsigned int domain,\n                          unsigned int bus,\n                          unsigned int slot,\n                          unsigned int function)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == domain &&\n            other->address.bus      == bus    &&\n            other->address.slot     == slot   &&\n            other->address.function == function)\n            return list->devs[i];\n    }\n    return NULL;\n}"
  },
  {
    "function_name": "virPCIDeviceListFindIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1670-1684",
    "snippet": "int\nvirPCIDeviceListFindIndex(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == dev->address.domain &&\n            other->address.bus      == dev->address.bus    &&\n            other->address.slot     == dev->address.slot   &&\n            other->address.function == dev->address.function)\n            return i;\n    }\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListFindIndex(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == dev->address.domain &&\n            other->address.bus      == dev->address.bus    &&\n            other->address.slot     == dev->address.slot   &&\n            other->address.function == dev->address.function)\n            return i;\n    }\n    return -1;\n}"
  },
  {
    "function_name": "virPCIDeviceListDel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1663-1668",
    "snippet": "void\nvirPCIDeviceListDel(virPCIDeviceListPtr list,\n                    virPCIDevicePtr dev)\n{\n    virPCIDeviceFree(virPCIDeviceListSteal(list, dev));\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceFree",
          "args": [
            "virPCIDeviceListSteal(list, dev)"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1439-1450",
          "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListSteal",
          "args": [
            "list",
            "dev"
          ],
          "line": 1667
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListSteal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1656-1661",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListSteal(virPCIDeviceListPtr list,\n                      virPCIDevicePtr dev)\n{\n    return virPCIDeviceListStealIndex(list, virPCIDeviceListFindIndex(list, dev));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListSteal(virPCIDeviceListPtr list,\n                      virPCIDevicePtr dev)\n{\n    return virPCIDeviceListStealIndex(list, virPCIDeviceListFindIndex(list, dev));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceListDel(virPCIDeviceListPtr list,\n                    virPCIDevicePtr dev)\n{\n    virPCIDeviceFree(virPCIDeviceListSteal(list, dev));\n}"
  },
  {
    "function_name": "virPCIDeviceListSteal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1656-1661",
    "snippet": "virPCIDevicePtr\nvirPCIDeviceListSteal(virPCIDeviceListPtr list,\n                      virPCIDevicePtr dev)\n{\n    return virPCIDeviceListStealIndex(list, virPCIDeviceListFindIndex(list, dev));\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceListStealIndex",
          "args": [
            "list",
            "virPCIDeviceListFindIndex(list, dev)"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListStealIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1642-1654",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListStealIndex(virPCIDeviceListPtr list,\n                           int idx)\n{\n    virPCIDevicePtr ret;\n\n    if (idx < 0 || idx >= list->count)\n        return NULL;\n\n    ret = list->devs[idx];\n    VIR_DELETE_ELEMENT(list->devs, idx, list->count);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListStealIndex(virPCIDeviceListPtr list,\n                           int idx)\n{\n    virPCIDevicePtr ret;\n\n    if (idx < 0 || idx >= list->count)\n        return NULL;\n\n    ret = list->devs[idx];\n    VIR_DELETE_ELEMENT(list->devs, idx, list->count);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListFindIndex",
          "args": [
            "list",
            "dev"
          ],
          "line": 1660
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFindIndex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1670-1684",
          "snippet": "int\nvirPCIDeviceListFindIndex(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == dev->address.domain &&\n            other->address.bus      == dev->address.bus    &&\n            other->address.slot     == dev->address.slot   &&\n            other->address.function == dev->address.function)\n            return i;\n    }\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListFindIndex(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDevicePtr other = list->devs[i];\n        if (other->address.domain   == dev->address.domain &&\n            other->address.bus      == dev->address.bus    &&\n            other->address.slot     == dev->address.slot   &&\n            other->address.function == dev->address.function)\n            return i;\n    }\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListSteal(virPCIDeviceListPtr list,\n                      virPCIDevicePtr dev)\n{\n    return virPCIDeviceListStealIndex(list, virPCIDeviceListFindIndex(list, dev));\n}"
  },
  {
    "function_name": "virPCIDeviceListStealIndex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1642-1654",
    "snippet": "virPCIDevicePtr\nvirPCIDeviceListStealIndex(virPCIDeviceListPtr list,\n                           int idx)\n{\n    virPCIDevicePtr ret;\n\n    if (idx < 0 || idx >= list->count)\n        return NULL;\n\n    ret = list->devs[idx];\n    VIR_DELETE_ELEMENT(list->devs, idx, list->count);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DELETE_ELEMENT",
          "args": [
            "list->devs",
            "idx",
            "list->count"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListStealIndex(virPCIDeviceListPtr list,\n                           int idx)\n{\n    virPCIDevicePtr ret;\n\n    if (idx < 0 || idx >= list->count)\n        return NULL;\n\n    ret = list->devs[idx];\n    VIR_DELETE_ELEMENT(list->devs, idx, list->count);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceListCount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1636-1640",
    "snippet": "size_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nsize_t\nvirPCIDeviceListCount(virPCIDeviceListPtr list)\n{\n    return list->count;\n}"
  },
  {
    "function_name": "virPCIDeviceListGet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1624-1634",
    "snippet": "virPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListGet(virPCIDeviceListPtr list,\n                    int idx)\n{\n    if (idx >= list->count)\n        return NULL;\n    if (idx < 0)\n        return NULL;\n\n    return list->devs[idx];\n}"
  },
  {
    "function_name": "virPCIDeviceListAddCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1609-1621",
    "snippet": "int\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceListAdd",
          "args": [
            "list",
            "copy"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListAddCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1609-1621",
          "snippet": "int\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceCopy",
          "args": [
            "dev"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1419-1436",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceCopy(virPCIDevicePtr dev)\n{\n    virPCIDevicePtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    /* shallow copy to take care of most attributes */\n    *copy = *dev;\n    copy->path = NULL;\n    copy->used_by_drvname = copy->used_by_domname = NULL;\n    copy->name = g_strdup(dev->name);\n    copy->path = g_strdup(dev->path);\n    copy->used_by_drvname = g_strdup(dev->used_by_drvname);\n    copy->used_by_domname = g_strdup(dev->used_by_domname);\n    return copy;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceCopy(virPCIDevicePtr dev)\n{\n    virPCIDevicePtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    /* shallow copy to take care of most attributes */\n    *copy = *dev;\n    copy->path = NULL;\n    copy->used_by_drvname = copy->used_by_domname = NULL;\n    copy->name = g_strdup(dev->name);\n    copy->path = g_strdup(dev->path);\n    copy->used_by_drvname = g_strdup(dev->used_by_drvname);\n    copy->used_by_domname = g_strdup(dev->used_by_domname);\n    return copy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceListAdd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1595-1605",
    "snippet": "int\nvirPCIDeviceListAdd(virPCIDeviceListPtr list,\n                    virPCIDevicePtr dev)\n{\n    if (virPCIDeviceListFind(list, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s is already in use\"), dev->name);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, dev);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_APPEND_ELEMENT",
          "args": [
            "list->devs",
            "list->count",
            "dev"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Device %s is already in use\")",
            "dev->name"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Device %s is already in use\""
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListFind",
          "args": [
            "list",
            "dev"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1708-1717",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListAdd(virPCIDeviceListPtr list,\n                    virPCIDevicePtr dev)\n{\n    if (virPCIDeviceListFind(list, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Device %s is already in use\"), dev->name);\n        return -1;\n    }\n    return VIR_APPEND_ELEMENT(list->devs, list->count, dev);\n}"
  },
  {
    "function_name": "virPCIDeviceListDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1580-1593",
    "snippet": "static void\nvirPCIDeviceListDispose(void *obj)\n{\n    virPCIDeviceListPtr list = obj;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDeviceFree(list->devs[i]);\n        list->devs[i] = NULL;\n    }\n\n    list->count = 0;\n    VIR_FREE(list->devs);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void virPCIDeviceListDispose(void *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "list->devs"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFree",
          "args": [
            "list->devs[i]"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1439-1450",
          "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void virPCIDeviceListDispose(void *obj);\n\nstatic void\nvirPCIDeviceListDispose(void *obj)\n{\n    virPCIDeviceListPtr list = obj;\n    size_t i;\n\n    for (i = 0; i < list->count; i++) {\n        virPCIDeviceFree(list->devs[i]);\n        list->devs[i] = NULL;\n    }\n\n    list->count = 0;\n    VIR_FREE(list->devs);\n}"
  },
  {
    "function_name": "virPCIDeviceListNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1566-1578",
    "snippet": "virPCIDeviceListPtr\nvirPCIDeviceListNew(void)\n{\n    virPCIDeviceListPtr list;\n\n    if (virPCIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virPCIDeviceListClass)))\n        return NULL;\n\n    return list;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr virPCIDeviceListClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectLockableNew",
          "args": [
            "virPCIDeviceListClass"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectLockableNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "256-279",
          "snippet": "void *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectLockableNew(virClassPtr klass)\n{\n    virObjectLockablePtr obj;\n\n    if (!virClassIsDerivedFrom(klass, virClassForObjectLockable())) {\n        virReportInvalidArg(klass,\n                            _(\"Class %s must derive from virObjectLockable\"),\n                            virClassName(klass));\n        return NULL;\n    }\n\n    if (!(obj = virObjectNew(klass)))\n        return NULL;\n\n    if (virMutexInit(&obj->lock) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Unable to initialize mutex\"));\n        virObjectUnref(obj);\n        return NULL;\n    }\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIInitialize",
          "args": [],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic virClassPtr virPCIDeviceListClass;\n\nvirPCIDeviceListPtr\nvirPCIDeviceListNew(void)\n{\n    virPCIDeviceListPtr list;\n\n    if (virPCIInitialize() < 0)\n        return NULL;\n\n    if (!(list = virObjectLockableNew(virPCIDeviceListClass)))\n        return NULL;\n\n    return list;\n}"
  },
  {
    "function_name": "virPCIDeviceGetUsedBy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1557-1564",
    "snippet": "void\nvirPCIDeviceGetUsedBy(virPCIDevicePtr dev,\n                      const char **drv_name,\n                      const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceGetUsedBy(virPCIDevicePtr dev,\n                      const char **drv_name,\n                      const char **dom_name)\n{\n    *drv_name = dev->used_by_drvname;\n    *dom_name = dev->used_by_domname;\n}"
  },
  {
    "function_name": "virPCIDeviceSetUsedBy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1544-1555",
    "snippet": "int\nvirPCIDeviceSetUsedBy(virPCIDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dom_name"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dev->used_by_domname"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dev->used_by_drvname"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceSetUsedBy(virPCIDevicePtr dev,\n                      const char *drv_name,\n                      const char *dom_name)\n{\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    dev->used_by_drvname = g_strdup(drv_name);\n    dev->used_by_domname = g_strdup(dom_name);\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceSetReprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1538-1542",
    "snippet": "void\nvirPCIDeviceSetReprobe(virPCIDevicePtr dev, bool reprobe)\n{\n    dev->reprobe = reprobe;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetReprobe(virPCIDevicePtr dev, bool reprobe)\n{\n    dev->reprobe = reprobe;\n}"
  },
  {
    "function_name": "virPCIDeviceGetReprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1532-1536",
    "snippet": "bool\nvirPCIDeviceGetReprobe(virPCIDevicePtr dev)\n{\n    return dev->reprobe;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceGetReprobe(virPCIDevicePtr dev)\n{\n    return dev->reprobe;\n}"
  },
  {
    "function_name": "virPCIDeviceSetRemoveSlot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1526-1530",
    "snippet": "void\nvirPCIDeviceSetRemoveSlot(virPCIDevicePtr dev, bool remove_slot)\n{\n    dev->remove_slot = remove_slot;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetRemoveSlot(virPCIDevicePtr dev, bool remove_slot)\n{\n    dev->remove_slot = remove_slot;\n}"
  },
  {
    "function_name": "virPCIDeviceGetRemoveSlot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1520-1524",
    "snippet": "bool\nvirPCIDeviceGetRemoveSlot(virPCIDevicePtr dev)\n{\n    return dev->remove_slot;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceGetRemoveSlot(virPCIDevicePtr dev)\n{\n    return dev->remove_slot;\n}"
  },
  {
    "function_name": "virPCIDeviceSetUnbindFromStub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1514-1518",
    "snippet": "void\nvirPCIDeviceSetUnbindFromStub(virPCIDevicePtr dev, bool unbind)\n{\n    dev->unbind_from_stub = unbind;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetUnbindFromStub(virPCIDevicePtr dev, bool unbind)\n{\n    dev->unbind_from_stub = unbind;\n}"
  },
  {
    "function_name": "virPCIDeviceGetUnbindFromStub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1508-1512",
    "snippet": "bool\nvirPCIDeviceGetUnbindFromStub(virPCIDevicePtr dev)\n{\n    return dev->unbind_from_stub;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceGetUnbindFromStub(virPCIDevicePtr dev)\n{\n    return dev->unbind_from_stub;\n}"
  },
  {
    "function_name": "virPCIDeviceGetStubDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1502-1506",
    "snippet": "virPCIStubDriver\nvirPCIDeviceGetStubDriver(virPCIDevicePtr dev)\n{\n    return dev->stubDriver;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIStubDriver\nvirPCIDeviceGetStubDriver(virPCIDevicePtr dev)\n{\n    return dev->stubDriver;\n}"
  },
  {
    "function_name": "virPCIDeviceSetStubDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1496-1500",
    "snippet": "void\nvirPCIDeviceSetStubDriver(virPCIDevicePtr dev, virPCIStubDriver driver)\n{\n    dev->stubDriver = driver;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceSetStubDriver(virPCIDevicePtr dev, virPCIStubDriver driver)\n{\n    dev->stubDriver = driver;\n}"
  },
  {
    "function_name": "virPCIDeviceGetManaged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1490-1494",
    "snippet": "bool\nvirPCIDeviceGetManaged(virPCIDevicePtr dev)\n{\n    return dev->managed;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceGetManaged(virPCIDevicePtr dev)\n{\n    return dev->managed;\n}"
  },
  {
    "function_name": "virPCIDeviceSetManaged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1485-1488",
    "snippet": "void virPCIDeviceSetManaged(virPCIDevicePtr dev, bool managed)\n{\n    dev->managed = managed;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid virPCIDeviceSetManaged(virPCIDevicePtr dev, bool managed)\n{\n    dev->managed = managed;\n}"
  },
  {
    "function_name": "virPCIDeviceGetConfigPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1479-1483",
    "snippet": "const char *\nvirPCIDeviceGetConfigPath(virPCIDevicePtr dev)\n{\n    return dev->path;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nconst char *\nvirPCIDeviceGetConfigPath(virPCIDevicePtr dev)\n{\n    return dev->path;\n}"
  },
  {
    "function_name": "virPCIDeviceGetName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1467-1471",
    "snippet": "const char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nconst char *\nvirPCIDeviceGetName(virPCIDevicePtr dev)\n{\n    return dev->name;\n}"
  },
  {
    "function_name": "virPCIDeviceGetAddress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1461-1465",
    "snippet": "virPCIDeviceAddressPtr\nvirPCIDeviceGetAddress(virPCIDevicePtr dev)\n{\n    return &(dev->address);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDeviceAddressPtr\nvirPCIDeviceGetAddress(virPCIDevicePtr dev)\n{\n    return &(dev->address);\n}"
  },
  {
    "function_name": "virPCIDeviceFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1439-1450",
    "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dev"
          ],
          "line": 1449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dev->used_by_domname"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dev->used_by_drvname"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dev->path"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "dev->name"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: freeing\"",
            "dev->id",
            "dev->name"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
  },
  {
    "function_name": "virPCIDeviceCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1419-1436",
    "snippet": "virPCIDevicePtr\nvirPCIDeviceCopy(virPCIDevicePtr dev)\n{\n    virPCIDevicePtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    /* shallow copy to take care of most attributes */\n    *copy = *dev;\n    copy->path = NULL;\n    copy->used_by_drvname = copy->used_by_domname = NULL;\n    copy->name = g_strdup(dev->name);\n    copy->path = g_strdup(dev->path);\n    copy->used_by_drvname = g_strdup(dev->used_by_drvname);\n    copy->used_by_domname = g_strdup(dev->used_by_domname);\n    return copy;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "dev->used_by_domname"
          ],
          "line": 1434
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "copy"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceCopy(virPCIDevicePtr dev)\n{\n    virPCIDevicePtr copy;\n\n    if (VIR_ALLOC(copy) < 0)\n        return NULL;\n\n    /* shallow copy to take care of most attributes */\n    *copy = *dev;\n    copy->path = NULL;\n    copy->used_by_drvname = copy->used_by_domname = NULL;\n    copy->name = g_strdup(dev->name);\n    copy->path = g_strdup(dev->path);\n    copy->used_by_drvname = g_strdup(dev->used_by_drvname);\n    copy->used_by_domname = g_strdup(dev->used_by_domname);\n    return copy;\n}"
  },
  {
    "function_name": "virPCIDeviceNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1364-1416",
    "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_SYSFS \"/sys/bus/pci/\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&dev"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: initialized\"",
            "dev->id",
            "dev->name"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"dev->id buffer overflow: %s %s\")",
            "&vendor[2]",
            "&product[2]"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"dev->id buffer overflow: %s %s\""
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_snprintf",
          "args": [
            "dev->id",
            "sizeof(dev->id)",
            "\"%s %s\"",
            "&vendor[2]",
            "&product[2]"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to read product/vendor ID for %s\")",
            "dev->name"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceReadID",
          "args": [
            "dev",
            "\"device\""
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceReadID",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1255-1278",
          "snippet": "static char *\nvirPCIDeviceReadID(virPCIDevicePtr dev, const char *id_name)\n{\n    g_autofree char *path = NULL;\n    char *id_str;\n\n    if (!(path = virPCIFile(dev->name, id_name)))\n        return NULL;\n\n    /* ID string is '0xNNNN\\n' ... i.e. 7 bytes */\n    if (virFileReadAll(path, 7, &id_str) < 0)\n        return NULL;\n\n    /* Check for 0x suffix */\n    if (id_str[0] != '0' || id_str[1] != 'x') {\n        VIR_FREE(id_str);\n        return NULL;\n    }\n\n    /* Chop off the newline; we know the string is 7 bytes */\n    id_str[6] = '\\0';\n\n    return id_str;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic char *\nvirPCIDeviceReadID(virPCIDevicePtr dev, const char *id_name)\n{\n    g_autofree char *path = NULL;\n    char *id_str;\n\n    if (!(path = virPCIFile(dev->name, id_name)))\n        return NULL;\n\n    /* ID string is '0xNNNN\\n' ... i.e. 7 bytes */\n    if (virFileReadAll(path, 7, &id_str) < 0)\n        return NULL;\n\n    /* Check for 0x suffix */\n    if (id_str[0] != '0' || id_str[1] != 'x') {\n        VIR_FREE(id_str);\n        return NULL;\n    }\n\n    /* Chop off the newline; we know the string is 7 bytes */\n    id_str[6] = '\\0';\n\n    return id_str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Device %s not found: could not access %s\")",
            "dev->name",
            "dev->path"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "dev->path"
          ],
          "line": 1387
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "dev"
          ],
          "line": 1374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
  },
  {
    "function_name": "virPCIDeviceAddressAsString",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1351-1362",
    "snippet": "char *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "VIR_PCI_DEVICE_ADDRESS_FMT",
            "addr->domain",
            "addr->bus",
            "addr->slot",
            "addr->function"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nchar *\nvirPCIDeviceAddressAsString(const virPCIDeviceAddress *addr)\n{\n    char *str;\n\n    str = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT,\n                          addr->domain,\n                          addr->bus,\n                          addr->slot,\n                          addr->function);\n    return str;\n}"
  },
  {
    "function_name": "virPCIDeviceAddressCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1345-1349",
    "snippet": "void virPCIDeviceAddressCopy(virPCIDeviceAddressPtr dst,\n                             const virPCIDeviceAddress *src)\n{\n    memcpy(dst, src, sizeof(*src));\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "src",
            "sizeof(*src)"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid virPCIDeviceAddressCopy(virPCIDeviceAddressPtr dst,\n                             const virPCIDeviceAddress *src)\n{\n    memcpy(dst, src, sizeof(*src));\n}"
  },
  {
    "function_name": "virPCIDeviceAddressEqual",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1324-1335",
    "snippet": "bool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressEqual(const virPCIDeviceAddress *addr1,\n                         const virPCIDeviceAddress *addr2)\n{\n    if (addr1->domain == addr2->domain &&\n        addr1->bus == addr2->bus &&\n        addr1->slot == addr2->slot &&\n        addr1->function == addr2->function) {\n        return true;\n    }\n    return false;\n}"
  },
  {
    "function_name": "virPCIDeviceAddressIsEmpty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1318-1322",
    "snippet": "bool\nvirPCIDeviceAddressIsEmpty(const virPCIDeviceAddress *addr)\n{\n    return !(addr->domain || addr->bus || addr->slot);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressIsEmpty(const virPCIDeviceAddress *addr)\n{\n    return !(addr->domain || addr->bus || addr->slot);\n}"
  },
  {
    "function_name": "virPCIDeviceAddressIsValid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1280-1316",
    "snippet": "bool\nvirPCIDeviceAddressIsValid(virPCIDeviceAddressPtr addr,\n                           bool report)\n{\n    if (addr->bus > 0xFF) {\n        if (report)\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid PCI address bus='0x%x', \"\n                             \"must be <= 0xFF\"),\n                           addr->bus);\n        return false;\n    }\n    if (addr->slot > 0x1F) {\n        if (report)\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid PCI address slot='0x%x', \"\n                             \"must be <= 0x1F\"),\n                           addr->slot);\n        return false;\n    }\n    if (addr->function > 7) {\n        if (report)\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid PCI address function=0x%x, \"\n                             \"must be <= 7\"),\n                           addr->function);\n        return false;\n    }\n    if (virPCIDeviceAddressIsEmpty(addr)) {\n        if (report)\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid PCI address 0000:00:00, at least \"\n                             \"one of domain, bus, or slot must be > 0\"));\n        return false;\n    }\n    return true;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "\"%s\"",
            "_(\"Invalid PCI address 0000:00:00, at least \"\n                             \"one of domain, bus, or slot must be > 0\")"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid PCI address 0000:00:00, at least \"\n                             \"one of domain, bus, or slot must be > 0\""
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceAddressIsEmpty",
          "args": [
            "addr"
          ],
          "line": 1308
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceAddressIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1318-1322",
          "snippet": "bool\nvirPCIDeviceAddressIsEmpty(const virPCIDeviceAddress *addr)\n{\n    return !(addr->domain || addr->bus || addr->slot);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressIsEmpty(const virPCIDeviceAddress *addr)\n{\n    return !(addr->domain || addr->bus || addr->slot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid PCI address function=0x%x, \"\n                             \"must be <= 7\")",
            "addr->function"
          ],
          "line": 1302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid PCI address slot='0x%x', \"\n                             \"must be <= 0x1F\")",
            "addr->slot"
          ],
          "line": 1294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_XML_ERROR",
            "_(\"Invalid PCI address bus='0x%x', \"\n                             \"must be <= 0xFF\")",
            "addr->bus"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nbool\nvirPCIDeviceAddressIsValid(virPCIDeviceAddressPtr addr,\n                           bool report)\n{\n    if (addr->bus > 0xFF) {\n        if (report)\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid PCI address bus='0x%x', \"\n                             \"must be <= 0xFF\"),\n                           addr->bus);\n        return false;\n    }\n    if (addr->slot > 0x1F) {\n        if (report)\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid PCI address slot='0x%x', \"\n                             \"must be <= 0x1F\"),\n                           addr->slot);\n        return false;\n    }\n    if (addr->function > 7) {\n        if (report)\n            virReportError(VIR_ERR_XML_ERROR,\n                           _(\"Invalid PCI address function=0x%x, \"\n                             \"must be <= 7\"),\n                           addr->function);\n        return false;\n    }\n    if (virPCIDeviceAddressIsEmpty(addr)) {\n        if (report)\n            virReportError(VIR_ERR_XML_ERROR, \"%s\",\n                           _(\"Invalid PCI address 0000:00:00, at least \"\n                             \"one of domain, bus, or slot must be > 0\"));\n        return false;\n    }\n    return true;\n}"
  },
  {
    "function_name": "virPCIDeviceReadID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1255-1278",
    "snippet": "static char *\nvirPCIDeviceReadID(virPCIDevicePtr dev, const char *id_name)\n{\n    g_autofree char *path = NULL;\n    char *id_str;\n\n    if (!(path = virPCIFile(dev->name, id_name)))\n        return NULL;\n\n    /* ID string is '0xNNNN\\n' ... i.e. 7 bytes */\n    if (virFileReadAll(path, 7, &id_str) < 0)\n        return NULL;\n\n    /* Check for 0x suffix */\n    if (id_str[0] != '0' || id_str[1] != 'x') {\n        VIR_FREE(id_str);\n        return NULL;\n    }\n\n    /* Chop off the newline; we know the string is 7 bytes */\n    id_str[6] = '\\0';\n\n    return id_str;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "id_str"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "path",
            "7",
            "&id_str"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIFile",
          "args": [
            "dev->name",
            "id_name"
          ],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "219-226",
          "snippet": "static char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic char *\nvirPCIDeviceReadID(virPCIDevicePtr dev, const char *id_name)\n{\n    g_autofree char *path = NULL;\n    char *id_str;\n\n    if (!(path = virPCIFile(dev->name, id_name)))\n        return NULL;\n\n    /* ID string is '0xNNNN\\n' ... i.e. 7 bytes */\n    if (virFileReadAll(path, 7, &id_str) < 0)\n        return NULL;\n\n    /* Check for 0x suffix */\n    if (id_str[0] != '0' || id_str[1] != 'x') {\n        VIR_FREE(id_str);\n        return NULL;\n    }\n\n    /* Chop off the newline; we know the string is 7 bytes */\n    id_str[6] = '\\0';\n\n    return id_str;\n}"
  },
  {
    "function_name": "virPCIDeviceReattach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1232-1253",
    "snippet": "int\nvirPCIDeviceReattach(virPCIDevicePtr dev,\n                     virPCIDeviceListPtr activeDevs,\n                     virPCIDeviceListPtr inactiveDevs)\n{\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not reattaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceUnbindFromStub(dev) < 0)\n        return -1;\n\n    /* Steal the dev from list inactiveDevs */\n    if (inactiveDevs) {\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\", dev->name);\n        virPCIDeviceListDel(inactiveDevs, dev);\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceListDel",
          "args": [
            "inactiveDevs",
            "dev"
          ],
          "line": 1249
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListDel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1663-1668",
          "snippet": "void\nvirPCIDeviceListDel(virPCIDeviceListPtr list,\n                    virPCIDevicePtr dev)\n{\n    virPCIDeviceFree(virPCIDeviceListSteal(list, dev));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceListDel(virPCIDeviceListPtr list,\n                    virPCIDevicePtr dev)\n{\n    virPCIDeviceFree(virPCIDeviceListSteal(list, dev));\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Removing PCI device %s from inactive list\"",
            "dev->name"
          ],
          "line": 1248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceUnbindFromStub",
          "args": [
            "dev"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceUnbindFromStub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1130-1139",
          "snippet": "static int\nvirPCIDeviceUnbindFromStub(virPCIDevicePtr dev)\n{\n    if (!dev->unbind_from_stub) {\n        VIR_DEBUG(\"Unbind from stub skipped for PCI device %s\", dev->name);\n        return 0;\n    }\n\n    return virPCIDeviceBindWithDriverOverride(dev, \"\\n\");\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceUnbindFromStub(virPCIDevicePtr dev)\n{\n    if (!dev->unbind_from_stub) {\n        VIR_DEBUG(\"Unbind from stub skipped for PCI device %s\", dev->name);\n        return 0;\n    }\n\n    return virPCIDeviceBindWithDriverOverride(dev, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Not reattaching active device %s\")",
            "dev->name"
          ],
          "line": 1238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Not reattaching active device %s\""
          ],
          "line": 1239
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListFind",
          "args": [
            "activeDevs",
            "dev"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1708-1717",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceReattach(virPCIDevicePtr dev,\n                     virPCIDeviceListPtr activeDevs,\n                     virPCIDeviceListPtr inactiveDevs)\n{\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not reattaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceUnbindFromStub(dev) < 0)\n        return -1;\n\n    /* Steal the dev from list inactiveDevs */\n    if (inactiveDevs) {\n        VIR_DEBUG(\"Removing PCI device %s from inactive list\", dev->name);\n        virPCIDeviceListDel(inactiveDevs, dev);\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceDetach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1199-1226",
    "snippet": "int\nvirPCIDeviceDetach(virPCIDevicePtr dev,\n                   virPCIDeviceList *activeDevs,\n                   virPCIDeviceList *inactiveDevs)\n{\n    if (virPCIProbeStubDriver(dev->stubDriver) < 0)\n        return -1;\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not detaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceBindToStub(dev) < 0)\n        return -1;\n\n    /* Add *a copy of* the dev into list inactiveDevs, if\n     * it's not already there.\n     */\n    if (inactiveDevs && !virPCIDeviceListFind(inactiveDevs, dev)) {\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\", dev->name);\n        if (virPCIDeviceListAddCopy(inactiveDevs, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceListAddCopy",
          "args": [
            "inactiveDevs",
            "dev"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListAddCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1609-1621",
          "snippet": "int\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceListAddCopy(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    g_autoptr(virPCIDevice) copy = virPCIDeviceCopy(dev);\n\n    if (!copy)\n        return -1;\n    if (virPCIDeviceListAdd(list, copy) < 0)\n        return -1;\n\n    copy = NULL;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Adding PCI device %s to inactive list\"",
            "dev->name"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListFind",
          "args": [
            "inactiveDevs",
            "dev"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1708-1717",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceBindToStub",
          "args": [
            "dev"
          ],
          "line": 1213
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceBindToStub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1141-1179",
          "snippet": "static int\nvirPCIDeviceBindToStub(virPCIDevicePtr dev)\n{\n    const char *stubDriverName;\n    g_autofree char *stubDriverPath = NULL;\n    g_autofree char *driverLink = NULL;\n\n    /* Check the device is configured to use one of the known stub drivers */\n    if (dev->stubDriver == VIR_PCI_STUB_DRIVER_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No stub driver configured for PCI device %s\"),\n                       dev->name);\n        return -1;\n    } else if (!(stubDriverName = virPCIStubDriverTypeToString(dev->stubDriver))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown stub driver configured for PCI device %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    if (!(stubDriverPath = virPCIDriverDir(stubDriverName))  ||\n        !(driverLink = virPCIFile(dev->name, \"driver\")))\n        return -1;\n\n    if (virFileExists(driverLink)) {\n        if (virFileLinkPointsTo(driverLink, stubDriverPath)) {\n            /* The device is already bound to the correct driver */\n            VIR_DEBUG(\"Device %s is already bound to %s\",\n                      dev->name, stubDriverName);\n            return 0;\n        }\n    }\n\n    if (virPCIDeviceBindWithDriverOverride(dev, stubDriverName) < 0)\n        return -1;\n\n    dev->unbind_from_stub = true;\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceBindToStub(virPCIDevicePtr dev)\n{\n    const char *stubDriverName;\n    g_autofree char *stubDriverPath = NULL;\n    g_autofree char *driverLink = NULL;\n\n    /* Check the device is configured to use one of the known stub drivers */\n    if (dev->stubDriver == VIR_PCI_STUB_DRIVER_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No stub driver configured for PCI device %s\"),\n                       dev->name);\n        return -1;\n    } else if (!(stubDriverName = virPCIStubDriverTypeToString(dev->stubDriver))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown stub driver configured for PCI device %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    if (!(stubDriverPath = virPCIDriverDir(stubDriverName))  ||\n        !(driverLink = virPCIFile(dev->name, \"driver\")))\n        return -1;\n\n    if (virFileExists(driverLink)) {\n        if (virFileLinkPointsTo(driverLink, stubDriverPath)) {\n            /* The device is already bound to the correct driver */\n            VIR_DEBUG(\"Device %s is already bound to %s\",\n                      dev->name, stubDriverName);\n            return 0;\n        }\n    }\n\n    if (virPCIDeviceBindWithDriverOverride(dev, stubDriverName) < 0)\n        return -1;\n\n    dev->unbind_from_stub = true;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Not detaching active device %s\")",
            "dev->name"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Not detaching active device %s\""
          ],
          "line": 1209
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIProbeStubDriver",
          "args": [
            "dev->stubDriver"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIProbeStubDriver",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "993-1040",
          "snippet": "static int\nvirPCIProbeStubDriver(virPCIStubDriver driver)\n{\n    const char *drvname = NULL;\n    g_autofree char *drvpath = NULL;\n    bool probed = false;\n\n    if (driver == VIR_PCI_STUB_DRIVER_NONE ||\n        !(drvname = virPCIStubDriverTypeToString(driver))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"Attempting to use unknown stub driver\"));\n        return -1;\n    }\n\n recheck:\n    if ((drvpath = virPCIDriverDir(drvname)) && virFileExists(drvpath))\n        /* driver already loaded, return */\n        return 0;\n\n    if (!probed) {\n        g_autofree char *errbuf = NULL;\n        probed = true;\n        if ((errbuf = virKModLoad(drvname, true))) {\n            VIR_WARN(\"failed to load driver %s: %s\", drvname, errbuf);\n            goto cleanup;\n        }\n\n        goto recheck;\n    }\n\n cleanup:\n    /* If we know failure was because of blacklist, let's report that;\n     * otherwise, report a more generic failure message\n     */\n    if (virKModIsBlacklisted(drvname)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to load PCI stub module %s: \"\n                         \"administratively prohibited\"),\n                       drvname);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to load PCI stub module %s\"),\n                       drvname);\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIProbeStubDriver(virPCIStubDriver driver)\n{\n    const char *drvname = NULL;\n    g_autofree char *drvpath = NULL;\n    bool probed = false;\n\n    if (driver == VIR_PCI_STUB_DRIVER_NONE ||\n        !(drvname = virPCIStubDriverTypeToString(driver))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"Attempting to use unknown stub driver\"));\n        return -1;\n    }\n\n recheck:\n    if ((drvpath = virPCIDriverDir(drvname)) && virFileExists(drvpath))\n        /* driver already loaded, return */\n        return 0;\n\n    if (!probed) {\n        g_autofree char *errbuf = NULL;\n        probed = true;\n        if ((errbuf = virKModLoad(drvname, true))) {\n            VIR_WARN(\"failed to load driver %s: %s\", drvname, errbuf);\n            goto cleanup;\n        }\n\n        goto recheck;\n    }\n\n cleanup:\n    /* If we know failure was because of blacklist, let's report that;\n     * otherwise, report a more generic failure message\n     */\n    if (virKModIsBlacklisted(drvname)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to load PCI stub module %s: \"\n                         \"administratively prohibited\"),\n                       drvname);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to load PCI stub module %s\"),\n                       drvname);\n    }\n\n    return -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceDetach(virPCIDevicePtr dev,\n                   virPCIDeviceList *activeDevs,\n                   virPCIDeviceList *inactiveDevs)\n{\n    if (virPCIProbeStubDriver(dev->stubDriver) < 0)\n        return -1;\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not detaching active device %s\"), dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceBindToStub(dev) < 0)\n        return -1;\n\n    /* Add *a copy of* the dev into list inactiveDevs, if\n     * it's not already there.\n     */\n    if (inactiveDevs && !virPCIDeviceListFind(inactiveDevs, dev)) {\n        VIR_DEBUG(\"Adding PCI device %s to inactive list\", dev->name);\n        if (virPCIDeviceListAddCopy(inactiveDevs, dev) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceBindToStub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1141-1179",
    "snippet": "static int\nvirPCIDeviceBindToStub(virPCIDevicePtr dev)\n{\n    const char *stubDriverName;\n    g_autofree char *stubDriverPath = NULL;\n    g_autofree char *driverLink = NULL;\n\n    /* Check the device is configured to use one of the known stub drivers */\n    if (dev->stubDriver == VIR_PCI_STUB_DRIVER_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No stub driver configured for PCI device %s\"),\n                       dev->name);\n        return -1;\n    } else if (!(stubDriverName = virPCIStubDriverTypeToString(dev->stubDriver))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown stub driver configured for PCI device %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    if (!(stubDriverPath = virPCIDriverDir(stubDriverName))  ||\n        !(driverLink = virPCIFile(dev->name, \"driver\")))\n        return -1;\n\n    if (virFileExists(driverLink)) {\n        if (virFileLinkPointsTo(driverLink, stubDriverPath)) {\n            /* The device is already bound to the correct driver */\n            VIR_DEBUG(\"Device %s is already bound to %s\",\n                      dev->name, stubDriverName);\n            return 0;\n        }\n    }\n\n    if (virPCIDeviceBindWithDriverOverride(dev, stubDriverName) < 0)\n        return -1;\n\n    dev->unbind_from_stub = true;\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceBindWithDriverOverride",
          "args": [
            "dev",
            "stubDriverName"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceBindWithDriverOverride",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1107-1128",
          "snippet": "static int\nvirPCIDeviceBindWithDriverOverride(virPCIDevicePtr dev,\n                                   const char *driverName)\n{\n    g_autofree char *path = NULL;\n\n    if (!(path = virPCIFile(dev->name, \"driver_override\")))\n        return -1;\n\n    if (virFileWriteStr(path, driverName, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to add driver '%s' to driver_override \"\n                               \" interface of PCI device '%s'\"),\n                             driverName, dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceRebind(dev) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceBindWithDriverOverride(virPCIDevicePtr dev,\n                                   const char *driverName)\n{\n    g_autofree char *path = NULL;\n\n    if (!(path = virPCIFile(dev->name, \"driver_override\")))\n        return -1;\n\n    if (virFileWriteStr(path, driverName, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to add driver '%s' to driver_override \"\n                               \" interface of PCI device '%s'\"),\n                             driverName, dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceRebind(dev) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Device %s is already bound to %s\"",
            "dev->name",
            "stubDriverName"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileLinkPointsTo",
          "args": [
            "driverLink",
            "stubDriverPath"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "virFileLinkPointsTo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1533-1543",
          "snippet": "int\nvirFileLinkPointsTo(const char *checkLink,\n                    const char *checkDest)\n{\n    struct stat src_sb;\n    struct stat dest_sb;\n\n    return (stat(checkLink, &src_sb) == 0\n            && stat(checkDest, &dest_sb) == 0\n            && SAME_INODE(src_sb, dest_sb));\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileLinkPointsTo(const char *checkLink,\n                    const char *checkDest)\n{\n    struct stat src_sb;\n    struct stat dest_sb;\n\n    return (stat(checkLink, &src_sb) == 0\n            && stat(checkDest, &dest_sb) == 0\n            && SAME_INODE(src_sb, dest_sb));\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "driverLink"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIFile",
          "args": [
            "dev->name",
            "\"driver\""
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "219-226",
          "snippet": "static char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDriverDir",
          "args": [
            "stubDriverName"
          ],
          "line": 1161
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDriverDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "209-216",
          "snippet": "static char *\nvirPCIDriverDir(const char *driver)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"drivers/%s\", driver);\n    return buffer;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIDriverDir(const char *driver)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"drivers/%s\", driver);\n    return buffer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unknown stub driver configured for PCI device %s\")",
            "dev->name"
          ],
          "line": 1155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unknown stub driver configured for PCI device %s\""
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIStubDriverTypeToString",
          "args": [
            "dev->stubDriver"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"No stub driver configured for PCI device %s\")",
            "dev->name"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceBindToStub(virPCIDevicePtr dev)\n{\n    const char *stubDriverName;\n    g_autofree char *stubDriverPath = NULL;\n    g_autofree char *driverLink = NULL;\n\n    /* Check the device is configured to use one of the known stub drivers */\n    if (dev->stubDriver == VIR_PCI_STUB_DRIVER_NONE) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"No stub driver configured for PCI device %s\"),\n                       dev->name);\n        return -1;\n    } else if (!(stubDriverName = virPCIStubDriverTypeToString(dev->stubDriver))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown stub driver configured for PCI device %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    if (!(stubDriverPath = virPCIDriverDir(stubDriverName))  ||\n        !(driverLink = virPCIFile(dev->name, \"driver\")))\n        return -1;\n\n    if (virFileExists(driverLink)) {\n        if (virFileLinkPointsTo(driverLink, stubDriverPath)) {\n            /* The device is already bound to the correct driver */\n            VIR_DEBUG(\"Device %s is already bound to %s\",\n                      dev->name, stubDriverName);\n            return 0;\n        }\n    }\n\n    if (virPCIDeviceBindWithDriverOverride(dev, stubDriverName) < 0)\n        return -1;\n\n    dev->unbind_from_stub = true;\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceUnbindFromStub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1130-1139",
    "snippet": "static int\nvirPCIDeviceUnbindFromStub(virPCIDevicePtr dev)\n{\n    if (!dev->unbind_from_stub) {\n        VIR_DEBUG(\"Unbind from stub skipped for PCI device %s\", dev->name);\n        return 0;\n    }\n\n    return virPCIDeviceBindWithDriverOverride(dev, \"\\n\");\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceBindWithDriverOverride",
          "args": [
            "dev",
            "\"\\n\""
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceBindWithDriverOverride",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1107-1128",
          "snippet": "static int\nvirPCIDeviceBindWithDriverOverride(virPCIDevicePtr dev,\n                                   const char *driverName)\n{\n    g_autofree char *path = NULL;\n\n    if (!(path = virPCIFile(dev->name, \"driver_override\")))\n        return -1;\n\n    if (virFileWriteStr(path, driverName, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to add driver '%s' to driver_override \"\n                               \" interface of PCI device '%s'\"),\n                             driverName, dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceRebind(dev) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceBindWithDriverOverride(virPCIDevicePtr dev,\n                                   const char *driverName)\n{\n    g_autofree char *path = NULL;\n\n    if (!(path = virPCIFile(dev->name, \"driver_override\")))\n        return -1;\n\n    if (virFileWriteStr(path, driverName, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to add driver '%s' to driver_override \"\n                               \" interface of PCI device '%s'\"),\n                             driverName, dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceRebind(dev) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Unbind from stub skipped for PCI device %s\"",
            "dev->name"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceUnbindFromStub(virPCIDevicePtr dev)\n{\n    if (!dev->unbind_from_stub) {\n        VIR_DEBUG(\"Unbind from stub skipped for PCI device %s\", dev->name);\n        return 0;\n    }\n\n    return virPCIDeviceBindWithDriverOverride(dev, \"\\n\");\n}"
  },
  {
    "function_name": "virPCIDeviceBindWithDriverOverride",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1107-1128",
    "snippet": "static int\nvirPCIDeviceBindWithDriverOverride(virPCIDevicePtr dev,\n                                   const char *driverName)\n{\n    g_autofree char *path = NULL;\n\n    if (!(path = virPCIFile(dev->name, \"driver_override\")))\n        return -1;\n\n    if (virFileWriteStr(path, driverName, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to add driver '%s' to driver_override \"\n                               \" interface of PCI device '%s'\"),\n                             driverName, dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceRebind(dev) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceRebind",
          "args": [
            "dev"
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRebind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1080-1093",
          "snippet": "int virPCIDeviceRebind(virPCIDevicePtr dev)\n{\n    if (virPCIDeviceUnbind(dev) < 0)\n        return -1;\n\n    if (virFileWriteStr(PCI_SYSFS \"drivers_probe\", dev->name, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to trigger a probe for PCI device '%s'\"),\n                             dev->name);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nint virPCIDeviceRebind(virPCIDevicePtr dev)\n{\n    if (virPCIDeviceUnbind(dev) < 0)\n        return -1;\n\n    if (virFileWriteStr(PCI_SYSFS \"drivers_probe\", dev->name, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to trigger a probe for PCI device '%s'\"),\n                             dev->name);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to add driver '%s' to driver_override \"\n                               \" interface of PCI device '%s'\")",
            "driverName",
            "dev->name"
          ],
          "line": 1117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to add driver '%s' to driver_override \"\n                               \" interface of PCI device '%s'\""
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "path",
            "driverName",
            "0"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIFile",
          "args": [
            "dev->name",
            "\"driver_override\""
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "219-226",
          "snippet": "static char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceBindWithDriverOverride(virPCIDevicePtr dev,\n                                   const char *driverName)\n{\n    g_autofree char *path = NULL;\n\n    if (!(path = virPCIFile(dev->name, \"driver_override\")))\n        return -1;\n\n    if (virFileWriteStr(path, driverName, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to add driver '%s' to driver_override \"\n                               \" interface of PCI device '%s'\"),\n                             driverName, dev->name);\n        return -1;\n    }\n\n    if (virPCIDeviceRebind(dev) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceRebind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1080-1093",
    "snippet": "int virPCIDeviceRebind(virPCIDevicePtr dev)\n{\n    if (virPCIDeviceUnbind(dev) < 0)\n        return -1;\n\n    if (virFileWriteStr(PCI_SYSFS \"drivers_probe\", dev->name, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to trigger a probe for PCI device '%s'\"),\n                             dev->name);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_SYSFS \"/sys/bus/pci/\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to trigger a probe for PCI device '%s'\")",
            "dev->name"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to trigger a probe for PCI device '%s'\""
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "PCI_SYSFS \"drivers_probe\"",
            "dev->name",
            "0"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceUnbind",
          "args": [
            "dev"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceUnbindFromStub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1130-1139",
          "snippet": "static int\nvirPCIDeviceUnbindFromStub(virPCIDevicePtr dev)\n{\n    if (!dev->unbind_from_stub) {\n        VIR_DEBUG(\"Unbind from stub skipped for PCI device %s\", dev->name);\n        return 0;\n    }\n\n    return virPCIDeviceBindWithDriverOverride(dev, \"\\n\");\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceUnbindFromStub(virPCIDevicePtr dev)\n{\n    if (!dev->unbind_from_stub) {\n        VIR_DEBUG(\"Unbind from stub skipped for PCI device %s\", dev->name);\n        return 0;\n    }\n\n    return virPCIDeviceBindWithDriverOverride(dev, \"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nint virPCIDeviceRebind(virPCIDevicePtr dev)\n{\n    if (virPCIDeviceUnbind(dev) < 0)\n        return -1;\n\n    if (virFileWriteStr(PCI_SYSFS \"drivers_probe\", dev->name, 0) < 0) {\n        virReportSystemError(errno,\n                             _(\"Failed to trigger a probe for PCI device '%s'\"),\n                             dev->name);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceUnbind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "1042-1069",
    "snippet": "int\nvirPCIDeviceUnbind(virPCIDevicePtr dev)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *drvpath = NULL;\n    g_autofree char *driver = NULL;\n\n    if (virPCIDeviceGetDriverPathAndName(dev, &drvpath, &driver) < 0)\n        return -1;\n\n    if (!driver)\n        /* The device is not bound to any driver */\n        return 0;\n\n    if (!(path = virPCIFile(dev->name, \"driver/unbind\")))\n        return -1;\n\n    if (virFileExists(path)) {\n        if (virFileWriteStr(path, dev->name, 0) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to unbind PCI device '%s' from %s\"),\n                                 dev->name, driver);\n            return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to unbind PCI device '%s' from %s\")",
            "dev->name",
            "driver"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to unbind PCI device '%s' from %s\""
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileWriteStr",
          "args": [
            "path",
            "dev->name",
            "0"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "virFileWriteStr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1502-1524",
          "snippet": "int\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileWriteStr(const char *path, const char *str, mode_t mode)\n{\n    int fd;\n\n    if (mode)\n        fd = open(path, O_WRONLY|O_TRUNC|O_CREAT, mode);\n    else\n        fd = open(path, O_WRONLY|O_TRUNC);\n    if (fd == -1)\n        return -1;\n\n    if (safewrite(fd, str, strlen(str)) < 0) {\n        VIR_FORCE_CLOSE(fd);\n        return -1;\n    }\n\n    /* Use errno from failed close only if there was no write error.  */\n    if (VIR_CLOSE(fd) != 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "path"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIFile",
          "args": [
            "dev->name",
            "\"driver/unbind\""
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "219-226",
          "snippet": "static char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetDriverPathAndName",
          "args": [
            "dev",
            "&drvpath",
            "&driver"
          ],
          "line": 1049
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetDriverPathAndName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "236-276",
          "snippet": "int\nvirPCIDeviceGetDriverPathAndName(virPCIDevicePtr dev, char **path, char **name)\n{\n    int ret = -1;\n    g_autofree char *drvlink = NULL;\n\n    *path = *name = NULL;\n    /* drvlink = \"/sys/bus/pci/dddd:bb:ss.ff/driver\" */\n    if (!(drvlink = virPCIFile(dev->name, \"driver\")))\n        goto cleanup;\n\n    if (!virFileExists(drvlink)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileIsLink(drvlink) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s driver file %s is not a symlink\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    if (virFileResolveLink(drvlink, path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s driver symlink %s\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    /* path = \"/sys/bus/pci/drivers/${drivername}\" */\n\n    *name = g_path_get_basename(*path);\n    /* name = \"${drivername}\" */\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(*path);\n        VIR_FREE(*name);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceGetDriverPathAndName(virPCIDevicePtr dev, char **path, char **name)\n{\n    int ret = -1;\n    g_autofree char *drvlink = NULL;\n\n    *path = *name = NULL;\n    /* drvlink = \"/sys/bus/pci/dddd:bb:ss.ff/driver\" */\n    if (!(drvlink = virPCIFile(dev->name, \"driver\")))\n        goto cleanup;\n\n    if (!virFileExists(drvlink)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileIsLink(drvlink) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s driver file %s is not a symlink\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    if (virFileResolveLink(drvlink, path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s driver symlink %s\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    /* path = \"/sys/bus/pci/drivers/${drivername}\" */\n\n    *name = g_path_get_basename(*path);\n    /* name = \"${drivername}\" */\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(*path);\n        VIR_FREE(*name);\n    }\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceUnbind(virPCIDevicePtr dev)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *drvpath = NULL;\n    g_autofree char *driver = NULL;\n\n    if (virPCIDeviceGetDriverPathAndName(dev, &drvpath, &driver) < 0)\n        return -1;\n\n    if (!driver)\n        /* The device is not bound to any driver */\n        return 0;\n\n    if (!(path = virPCIFile(dev->name, \"driver/unbind\")))\n        return -1;\n\n    if (virFileExists(path)) {\n        if (virFileWriteStr(path, dev->name, 0) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Failed to unbind PCI device '%s' from %s\"),\n                                 dev->name, driver);\n            return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIProbeStubDriver",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "993-1040",
    "snippet": "static int\nvirPCIProbeStubDriver(virPCIStubDriver driver)\n{\n    const char *drvname = NULL;\n    g_autofree char *drvpath = NULL;\n    bool probed = false;\n\n    if (driver == VIR_PCI_STUB_DRIVER_NONE ||\n        !(drvname = virPCIStubDriverTypeToString(driver))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"Attempting to use unknown stub driver\"));\n        return -1;\n    }\n\n recheck:\n    if ((drvpath = virPCIDriverDir(drvname)) && virFileExists(drvpath))\n        /* driver already loaded, return */\n        return 0;\n\n    if (!probed) {\n        g_autofree char *errbuf = NULL;\n        probed = true;\n        if ((errbuf = virKModLoad(drvname, true))) {\n            VIR_WARN(\"failed to load driver %s: %s\", drvname, errbuf);\n            goto cleanup;\n        }\n\n        goto recheck;\n    }\n\n cleanup:\n    /* If we know failure was because of blacklist, let's report that;\n     * otherwise, report a more generic failure message\n     */\n    if (virKModIsBlacklisted(drvname)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to load PCI stub module %s: \"\n                         \"administratively prohibited\"),\n                       drvname);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to load PCI stub module %s\"),\n                       drvname);\n    }\n\n    return -1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to load PCI stub module %s\")",
            "drvname"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to load PCI stub module %s\""
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to load PCI stub module %s: \"\n                         \"administratively prohibited\")",
            "drvname"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virKModIsBlacklisted",
          "args": [
            "drvname"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "virKModIsBlacklisted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virkmod.c",
          "lines": "145-166",
          "snippet": "bool\nvirKModIsBlacklisted(const char *module)\n{\n    size_t i;\n    g_autofree char *drvblklst = NULL;\n    g_autofree char *outbuf = NULL;\n\n    drvblklst = g_strdup_printf(\"blacklist %s\\n\", module);\n\n    /* modprobe will convert all '-' into '_', so we need to as well */\n    for (i = 0; i < drvblklst[i]; i++)\n        if (drvblklst[i] == '-')\n            drvblklst[i] = '_';\n\n    if (doModprobe(\"-c\", NULL, &outbuf, NULL) < 0)\n        return false;\n\n    if (strstr(outbuf, drvblklst))\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"virkmod.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"virkmod.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nbool\nvirKModIsBlacklisted(const char *module)\n{\n    size_t i;\n    g_autofree char *drvblklst = NULL;\n    g_autofree char *outbuf = NULL;\n\n    drvblklst = g_strdup_printf(\"blacklist %s\\n\", module);\n\n    /* modprobe will convert all '-' into '_', so we need to as well */\n    for (i = 0; i < drvblklst[i]; i++)\n        if (drvblklst[i] == '-')\n            drvblklst[i] = '_';\n\n    if (doModprobe(\"-c\", NULL, &outbuf, NULL) < 0)\n        return false;\n\n    if (strstr(outbuf, drvblklst))\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"failed to load driver %s: %s\"",
            "drvname",
            "errbuf"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virKModLoad",
          "args": [
            "drvname",
            "true"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "virKModLoad",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virkmod.c",
          "lines": "94-104",
          "snippet": "char *\nvirKModLoad(const char *module, bool useBlacklist)\n{\n    char *errbuf = NULL;\n\n    if (doModprobe(useBlacklist ? \"-b\" : NULL, module, NULL, &errbuf) < 0)\n        return errbuf;\n\n    VIR_FREE(errbuf);\n    return NULL;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"vircommand.h\"",
            "#include \"virkmod.h\"",
            "#include \"viralloc.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"vircommand.h\"\n#include \"virkmod.h\"\n#include \"viralloc.h\"\n#include <config.h>\n\nchar *\nvirKModLoad(const char *module, bool useBlacklist)\n{\n    char *errbuf = NULL;\n\n    if (doModprobe(useBlacklist ? \"-b\" : NULL, module, NULL, &errbuf) < 0)\n        return errbuf;\n\n    VIR_FREE(errbuf);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "drvpath"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDriverDir",
          "args": [
            "drvname"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDriverDir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "209-216",
          "snippet": "static char *\nvirPCIDriverDir(const char *driver)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"drivers/%s\", driver);\n    return buffer;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIDriverDir(const char *driver)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"drivers/%s\", driver);\n    return buffer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"Attempting to use unknown stub driver\")"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIStubDriverTypeToString",
          "args": [
            "driver"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIProbeStubDriver(virPCIStubDriver driver)\n{\n    const char *drvname = NULL;\n    g_autofree char *drvpath = NULL;\n    bool probed = false;\n\n    if (driver == VIR_PCI_STUB_DRIVER_NONE ||\n        !(drvname = virPCIStubDriverTypeToString(driver))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       \"%s\",\n                       _(\"Attempting to use unknown stub driver\"));\n        return -1;\n    }\n\n recheck:\n    if ((drvpath = virPCIDriverDir(drvname)) && virFileExists(drvpath))\n        /* driver already loaded, return */\n        return 0;\n\n    if (!probed) {\n        g_autofree char *errbuf = NULL;\n        probed = true;\n        if ((errbuf = virKModLoad(drvname, true))) {\n            VIR_WARN(\"failed to load driver %s: %s\", drvname, errbuf);\n            goto cleanup;\n        }\n\n        goto recheck;\n    }\n\n cleanup:\n    /* If we know failure was because of blacklist, let's report that;\n     * otherwise, report a more generic failure message\n     */\n    if (virKModIsBlacklisted(drvname)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to load PCI stub module %s: \"\n                         \"administratively prohibited\"),\n                       drvname);\n    } else {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to load PCI stub module %s\"),\n                       drvname);\n    }\n\n    return -1;\n}"
  },
  {
    "function_name": "virPCIDeviceReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "909-990",
    "snippet": "int\nvirPCIDeviceReset(virPCIDevicePtr dev,\n                  virPCIDeviceList *activeDevs,\n                  virPCIDeviceList *inactiveDevs)\n{\n    g_autofree char *drvPath = NULL;\n    g_autofree char *drvName = NULL;\n    int ret = -1;\n    int fd = -1;\n    int hdrType = -1;\n\n    if (virPCIGetHeaderType(dev, &hdrType) < 0)\n        return -1;\n\n    if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid attempt to reset PCI device %s. \"\n                         \"Only PCI endpoint devices can be reset\"),\n                       dev->name);\n        return -1;\n    }\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not resetting active device %s\"), dev->name);\n        return -1;\n    }\n\n    /* If the device is currently bound to vfio-pci, ignore all\n     * requests to reset it, since the vfio-pci driver will always\n     * reset it whenever appropriate, so doing it ourselves would just\n     * be redundant.\n     */\n    if (virPCIDeviceGetDriverPathAndName(dev, &drvPath, &drvName) < 0)\n        goto cleanup;\n\n    if (virPCIStubDriverTypeFromString(drvName) == VIR_PCI_STUB_DRIVER_VFIO) {\n        VIR_DEBUG(\"Device %s is bound to vfio-pci - skip reset\",\n                  dev->name);\n        ret = 0;\n        goto cleanup;\n    }\n    VIR_DEBUG(\"Resetting device %s\", dev->name);\n\n    if ((fd = virPCIDeviceConfigOpenWrite(dev)) < 0)\n        goto cleanup;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    /* KVM will perform FLR when starting and stopping\n     * a guest, so there is no need for us to do it here.\n     */\n    if (dev->has_flr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* If the device supports PCI power management reset,\n     * that's the next best thing because it only resets\n     * the function, not the whole device.\n     */\n    if (dev->has_pm_reset)\n        ret = virPCIDeviceTryPowerManagementReset(dev, fd);\n\n    /* Bus reset is not an option with the root bus */\n    if (ret < 0 && dev->address.bus != 0)\n        ret = virPCIDeviceTrySecondaryBusReset(dev, fd, inactiveDevs);\n\n    if (ret < 0) {\n        virErrorPtr err = virGetLastError();\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to reset PCI device %s: %s\"),\n                       dev->name,\n                       err ? err->message :\n                       _(\"no FLR, PM reset or bus reset available\"));\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceConfigClose",
          "args": [
            "dev",
            "fd"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "320-327",
          "snippet": "static void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to reset PCI device %s: %s\")",
            "dev->name",
            "err ? err->message :\n                       _(\"no FLR, PM reset or bus reset available\")"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no FLR, PM reset or bus reset available\""
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetLastError",
          "args": [],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "virGetLastErrorMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virerror.c",
          "lines": "316-325",
          "snippet": "const char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}",
          "includes": [
            "#include \"virerrorpriv.h\"",
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virerror.h\"",
            "#include <stdarg.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virerrorpriv.h\"\n#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virerror.h\"\n#include <stdarg.h>\n#include <config.h>\n\nconst char *\nvirGetLastErrorMessage(void)\n{\n    virErrorPtr err = virLastErrorObject();\n    if (err && err->code == VIR_ERR_OK)\n        return _(\"no error\");\n    if (!err || !err->message)\n        return _(\"unknown error\");\n    return err->message;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceTrySecondaryBusReset",
          "args": [
            "dev",
            "fd",
            "inactiveDevs"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceTrySecondaryBusReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "772-845",
          "snippet": "static int\nvirPCIDeviceTrySecondaryBusReset(virPCIDevicePtr dev,\n                                 int cfgfd,\n                                 virPCIDeviceList *inactiveDevs)\n{\n    g_autoptr(virPCIDevice) parent = NULL;\n    g_autoptr(virPCIDevice) conflict = NULL;\n    uint8_t config_space[PCI_CONF_LEN];\n    uint16_t ctl;\n    int ret = -1;\n    int parentfd;\n\n    /* Refuse to do a secondary bus reset if there are other\n     * devices/functions behind the bus are used by the host\n     * or other guests.\n     */\n    if ((conflict = virPCIDeviceBusContainsActiveDevices(dev, inactiveDevs))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Active %s devices on bus with %s, not doing bus reset\"),\n                       conflict->name, dev->name);\n        return -1;\n    }\n\n    /* Find the parent bus */\n    if (virPCIDeviceGetParent(dev, &parent) < 0)\n        return -1;\n    if (!parent) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to find parent device for %s\"),\n                       dev->name);\n        return -1;\n    }\n    if ((parentfd = virPCIDeviceConfigOpenWrite(parent)) < 0)\n        goto out;\n\n    VIR_DEBUG(\"%s %s: doing a secondary bus reset\", dev->id, dev->name);\n\n    /* Save and restore the device's config space; we only do this\n     * for the supplied device since we refuse to do a reset if there\n     * are multiple devices/functions\n     */\n    if (virPCIDeviceRead(dev, cfgfd, 0, config_space, PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read PCI config space for %s\"),\n                       dev->name);\n        goto out;\n    }\n\n    /* Read the control register, set the reset flag, wait 200ms,\n     * unset the reset flag and wait 200ms.\n     */\n    ctl = virPCIDeviceRead16(dev, parentfd, PCI_BRIDGE_CONTROL);\n\n    virPCIDeviceWrite16(parent, parentfd, PCI_BRIDGE_CONTROL,\n                        ctl | PCI_BRIDGE_CTL_RESET);\n\n    g_usleep(200 * 1000); /* sleep 200ms */\n\n    virPCIDeviceWrite16(parent, parentfd, PCI_BRIDGE_CONTROL, ctl);\n\n    g_usleep(200 * 1000); /* sleep 200ms */\n\n    if (virPCIDeviceWrite(dev, cfgfd, 0, config_space, PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to restore PCI config space for %s\"),\n                       dev->name);\n        goto out;\n    }\n    ret = 0;\n\n out:\n    virPCIDeviceConfigClose(parent, parentfd);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_BRIDGE_CTL_RESET   0x40    /* Secondary bus reset */",
            "#define PCI_BRIDGE_CONTROL      0x3e",
            "#define PCI_CONF_LEN            0x100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_BRIDGE_CTL_RESET   0x40    /* Secondary bus reset */\n#define PCI_BRIDGE_CONTROL      0x3e\n#define PCI_CONF_LEN            0x100\n\nstatic int\nvirPCIDeviceTrySecondaryBusReset(virPCIDevicePtr dev,\n                                 int cfgfd,\n                                 virPCIDeviceList *inactiveDevs)\n{\n    g_autoptr(virPCIDevice) parent = NULL;\n    g_autoptr(virPCIDevice) conflict = NULL;\n    uint8_t config_space[PCI_CONF_LEN];\n    uint16_t ctl;\n    int ret = -1;\n    int parentfd;\n\n    /* Refuse to do a secondary bus reset if there are other\n     * devices/functions behind the bus are used by the host\n     * or other guests.\n     */\n    if ((conflict = virPCIDeviceBusContainsActiveDevices(dev, inactiveDevs))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Active %s devices on bus with %s, not doing bus reset\"),\n                       conflict->name, dev->name);\n        return -1;\n    }\n\n    /* Find the parent bus */\n    if (virPCIDeviceGetParent(dev, &parent) < 0)\n        return -1;\n    if (!parent) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to find parent device for %s\"),\n                       dev->name);\n        return -1;\n    }\n    if ((parentfd = virPCIDeviceConfigOpenWrite(parent)) < 0)\n        goto out;\n\n    VIR_DEBUG(\"%s %s: doing a secondary bus reset\", dev->id, dev->name);\n\n    /* Save and restore the device's config space; we only do this\n     * for the supplied device since we refuse to do a reset if there\n     * are multiple devices/functions\n     */\n    if (virPCIDeviceRead(dev, cfgfd, 0, config_space, PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read PCI config space for %s\"),\n                       dev->name);\n        goto out;\n    }\n\n    /* Read the control register, set the reset flag, wait 200ms,\n     * unset the reset flag and wait 200ms.\n     */\n    ctl = virPCIDeviceRead16(dev, parentfd, PCI_BRIDGE_CONTROL);\n\n    virPCIDeviceWrite16(parent, parentfd, PCI_BRIDGE_CONTROL,\n                        ctl | PCI_BRIDGE_CTL_RESET);\n\n    g_usleep(200 * 1000); /* sleep 200ms */\n\n    virPCIDeviceWrite16(parent, parentfd, PCI_BRIDGE_CONTROL, ctl);\n\n    g_usleep(200 * 1000); /* sleep 200ms */\n\n    if (virPCIDeviceWrite(dev, cfgfd, 0, config_space, PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to restore PCI config space for %s\"),\n                       dev->name);\n        goto out;\n    }\n    ret = 0;\n\n out:\n    virPCIDeviceConfigClose(parent, parentfd);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceTryPowerManagementReset",
          "args": [
            "dev",
            "fd"
          ],
          "line": 972
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceTryPowerManagementReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "851-891",
          "snippet": "static int\nvirPCIDeviceTryPowerManagementReset(virPCIDevicePtr dev, int cfgfd)\n{\n    uint8_t config_space[PCI_CONF_LEN];\n    uint32_t ctl;\n\n    if (!dev->pci_pm_cap_pos)\n        return -1;\n\n    /* Save and restore the device's config space. */\n    if (virPCIDeviceRead(dev, cfgfd, 0, &config_space[0], PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read PCI config space for %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: doing a power management reset\", dev->id, dev->name);\n\n    ctl = virPCIDeviceRead32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL);\n    ctl &= ~PCI_PM_CTRL_STATE_MASK;\n\n    virPCIDeviceWrite32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL,\n                        ctl | PCI_PM_CTRL_STATE_D3hot);\n\n    g_usleep(10 * 1000); /* sleep 10ms */\n\n    virPCIDeviceWrite32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL,\n                        ctl | PCI_PM_CTRL_STATE_D0);\n\n    g_usleep(10 * 1000); /* sleep 10ms */\n\n    if (virPCIDeviceWrite(dev, cfgfd, 0, &config_space[0], PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to restore PCI config space for %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_PM_CTRL_STATE_D3hot   0x3  /* D3 state */",
            "#define PCI_PM_CTRL_STATE_D0      0x0  /* D0 state */",
            "#define PCI_PM_CTRL_STATE_MASK    0x3  /* Current power state (D0 to D3) */",
            "#define PCI_PM_CTRL                4    /* PM control and status register */",
            "#define PCI_CONF_LEN            0x100"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_PM_CTRL_STATE_D3hot   0x3  /* D3 state */\n#define PCI_PM_CTRL_STATE_D0      0x0  /* D0 state */\n#define PCI_PM_CTRL_STATE_MASK    0x3  /* Current power state (D0 to D3) */\n#define PCI_PM_CTRL                4    /* PM control and status register */\n#define PCI_CONF_LEN            0x100\n\nstatic int\nvirPCIDeviceTryPowerManagementReset(virPCIDevicePtr dev, int cfgfd)\n{\n    uint8_t config_space[PCI_CONF_LEN];\n    uint32_t ctl;\n\n    if (!dev->pci_pm_cap_pos)\n        return -1;\n\n    /* Save and restore the device's config space. */\n    if (virPCIDeviceRead(dev, cfgfd, 0, &config_space[0], PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read PCI config space for %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: doing a power management reset\", dev->id, dev->name);\n\n    ctl = virPCIDeviceRead32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL);\n    ctl &= ~PCI_PM_CTRL_STATE_MASK;\n\n    virPCIDeviceWrite32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL,\n                        ctl | PCI_PM_CTRL_STATE_D3hot);\n\n    g_usleep(10 * 1000); /* sleep 10ms */\n\n    virPCIDeviceWrite32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL,\n                        ctl | PCI_PM_CTRL_STATE_D0);\n\n    g_usleep(10 * 1000); /* sleep 10ms */\n\n    if (virPCIDeviceWrite(dev, cfgfd, 0, &config_space[0], PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to restore PCI config space for %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceInit",
          "args": [
            "dev",
            "fd"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceInit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "893-907",
          "snippet": "static int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_CAP_ID_EXP          0x10    /* PCI Express */",
            "#define PCI_CAP_ID_PM           0x01    /* Power Management */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_CAP_ID_EXP          0x10    /* PCI Express */\n#define PCI_CAP_ID_PM           0x01    /* Power Management */\n\nstatic int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceConfigOpenWrite",
          "args": [
            "dev"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigOpenWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "314-318",
          "snippet": "static int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Resetting device %s\"",
            "dev->name"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"Device %s is bound to vfio-pci - skip reset\"",
            "dev->name"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIStubDriverTypeFromString",
          "args": [
            "drvName"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetDriverPathAndName",
          "args": [
            "dev",
            "&drvPath",
            "&drvName"
          ],
          "line": 942
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetDriverPathAndName",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "236-276",
          "snippet": "int\nvirPCIDeviceGetDriverPathAndName(virPCIDevicePtr dev, char **path, char **name)\n{\n    int ret = -1;\n    g_autofree char *drvlink = NULL;\n\n    *path = *name = NULL;\n    /* drvlink = \"/sys/bus/pci/dddd:bb:ss.ff/driver\" */\n    if (!(drvlink = virPCIFile(dev->name, \"driver\")))\n        goto cleanup;\n\n    if (!virFileExists(drvlink)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileIsLink(drvlink) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s driver file %s is not a symlink\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    if (virFileResolveLink(drvlink, path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s driver symlink %s\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    /* path = \"/sys/bus/pci/drivers/${drivername}\" */\n\n    *name = g_path_get_basename(*path);\n    /* name = \"${drivername}\" */\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(*path);\n        VIR_FREE(*name);\n    }\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceGetDriverPathAndName(virPCIDevicePtr dev, char **path, char **name)\n{\n    int ret = -1;\n    g_autofree char *drvlink = NULL;\n\n    *path = *name = NULL;\n    /* drvlink = \"/sys/bus/pci/dddd:bb:ss.ff/driver\" */\n    if (!(drvlink = virPCIFile(dev->name, \"driver\")))\n        goto cleanup;\n\n    if (!virFileExists(drvlink)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileIsLink(drvlink) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s driver file %s is not a symlink\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    if (virFileResolveLink(drvlink, path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s driver symlink %s\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    /* path = \"/sys/bus/pci/drivers/${drivername}\" */\n\n    *name = g_path_get_basename(*path);\n    /* name = \"${drivername}\" */\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(*path);\n        VIR_FREE(*name);\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Not resetting active device %s\")",
            "dev->name"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceListFind",
          "args": [
            "activeDevs",
            "dev"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1708-1717",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid attempt to reset PCI device %s. \"\n                         \"Only PCI endpoint devices can be reset\")",
            "dev->name"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIGetHeaderType",
          "args": [
            "dev",
            "&hdrType"
          ],
          "line": 920
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIGetHeaderType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "2812-2837",
          "snippet": "int virPCIGetHeaderType(virPCIDevicePtr dev, int *hdrType)\n{\n    int fd;\n    uint8_t type;\n\n    *hdrType = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    type = virPCIDeviceRead8(dev, fd, PCI_HEADER_TYPE);\n\n    virPCIDeviceConfigClose(dev, fd);\n\n    type &= PCI_HEADER_TYPE_MASK;\n    if (type >= VIR_PCI_HEADER_LAST) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown PCI header type '%d' for device '%s'\"),\n                       type, dev->name);\n        return -1;\n    }\n\n    *hdrType = type;\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_HEADER_TYPE_MASK   0x7f",
            "#define PCI_HEADER_TYPE         0x0e    /* Header type */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_HEADER_TYPE_MASK   0x7f\n#define PCI_HEADER_TYPE         0x0e    /* Header type */\n\nint virPCIGetHeaderType(virPCIDevicePtr dev, int *hdrType)\n{\n    int fd;\n    uint8_t type;\n\n    *hdrType = -1;\n\n    if ((fd = virPCIDeviceConfigOpen(dev)) < 0)\n        return -1;\n\n    type = virPCIDeviceRead8(dev, fd, PCI_HEADER_TYPE);\n\n    virPCIDeviceConfigClose(dev, fd);\n\n    type &= PCI_HEADER_TYPE_MASK;\n    if (type >= VIR_PCI_HEADER_LAST) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unknown PCI header type '%d' for device '%s'\"),\n                       type, dev->name);\n        return -1;\n    }\n\n    *hdrType = type;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceReset(virPCIDevicePtr dev,\n                  virPCIDeviceList *activeDevs,\n                  virPCIDeviceList *inactiveDevs)\n{\n    g_autofree char *drvPath = NULL;\n    g_autofree char *drvName = NULL;\n    int ret = -1;\n    int fd = -1;\n    int hdrType = -1;\n\n    if (virPCIGetHeaderType(dev, &hdrType) < 0)\n        return -1;\n\n    if (hdrType != VIR_PCI_HEADER_ENDPOINT) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid attempt to reset PCI device %s. \"\n                         \"Only PCI endpoint devices can be reset\"),\n                       dev->name);\n        return -1;\n    }\n\n    if (activeDevs && virPCIDeviceListFind(activeDevs, dev)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Not resetting active device %s\"), dev->name);\n        return -1;\n    }\n\n    /* If the device is currently bound to vfio-pci, ignore all\n     * requests to reset it, since the vfio-pci driver will always\n     * reset it whenever appropriate, so doing it ourselves would just\n     * be redundant.\n     */\n    if (virPCIDeviceGetDriverPathAndName(dev, &drvPath, &drvName) < 0)\n        goto cleanup;\n\n    if (virPCIStubDriverTypeFromString(drvName) == VIR_PCI_STUB_DRIVER_VFIO) {\n        VIR_DEBUG(\"Device %s is bound to vfio-pci - skip reset\",\n                  dev->name);\n        ret = 0;\n        goto cleanup;\n    }\n    VIR_DEBUG(\"Resetting device %s\", dev->name);\n\n    if ((fd = virPCIDeviceConfigOpenWrite(dev)) < 0)\n        goto cleanup;\n\n    if (virPCIDeviceInit(dev, fd) < 0)\n        goto cleanup;\n\n    /* KVM will perform FLR when starting and stopping\n     * a guest, so there is no need for us to do it here.\n     */\n    if (dev->has_flr) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    /* If the device supports PCI power management reset,\n     * that's the next best thing because it only resets\n     * the function, not the whole device.\n     */\n    if (dev->has_pm_reset)\n        ret = virPCIDeviceTryPowerManagementReset(dev, fd);\n\n    /* Bus reset is not an option with the root bus */\n    if (ret < 0 && dev->address.bus != 0)\n        ret = virPCIDeviceTrySecondaryBusReset(dev, fd, inactiveDevs);\n\n    if (ret < 0) {\n        virErrorPtr err = virGetLastError();\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to reset PCI device %s: %s\"),\n                       dev->name,\n                       err ? err->message :\n                       _(\"no FLR, PM reset or bus reset available\"));\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(dev, fd);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "893-907",
    "snippet": "static int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_CAP_ID_EXP          0x10    /* PCI Express */",
      "#define PCI_CAP_ID_PM           0x01    /* Power Management */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceDetectPowerManagementReset",
          "args": [
            "dev",
            "cfgfd"
          ],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceDetectPowerManagementReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "619-636",
          "snippet": "static unsigned int\nvirPCIDeviceDetectPowerManagementReset(virPCIDevicePtr dev, int cfgfd)\n{\n    if (dev->pci_pm_cap_pos) {\n        uint32_t ctl;\n\n        /* require the NO_SOFT_RESET bit is clear */\n        ctl = virPCIDeviceRead32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL);\n        if (!(ctl & PCI_PM_CTRL_NO_SOFT_RESET)) {\n            VIR_DEBUG(\"%s %s: detected PM reset capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    VIR_DEBUG(\"%s %s: no PM reset capability found\", dev->id, dev->name);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_PM_CTRL_NO_SOFT_RESET 0x8  /* No reset for D3hot->D0 */",
            "#define PCI_PM_CTRL                4    /* PM control and status register */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_PM_CTRL_NO_SOFT_RESET 0x8  /* No reset for D3hot->D0 */\n#define PCI_PM_CTRL                4    /* PM control and status register */\n\nstatic unsigned int\nvirPCIDeviceDetectPowerManagementReset(virPCIDevicePtr dev, int cfgfd)\n{\n    if (dev->pci_pm_cap_pos) {\n        uint32_t ctl;\n\n        /* require the NO_SOFT_RESET bit is clear */\n        ctl = virPCIDeviceRead32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL);\n        if (!(ctl & PCI_PM_CTRL_NO_SOFT_RESET)) {\n            VIR_DEBUG(\"%s %s: detected PM reset capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    VIR_DEBUG(\"%s %s: no PM reset capability found\", dev->id, dev->name);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceDetectFunctionLevelReset",
          "args": [
            "dev",
            "cfgfd"
          ],
          "line": 900
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceDetectFunctionLevelReset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "560-613",
          "snippet": "static int\nvirPCIDeviceDetectFunctionLevelReset(virPCIDevicePtr dev, int cfgfd)\n{\n    uint32_t caps;\n    uint8_t pos;\n    g_autofree char *path = NULL;\n    int found;\n\n    /* The PCIe Function Level Reset capability allows\n     * individual device functions to be reset without\n     * affecting any other functions on the device or\n     * any other devices on the bus. This is only common\n     * on SR-IOV NICs at the moment.\n     */\n    if (dev->pcie_cap_pos) {\n        caps = virPCIDeviceRead32(dev, cfgfd, dev->pcie_cap_pos + PCI_EXP_DEVCAP);\n        if (caps & PCI_EXP_DEVCAP_FLR) {\n            VIR_DEBUG(\"%s %s: detected PCIe FLR capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    /* The PCI AF Function Level Reset capability is\n     * the same thing, except for conventional PCI\n     * devices. This is not common yet.\n     */\n    pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_AF);\n    if (pos) {\n        caps = virPCIDeviceRead16(dev, cfgfd, pos + PCI_AF_CAP);\n        if (caps & PCI_AF_CAP_FLR) {\n            VIR_DEBUG(\"%s %s: detected PCI FLR capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    /* there are some buggy devices that do support FLR, but forget to\n     * advertise that fact in their capabilities.  However, FLR is *required*\n     * to be present for virtual functions (VFs), so if we see that this\n     * device is a VF, we just assume FLR works\n     */\n\n    path = g_strdup_printf(PCI_SYSFS \"devices/%s/physfn\", dev->name);\n\n    found = virFileExists(path);\n    if (found) {\n        VIR_DEBUG(\"%s %s: buggy device didn't advertise FLR, but is a VF; forcing flr on\",\n                  dev->id, dev->name);\n        return 1;\n    }\n\n    VIR_DEBUG(\"%s %s: no FLR capability found\", dev->id, dev->name);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_AF_CAP_FLR         0x2     /* Function Level Reset */",
            "#define PCI_AF_CAP              0x3     /* Advanced features capabilities */",
            "#define PCI_EXP_DEVCAP_FLR     (1<<28)  /* Function Level Reset */",
            "#define PCI_EXP_DEVCAP          0x4     /* Device capabilities */",
            "#define PCI_CAP_ID_AF           0x13    /* Advanced Features */",
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_AF_CAP_FLR         0x2     /* Function Level Reset */\n#define PCI_AF_CAP              0x3     /* Advanced features capabilities */\n#define PCI_EXP_DEVCAP_FLR     (1<<28)  /* Function Level Reset */\n#define PCI_EXP_DEVCAP          0x4     /* Device capabilities */\n#define PCI_CAP_ID_AF           0x13    /* Advanced Features */\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic int\nvirPCIDeviceDetectFunctionLevelReset(virPCIDevicePtr dev, int cfgfd)\n{\n    uint32_t caps;\n    uint8_t pos;\n    g_autofree char *path = NULL;\n    int found;\n\n    /* The PCIe Function Level Reset capability allows\n     * individual device functions to be reset without\n     * affecting any other functions on the device or\n     * any other devices on the bus. This is only common\n     * on SR-IOV NICs at the moment.\n     */\n    if (dev->pcie_cap_pos) {\n        caps = virPCIDeviceRead32(dev, cfgfd, dev->pcie_cap_pos + PCI_EXP_DEVCAP);\n        if (caps & PCI_EXP_DEVCAP_FLR) {\n            VIR_DEBUG(\"%s %s: detected PCIe FLR capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    /* The PCI AF Function Level Reset capability is\n     * the same thing, except for conventional PCI\n     * devices. This is not common yet.\n     */\n    pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_AF);\n    if (pos) {\n        caps = virPCIDeviceRead16(dev, cfgfd, pos + PCI_AF_CAP);\n        if (caps & PCI_AF_CAP_FLR) {\n            VIR_DEBUG(\"%s %s: detected PCI FLR capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    /* there are some buggy devices that do support FLR, but forget to\n     * advertise that fact in their capabilities.  However, FLR is *required*\n     * to be present for virtual functions (VFs), so if we see that this\n     * device is a VF, we just assume FLR works\n     */\n\n    path = g_strdup_printf(PCI_SYSFS \"devices/%s/physfn\", dev->name);\n\n    found = virFileExists(path);\n    if (found) {\n        VIR_DEBUG(\"%s %s: buggy device didn't advertise FLR, but is a VF; forcing flr on\",\n                  dev->id, dev->name);\n        return 1;\n    }\n\n    VIR_DEBUG(\"%s %s: no FLR capability found\", dev->id, dev->name);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFindCapabilityOffset",
          "args": [
            "dev",
            "cfgfd",
            "PCI_CAP_ID_PM"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFindCapabilityOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "494-529",
          "snippet": "static uint8_t\nvirPCIDeviceFindCapabilityOffset(virPCIDevicePtr dev,\n                                 int cfgfd,\n                                 unsigned int capability)\n{\n    uint16_t status;\n    uint8_t pos;\n\n    status = virPCIDeviceRead16(dev, cfgfd, PCI_STATUS);\n    if (!(status & PCI_STATUS_CAP_LIST))\n        return 0;\n\n    pos = virPCIDeviceRead8(dev, cfgfd, PCI_CAPABILITY_LIST);\n\n    /* Zero indicates last capability, capabilities can't\n     * be in the config space header and 0xff is returned\n     * by the kernel if we don't have access to this region\n     *\n     * Note: we're not handling loops or extended\n     * capabilities here.\n     */\n    while (pos >= PCI_CONF_HEADER_LEN && pos != 0xff) {\n        uint8_t capid = virPCIDeviceRead8(dev, cfgfd, pos);\n        if (capid == capability) {\n            VIR_DEBUG(\"%s %s: found cap 0x%.2x at 0x%.2x\",\n                      dev->id, dev->name, capability, pos);\n            return pos;\n        }\n\n        pos = virPCIDeviceRead8(dev, cfgfd, pos + 1);\n    }\n\n    VIR_DEBUG(\"%s %s: failed to find cap 0x%.2x\", dev->id, dev->name, capability);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_CAPABILITY_LIST     0x34    /* Offset of first capability list entry */",
            "#define PCI_STATUS_CAP_LIST    0x10    /* Support Capability List */",
            "#define PCI_STATUS              0x06    /* 16 bits */",
            "#define PCI_CONF_HEADER_LEN     0x40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_CAPABILITY_LIST     0x34    /* Offset of first capability list entry */\n#define PCI_STATUS_CAP_LIST    0x10    /* Support Capability List */\n#define PCI_STATUS              0x06    /* 16 bits */\n#define PCI_CONF_HEADER_LEN     0x40\n\nstatic uint8_t\nvirPCIDeviceFindCapabilityOffset(virPCIDevicePtr dev,\n                                 int cfgfd,\n                                 unsigned int capability)\n{\n    uint16_t status;\n    uint8_t pos;\n\n    status = virPCIDeviceRead16(dev, cfgfd, PCI_STATUS);\n    if (!(status & PCI_STATUS_CAP_LIST))\n        return 0;\n\n    pos = virPCIDeviceRead8(dev, cfgfd, PCI_CAPABILITY_LIST);\n\n    /* Zero indicates last capability, capabilities can't\n     * be in the config space header and 0xff is returned\n     * by the kernel if we don't have access to this region\n     *\n     * Note: we're not handling loops or extended\n     * capabilities here.\n     */\n    while (pos >= PCI_CONF_HEADER_LEN && pos != 0xff) {\n        uint8_t capid = virPCIDeviceRead8(dev, cfgfd, pos);\n        if (capid == capability) {\n            VIR_DEBUG(\"%s %s: found cap 0x%.2x at 0x%.2x\",\n                      dev->id, dev->name, capability, pos);\n            return pos;\n        }\n\n        pos = virPCIDeviceRead8(dev, cfgfd, pos + 1);\n    }\n\n    VIR_DEBUG(\"%s %s: failed to find cap 0x%.2x\", dev->id, dev->name, capability);\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_CAP_ID_EXP          0x10    /* PCI Express */\n#define PCI_CAP_ID_PM           0x01    /* Power Management */\n\nstatic int\nvirPCIDeviceInit(virPCIDevicePtr dev, int cfgfd)\n{\n    int flr;\n\n    dev->pcie_cap_pos   = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_EXP);\n    dev->pci_pm_cap_pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_PM);\n    flr = virPCIDeviceDetectFunctionLevelReset(dev, cfgfd);\n    if (flr < 0)\n        return flr;\n    dev->has_flr        = !!flr;\n    dev->has_pm_reset   = !!virPCIDeviceDetectPowerManagementReset(dev, cfgfd);\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceTryPowerManagementReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "851-891",
    "snippet": "static int\nvirPCIDeviceTryPowerManagementReset(virPCIDevicePtr dev, int cfgfd)\n{\n    uint8_t config_space[PCI_CONF_LEN];\n    uint32_t ctl;\n\n    if (!dev->pci_pm_cap_pos)\n        return -1;\n\n    /* Save and restore the device's config space. */\n    if (virPCIDeviceRead(dev, cfgfd, 0, &config_space[0], PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read PCI config space for %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: doing a power management reset\", dev->id, dev->name);\n\n    ctl = virPCIDeviceRead32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL);\n    ctl &= ~PCI_PM_CTRL_STATE_MASK;\n\n    virPCIDeviceWrite32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL,\n                        ctl | PCI_PM_CTRL_STATE_D3hot);\n\n    g_usleep(10 * 1000); /* sleep 10ms */\n\n    virPCIDeviceWrite32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL,\n                        ctl | PCI_PM_CTRL_STATE_D0);\n\n    g_usleep(10 * 1000); /* sleep 10ms */\n\n    if (virPCIDeviceWrite(dev, cfgfd, 0, &config_space[0], PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to restore PCI config space for %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_PM_CTRL_STATE_D3hot   0x3  /* D3 state */",
      "#define PCI_PM_CTRL_STATE_D0      0x0  /* D0 state */",
      "#define PCI_PM_CTRL_STATE_MASK    0x3  /* Current power state (D0 to D3) */",
      "#define PCI_PM_CTRL                4    /* PM control and status register */",
      "#define PCI_CONF_LEN            0x100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to restore PCI config space for %s\")",
            "dev->name"
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to restore PCI config space for %s\""
          ],
          "line": 885
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceWrite",
          "args": [
            "dev",
            "cfgfd",
            "0",
            "&config_space[0]",
            "PCI_CONF_LEN"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "398-412",
          "snippet": "static int\nvirPCIDeviceWrite(virPCIDevicePtr dev,\n                  int cfgfd,\n                  unsigned int pos,\n                  uint8_t *buf,\n                  unsigned int buflen)\n{\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        safewrite(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to write to '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceWrite(virPCIDevicePtr dev,\n                  int cfgfd,\n                  unsigned int pos,\n                  uint8_t *buf,\n                  unsigned int buflen)\n{\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        safewrite(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to write to '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceWrite32",
          "args": [
            "dev",
            "cfgfd",
            "dev->pci_pm_cap_pos + PCI_PM_CTRL",
            "ctl | PCI_PM_CTRL_STATE_D0"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceWrite32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "421-426",
          "snippet": "static void\nvirPCIDeviceWrite32(virPCIDevicePtr dev, int cfgfd, unsigned int pos, uint32_t val)\n{\n    uint8_t buf[4] = { (val >> 0), (val >> 8), (val >> 16), (val >> 24) };\n    virPCIDeviceWrite(dev, cfgfd, pos, &buf[0], sizeof(buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceWrite32(virPCIDevicePtr dev, int cfgfd, unsigned int pos, uint32_t val)\n{\n    uint8_t buf[4] = { (val >> 0), (val >> 8), (val >> 16), (val >> 24) };\n    virPCIDeviceWrite(dev, cfgfd, pos, &buf[0], sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "10 * 1000"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead32",
          "args": [
            "dev",
            "cfgfd",
            "dev->pci_pm_cap_pos + PCI_PM_CTRL"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "364-370",
          "snippet": "static uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: doing a power management reset\"",
            "dev->id",
            "dev->name"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to read PCI config space for %s\")",
            "dev->name"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead",
          "args": [
            "dev",
            "cfgfd",
            "0",
            "&config_space[0]",
            "PCI_CONF_LEN"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "330-346",
          "snippet": "static int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_PM_CTRL_STATE_D3hot   0x3  /* D3 state */\n#define PCI_PM_CTRL_STATE_D0      0x0  /* D0 state */\n#define PCI_PM_CTRL_STATE_MASK    0x3  /* Current power state (D0 to D3) */\n#define PCI_PM_CTRL                4    /* PM control and status register */\n#define PCI_CONF_LEN            0x100\n\nstatic int\nvirPCIDeviceTryPowerManagementReset(virPCIDevicePtr dev, int cfgfd)\n{\n    uint8_t config_space[PCI_CONF_LEN];\n    uint32_t ctl;\n\n    if (!dev->pci_pm_cap_pos)\n        return -1;\n\n    /* Save and restore the device's config space. */\n    if (virPCIDeviceRead(dev, cfgfd, 0, &config_space[0], PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read PCI config space for %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: doing a power management reset\", dev->id, dev->name);\n\n    ctl = virPCIDeviceRead32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL);\n    ctl &= ~PCI_PM_CTRL_STATE_MASK;\n\n    virPCIDeviceWrite32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL,\n                        ctl | PCI_PM_CTRL_STATE_D3hot);\n\n    g_usleep(10 * 1000); /* sleep 10ms */\n\n    virPCIDeviceWrite32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL,\n                        ctl | PCI_PM_CTRL_STATE_D0);\n\n    g_usleep(10 * 1000); /* sleep 10ms */\n\n    if (virPCIDeviceWrite(dev, cfgfd, 0, &config_space[0], PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to restore PCI config space for %s\"),\n                       dev->name);\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceTrySecondaryBusReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "772-845",
    "snippet": "static int\nvirPCIDeviceTrySecondaryBusReset(virPCIDevicePtr dev,\n                                 int cfgfd,\n                                 virPCIDeviceList *inactiveDevs)\n{\n    g_autoptr(virPCIDevice) parent = NULL;\n    g_autoptr(virPCIDevice) conflict = NULL;\n    uint8_t config_space[PCI_CONF_LEN];\n    uint16_t ctl;\n    int ret = -1;\n    int parentfd;\n\n    /* Refuse to do a secondary bus reset if there are other\n     * devices/functions behind the bus are used by the host\n     * or other guests.\n     */\n    if ((conflict = virPCIDeviceBusContainsActiveDevices(dev, inactiveDevs))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Active %s devices on bus with %s, not doing bus reset\"),\n                       conflict->name, dev->name);\n        return -1;\n    }\n\n    /* Find the parent bus */\n    if (virPCIDeviceGetParent(dev, &parent) < 0)\n        return -1;\n    if (!parent) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to find parent device for %s\"),\n                       dev->name);\n        return -1;\n    }\n    if ((parentfd = virPCIDeviceConfigOpenWrite(parent)) < 0)\n        goto out;\n\n    VIR_DEBUG(\"%s %s: doing a secondary bus reset\", dev->id, dev->name);\n\n    /* Save and restore the device's config space; we only do this\n     * for the supplied device since we refuse to do a reset if there\n     * are multiple devices/functions\n     */\n    if (virPCIDeviceRead(dev, cfgfd, 0, config_space, PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read PCI config space for %s\"),\n                       dev->name);\n        goto out;\n    }\n\n    /* Read the control register, set the reset flag, wait 200ms,\n     * unset the reset flag and wait 200ms.\n     */\n    ctl = virPCIDeviceRead16(dev, parentfd, PCI_BRIDGE_CONTROL);\n\n    virPCIDeviceWrite16(parent, parentfd, PCI_BRIDGE_CONTROL,\n                        ctl | PCI_BRIDGE_CTL_RESET);\n\n    g_usleep(200 * 1000); /* sleep 200ms */\n\n    virPCIDeviceWrite16(parent, parentfd, PCI_BRIDGE_CONTROL, ctl);\n\n    g_usleep(200 * 1000); /* sleep 200ms */\n\n    if (virPCIDeviceWrite(dev, cfgfd, 0, config_space, PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to restore PCI config space for %s\"),\n                       dev->name);\n        goto out;\n    }\n    ret = 0;\n\n out:\n    virPCIDeviceConfigClose(parent, parentfd);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_BRIDGE_CTL_RESET   0x40    /* Secondary bus reset */",
      "#define PCI_BRIDGE_CONTROL      0x3e",
      "#define PCI_CONF_LEN            0x100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceConfigClose",
          "args": [
            "parent",
            "parentfd"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "320-327",
          "snippet": "static void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to restore PCI config space for %s\")",
            "dev->name"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to restore PCI config space for %s\""
          ],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceWrite",
          "args": [
            "dev",
            "cfgfd",
            "0",
            "config_space",
            "PCI_CONF_LEN"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "398-412",
          "snippet": "static int\nvirPCIDeviceWrite(virPCIDevicePtr dev,\n                  int cfgfd,\n                  unsigned int pos,\n                  uint8_t *buf,\n                  unsigned int buflen)\n{\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        safewrite(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to write to '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceWrite(virPCIDevicePtr dev,\n                  int cfgfd,\n                  unsigned int pos,\n                  uint8_t *buf,\n                  unsigned int buflen)\n{\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        safewrite(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to write to '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "200 * 1000"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceWrite16",
          "args": [
            "parent",
            "parentfd",
            "PCI_BRIDGE_CONTROL",
            "ctl"
          ],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceWrite16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "414-419",
          "snippet": "static void\nvirPCIDeviceWrite16(virPCIDevicePtr dev, int cfgfd, unsigned int pos, uint16_t val)\n{\n    uint8_t buf[2] = { (val >> 0), (val >> 8) };\n    virPCIDeviceWrite(dev, cfgfd, pos, &buf[0], sizeof(buf));\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceWrite16(virPCIDevicePtr dev, int cfgfd, unsigned int pos, uint16_t val)\n{\n    uint8_t buf[2] = { (val >> 0), (val >> 8) };\n    virPCIDeviceWrite(dev, cfgfd, pos, &buf[0], sizeof(buf));\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_usleep",
          "args": [
            "200 * 1000"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead16",
          "args": [
            "dev",
            "parentfd",
            "PCI_BRIDGE_CONTROL"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "356-362",
          "snippet": "static uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to read PCI config space for %s\")",
            "dev->name"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead",
          "args": [
            "dev",
            "cfgfd",
            "0",
            "config_space",
            "PCI_CONF_LEN"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "330-346",
          "snippet": "static int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: doing a secondary bus reset\"",
            "dev->id",
            "dev->name"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceConfigOpenWrite",
          "args": [
            "parent"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigOpenWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "314-318",
          "snippet": "static int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Failed to find parent device for %s\")",
            "dev->name"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceGetParent",
          "args": [
            "dev",
            "&parent"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceGetParent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "754-767",
          "snippet": "static int\nvirPCIDeviceGetParent(virPCIDevicePtr dev, virPCIDevicePtr *parent)\n{\n    virPCIDevicePtr best = NULL;\n    int ret;\n\n    *parent = NULL;\n    ret = virPCIDeviceIterDevices(virPCIDeviceIsParent, dev, parent, &best);\n    if (ret == 1)\n        virPCIDeviceFree(best);\n    else if (ret == 0)\n        *parent = best;\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceGetParent(virPCIDevicePtr dev, virPCIDevicePtr *parent)\n{\n    virPCIDevicePtr best = NULL;\n    int ret;\n\n    *parent = NULL;\n    ret = virPCIDeviceIterDevices(virPCIDeviceIsParent, dev, parent, &best);\n    if (ret == 1)\n        virPCIDeviceFree(best);\n    else if (ret == 0)\n        *parent = best;\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Active %s devices on bus with %s, not doing bus reset\")",
            "conflict->name",
            "dev->name"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceBusContainsActiveDevices",
          "args": [
            "dev",
            "inactiveDevs"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceBusContainsActiveDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "658-667",
          "snippet": "static virPCIDevicePtr\nvirPCIDeviceBusContainsActiveDevices(virPCIDevicePtr dev,\n                                     virPCIDeviceList *inactiveDevs)\n{\n    virPCIDevicePtr active = NULL;\n    if (virPCIDeviceIterDevices(virPCIDeviceSharesBusWithActive,\n                                dev, &active, inactiveDevs) < 0)\n        return NULL;\n    return active;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic virPCIDevicePtr\nvirPCIDeviceBusContainsActiveDevices(virPCIDevicePtr dev,\n                                     virPCIDeviceList *inactiveDevs)\n{\n    virPCIDevicePtr active = NULL;\n    if (virPCIDeviceIterDevices(virPCIDeviceSharesBusWithActive,\n                                dev, &active, inactiveDevs) < 0)\n        return NULL;\n    return active;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_BRIDGE_CTL_RESET   0x40    /* Secondary bus reset */\n#define PCI_BRIDGE_CONTROL      0x3e\n#define PCI_CONF_LEN            0x100\n\nstatic int\nvirPCIDeviceTrySecondaryBusReset(virPCIDevicePtr dev,\n                                 int cfgfd,\n                                 virPCIDeviceList *inactiveDevs)\n{\n    g_autoptr(virPCIDevice) parent = NULL;\n    g_autoptr(virPCIDevice) conflict = NULL;\n    uint8_t config_space[PCI_CONF_LEN];\n    uint16_t ctl;\n    int ret = -1;\n    int parentfd;\n\n    /* Refuse to do a secondary bus reset if there are other\n     * devices/functions behind the bus are used by the host\n     * or other guests.\n     */\n    if ((conflict = virPCIDeviceBusContainsActiveDevices(dev, inactiveDevs))) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Active %s devices on bus with %s, not doing bus reset\"),\n                       conflict->name, dev->name);\n        return -1;\n    }\n\n    /* Find the parent bus */\n    if (virPCIDeviceGetParent(dev, &parent) < 0)\n        return -1;\n    if (!parent) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to find parent device for %s\"),\n                       dev->name);\n        return -1;\n    }\n    if ((parentfd = virPCIDeviceConfigOpenWrite(parent)) < 0)\n        goto out;\n\n    VIR_DEBUG(\"%s %s: doing a secondary bus reset\", dev->id, dev->name);\n\n    /* Save and restore the device's config space; we only do this\n     * for the supplied device since we refuse to do a reset if there\n     * are multiple devices/functions\n     */\n    if (virPCIDeviceRead(dev, cfgfd, 0, config_space, PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read PCI config space for %s\"),\n                       dev->name);\n        goto out;\n    }\n\n    /* Read the control register, set the reset flag, wait 200ms,\n     * unset the reset flag and wait 200ms.\n     */\n    ctl = virPCIDeviceRead16(dev, parentfd, PCI_BRIDGE_CONTROL);\n\n    virPCIDeviceWrite16(parent, parentfd, PCI_BRIDGE_CONTROL,\n                        ctl | PCI_BRIDGE_CTL_RESET);\n\n    g_usleep(200 * 1000); /* sleep 200ms */\n\n    virPCIDeviceWrite16(parent, parentfd, PCI_BRIDGE_CONTROL, ctl);\n\n    g_usleep(200 * 1000); /* sleep 200ms */\n\n    if (virPCIDeviceWrite(dev, cfgfd, 0, config_space, PCI_CONF_LEN) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to restore PCI config space for %s\"),\n                       dev->name);\n        goto out;\n    }\n    ret = 0;\n\n out:\n    virPCIDeviceConfigClose(parent, parentfd);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceGetParent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "754-767",
    "snippet": "static int\nvirPCIDeviceGetParent(virPCIDevicePtr dev, virPCIDevicePtr *parent)\n{\n    virPCIDevicePtr best = NULL;\n    int ret;\n\n    *parent = NULL;\n    ret = virPCIDeviceIterDevices(virPCIDeviceIsParent, dev, parent, &best);\n    if (ret == 1)\n        virPCIDeviceFree(best);\n    else if (ret == 0)\n        *parent = best;\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceFree",
          "args": [
            "best"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1439-1450",
          "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceIterDevices",
          "args": [
            "virPCIDeviceIsParent",
            "dev",
            "parent",
            "&best"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceIterDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "436-492",
          "snippet": "static int\nvirPCIDeviceIterDevices(virPCIDeviceIterPredicate predicate,\n                        virPCIDevicePtr dev,\n                        virPCIDevicePtr *matched,\n                        void *data)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = 0;\n    int rc;\n\n    *matched = NULL;\n\n    VIR_DEBUG(\"%s %s: iterating over \" PCI_SYSFS \"devices\", dev->id, dev->name);\n\n    if (virDirOpen(&dir, PCI_SYSFS \"devices\") < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &entry, PCI_SYSFS \"devices\")) > 0) {\n        unsigned int domain, bus, slot, function;\n        g_autoptr(virPCIDevice) check = NULL;\n        char *tmp;\n\n        /* expected format: <domain>:<bus>:<slot>.<function> */\n        if (/* domain */\n            virStrToLong_ui(entry->d_name, &tmp, 16, &domain) < 0 || *tmp != ':' ||\n            /* bus */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &bus) < 0 || *tmp != ':' ||\n            /* slot */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &slot) < 0 || *tmp != '.' ||\n            /* function */\n            virStrToLong_ui(tmp + 1, NULL, 16, &function) < 0) {\n            VIR_WARN(\"Unusual entry in \" PCI_SYSFS \"devices: %s\", entry->d_name);\n            continue;\n        }\n\n        check = virPCIDeviceNew(domain, bus, slot, function);\n        if (!check) {\n            ret = -1;\n            break;\n        }\n\n        rc = predicate(dev, check, data);\n        if (rc < 0) {\n            /* the predicate returned an error, bail */\n            ret = -1;\n            break;\n        } else if (rc == 1) {\n            VIR_DEBUG(\"%s %s: iter matched on %s\", dev->id, dev->name, check->name);\n            *matched = g_steal_pointer(&check);\n            ret = 1;\n            break;\n        }\n    }\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic int\nvirPCIDeviceIterDevices(virPCIDeviceIterPredicate predicate,\n                        virPCIDevicePtr dev,\n                        virPCIDevicePtr *matched,\n                        void *data)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = 0;\n    int rc;\n\n    *matched = NULL;\n\n    VIR_DEBUG(\"%s %s: iterating over \" PCI_SYSFS \"devices\", dev->id, dev->name);\n\n    if (virDirOpen(&dir, PCI_SYSFS \"devices\") < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &entry, PCI_SYSFS \"devices\")) > 0) {\n        unsigned int domain, bus, slot, function;\n        g_autoptr(virPCIDevice) check = NULL;\n        char *tmp;\n\n        /* expected format: <domain>:<bus>:<slot>.<function> */\n        if (/* domain */\n            virStrToLong_ui(entry->d_name, &tmp, 16, &domain) < 0 || *tmp != ':' ||\n            /* bus */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &bus) < 0 || *tmp != ':' ||\n            /* slot */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &slot) < 0 || *tmp != '.' ||\n            /* function */\n            virStrToLong_ui(tmp + 1, NULL, 16, &function) < 0) {\n            VIR_WARN(\"Unusual entry in \" PCI_SYSFS \"devices: %s\", entry->d_name);\n            continue;\n        }\n\n        check = virPCIDeviceNew(domain, bus, slot, function);\n        if (!check) {\n            ret = -1;\n            break;\n        }\n\n        rc = predicate(dev, check, data);\n        if (rc < 0) {\n            /* the predicate returned an error, bail */\n            ret = -1;\n            break;\n        } else if (rc == 1) {\n            VIR_DEBUG(\"%s %s: iter matched on %s\", dev->id, dev->name, check->name);\n            *matched = g_steal_pointer(&check);\n            ret = 1;\n            break;\n        }\n    }\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceGetParent(virPCIDevicePtr dev, virPCIDevicePtr *parent)\n{\n    virPCIDevicePtr best = NULL;\n    int ret;\n\n    *parent = NULL;\n    ret = virPCIDeviceIterDevices(virPCIDeviceIsParent, dev, parent, &best);\n    if (ret == 1)\n        virPCIDeviceFree(best);\n    else if (ret == 0)\n        *parent = best;\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceIsParent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "670-752",
    "snippet": "static int\nvirPCIDeviceIsParent(virPCIDevicePtr dev, virPCIDevicePtr check, void *data)\n{\n    uint16_t device_class;\n    uint8_t header_type, secondary, subordinate;\n    virPCIDevicePtr *best = data;\n    int ret = 0;\n    int fd;\n\n    if (dev->address.domain != check->address.domain)\n        return 0;\n\n    if ((fd = virPCIDeviceConfigOpenTry(check)) < 0)\n        return 0;\n\n    /* Is it a bridge? */\n    ret = virPCIDeviceReadClass(check, &device_class);\n    if (ret < 0 || device_class != PCI_CLASS_BRIDGE_PCI)\n        goto cleanup;\n\n    /* Is it a plane? */\n    header_type = virPCIDeviceRead8(check, fd, PCI_HEADER_TYPE);\n    if ((header_type & PCI_HEADER_TYPE_MASK) != PCI_HEADER_TYPE_BRIDGE)\n        goto cleanup;\n\n    secondary   = virPCIDeviceRead8(check, fd, PCI_SECONDARY_BUS);\n    subordinate = virPCIDeviceRead8(check, fd, PCI_SUBORDINATE_BUS);\n\n    VIR_DEBUG(\"%s %s: found parent device %s\", dev->id, dev->name, check->name);\n\n    /* if the secondary bus exactly equals the device's bus, then we found\n     * the direct parent.  No further work is necessary\n     */\n    if (dev->address.bus == secondary) {\n        ret = 1;\n        goto cleanup;\n    }\n\n    /* otherwise, SRIOV allows VFs to be on different buses than their PFs.\n     * In this case, what we need to do is look for the \"best\" match; i.e.\n     * the most restrictive match that still satisfies all of the conditions.\n     */\n    if (dev->address.bus > secondary && dev->address.bus <= subordinate) {\n        if (*best == NULL) {\n            *best = virPCIDeviceNew(check->address.domain,\n                                    check->address.bus,\n                                    check->address.slot,\n                                    check->address.function);\n            if (*best == NULL) {\n                ret = -1;\n                goto cleanup;\n            }\n        } else {\n            /* OK, we had already recorded a previous \"best\" match for the\n             * parent.  See if the current device is more restrictive than the\n             * best, and if so, make it the new best\n             */\n            int bestfd;\n            uint8_t best_secondary;\n\n            if ((bestfd = virPCIDeviceConfigOpenTry(*best)) < 0)\n                goto cleanup;\n            best_secondary = virPCIDeviceRead8(*best, bestfd, PCI_SECONDARY_BUS);\n            virPCIDeviceConfigClose(*best, bestfd);\n\n            if (secondary > best_secondary) {\n                virPCIDeviceFree(*best);\n                *best = virPCIDeviceNew(check->address.domain,\n                                        check->address.bus,\n                                        check->address.slot,\n                                        check->address.function);\n                if (*best == NULL) {\n                    ret = -1;\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(check, fd);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_SUBORDINATE_BUS     0x1a    /* BR12 3.2.5.4 Highest bus number behind the bridge */",
      "#define PCI_SECONDARY_BUS       0x19    /* BR12 3.2.5.3 Secondary bus number */",
      "#define PCI_CLASS_BRIDGE_PCI    0x0604",
      "#define PCI_HEADER_TYPE_MASK   0x7f",
      "#define PCI_HEADER_TYPE_BRIDGE 0x1",
      "#define PCI_HEADER_TYPE         0x0e    /* Header type */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceConfigClose",
          "args": [
            "check",
            "fd"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "320-327",
          "snippet": "static void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "check->address.domain",
            "check->address.bus",
            "check->address.slot",
            "check->address.function"
          ],
          "line": 737
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFree",
          "args": [
            "*best"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1439-1450",
          "snippet": "void\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvoid\nvirPCIDeviceFree(virPCIDevicePtr dev)\n{\n    if (!dev)\n        return;\n    VIR_DEBUG(\"%s %s: freeing\", dev->id, dev->name);\n    VIR_FREE(dev->name);\n    VIR_FREE(dev->path);\n    VIR_FREE(dev->used_by_drvname);\n    VIR_FREE(dev->used_by_domname);\n    VIR_FREE(dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead8",
          "args": [
            "*best",
            "bestfd",
            "PCI_SECONDARY_BUS"
          ],
          "line": 732
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "348-354",
          "snippet": "static uint8_t\nvirPCIDeviceRead8(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf;\n    virPCIDeviceRead(dev, cfgfd, pos, &buf, sizeof(buf));\n    return buf;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint8_t\nvirPCIDeviceRead8(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf;\n    virPCIDeviceRead(dev, cfgfd, pos, &buf, sizeof(buf));\n    return buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceConfigOpenTry",
          "args": [
            "*best"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigOpenTry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "308-312",
          "snippet": "static int\nvirPCIDeviceConfigOpenTry(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, true, false);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenTry(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, true, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: found parent device %s\"",
            "dev->id",
            "dev->name",
            "check->name"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceReadClass",
          "args": [
            "check",
            "&device_class"
          ],
          "line": 686
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceReadClass",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "372-396",
          "snippet": "static int\nvirPCIDeviceReadClass(virPCIDevicePtr dev, uint16_t *device_class)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *id_str = NULL;\n    unsigned int value;\n\n    if (!(path = virPCIFile(dev->name, \"class\")))\n        return -1;\n\n    /* class string is '0xNNNNNN\\n' ... i.e. 9 bytes */\n    if (virFileReadAll(path, 9, &id_str) < 0)\n        return -1;\n\n    id_str[8] = '\\0';\n    if (virStrToLong_ui(id_str, NULL, 16, &value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unusual value in %s/devices/%s/class: %s\"),\n                       PCI_SYSFS, dev->name, id_str);\n        return -1;\n    }\n\n    *device_class = (value >> 8) & 0xFFFF;\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic int\nvirPCIDeviceReadClass(virPCIDevicePtr dev, uint16_t *device_class)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *id_str = NULL;\n    unsigned int value;\n\n    if (!(path = virPCIFile(dev->name, \"class\")))\n        return -1;\n\n    /* class string is '0xNNNNNN\\n' ... i.e. 9 bytes */\n    if (virFileReadAll(path, 9, &id_str) < 0)\n        return -1;\n\n    id_str[8] = '\\0';\n    if (virStrToLong_ui(id_str, NULL, 16, &value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unusual value in %s/devices/%s/class: %s\"),\n                       PCI_SYSFS, dev->name, id_str);\n        return -1;\n    }\n\n    *device_class = (value >> 8) & 0xFFFF;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SUBORDINATE_BUS     0x1a    /* BR12 3.2.5.4 Highest bus number behind the bridge */\n#define PCI_SECONDARY_BUS       0x19    /* BR12 3.2.5.3 Secondary bus number */\n#define PCI_CLASS_BRIDGE_PCI    0x0604\n#define PCI_HEADER_TYPE_MASK   0x7f\n#define PCI_HEADER_TYPE_BRIDGE 0x1\n#define PCI_HEADER_TYPE         0x0e    /* Header type */\n\nstatic int\nvirPCIDeviceIsParent(virPCIDevicePtr dev, virPCIDevicePtr check, void *data)\n{\n    uint16_t device_class;\n    uint8_t header_type, secondary, subordinate;\n    virPCIDevicePtr *best = data;\n    int ret = 0;\n    int fd;\n\n    if (dev->address.domain != check->address.domain)\n        return 0;\n\n    if ((fd = virPCIDeviceConfigOpenTry(check)) < 0)\n        return 0;\n\n    /* Is it a bridge? */\n    ret = virPCIDeviceReadClass(check, &device_class);\n    if (ret < 0 || device_class != PCI_CLASS_BRIDGE_PCI)\n        goto cleanup;\n\n    /* Is it a plane? */\n    header_type = virPCIDeviceRead8(check, fd, PCI_HEADER_TYPE);\n    if ((header_type & PCI_HEADER_TYPE_MASK) != PCI_HEADER_TYPE_BRIDGE)\n        goto cleanup;\n\n    secondary   = virPCIDeviceRead8(check, fd, PCI_SECONDARY_BUS);\n    subordinate = virPCIDeviceRead8(check, fd, PCI_SUBORDINATE_BUS);\n\n    VIR_DEBUG(\"%s %s: found parent device %s\", dev->id, dev->name, check->name);\n\n    /* if the secondary bus exactly equals the device's bus, then we found\n     * the direct parent.  No further work is necessary\n     */\n    if (dev->address.bus == secondary) {\n        ret = 1;\n        goto cleanup;\n    }\n\n    /* otherwise, SRIOV allows VFs to be on different buses than their PFs.\n     * In this case, what we need to do is look for the \"best\" match; i.e.\n     * the most restrictive match that still satisfies all of the conditions.\n     */\n    if (dev->address.bus > secondary && dev->address.bus <= subordinate) {\n        if (*best == NULL) {\n            *best = virPCIDeviceNew(check->address.domain,\n                                    check->address.bus,\n                                    check->address.slot,\n                                    check->address.function);\n            if (*best == NULL) {\n                ret = -1;\n                goto cleanup;\n            }\n        } else {\n            /* OK, we had already recorded a previous \"best\" match for the\n             * parent.  See if the current device is more restrictive than the\n             * best, and if so, make it the new best\n             */\n            int bestfd;\n            uint8_t best_secondary;\n\n            if ((bestfd = virPCIDeviceConfigOpenTry(*best)) < 0)\n                goto cleanup;\n            best_secondary = virPCIDeviceRead8(*best, bestfd, PCI_SECONDARY_BUS);\n            virPCIDeviceConfigClose(*best, bestfd);\n\n            if (secondary > best_secondary) {\n                virPCIDeviceFree(*best);\n                *best = virPCIDeviceNew(check->address.domain,\n                                        check->address.bus,\n                                        check->address.slot,\n                                        check->address.function);\n                if (*best == NULL) {\n                    ret = -1;\n                    goto cleanup;\n                }\n            }\n        }\n    }\n\n cleanup:\n    virPCIDeviceConfigClose(check, fd);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceBusContainsActiveDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "658-667",
    "snippet": "static virPCIDevicePtr\nvirPCIDeviceBusContainsActiveDevices(virPCIDevicePtr dev,\n                                     virPCIDeviceList *inactiveDevs)\n{\n    virPCIDevicePtr active = NULL;\n    if (virPCIDeviceIterDevices(virPCIDeviceSharesBusWithActive,\n                                dev, &active, inactiveDevs) < 0)\n        return NULL;\n    return active;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceIterDevices",
          "args": [
            "virPCIDeviceSharesBusWithActive",
            "dev",
            "&active",
            "inactiveDevs"
          ],
          "line": 663
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceIterDevices",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "436-492",
          "snippet": "static int\nvirPCIDeviceIterDevices(virPCIDeviceIterPredicate predicate,\n                        virPCIDevicePtr dev,\n                        virPCIDevicePtr *matched,\n                        void *data)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = 0;\n    int rc;\n\n    *matched = NULL;\n\n    VIR_DEBUG(\"%s %s: iterating over \" PCI_SYSFS \"devices\", dev->id, dev->name);\n\n    if (virDirOpen(&dir, PCI_SYSFS \"devices\") < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &entry, PCI_SYSFS \"devices\")) > 0) {\n        unsigned int domain, bus, slot, function;\n        g_autoptr(virPCIDevice) check = NULL;\n        char *tmp;\n\n        /* expected format: <domain>:<bus>:<slot>.<function> */\n        if (/* domain */\n            virStrToLong_ui(entry->d_name, &tmp, 16, &domain) < 0 || *tmp != ':' ||\n            /* bus */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &bus) < 0 || *tmp != ':' ||\n            /* slot */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &slot) < 0 || *tmp != '.' ||\n            /* function */\n            virStrToLong_ui(tmp + 1, NULL, 16, &function) < 0) {\n            VIR_WARN(\"Unusual entry in \" PCI_SYSFS \"devices: %s\", entry->d_name);\n            continue;\n        }\n\n        check = virPCIDeviceNew(domain, bus, slot, function);\n        if (!check) {\n            ret = -1;\n            break;\n        }\n\n        rc = predicate(dev, check, data);\n        if (rc < 0) {\n            /* the predicate returned an error, bail */\n            ret = -1;\n            break;\n        } else if (rc == 1) {\n            VIR_DEBUG(\"%s %s: iter matched on %s\", dev->id, dev->name, check->name);\n            *matched = g_steal_pointer(&check);\n            ret = 1;\n            break;\n        }\n    }\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic int\nvirPCIDeviceIterDevices(virPCIDeviceIterPredicate predicate,\n                        virPCIDevicePtr dev,\n                        virPCIDevicePtr *matched,\n                        void *data)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = 0;\n    int rc;\n\n    *matched = NULL;\n\n    VIR_DEBUG(\"%s %s: iterating over \" PCI_SYSFS \"devices\", dev->id, dev->name);\n\n    if (virDirOpen(&dir, PCI_SYSFS \"devices\") < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &entry, PCI_SYSFS \"devices\")) > 0) {\n        unsigned int domain, bus, slot, function;\n        g_autoptr(virPCIDevice) check = NULL;\n        char *tmp;\n\n        /* expected format: <domain>:<bus>:<slot>.<function> */\n        if (/* domain */\n            virStrToLong_ui(entry->d_name, &tmp, 16, &domain) < 0 || *tmp != ':' ||\n            /* bus */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &bus) < 0 || *tmp != ':' ||\n            /* slot */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &slot) < 0 || *tmp != '.' ||\n            /* function */\n            virStrToLong_ui(tmp + 1, NULL, 16, &function) < 0) {\n            VIR_WARN(\"Unusual entry in \" PCI_SYSFS \"devices: %s\", entry->d_name);\n            continue;\n        }\n\n        check = virPCIDeviceNew(domain, bus, slot, function);\n        if (!check) {\n            ret = -1;\n            break;\n        }\n\n        rc = predicate(dev, check, data);\n        if (rc < 0) {\n            /* the predicate returned an error, bail */\n            ret = -1;\n            break;\n        } else if (rc == 1) {\n            VIR_DEBUG(\"%s %s: iter matched on %s\", dev->id, dev->name, check->name);\n            *matched = g_steal_pointer(&check);\n            ret = 1;\n            break;\n        }\n    }\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic virPCIDevicePtr\nvirPCIDeviceBusContainsActiveDevices(virPCIDevicePtr dev,\n                                     virPCIDeviceList *inactiveDevs)\n{\n    virPCIDevicePtr active = NULL;\n    if (virPCIDeviceIterDevices(virPCIDeviceSharesBusWithActive,\n                                dev, &active, inactiveDevs) < 0)\n        return NULL;\n    return active;\n}"
  },
  {
    "function_name": "virPCIDeviceSharesBusWithActive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "639-656",
    "snippet": "static int\nvirPCIDeviceSharesBusWithActive(virPCIDevicePtr dev, virPCIDevicePtr check, void *data)\n{\n    virPCIDeviceList *inactiveDevs = data;\n\n    /* Different domain, different bus, or simply identical device */\n    if (dev->address.domain != check->address.domain ||\n        dev->address.bus != check->address.bus ||\n        (dev->address.slot == check->address.slot &&\n         dev->address.function == check->address.function))\n        return 0;\n\n    /* same bus, but inactive, i.e. about to be assigned to guest */\n    if (inactiveDevs && virPCIDeviceListFind(inactiveDevs, check))\n        return 0;\n\n    return 1;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceListFind",
          "args": [
            "inactiveDevs",
            "check"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceListFind",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1708-1717",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nvirPCIDevicePtr\nvirPCIDeviceListFind(virPCIDeviceListPtr list, virPCIDevicePtr dev)\n{\n    int idx;\n\n    if ((idx = virPCIDeviceListFindIndex(list, dev)) >= 0)\n        return list->devs[idx];\n    else\n        return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceSharesBusWithActive(virPCIDevicePtr dev, virPCIDevicePtr check, void *data)\n{\n    virPCIDeviceList *inactiveDevs = data;\n\n    /* Different domain, different bus, or simply identical device */\n    if (dev->address.domain != check->address.domain ||\n        dev->address.bus != check->address.bus ||\n        (dev->address.slot == check->address.slot &&\n         dev->address.function == check->address.function))\n        return 0;\n\n    /* same bus, but inactive, i.e. about to be assigned to guest */\n    if (inactiveDevs && virPCIDeviceListFind(inactiveDevs, check))\n        return 0;\n\n    return 1;\n}"
  },
  {
    "function_name": "virPCIDeviceDetectPowerManagementReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "619-636",
    "snippet": "static unsigned int\nvirPCIDeviceDetectPowerManagementReset(virPCIDevicePtr dev, int cfgfd)\n{\n    if (dev->pci_pm_cap_pos) {\n        uint32_t ctl;\n\n        /* require the NO_SOFT_RESET bit is clear */\n        ctl = virPCIDeviceRead32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL);\n        if (!(ctl & PCI_PM_CTRL_NO_SOFT_RESET)) {\n            VIR_DEBUG(\"%s %s: detected PM reset capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    VIR_DEBUG(\"%s %s: no PM reset capability found\", dev->id, dev->name);\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_PM_CTRL_NO_SOFT_RESET 0x8  /* No reset for D3hot->D0 */",
      "#define PCI_PM_CTRL                4    /* PM control and status register */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: no PM reset capability found\"",
            "dev->id",
            "dev->name"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: detected PM reset capability\"",
            "dev->id",
            "dev->name"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead32",
          "args": [
            "dev",
            "cfgfd",
            "dev->pci_pm_cap_pos + PCI_PM_CTRL"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "364-370",
          "snippet": "static uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_PM_CTRL_NO_SOFT_RESET 0x8  /* No reset for D3hot->D0 */\n#define PCI_PM_CTRL                4    /* PM control and status register */\n\nstatic unsigned int\nvirPCIDeviceDetectPowerManagementReset(virPCIDevicePtr dev, int cfgfd)\n{\n    if (dev->pci_pm_cap_pos) {\n        uint32_t ctl;\n\n        /* require the NO_SOFT_RESET bit is clear */\n        ctl = virPCIDeviceRead32(dev, cfgfd, dev->pci_pm_cap_pos + PCI_PM_CTRL);\n        if (!(ctl & PCI_PM_CTRL_NO_SOFT_RESET)) {\n            VIR_DEBUG(\"%s %s: detected PM reset capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    VIR_DEBUG(\"%s %s: no PM reset capability found\", dev->id, dev->name);\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceDetectFunctionLevelReset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "560-613",
    "snippet": "static int\nvirPCIDeviceDetectFunctionLevelReset(virPCIDevicePtr dev, int cfgfd)\n{\n    uint32_t caps;\n    uint8_t pos;\n    g_autofree char *path = NULL;\n    int found;\n\n    /* The PCIe Function Level Reset capability allows\n     * individual device functions to be reset without\n     * affecting any other functions on the device or\n     * any other devices on the bus. This is only common\n     * on SR-IOV NICs at the moment.\n     */\n    if (dev->pcie_cap_pos) {\n        caps = virPCIDeviceRead32(dev, cfgfd, dev->pcie_cap_pos + PCI_EXP_DEVCAP);\n        if (caps & PCI_EXP_DEVCAP_FLR) {\n            VIR_DEBUG(\"%s %s: detected PCIe FLR capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    /* The PCI AF Function Level Reset capability is\n     * the same thing, except for conventional PCI\n     * devices. This is not common yet.\n     */\n    pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_AF);\n    if (pos) {\n        caps = virPCIDeviceRead16(dev, cfgfd, pos + PCI_AF_CAP);\n        if (caps & PCI_AF_CAP_FLR) {\n            VIR_DEBUG(\"%s %s: detected PCI FLR capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    /* there are some buggy devices that do support FLR, but forget to\n     * advertise that fact in their capabilities.  However, FLR is *required*\n     * to be present for virtual functions (VFs), so if we see that this\n     * device is a VF, we just assume FLR works\n     */\n\n    path = g_strdup_printf(PCI_SYSFS \"devices/%s/physfn\", dev->name);\n\n    found = virFileExists(path);\n    if (found) {\n        VIR_DEBUG(\"%s %s: buggy device didn't advertise FLR, but is a VF; forcing flr on\",\n                  dev->id, dev->name);\n        return 1;\n    }\n\n    VIR_DEBUG(\"%s %s: no FLR capability found\", dev->id, dev->name);\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_AF_CAP_FLR         0x2     /* Function Level Reset */",
      "#define PCI_AF_CAP              0x3     /* Advanced features capabilities */",
      "#define PCI_EXP_DEVCAP_FLR     (1<<28)  /* Function Level Reset */",
      "#define PCI_EXP_DEVCAP          0x4     /* Device capabilities */",
      "#define PCI_CAP_ID_AF           0x13    /* Advanced Features */",
      "#define PCI_SYSFS \"/sys/bus/pci/\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: no FLR capability found\"",
            "dev->id",
            "dev->name"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: buggy device didn't advertise FLR, but is a VF; forcing flr on\"",
            "dev->id",
            "dev->name"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "path"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "PCI_SYSFS \"devices/%s/physfn\"",
            "dev->name"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: detected PCI FLR capability\"",
            "dev->id",
            "dev->name"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead16",
          "args": [
            "dev",
            "cfgfd",
            "pos + PCI_AF_CAP"
          ],
          "line": 588
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "356-362",
          "snippet": "static uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIDeviceFindCapabilityOffset",
          "args": [
            "dev",
            "cfgfd",
            "PCI_CAP_ID_AF"
          ],
          "line": 586
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceFindCapabilityOffset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "494-529",
          "snippet": "static uint8_t\nvirPCIDeviceFindCapabilityOffset(virPCIDevicePtr dev,\n                                 int cfgfd,\n                                 unsigned int capability)\n{\n    uint16_t status;\n    uint8_t pos;\n\n    status = virPCIDeviceRead16(dev, cfgfd, PCI_STATUS);\n    if (!(status & PCI_STATUS_CAP_LIST))\n        return 0;\n\n    pos = virPCIDeviceRead8(dev, cfgfd, PCI_CAPABILITY_LIST);\n\n    /* Zero indicates last capability, capabilities can't\n     * be in the config space header and 0xff is returned\n     * by the kernel if we don't have access to this region\n     *\n     * Note: we're not handling loops or extended\n     * capabilities here.\n     */\n    while (pos >= PCI_CONF_HEADER_LEN && pos != 0xff) {\n        uint8_t capid = virPCIDeviceRead8(dev, cfgfd, pos);\n        if (capid == capability) {\n            VIR_DEBUG(\"%s %s: found cap 0x%.2x at 0x%.2x\",\n                      dev->id, dev->name, capability, pos);\n            return pos;\n        }\n\n        pos = virPCIDeviceRead8(dev, cfgfd, pos + 1);\n    }\n\n    VIR_DEBUG(\"%s %s: failed to find cap 0x%.2x\", dev->id, dev->name, capability);\n\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_CAPABILITY_LIST     0x34    /* Offset of first capability list entry */",
            "#define PCI_STATUS_CAP_LIST    0x10    /* Support Capability List */",
            "#define PCI_STATUS              0x06    /* 16 bits */",
            "#define PCI_CONF_HEADER_LEN     0x40"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_CAPABILITY_LIST     0x34    /* Offset of first capability list entry */\n#define PCI_STATUS_CAP_LIST    0x10    /* Support Capability List */\n#define PCI_STATUS              0x06    /* 16 bits */\n#define PCI_CONF_HEADER_LEN     0x40\n\nstatic uint8_t\nvirPCIDeviceFindCapabilityOffset(virPCIDevicePtr dev,\n                                 int cfgfd,\n                                 unsigned int capability)\n{\n    uint16_t status;\n    uint8_t pos;\n\n    status = virPCIDeviceRead16(dev, cfgfd, PCI_STATUS);\n    if (!(status & PCI_STATUS_CAP_LIST))\n        return 0;\n\n    pos = virPCIDeviceRead8(dev, cfgfd, PCI_CAPABILITY_LIST);\n\n    /* Zero indicates last capability, capabilities can't\n     * be in the config space header and 0xff is returned\n     * by the kernel if we don't have access to this region\n     *\n     * Note: we're not handling loops or extended\n     * capabilities here.\n     */\n    while (pos >= PCI_CONF_HEADER_LEN && pos != 0xff) {\n        uint8_t capid = virPCIDeviceRead8(dev, cfgfd, pos);\n        if (capid == capability) {\n            VIR_DEBUG(\"%s %s: found cap 0x%.2x at 0x%.2x\",\n                      dev->id, dev->name, capability, pos);\n            return pos;\n        }\n\n        pos = virPCIDeviceRead8(dev, cfgfd, pos + 1);\n    }\n\n    VIR_DEBUG(\"%s %s: failed to find cap 0x%.2x\", dev->id, dev->name, capability);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: detected PCIe FLR capability\"",
            "dev->id",
            "dev->name"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead32",
          "args": [
            "dev",
            "cfgfd",
            "dev->pcie_cap_pos + PCI_EXP_DEVCAP"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "364-370",
          "snippet": "static uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_AF_CAP_FLR         0x2     /* Function Level Reset */\n#define PCI_AF_CAP              0x3     /* Advanced features capabilities */\n#define PCI_EXP_DEVCAP_FLR     (1<<28)  /* Function Level Reset */\n#define PCI_EXP_DEVCAP          0x4     /* Device capabilities */\n#define PCI_CAP_ID_AF           0x13    /* Advanced Features */\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic int\nvirPCIDeviceDetectFunctionLevelReset(virPCIDevicePtr dev, int cfgfd)\n{\n    uint32_t caps;\n    uint8_t pos;\n    g_autofree char *path = NULL;\n    int found;\n\n    /* The PCIe Function Level Reset capability allows\n     * individual device functions to be reset without\n     * affecting any other functions on the device or\n     * any other devices on the bus. This is only common\n     * on SR-IOV NICs at the moment.\n     */\n    if (dev->pcie_cap_pos) {\n        caps = virPCIDeviceRead32(dev, cfgfd, dev->pcie_cap_pos + PCI_EXP_DEVCAP);\n        if (caps & PCI_EXP_DEVCAP_FLR) {\n            VIR_DEBUG(\"%s %s: detected PCIe FLR capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    /* The PCI AF Function Level Reset capability is\n     * the same thing, except for conventional PCI\n     * devices. This is not common yet.\n     */\n    pos = virPCIDeviceFindCapabilityOffset(dev, cfgfd, PCI_CAP_ID_AF);\n    if (pos) {\n        caps = virPCIDeviceRead16(dev, cfgfd, pos + PCI_AF_CAP);\n        if (caps & PCI_AF_CAP_FLR) {\n            VIR_DEBUG(\"%s %s: detected PCI FLR capability\", dev->id, dev->name);\n            return 1;\n        }\n    }\n\n    /* there are some buggy devices that do support FLR, but forget to\n     * advertise that fact in their capabilities.  However, FLR is *required*\n     * to be present for virtual functions (VFs), so if we see that this\n     * device is a VF, we just assume FLR works\n     */\n\n    path = g_strdup_printf(PCI_SYSFS \"devices/%s/physfn\", dev->name);\n\n    found = virFileExists(path);\n    if (found) {\n        VIR_DEBUG(\"%s %s: buggy device didn't advertise FLR, but is a VF; forcing flr on\",\n                  dev->id, dev->name);\n        return 1;\n    }\n\n    VIR_DEBUG(\"%s %s: no FLR capability found\", dev->id, dev->name);\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceFindExtendedCapabilityOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "531-555",
    "snippet": "static unsigned int\nvirPCIDeviceFindExtendedCapabilityOffset(virPCIDevicePtr dev,\n                                         int cfgfd,\n                                         unsigned int capability)\n{\n    int ttl;\n    unsigned int pos;\n    uint32_t header;\n\n    /* minimum 8 bytes per capability */\n    ttl = (PCI_EXT_CAP_LIMIT - PCI_EXT_CAP_BASE) / 8;\n    pos = PCI_EXT_CAP_BASE;\n\n    while (ttl > 0 && pos >= PCI_EXT_CAP_BASE) {\n        header = virPCIDeviceRead32(dev, cfgfd, pos);\n\n        if ((header & PCI_EXT_CAP_ID_MASK) == capability)\n            return pos;\n\n        pos = (header >> PCI_EXT_CAP_OFFSET_SHIFT) & PCI_EXT_CAP_OFFSET_MASK;\n        ttl--;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_EXT_CAP_OFFSET_MASK   0x00000ffc",
      "#define PCI_EXT_CAP_OFFSET_SHIFT  20",
      "#define PCI_EXT_CAP_ID_MASK       0x0000ffff",
      "#define PCI_EXT_CAP_LIMIT         0x1000",
      "#define PCI_EXT_CAP_BASE          0x100"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceRead32",
          "args": [
            "dev",
            "cfgfd",
            "pos"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "364-370",
          "snippet": "static uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_EXT_CAP_OFFSET_MASK   0x00000ffc\n#define PCI_EXT_CAP_OFFSET_SHIFT  20\n#define PCI_EXT_CAP_ID_MASK       0x0000ffff\n#define PCI_EXT_CAP_LIMIT         0x1000\n#define PCI_EXT_CAP_BASE          0x100\n\nstatic unsigned int\nvirPCIDeviceFindExtendedCapabilityOffset(virPCIDevicePtr dev,\n                                         int cfgfd,\n                                         unsigned int capability)\n{\n    int ttl;\n    unsigned int pos;\n    uint32_t header;\n\n    /* minimum 8 bytes per capability */\n    ttl = (PCI_EXT_CAP_LIMIT - PCI_EXT_CAP_BASE) / 8;\n    pos = PCI_EXT_CAP_BASE;\n\n    while (ttl > 0 && pos >= PCI_EXT_CAP_BASE) {\n        header = virPCIDeviceRead32(dev, cfgfd, pos);\n\n        if ((header & PCI_EXT_CAP_ID_MASK) == capability)\n            return pos;\n\n        pos = (header >> PCI_EXT_CAP_OFFSET_SHIFT) & PCI_EXT_CAP_OFFSET_MASK;\n        ttl--;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceFindCapabilityOffset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "494-529",
    "snippet": "static uint8_t\nvirPCIDeviceFindCapabilityOffset(virPCIDevicePtr dev,\n                                 int cfgfd,\n                                 unsigned int capability)\n{\n    uint16_t status;\n    uint8_t pos;\n\n    status = virPCIDeviceRead16(dev, cfgfd, PCI_STATUS);\n    if (!(status & PCI_STATUS_CAP_LIST))\n        return 0;\n\n    pos = virPCIDeviceRead8(dev, cfgfd, PCI_CAPABILITY_LIST);\n\n    /* Zero indicates last capability, capabilities can't\n     * be in the config space header and 0xff is returned\n     * by the kernel if we don't have access to this region\n     *\n     * Note: we're not handling loops or extended\n     * capabilities here.\n     */\n    while (pos >= PCI_CONF_HEADER_LEN && pos != 0xff) {\n        uint8_t capid = virPCIDeviceRead8(dev, cfgfd, pos);\n        if (capid == capability) {\n            VIR_DEBUG(\"%s %s: found cap 0x%.2x at 0x%.2x\",\n                      dev->id, dev->name, capability, pos);\n            return pos;\n        }\n\n        pos = virPCIDeviceRead8(dev, cfgfd, pos + 1);\n    }\n\n    VIR_DEBUG(\"%s %s: failed to find cap 0x%.2x\", dev->id, dev->name, capability);\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_CAPABILITY_LIST     0x34    /* Offset of first capability list entry */",
      "#define PCI_STATUS_CAP_LIST    0x10    /* Support Capability List */",
      "#define PCI_STATUS              0x06    /* 16 bits */",
      "#define PCI_CONF_HEADER_LEN     0x40"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: failed to find cap 0x%.2x\"",
            "dev->id",
            "dev->name",
            "capability"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead8",
          "args": [
            "dev",
            "cfgfd",
            "pos + 1"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "348-354",
          "snippet": "static uint8_t\nvirPCIDeviceRead8(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf;\n    virPCIDeviceRead(dev, cfgfd, pos, &buf, sizeof(buf));\n    return buf;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint8_t\nvirPCIDeviceRead8(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf;\n    virPCIDeviceRead(dev, cfgfd, pos, &buf, sizeof(buf));\n    return buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: found cap 0x%.2x at 0x%.2x\"",
            "dev->id",
            "dev->name",
            "capability",
            "pos"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceRead16",
          "args": [
            "dev",
            "cfgfd",
            "PCI_STATUS"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "356-362",
          "snippet": "static uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_CAPABILITY_LIST     0x34    /* Offset of first capability list entry */\n#define PCI_STATUS_CAP_LIST    0x10    /* Support Capability List */\n#define PCI_STATUS              0x06    /* 16 bits */\n#define PCI_CONF_HEADER_LEN     0x40\n\nstatic uint8_t\nvirPCIDeviceFindCapabilityOffset(virPCIDevicePtr dev,\n                                 int cfgfd,\n                                 unsigned int capability)\n{\n    uint16_t status;\n    uint8_t pos;\n\n    status = virPCIDeviceRead16(dev, cfgfd, PCI_STATUS);\n    if (!(status & PCI_STATUS_CAP_LIST))\n        return 0;\n\n    pos = virPCIDeviceRead8(dev, cfgfd, PCI_CAPABILITY_LIST);\n\n    /* Zero indicates last capability, capabilities can't\n     * be in the config space header and 0xff is returned\n     * by the kernel if we don't have access to this region\n     *\n     * Note: we're not handling loops or extended\n     * capabilities here.\n     */\n    while (pos >= PCI_CONF_HEADER_LEN && pos != 0xff) {\n        uint8_t capid = virPCIDeviceRead8(dev, cfgfd, pos);\n        if (capid == capability) {\n            VIR_DEBUG(\"%s %s: found cap 0x%.2x at 0x%.2x\",\n                      dev->id, dev->name, capability, pos);\n            return pos;\n        }\n\n        pos = virPCIDeviceRead8(dev, cfgfd, pos + 1);\n    }\n\n    VIR_DEBUG(\"%s %s: failed to find cap 0x%.2x\", dev->id, dev->name, capability);\n\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceIterDevices",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "436-492",
    "snippet": "static int\nvirPCIDeviceIterDevices(virPCIDeviceIterPredicate predicate,\n                        virPCIDevicePtr dev,\n                        virPCIDevicePtr *matched,\n                        void *data)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = 0;\n    int rc;\n\n    *matched = NULL;\n\n    VIR_DEBUG(\"%s %s: iterating over \" PCI_SYSFS \"devices\", dev->id, dev->name);\n\n    if (virDirOpen(&dir, PCI_SYSFS \"devices\") < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &entry, PCI_SYSFS \"devices\")) > 0) {\n        unsigned int domain, bus, slot, function;\n        g_autoptr(virPCIDevice) check = NULL;\n        char *tmp;\n\n        /* expected format: <domain>:<bus>:<slot>.<function> */\n        if (/* domain */\n            virStrToLong_ui(entry->d_name, &tmp, 16, &domain) < 0 || *tmp != ':' ||\n            /* bus */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &bus) < 0 || *tmp != ':' ||\n            /* slot */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &slot) < 0 || *tmp != '.' ||\n            /* function */\n            virStrToLong_ui(tmp + 1, NULL, 16, &function) < 0) {\n            VIR_WARN(\"Unusual entry in \" PCI_SYSFS \"devices: %s\", entry->d_name);\n            continue;\n        }\n\n        check = virPCIDeviceNew(domain, bus, slot, function);\n        if (!check) {\n            ret = -1;\n            break;\n        }\n\n        rc = predicate(dev, check, data);\n        if (rc < 0) {\n            /* the predicate returned an error, bail */\n            ret = -1;\n            break;\n        } else if (rc == 1) {\n            VIR_DEBUG(\"%s %s: iter matched on %s\", dev->id, dev->name, check->name);\n            *matched = g_steal_pointer(&check);\n            ret = 1;\n            break;\n        }\n    }\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_SYSFS \"/sys/bus/pci/\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DIR_CLOSE",
          "args": [
            "dir"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&check"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: iter matched on %s\"",
            "dev->id",
            "dev->name",
            "check->name"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "predicate",
          "args": [
            "dev",
            "check",
            "data"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virPCIDeviceNew",
          "args": [
            "domain",
            "bus",
            "slot",
            "function"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "1364-1416",
          "snippet": "virPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nvirPCIDevicePtr\nvirPCIDeviceNew(unsigned int domain,\n                unsigned int bus,\n                unsigned int slot,\n                unsigned int function)\n{\n    g_autoptr(virPCIDevice) dev = NULL;\n    g_autofree char *vendor = NULL;\n    g_autofree char *product = NULL;\n\n    if (VIR_ALLOC(dev) < 0)\n        return NULL;\n\n    dev->address.domain = domain;\n    dev->address.bus = bus;\n    dev->address.slot = slot;\n    dev->address.function = function;\n\n    dev->name = g_strdup_printf(VIR_PCI_DEVICE_ADDRESS_FMT, domain, bus, slot,\n                                function);\n\n    dev->path = g_strdup_printf(PCI_SYSFS \"devices/%s/config\", dev->name);\n\n    if (!virFileExists(dev->path)) {\n        virReportSystemError(errno,\n                             _(\"Device %s not found: could not access %s\"),\n                             dev->name, dev->path);\n        return NULL;\n    }\n\n    vendor  = virPCIDeviceReadID(dev, \"vendor\");\n    product = virPCIDeviceReadID(dev, \"device\");\n\n    if (!vendor || !product) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Failed to read product/vendor ID for %s\"),\n                       dev->name);\n        return NULL;\n    }\n\n    /* strings contain '0x' prefix */\n    if (g_snprintf(dev->id, sizeof(dev->id), \"%s %s\", &vendor[2],\n                   &product[2]) >= sizeof(dev->id)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"dev->id buffer overflow: %s %s\"),\n                       &vendor[2], &product[2]);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"%s %s: initialized\", dev->id, dev->name);\n\n    return g_steal_pointer(&dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unusual entry in \" PCI_SYSFS \"devices: %s\"",
            "entry->d_name"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "tmp + 1",
            "NULL",
            "16",
            "&function"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirRead",
          "args": [
            "dir",
            "&entry",
            "PCI_SYSFS \"devices\""
          ],
          "line": 454
        },
        "resolved": true,
        "details": {
          "function_name": "virDirRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2940-2954",
          "snippet": "int virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint virDirRead(DIR *dirp, struct dirent **ent, const char *name)\n{\n    do {\n        errno = 0;\n        *ent = readdir(dirp); /* exempt from syntax-check */\n        if (!*ent && errno) {\n            if (name)\n                virReportSystemError(errno, _(\"Unable to read directory '%s'\"),\n                                     name);\n            return -1;\n        }\n    } while (*ent && (STREQ((*ent)->d_name, \".\") ||\n                      STREQ((*ent)->d_name, \"..\")));\n    return !!*ent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDirOpen",
          "args": [
            "&dir",
            "PCI_SYSFS \"devices\""
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "virDirOpenQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2914-2918",
          "snippet": "int\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirDirOpenQuiet(DIR **dirp, const char *name)\n{\n    return virDirOpenInternal(dirp, name, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: iterating over \" PCI_SYSFS \"devices\"",
            "dev->id",
            "dev->name"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic int\nvirPCIDeviceIterDevices(virPCIDeviceIterPredicate predicate,\n                        virPCIDevicePtr dev,\n                        virPCIDevicePtr *matched,\n                        void *data)\n{\n    DIR *dir;\n    struct dirent *entry;\n    int ret = 0;\n    int rc;\n\n    *matched = NULL;\n\n    VIR_DEBUG(\"%s %s: iterating over \" PCI_SYSFS \"devices\", dev->id, dev->name);\n\n    if (virDirOpen(&dir, PCI_SYSFS \"devices\") < 0)\n        return -1;\n\n    while ((ret = virDirRead(dir, &entry, PCI_SYSFS \"devices\")) > 0) {\n        unsigned int domain, bus, slot, function;\n        g_autoptr(virPCIDevice) check = NULL;\n        char *tmp;\n\n        /* expected format: <domain>:<bus>:<slot>.<function> */\n        if (/* domain */\n            virStrToLong_ui(entry->d_name, &tmp, 16, &domain) < 0 || *tmp != ':' ||\n            /* bus */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &bus) < 0 || *tmp != ':' ||\n            /* slot */\n            virStrToLong_ui(tmp + 1, &tmp, 16, &slot) < 0 || *tmp != '.' ||\n            /* function */\n            virStrToLong_ui(tmp + 1, NULL, 16, &function) < 0) {\n            VIR_WARN(\"Unusual entry in \" PCI_SYSFS \"devices: %s\", entry->d_name);\n            continue;\n        }\n\n        check = virPCIDeviceNew(domain, bus, slot, function);\n        if (!check) {\n            ret = -1;\n            break;\n        }\n\n        rc = predicate(dev, check, data);\n        if (rc < 0) {\n            /* the predicate returned an error, bail */\n            ret = -1;\n            break;\n        } else if (rc == 1) {\n            VIR_DEBUG(\"%s %s: iter matched on %s\", dev->id, dev->name, check->name);\n            *matched = g_steal_pointer(&check);\n            ret = 1;\n            break;\n        }\n    }\n    VIR_DIR_CLOSE(dir);\n    return ret;\n}"
  },
  {
    "function_name": "virPCIDeviceWrite32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "421-426",
    "snippet": "static void\nvirPCIDeviceWrite32(virPCIDevicePtr dev, int cfgfd, unsigned int pos, uint32_t val)\n{\n    uint8_t buf[4] = { (val >> 0), (val >> 8), (val >> 16), (val >> 24) };\n    virPCIDeviceWrite(dev, cfgfd, pos, &buf[0], sizeof(buf));\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceWrite",
          "args": [
            "dev",
            "cfgfd",
            "pos",
            "&buf[0]",
            "sizeof(buf)"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "398-412",
          "snippet": "static int\nvirPCIDeviceWrite(virPCIDevicePtr dev,\n                  int cfgfd,\n                  unsigned int pos,\n                  uint8_t *buf,\n                  unsigned int buflen)\n{\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        safewrite(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to write to '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceWrite(virPCIDevicePtr dev,\n                  int cfgfd,\n                  unsigned int pos,\n                  uint8_t *buf,\n                  unsigned int buflen)\n{\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        safewrite(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to write to '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceWrite32(virPCIDevicePtr dev, int cfgfd, unsigned int pos, uint32_t val)\n{\n    uint8_t buf[4] = { (val >> 0), (val >> 8), (val >> 16), (val >> 24) };\n    virPCIDeviceWrite(dev, cfgfd, pos, &buf[0], sizeof(buf));\n}"
  },
  {
    "function_name": "virPCIDeviceWrite16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "414-419",
    "snippet": "static void\nvirPCIDeviceWrite16(virPCIDevicePtr dev, int cfgfd, unsigned int pos, uint16_t val)\n{\n    uint8_t buf[2] = { (val >> 0), (val >> 8) };\n    virPCIDeviceWrite(dev, cfgfd, pos, &buf[0], sizeof(buf));\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceWrite",
          "args": [
            "dev",
            "cfgfd",
            "pos",
            "&buf[0]",
            "sizeof(buf)"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "398-412",
          "snippet": "static int\nvirPCIDeviceWrite(virPCIDevicePtr dev,\n                  int cfgfd,\n                  unsigned int pos,\n                  uint8_t *buf,\n                  unsigned int buflen)\n{\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        safewrite(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to write to '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceWrite(virPCIDevicePtr dev,\n                  int cfgfd,\n                  unsigned int pos,\n                  uint8_t *buf,\n                  unsigned int buflen)\n{\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        safewrite(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to write to '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceWrite16(virPCIDevicePtr dev, int cfgfd, unsigned int pos, uint16_t val)\n{\n    uint8_t buf[2] = { (val >> 0), (val >> 8) };\n    virPCIDeviceWrite(dev, cfgfd, pos, &buf[0], sizeof(buf));\n}"
  },
  {
    "function_name": "virPCIDeviceWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "398-412",
    "snippet": "static int\nvirPCIDeviceWrite(virPCIDevicePtr dev,\n                  int cfgfd,\n                  unsigned int pos,\n                  uint8_t *buf,\n                  unsigned int buflen)\n{\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        safewrite(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to write to '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to write to '%s' : %s\"",
            "dev->path",
            "g_strerror(errno)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safewrite",
          "args": [
            "cfgfd",
            "buf",
            "buflen"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "safewrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1093-1111",
          "snippet": "ssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nssize_t\nsafewrite(int fd, const void *buf, size_t count)\n{\n    size_t nwritten = 0;\n    while (count > 0) {\n        ssize_t r = write(fd, buf, count);\n\n        if (r < 0 && errno == EINTR)\n            continue;\n        if (r < 0)\n            return r;\n        if (r == 0)\n            return nwritten;\n        buf = (const char *)buf + r;\n        count -= r;\n        nwritten += r;\n    }\n    return nwritten;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "cfgfd",
            "pos",
            "SEEK_SET"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceWrite(virPCIDevicePtr dev,\n                  int cfgfd,\n                  unsigned int pos,\n                  uint8_t *buf,\n                  unsigned int buflen)\n{\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        safewrite(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to write to '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceReadClass",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "372-396",
    "snippet": "static int\nvirPCIDeviceReadClass(virPCIDevicePtr dev, uint16_t *device_class)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *id_str = NULL;\n    unsigned int value;\n\n    if (!(path = virPCIFile(dev->name, \"class\")))\n        return -1;\n\n    /* class string is '0xNNNNNN\\n' ... i.e. 9 bytes */\n    if (virFileReadAll(path, 9, &id_str) < 0)\n        return -1;\n\n    id_str[8] = '\\0';\n    if (virStrToLong_ui(id_str, NULL, 16, &value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unusual value in %s/devices/%s/class: %s\"),\n                       PCI_SYSFS, dev->name, id_str);\n        return -1;\n    }\n\n    *device_class = (value >> 8) & 0xFFFF;\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_SYSFS \"/sys/bus/pci/\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unusual value in %s/devices/%s/class: %s\")",
            "PCI_SYSFS",
            "dev->name",
            "id_str"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unusual value in %s/devices/%s/class: %s\""
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStrToLong_ui",
          "args": [
            "id_str",
            "NULL",
            "16",
            "&value"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "virStrToLong_uip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstring.c",
          "lines": "444-461",
          "snippet": "int\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virstring.h\"",
            "# include <xlocale.h>",
            "#include <locale.h>",
            "#include <glib/gprintf.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"virbuffer.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virstring.h\"\n# include <xlocale.h>\n#include <locale.h>\n#include <glib/gprintf.h>\n#include <config.h>\n\nint\nvirStrToLong_uip(char const *s, char **end_ptr, int base, unsigned int *result)\n{\n    unsigned long int val;\n    char *p;\n    bool err = false;\n\n    errno = 0;\n    val = strtoul(s, &p, base); /* exempt from syntax-check */\n    err = (memchr(s, '-', p - s) ||\n           errno || (!end_ptr && *p) || p == s || (unsigned int) val != val);\n    if (end_ptr)\n        *end_ptr = p;\n    if (err)\n        return -1;\n    *result = val;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileReadAll",
          "args": [
            "path",
            "9",
            "&id_str"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "virFileReadAllQuiet",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1459-1472",
          "snippet": "int\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileReadAllQuiet(const char *path, int maxlen, char **buf)\n{\n    int fd = open(path, O_RDONLY);\n    if (fd < 0)\n        return -errno;\n\n    int len = virFileReadLimFD(fd, maxlen, buf);\n    VIR_FORCE_CLOSE(fd);\n    if (len < 0)\n        return -errno;\n\n    return len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIFile",
          "args": [
            "dev->name",
            "\"class\""
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "219-226",
          "snippet": "static char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic int\nvirPCIDeviceReadClass(virPCIDevicePtr dev, uint16_t *device_class)\n{\n    g_autofree char *path = NULL;\n    g_autofree char *id_str = NULL;\n    unsigned int value;\n\n    if (!(path = virPCIFile(dev->name, \"class\")))\n        return -1;\n\n    /* class string is '0xNNNNNN\\n' ... i.e. 9 bytes */\n    if (virFileReadAll(path, 9, &id_str) < 0)\n        return -1;\n\n    id_str[8] = '\\0';\n    if (virStrToLong_ui(id_str, NULL, 16, &value) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unusual value in %s/devices/%s/class: %s\"),\n                       PCI_SYSFS, dev->name, id_str);\n        return -1;\n    }\n\n    *device_class = (value >> 8) & 0xFFFF;\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceRead32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "364-370",
    "snippet": "static uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceRead",
          "args": [
            "dev",
            "cfgfd",
            "pos",
            "&buf[0]",
            "sizeof(buf)"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "330-346",
          "snippet": "static int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint32_t\nvirPCIDeviceRead32(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[4];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8) | (buf[2] << 16) | (buf[3] << 24);\n}"
  },
  {
    "function_name": "virPCIDeviceRead16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "356-362",
    "snippet": "static uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceRead",
          "args": [
            "dev",
            "cfgfd",
            "pos",
            "&buf[0]",
            "sizeof(buf)"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "330-346",
          "snippet": "static int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint16_t\nvirPCIDeviceRead16(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf[2];\n    virPCIDeviceRead(dev, cfgfd, pos, &buf[0], sizeof(buf));\n    return (buf[0] << 0) | (buf[1] << 8);\n}"
  },
  {
    "function_name": "virPCIDeviceRead8",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "348-354",
    "snippet": "static uint8_t\nvirPCIDeviceRead8(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf;\n    virPCIDeviceRead(dev, cfgfd, pos, &buf, sizeof(buf));\n    return buf;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceRead",
          "args": [
            "dev",
            "cfgfd",
            "pos",
            "&buf",
            "sizeof(buf)"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceRead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "330-346",
          "snippet": "static int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic uint8_t\nvirPCIDeviceRead8(virPCIDevicePtr dev, int cfgfd, unsigned int pos)\n{\n    uint8_t buf;\n    virPCIDeviceRead(dev, cfgfd, pos, &buf, sizeof(buf));\n    return buf;\n}"
  },
  {
    "function_name": "virPCIDeviceRead",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "330-346",
    "snippet": "static int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to read from '%s' : %s\"",
            "dev->path",
            "g_strerror(errno)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "saferead",
          "args": [
            "cfgfd",
            "buf",
            "buflen"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "saferead_lim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1330-1372",
          "snippet": "static char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic char *\nsaferead_lim(int fd, size_t max_len, size_t *length)\n{\n    char *buf = NULL;\n    size_t alloc = 0;\n    size_t size = 0;\n    int save_errno;\n\n    for (;;) {\n        int count;\n        int requested;\n\n        if (size + BUFSIZ + 1 > alloc) {\n            alloc += alloc / 2;\n            if (alloc < size + BUFSIZ + 1)\n                alloc = size + BUFSIZ + 1;\n\n            if (VIR_REALLOC_N(buf, alloc) < 0) {\n                save_errno = errno;\n                break;\n            }\n        }\n\n        /* Ensure that (size + requested <= max_len); */\n        requested = MIN(size < max_len ? max_len - size : 0,\n                        alloc - size - 1);\n        count = saferead(fd, buf + size, requested);\n        size += count;\n\n        if (count != requested || requested == 0) {\n            save_errno = errno;\n            if (count < 0)\n                break;\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n        }\n    }\n\n    VIR_FREE(buf);\n    errno = save_errno;\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "cfgfd",
            "pos",
            "SEEK_SET"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "buf",
            "0",
            "buflen"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceRead(virPCIDevicePtr dev,\n                 int cfgfd,\n                 unsigned int pos,\n                 uint8_t *buf,\n                 unsigned int buflen)\n{\n    memset(buf, 0, buflen);\n\n    if (lseek(cfgfd, pos, SEEK_SET) != pos ||\n        saferead(cfgfd, buf, buflen) != buflen) {\n        VIR_WARN(\"Failed to read from '%s' : %s\", dev->path,\n                 g_strerror(errno));\n        return -1;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "virPCIDeviceConfigClose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "320-327",
    "snippet": "static void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to close config space file '%s': %s\"",
            "dev->path",
            "g_strerror(errno)"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_CLOSE",
          "args": [
            "cfgfd"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic void\nvirPCIDeviceConfigClose(virPCIDevicePtr dev, int cfgfd)\n{\n    if (VIR_CLOSE(cfgfd) < 0) {\n        VIR_WARN(\"Failed to close config space file '%s': %s\",\n                 dev->path, g_strerror(errno));\n    }\n}"
  },
  {
    "function_name": "virPCIDeviceConfigOpenWrite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "314-318",
    "snippet": "static int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceConfigOpenInternal",
          "args": [
            "dev",
            "false",
            "true"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigOpenInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "279-300",
          "snippet": "static int\nvirPCIDeviceConfigOpenInternal(virPCIDevicePtr dev, bool readonly, bool fatal)\n{\n    int fd;\n\n    fd = open(dev->path, readonly ? O_RDONLY : O_RDWR);\n\n    if (fd < 0) {\n        if (fatal) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open config space file '%s'\"),\n                                 dev->path);\n        } else {\n            VIR_WARN(\"Failed to open config space file '%s': %s\",\n                     dev->path, g_strerror(errno));\n        }\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: opened %s\", dev->id, dev->name, dev->path);\n    return fd;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenInternal(virPCIDevicePtr dev, bool readonly, bool fatal)\n{\n    int fd;\n\n    fd = open(dev->path, readonly ? O_RDONLY : O_RDWR);\n\n    if (fd < 0) {\n        if (fatal) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open config space file '%s'\"),\n                                 dev->path);\n        } else {\n            VIR_WARN(\"Failed to open config space file '%s': %s\",\n                     dev->path, g_strerror(errno));\n        }\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: opened %s\", dev->id, dev->name, dev->path);\n    return fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenWrite(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, false, true);\n}"
  },
  {
    "function_name": "virPCIDeviceConfigOpenTry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "308-312",
    "snippet": "static int\nvirPCIDeviceConfigOpenTry(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, true, false);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceConfigOpenInternal",
          "args": [
            "dev",
            "true",
            "false"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigOpenInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "279-300",
          "snippet": "static int\nvirPCIDeviceConfigOpenInternal(virPCIDevicePtr dev, bool readonly, bool fatal)\n{\n    int fd;\n\n    fd = open(dev->path, readonly ? O_RDONLY : O_RDWR);\n\n    if (fd < 0) {\n        if (fatal) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open config space file '%s'\"),\n                                 dev->path);\n        } else {\n            VIR_WARN(\"Failed to open config space file '%s': %s\",\n                     dev->path, g_strerror(errno));\n        }\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: opened %s\", dev->id, dev->name, dev->path);\n    return fd;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenInternal(virPCIDevicePtr dev, bool readonly, bool fatal)\n{\n    int fd;\n\n    fd = open(dev->path, readonly ? O_RDONLY : O_RDWR);\n\n    if (fd < 0) {\n        if (fatal) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open config space file '%s'\"),\n                                 dev->path);\n        } else {\n            VIR_WARN(\"Failed to open config space file '%s': %s\",\n                     dev->path, g_strerror(errno));\n        }\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: opened %s\", dev->id, dev->name, dev->path);\n    return fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenTry(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, true, false);\n}"
  },
  {
    "function_name": "virPCIDeviceConfigOpen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "302-306",
    "snippet": "static int\nvirPCIDeviceConfigOpen(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, true, true);\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virPCIDeviceConfigOpenInternal",
          "args": [
            "dev",
            "true",
            "true"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIDeviceConfigOpenInternal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "279-300",
          "snippet": "static int\nvirPCIDeviceConfigOpenInternal(virPCIDevicePtr dev, bool readonly, bool fatal)\n{\n    int fd;\n\n    fd = open(dev->path, readonly ? O_RDONLY : O_RDWR);\n\n    if (fd < 0) {\n        if (fatal) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open config space file '%s'\"),\n                                 dev->path);\n        } else {\n            VIR_WARN(\"Failed to open config space file '%s': %s\",\n                     dev->path, g_strerror(errno));\n        }\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: opened %s\", dev->id, dev->name, dev->path);\n    return fd;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenInternal(virPCIDevicePtr dev, bool readonly, bool fatal)\n{\n    int fd;\n\n    fd = open(dev->path, readonly ? O_RDONLY : O_RDWR);\n\n    if (fd < 0) {\n        if (fatal) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open config space file '%s'\"),\n                                 dev->path);\n        } else {\n            VIR_WARN(\"Failed to open config space file '%s': %s\",\n                     dev->path, g_strerror(errno));\n        }\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: opened %s\", dev->id, dev->name, dev->path);\n    return fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpen(virPCIDevicePtr dev)\n{\n    return virPCIDeviceConfigOpenInternal(dev, true, true);\n}"
  },
  {
    "function_name": "virPCIDeviceConfigOpenInternal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "279-300",
    "snippet": "static int\nvirPCIDeviceConfigOpenInternal(virPCIDevicePtr dev, bool readonly, bool fatal)\n{\n    int fd;\n\n    fd = open(dev->path, readonly ? O_RDONLY : O_RDWR);\n\n    if (fd < 0) {\n        if (fatal) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open config space file '%s'\"),\n                                 dev->path);\n        } else {\n            VIR_WARN(\"Failed to open config space file '%s': %s\",\n                     dev->path, g_strerror(errno));\n        }\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: opened %s\", dev->id, dev->name, dev->path);\n    return fd;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"%s %s: opened %s\"",
            "dev->id",
            "dev->name",
            "dev->path"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Failed to open config space file '%s': %s\"",
            "dev->path",
            "g_strerror(errno)"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportSystemError",
          "args": [
            "errno",
            "_(\"Failed to open config space file '%s'\")",
            "dev->path"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Failed to open config space file '%s'\""
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "dev->path",
            "readonly ? O_RDONLY : O_RDWR"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFdopen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "164-177",
          "snippet": "FILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nFILE *virFileFdopen(int *fdptr, const char *mode)\n{\n    FILE *file = NULL;\n\n    if (*fdptr >= 0) {\n        file = fdopen(*fdptr, mode);\n        if (file)\n            *fdptr = -1;\n    } else {\n        errno = EBADF;\n    }\n\n    return file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int\nvirPCIDeviceConfigOpenInternal(virPCIDevicePtr dev, bool readonly, bool fatal)\n{\n    int fd;\n\n    fd = open(dev->path, readonly ? O_RDONLY : O_RDWR);\n\n    if (fd < 0) {\n        if (fatal) {\n            virReportSystemError(errno,\n                                 _(\"Failed to open config space file '%s'\"),\n                                 dev->path);\n        } else {\n            VIR_WARN(\"Failed to open config space file '%s': %s\",\n                     dev->path, g_strerror(errno));\n        }\n        return -1;\n    }\n\n    VIR_DEBUG(\"%s %s: opened %s\", dev->id, dev->name, dev->path);\n    return fd;\n}"
  },
  {
    "function_name": "virPCIDeviceGetDriverPathAndName",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "236-276",
    "snippet": "int\nvirPCIDeviceGetDriverPathAndName(virPCIDevicePtr dev, char **path, char **name)\n{\n    int ret = -1;\n    g_autofree char *drvlink = NULL;\n\n    *path = *name = NULL;\n    /* drvlink = \"/sys/bus/pci/dddd:bb:ss.ff/driver\" */\n    if (!(drvlink = virPCIFile(dev->name, \"driver\")))\n        goto cleanup;\n\n    if (!virFileExists(drvlink)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileIsLink(drvlink) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s driver file %s is not a symlink\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    if (virFileResolveLink(drvlink, path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s driver symlink %s\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    /* path = \"/sys/bus/pci/drivers/${drivername}\" */\n\n    *name = g_path_get_basename(*path);\n    /* name = \"${drivername}\" */\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(*path);\n        VIR_FREE(*name);\n    }\n    return ret;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*name"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "*path"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_path_get_basename",
          "args": [
            "*path"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Unable to resolve device %s driver symlink %s\")",
            "dev->name",
            "drvlink"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Unable to resolve device %s driver symlink %s\""
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileResolveLink",
          "args": [
            "drvlink",
            "path"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "virFileResolveLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1608-1612",
          "snippet": "int\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileResolveLink(const char *linkpath, char **resultpath)\n{\n    return virFileResolveLinkHelper(linkpath, false, resultpath);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"Invalid device %s driver file %s is not a symlink\")",
            "dev->name",
            "drvlink"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileIsLink",
          "args": [
            "drvlink"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "virFileIsLink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1633-1649",
          "snippet": "int\nvirFileIsLink(const char *linkpath)\n{\n    GStatBuf st;\n\n    /* Still do this on Windows so we report\n     * errors like ENOENT, etc\n     */\n    if (g_lstat(linkpath, &st) < 0)\n        return -errno;\n\n#ifndef WIN32\n    return S_ISLNK(st.st_mode) != 0;\n#else /* WIN32 */\n    return 0;\n#endif /* WIN32 */\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileIsLink(const char *linkpath)\n{\n    GStatBuf st;\n\n    /* Still do this on Windows so we report\n     * errors like ENOENT, etc\n     */\n    if (g_lstat(linkpath, &st) < 0)\n        return -errno;\n\n#ifndef WIN32\n    return S_ISLNK(st.st_mode) != 0;\n#else /* WIN32 */\n    return 0;\n#endif /* WIN32 */\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileExists",
          "args": [
            "drvlink"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "virFileExists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1873-1877",
          "snippet": "bool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nbool\nvirFileExists(const char *path)\n{\n    return access(path, F_OK) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virPCIFile",
          "args": [
            "dev->name",
            "\"driver\""
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "virPCIFile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
          "lines": "219-226",
          "snippet": "static char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}",
          "includes": [
            "#include \"viralloc.h\"",
            "#include \"virstring.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"virlog.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <inttypes.h>",
            "#include <fcntl.h>",
            "#include <dirent.h>",
            "#include \"virnetdev.h\"",
            "#include \"virpci.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define PCI_SYSFS \"/sys/bus/pci/\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nint\nvirPCIDeviceGetDriverPathAndName(virPCIDevicePtr dev, char **path, char **name)\n{\n    int ret = -1;\n    g_autofree char *drvlink = NULL;\n\n    *path = *name = NULL;\n    /* drvlink = \"/sys/bus/pci/dddd:bb:ss.ff/driver\" */\n    if (!(drvlink = virPCIFile(dev->name, \"driver\")))\n        goto cleanup;\n\n    if (!virFileExists(drvlink)) {\n        ret = 0;\n        goto cleanup;\n    }\n\n    if (virFileIsLink(drvlink) != 1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Invalid device %s driver file %s is not a symlink\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    if (virFileResolveLink(drvlink, path) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unable to resolve device %s driver symlink %s\"),\n                       dev->name, drvlink);\n        goto cleanup;\n    }\n    /* path = \"/sys/bus/pci/drivers/${drivername}\" */\n\n    *name = g_path_get_basename(*path);\n    /* name = \"${drivername}\" */\n\n    ret = 0;\n cleanup:\n    if (ret < 0) {\n        VIR_FREE(*path);\n        VIR_FREE(*name);\n    }\n    return ret;\n}"
  },
  {
    "function_name": "virPCIFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "219-226",
    "snippet": "static char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_SYSFS \"/sys/bus/pci/\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "PCI_SYSFS \"devices/%s/%s\"",
            "device",
            "file"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIFile(const char *device, const char *file)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"devices/%s/%s\", device, file);\n    return buffer;\n}"
  },
  {
    "function_name": "virPCIDriverDir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "209-216",
    "snippet": "static char *\nvirPCIDriverDir(const char *driver)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"drivers/%s\", driver);\n    return buffer;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [
      "#define PCI_SYSFS \"/sys/bus/pci/\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "PCI_SYSFS \"drivers/%s\"",
            "driver"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\n#define PCI_SYSFS \"/sys/bus/pci/\"\n\nstatic char *\nvirPCIDriverDir(const char *driver)\n{\n    char *buffer;\n\n    buffer = g_strdup_printf(PCI_SYSFS \"drivers/%s\", driver);\n    return buffer;\n}"
  },
  {
    "function_name": "virPCIOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virpci.c",
    "lines": "198-204",
    "snippet": "static int virPCIOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virPCIDeviceList, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"viralloc.h\"",
      "#include \"virstring.h\"",
      "#include \"virkmod.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"vircommand.h\"",
      "#include \"virlog.h\"",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <inttypes.h>",
      "#include <fcntl.h>",
      "#include <dirent.h>",
      "#include \"virnetdev.h\"",
      "#include \"virpci.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "virPCIDeviceList",
            "virClassForObjectLockable()"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObjectLockable",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "116-123",
          "snippet": "virClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectLockableClass;\n\nvirClassPtr\nvirClassForObjectLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"viralloc.h\"\n#include \"virstring.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"virlog.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <inttypes.h>\n#include <fcntl.h>\n#include <dirent.h>\n#include \"virnetdev.h\"\n#include \"virpci.h\"\n#include <config.h>\n\nstatic int virPCIOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(virPCIDeviceList, virClassForObjectLockable()))\n        return -1;\n\n    return 0;\n}"
  }
]