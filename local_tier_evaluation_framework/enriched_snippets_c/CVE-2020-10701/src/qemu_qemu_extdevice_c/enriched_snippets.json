[
  {
    "function_name": "qemuExtDevicesSetupCgroup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
    "lines": "271-300",
    "snippet": "int\nqemuExtDevicesSetupCgroup(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          virCgroupPtr cgroup)\n{\n    virDomainDefPtr def = vm->def;\n    size_t i;\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->backend == VIR_DOMAIN_VIDEO_BACKEND_TYPE_VHOSTUSER &&\n            qemuExtVhostUserGPUSetupCgroup(driver, def, video, cgroup) < 0)\n            return -1;\n    }\n\n    if (def->tpm &&\n        qemuExtTPMSetupCgroup(driver, def, cgroup) < 0)\n        return -1;\n\n    for (i = 0; i < def->nfss; i++) {\n        virDomainFSDefPtr fs = def->fss[i];\n\n        if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS &&\n            qemuVirtioFSSetupCgroup(vm, fs, cgroup) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtpm.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_tpm.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_command.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuVirtioFSSetupCgroup",
          "args": [
            "vm",
            "fs",
            "cgroup"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVirtioFSSetupCgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
          "lines": "305-328",
          "snippet": "int\nqemuVirtioFSSetupCgroup(virDomainObjPtr vm,\n                        virDomainFSDefPtr fs,\n                        virCgroupPtr cgroup)\n{\n    g_autofree char *pidfile = NULL;\n    pid_t pid = -1;\n    int rc;\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        return -1;\n\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, NULL);\n    if (rc < 0 || pid == (pid_t) -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virtiofsd died unexpectedly\"));\n        return -1;\n    }\n\n    if (virCgroupAddProcess(cgroup, pid) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virqemu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_command.h\"",
            "#include \"virlog.h\"",
            "#include \"logging/log_manager.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nqemuVirtioFSSetupCgroup(virDomainObjPtr vm,\n                        virDomainFSDefPtr fs,\n                        virCgroupPtr cgroup)\n{\n    g_autofree char *pidfile = NULL;\n    pid_t pid = -1;\n    int rc;\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        return -1;\n\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, NULL);\n    if (rc < 0 || pid == (pid_t) -1) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"virtiofsd died unexpectedly\"));\n        return -1;\n    }\n\n    if (virCgroupAddProcess(cgroup, pid) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtTPMSetupCgroup",
          "args": [
            "driver",
            "def",
            "cgroup"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtTPMSetupCgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_tpm.c",
          "lines": "873-903",
          "snippet": "int\nqemuExtTPMSetupCgroup(virQEMUDriverPtr driver,\n                      virDomainDefPtr def,\n                      virCgroupPtr cgroup)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortName = NULL;\n    int rc;\n    pid_t pid;\n\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        shortName = virDomainDefGetShortName(def);\n        if (!shortName)\n            return -1;\n        rc = qemuTPMEmulatorGetPid(cfg->swtpmStateDir, shortName, &pid);\n        if (rc < 0 || (rc == 0 && pid == (pid_t)-1)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get process id of swtpm\"));\n            return -1;\n        }\n        if (virCgroupAddProcess(cgroup, pid) < 0)\n            return -1;\n        break;\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"qemu_tpm.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_security.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_extdevice.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nqemuExtTPMSetupCgroup(virQEMUDriverPtr driver,\n                      virDomainDefPtr def,\n                      virCgroupPtr cgroup)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortName = NULL;\n    int rc;\n    pid_t pid;\n\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        shortName = virDomainDefGetShortName(def);\n        if (!shortName)\n            return -1;\n        rc = qemuTPMEmulatorGetPid(cfg->swtpmStateDir, shortName, &pid);\n        if (rc < 0 || (rc == 0 && pid == (pid_t)-1)) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"Could not get process id of swtpm\"));\n            return -1;\n        }\n        if (virCgroupAddProcess(cgroup, pid) < 0)\n            return -1;\n        break;\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtVhostUserGPUSetupCgroup",
          "args": [
            "driver",
            "def",
            "video",
            "cgroup"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtVhostUserGPUSetupCgroup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
          "lines": "241-267",
          "snippet": "int\nqemuExtVhostUserGPUSetupCgroup(virQEMUDriverPtr driver,\n                               virDomainDefPtr def,\n                               virDomainVideoDefPtr video,\n                               virCgroupPtr cgroup)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortname = NULL;\n    int rc;\n    pid_t pid;\n\n    shortname = virDomainDefGetShortName(def);\n    if (!shortname)\n        return -1;\n\n    rc = qemuVhostUserGPUGetPid(video->driver->vhost_user_binary,\n                                cfg->stateDir, shortname, video->info.alias, &pid);\n    if (rc < 0 || (rc == 0 && pid == (pid_t)-1)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not get process id of vhost-user-gpu\"));\n        return -1;\n    }\n    if (virCgroupAddProcess(cgroup, pid) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nint\nqemuExtVhostUserGPUSetupCgroup(virQEMUDriverPtr driver,\n                               virDomainDefPtr def,\n                               virDomainVideoDefPtr video,\n                               virCgroupPtr cgroup)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortname = NULL;\n    int rc;\n    pid_t pid;\n\n    shortname = virDomainDefGetShortName(def);\n    if (!shortname)\n        return -1;\n\n    rc = qemuVhostUserGPUGetPid(video->driver->vhost_user_binary,\n                                cfg->stateDir, shortname, video->info.alias, &pid);\n    if (rc < 0 || (rc == 0 && pid == (pid_t)-1)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not get process id of vhost-user-gpu\"));\n        return -1;\n    }\n    if (virCgroupAddProcess(cgroup, pid) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nint\nqemuExtDevicesSetupCgroup(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm,\n                          virCgroupPtr cgroup)\n{\n    virDomainDefPtr def = vm->def;\n    size_t i;\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->backend == VIR_DOMAIN_VIDEO_BACKEND_TYPE_VHOSTUSER &&\n            qemuExtVhostUserGPUSetupCgroup(driver, def, video, cgroup) < 0)\n            return -1;\n    }\n\n    if (def->tpm &&\n        qemuExtTPMSetupCgroup(driver, def, cgroup) < 0)\n        return -1;\n\n    for (i = 0; i < def->nfss; i++) {\n        virDomainFSDefPtr fs = def->fss[i];\n\n        if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS &&\n            qemuVirtioFSSetupCgroup(vm, fs, cgroup) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuExtDevicesHasDevice",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
    "lines": "247-268",
    "snippet": "bool\nqemuExtDevicesHasDevice(virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nvideos; i++) {\n        if (def->videos[i]->backend == VIR_DOMAIN_VIDEO_BACKEND_TYPE_VHOSTUSER)\n            return true;\n    }\n\n    if (def->tpm && def->tpm->type == VIR_DOMAIN_TPM_TYPE_EMULATOR)\n        return true;\n\n    for (i = 0; i < def->nfss; i++) {\n        virDomainFSDefPtr fs = def->fss[i];\n\n        if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS)\n            return true;\n    }\n\n    return false;\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtpm.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_tpm.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_command.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nbool\nqemuExtDevicesHasDevice(virDomainDefPtr def)\n{\n    size_t i;\n\n    for (i = 0; i < def->nvideos; i++) {\n        if (def->videos[i]->backend == VIR_DOMAIN_VIDEO_BACKEND_TYPE_VHOSTUSER)\n            return true;\n    }\n\n    if (def->tpm && def->tpm->type == VIR_DOMAIN_TPM_TYPE_EMULATOR)\n        return true;\n\n    for (i = 0; i < def->nfss; i++) {\n        virDomainFSDefPtr fs = def->fss[i];\n\n        if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS)\n            return true;\n    }\n\n    return false;\n}"
  },
  {
    "function_name": "qemuExtDevicesStop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
    "lines": "210-244",
    "snippet": "void\nqemuExtDevicesStop(virQEMUDriverPtr driver,\n                   virDomainObjPtr vm)\n{\n    virDomainDefPtr def = vm->def;\n    size_t i;\n\n    if (qemuExtDevicesInitPaths(driver, def) < 0)\n        return;\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->backend == VIR_DOMAIN_VIDEO_BACKEND_TYPE_VHOSTUSER)\n            qemuExtVhostUserGPUStop(driver, vm, video);\n    }\n\n    if (def->tpm)\n        qemuExtTPMStop(driver, vm);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n        if (slirp)\n            qemuSlirpStop(slirp, vm, driver, net, false);\n    }\n\n    for (i = 0; i < def->nfss; i++) {\n        virDomainFSDefPtr fs = def->fss[i];\n\n        if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS)\n            qemuVirtioFSStop(driver, vm, fs);\n    }\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtpm.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_tpm.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_command.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuVirtioFSStop",
          "args": [
            "driver",
            "vm",
            "fs"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVirtioFSStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
          "lines": "271-302",
          "snippet": "void\nqemuVirtioFSStop(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                    virDomainObjPtr vm,\n                    virDomainFSDefPtr fs)\n{\n    g_autofree char *pidfile = NULL;\n    virErrorPtr orig_err;\n    pid_t pid = -1;\n    int rc;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, NULL);\n    if (rc >= 0 && pid != (pid_t) -1)\n        virProcessKillPainfully(pid, true);\n\n    if (unlink(pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to remove stale pidfile %s\"),\n                             pidfile);\n    }\n\n    if (QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock)\n        unlink(QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virqemu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_command.h\"",
            "#include \"virlog.h\"",
            "#include \"logging/log_manager.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvoid\nqemuVirtioFSStop(virQEMUDriverPtr driver G_GNUC_UNUSED,\n                    virDomainObjPtr vm,\n                    virDomainFSDefPtr fs)\n{\n    g_autofree char *pidfile = NULL;\n    virErrorPtr orig_err;\n    pid_t pid = -1;\n    int rc;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, NULL);\n    if (rc >= 0 && pid != (pid_t) -1)\n        virProcessKillPainfully(pid, true);\n\n    if (unlink(pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to remove stale pidfile %s\"),\n                             pidfile);\n    }\n\n    if (QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock)\n        unlink(QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock);\n\n cleanup:\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSlirpStop",
          "args": [
            "slirp",
            "vm",
            "driver",
            "net",
            "false"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "237-289",
          "snippet": "void\nqemuSlirpStop(qemuSlirpPtr slirp,\n              virDomainObjPtr vm,\n              virQEMUDriverPtr driver,\n              virDomainNetDefPtr net,\n              bool hot)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *pidfile = NULL;\n    g_autofree char *dbus_path = NULL;\n    g_autofree char *id = qemuSlirpGetDBusVMStateId(net);\n    virErrorPtr orig_err;\n    pid_t pid;\n    int rc;\n\n    if (!(pidfile = qemuSlirpCreatePidFilename(cfg, vm->def, net->info.alias))) {\n        VIR_WARN(\"Unable to construct slirp pidfile path\");\n        return;\n    }\n\n    if (id) {\n        qemuDBusVMStateRemove(driver, vm, id, hot);\n    } else {\n        VIR_WARN(\"Unable to construct vmstate id\");\n    }\n\n    virErrorPreserveLast(&orig_err);\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, cfg->slirpHelperName);\n    if (rc >= 0 && pid != (pid_t) -1)\n        virProcessKillPainfully(pid, true);\n\n    if (unlink(pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to remove stale pidfile %s\"),\n                             pidfile);\n    }\n    slirp->pid = 0;\n\n    dbus_path = qemuSlirpGetDBusPath(cfg, vm->def, net->info.alias);\n    if (dbus_path) {\n        if (unlink(dbus_path) < 0 &&\n            errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to remove stale dbus socket %s\"),\n                                 dbus_path);\n        }\n    } else {\n        VIR_WARN(\"Unable to construct dbus socket path\");\n    }\n\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nvoid\nqemuSlirpStop(qemuSlirpPtr slirp,\n              virDomainObjPtr vm,\n              virQEMUDriverPtr driver,\n              virDomainNetDefPtr net,\n              bool hot)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *pidfile = NULL;\n    g_autofree char *dbus_path = NULL;\n    g_autofree char *id = qemuSlirpGetDBusVMStateId(net);\n    virErrorPtr orig_err;\n    pid_t pid;\n    int rc;\n\n    if (!(pidfile = qemuSlirpCreatePidFilename(cfg, vm->def, net->info.alias))) {\n        VIR_WARN(\"Unable to construct slirp pidfile path\");\n        return;\n    }\n\n    if (id) {\n        qemuDBusVMStateRemove(driver, vm, id, hot);\n    } else {\n        VIR_WARN(\"Unable to construct vmstate id\");\n    }\n\n    virErrorPreserveLast(&orig_err);\n    rc = virPidFileReadPathIfAlive(pidfile, &pid, cfg->slirpHelperName);\n    if (rc >= 0 && pid != (pid_t) -1)\n        virProcessKillPainfully(pid, true);\n\n    if (unlink(pidfile) < 0 &&\n        errno != ENOENT) {\n        virReportSystemError(errno,\n                             _(\"Unable to remove stale pidfile %s\"),\n                             pidfile);\n    }\n    slirp->pid = 0;\n\n    dbus_path = qemuSlirpGetDBusPath(cfg, vm->def, net->info.alias);\n    if (dbus_path) {\n        if (unlink(dbus_path) < 0 &&\n            errno != ENOENT) {\n            virReportSystemError(errno,\n                                 _(\"Unable to remove stale dbus socket %s\"),\n                                 dbus_path);\n        }\n    } else {\n        VIR_WARN(\"Unable to construct dbus socket path\");\n    }\n\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_NETWORK_PRIVATE",
          "args": [
            "net"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuExtTPMStop",
          "args": [
            "driver",
            "vm"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtTPMStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_tpm.c",
          "lines": "848-870",
          "snippet": "void\nqemuExtTPMStop(virQEMUDriverPtr driver,\n               virDomainObjPtr vm)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortName = NULL;\n\n    switch (vm->def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        shortName = virDomainDefGetShortName(vm->def);\n        if (!shortName)\n            return;\n\n        qemuTPMEmulatorStop(cfg->swtpmStateDir, shortName);\n        qemuSecurityCleanupTPMEmulator(driver, vm);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return;\n}",
          "includes": [
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"qemu_tpm.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_security.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_extdevice.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nqemuExtTPMStop(virQEMUDriverPtr driver,\n               virDomainObjPtr vm)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortName = NULL;\n\n    switch (vm->def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        shortName = virDomainDefGetShortName(vm->def);\n        if (!shortName)\n            return;\n\n        qemuTPMEmulatorStop(cfg->swtpmStateDir, shortName);\n        qemuSecurityCleanupTPMEmulator(driver, vm);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtVhostUserGPUStop",
          "args": [
            "driver",
            "vm",
            "video"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtVhostUserGPUStop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
          "lines": "208-228",
          "snippet": "void qemuExtVhostUserGPUStop(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainVideoDefPtr video)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *pidfile = NULL;\n    g_autofree char *shortname = NULL;\n    virErrorPtr orig_err;\n\n    shortname = virDomainDefGetShortName(vm->def);\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(\n              cfg->stateDir, shortname, video->info.alias))) {\n        VIR_WARN(\"Unable to construct vhost-user-gpu pidfile path\");\n        return;\n    }\n\n    virErrorPreserveLast(&orig_err);\n    if (virPidFileForceCleanupPath(pidfile) < 0)\n        VIR_WARN(\"Unable to kill vhost-user-gpu process\");\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nvoid qemuExtVhostUserGPUStop(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainVideoDefPtr video)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *pidfile = NULL;\n    g_autofree char *shortname = NULL;\n    virErrorPtr orig_err;\n\n    shortname = virDomainDefGetShortName(vm->def);\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(\n              cfg->stateDir, shortname, video->info.alias))) {\n        VIR_WARN(\"Unable to construct vhost-user-gpu pidfile path\");\n        return;\n    }\n\n    virErrorPreserveLast(&orig_err);\n    if (virPidFileForceCleanupPath(pidfile) < 0)\n        VIR_WARN(\"Unable to kill vhost-user-gpu process\");\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtDevicesInitPaths",
          "args": [
            "driver",
            "def"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtDevicesInitPaths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
          "lines": "71-81",
          "snippet": "static int\nqemuExtDevicesInitPaths(virQEMUDriverPtr driver,\n                        virDomainDefPtr def)\n{\n    int ret = 0;\n\n    if (def->tpm)\n        ret = qemuExtTPMInitPaths(driver, def);\n\n    return ret;\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtpm.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_command.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nstatic int\nqemuExtDevicesInitPaths(virQEMUDriverPtr driver,\n                        virDomainDefPtr def)\n{\n    int ret = 0;\n\n    if (def->tpm)\n        ret = qemuExtTPMInitPaths(driver, def);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nvoid\nqemuExtDevicesStop(virQEMUDriverPtr driver,\n                   virDomainObjPtr vm)\n{\n    virDomainDefPtr def = vm->def;\n    size_t i;\n\n    if (qemuExtDevicesInitPaths(driver, def) < 0)\n        return;\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->backend == VIR_DOMAIN_VIDEO_BACKEND_TYPE_VHOSTUSER)\n            qemuExtVhostUserGPUStop(driver, vm, video);\n    }\n\n    if (def->tpm)\n        qemuExtTPMStop(driver, vm);\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n        if (slirp)\n            qemuSlirpStop(slirp, vm, driver, net, false);\n    }\n\n    for (i = 0; i < def->nfss; i++) {\n        virDomainFSDefPtr fs = def->fss[i];\n\n        if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS)\n            qemuVirtioFSStop(driver, vm, fs);\n    }\n}"
  },
  {
    "function_name": "qemuExtDevicesStart",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
    "lines": "164-207",
    "snippet": "int\nqemuExtDevicesStart(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    virLogManagerPtr logManager,\n                    bool incomingMigration)\n{\n    virDomainDefPtr def = vm->def;\n    size_t i;\n\n    if (qemuExtDevicesInitPaths(driver, def) < 0)\n        return -1;\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->backend == VIR_DOMAIN_VIDEO_BACKEND_TYPE_VHOSTUSER) {\n            if (qemuExtVhostUserGPUStart(driver, vm, video) < 0)\n                return -1;\n        }\n    }\n\n    if (def->tpm && qemuExtTPMStart(driver, vm, incomingMigration) < 0)\n        return -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n        if (slirp &&\n            qemuSlirpStart(slirp, vm, driver, net, false, incomingMigration) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nfss; i++) {\n        virDomainFSDefPtr fs = def->fss[i];\n\n        if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS) {\n            if (qemuVirtioFSStart(logManager, driver, vm, fs) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtpm.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_tpm.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_command.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuVirtioFSStart",
          "args": [
            "logManager",
            "driver",
            "vm",
            "fs"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVirtioFSStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
          "lines": "159-268",
          "snippet": "int\nqemuVirtioFSStart(virLogManagerPtr logManager,\n                  virQEMUDriverPtr driver,\n                  virDomainObjPtr vm,\n                  virDomainFSDefPtr fs)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *socket_path = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autofree char *logpath = NULL;\n    pid_t pid = (pid_t) -1;\n    VIR_AUTOCLOSE fd = -1;\n    VIR_AUTOCLOSE logfd = -1;\n    int ret = -1;\n    int rc;\n\n    if (!virFileExists(fs->src->path)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"the virtiofs export directory '%s' does not exist\"),\n                       fs->src->path);\n        return -1;\n    }\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    if (!(socket_path = qemuVirtioFSCreateSocketFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    if ((fd = qemuVirtioFSOpenChardev(driver, vm, socket_path)) < 0)\n        goto cleanup;\n\n    logpath = qemuVirtioFSCreateLogFilename(cfg, vm->def, fs->info.alias);\n\n    if (cfg->stdioLogD) {\n        if ((logfd = virLogManagerDomainOpenLogFile(logManager,\n                                                    \"qemu\",\n                                                    vm->def->uuid,\n                                                    vm->def->name,\n                                                    logpath,\n                                                    0,\n                                                    NULL, NULL)) < 0)\n            goto cleanup;\n    } else {\n        if ((logfd = open(logpath, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR)) < 0) {\n            virReportSystemError(errno, _(\"failed to create logfile %s\"),\n                                 logpath);\n            goto cleanup;\n        }\n        if (virSetCloseExec(logfd) < 0) {\n            virReportSystemError(errno, _(\"failed to set close-on-exec flag on %s\"),\n                                 logpath);\n            goto error;\n        }\n    }\n\n    if (!(cmd = qemuVirtioFSBuildCommandLine(cfg, fs, &fd)))\n        goto cleanup;\n\n    /* so far only running as root is supported */\n    virCommandSetUID(cmd, 0);\n    virCommandSetGID(cmd, 0);\n\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetOutputFD(cmd, &logfd);\n    virCommandSetErrorFD(cmd, &logfd);\n    virCommandNonblockingFDs(cmd);\n    virCommandDaemonize(cmd);\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"virtiofsd\") < 0)\n        goto cleanup;\n\n    rc = virCommandRun(cmd, NULL);\n\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not start 'virtiofsd'\"));\n        goto error;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read virtiofsd pidfile '%s'\"),\n                             pidfile);\n        goto error;\n    }\n\n    if (virProcessKill(pid, 0) != 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"virtiofsd died unexpectedly\"));\n        goto error;\n    }\n\n    QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock = g_steal_pointer(&socket_path);\n    ret = 0;\n\n cleanup:\n    if (socket_path)\n        unlink(socket_path);\n    return ret;\n\n error:\n    if (pid != -1)\n        virProcessKillPainfully(pid, true);\n    if (pidfile)\n        unlink(pidfile);\n    goto cleanup;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virqemu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_command.h\"",
            "#include \"virlog.h\"",
            "#include \"logging/log_manager.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nqemuVirtioFSStart(virLogManagerPtr logManager,\n                  virQEMUDriverPtr driver,\n                  virDomainObjPtr vm,\n                  virDomainFSDefPtr fs)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *socket_path = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autofree char *logpath = NULL;\n    pid_t pid = (pid_t) -1;\n    VIR_AUTOCLOSE fd = -1;\n    VIR_AUTOCLOSE logfd = -1;\n    int ret = -1;\n    int rc;\n\n    if (!virFileExists(fs->src->path)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"the virtiofs export directory '%s' does not exist\"),\n                       fs->src->path);\n        return -1;\n    }\n\n    if (!(pidfile = qemuVirtioFSCreatePidFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    if (!(socket_path = qemuVirtioFSCreateSocketFilename(vm, fs->info.alias)))\n        goto cleanup;\n\n    if ((fd = qemuVirtioFSOpenChardev(driver, vm, socket_path)) < 0)\n        goto cleanup;\n\n    logpath = qemuVirtioFSCreateLogFilename(cfg, vm->def, fs->info.alias);\n\n    if (cfg->stdioLogD) {\n        if ((logfd = virLogManagerDomainOpenLogFile(logManager,\n                                                    \"qemu\",\n                                                    vm->def->uuid,\n                                                    vm->def->name,\n                                                    logpath,\n                                                    0,\n                                                    NULL, NULL)) < 0)\n            goto cleanup;\n    } else {\n        if ((logfd = open(logpath, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR)) < 0) {\n            virReportSystemError(errno, _(\"failed to create logfile %s\"),\n                                 logpath);\n            goto cleanup;\n        }\n        if (virSetCloseExec(logfd) < 0) {\n            virReportSystemError(errno, _(\"failed to set close-on-exec flag on %s\"),\n                                 logpath);\n            goto error;\n        }\n    }\n\n    if (!(cmd = qemuVirtioFSBuildCommandLine(cfg, fs, &fd)))\n        goto cleanup;\n\n    /* so far only running as root is supported */\n    virCommandSetUID(cmd, 0);\n    virCommandSetGID(cmd, 0);\n\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetOutputFD(cmd, &logfd);\n    virCommandSetErrorFD(cmd, &logfd);\n    virCommandNonblockingFDs(cmd);\n    virCommandDaemonize(cmd);\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"virtiofsd\") < 0)\n        goto cleanup;\n\n    rc = virCommandRun(cmd, NULL);\n\n    if (rc < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Could not start 'virtiofsd'\"));\n        goto error;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read virtiofsd pidfile '%s'\"),\n                             pidfile);\n        goto error;\n    }\n\n    if (virProcessKill(pid, 0) != 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"virtiofsd died unexpectedly\"));\n        goto error;\n    }\n\n    QEMU_DOMAIN_FS_PRIVATE(fs)->vhostuser_fs_sock = g_steal_pointer(&socket_path);\n    ret = 0;\n\n cleanup:\n    if (socket_path)\n        unlink(socket_path);\n    return ret;\n\n error:\n    if (pid != -1)\n        virProcessKillPainfully(pid, true);\n    if (pidfile)\n        unlink(pidfile);\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuSlirpStart",
          "args": [
            "slirp",
            "vm",
            "driver",
            "net",
            "false",
            "incomingMigration"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "292-468",
          "snippet": "int\nqemuSlirpStart(qemuSlirpPtr slirp,\n               virDomainObjPtr vm,\n               virQEMUDriverPtr driver,\n               virDomainNetDefPtr net,\n               bool hotplug,\n               bool incoming)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autofree char *dbus_path = NULL;\n    g_autofree char *dbus_addr = NULL;\n    g_autofree char *id = NULL;\n    size_t i;\n    const unsigned long long timeout = 5 * 1000; /* ms */\n    pid_t pid = (pid_t) -1;\n    int rc;\n    int exitstatus = 0;\n    int cmdret = 0;\n    VIR_AUTOCLOSE errfd = -1;\n\n    if (incoming &&\n        !qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The slirp-helper doesn't support migration\"));\n    }\n\n    if (!(pidfile = qemuSlirpCreatePidFilename(cfg, vm->def, net->info.alias)))\n        return -1;\n\n    if (!(cmd = virCommandNew(cfg->slirpHelperName)))\n        return -1;\n\n    virCommandClearCaps(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetErrorFD(cmd, &errfd);\n    virCommandDaemonize(cmd);\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", slirp->fd[1]);\n    virCommandPassFD(cmd, slirp->fd[1],\n                     VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    slirp->fd[1] = -1;\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        const virNetDevIPAddr *ip = net->guestIP.ips[i];\n        g_autofree char *addr = NULL;\n        const char *opt = \"\";\n\n        if (!(addr = virSocketAddrFormat(&ip->address)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET))\n            opt = \"--net\";\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET6))\n            opt = \"--prefix-ipv6\";\n\n        virCommandAddArgFormat(cmd, \"%s=%s\", opt, addr);\n\n        if (ip->prefix) {\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET)) {\n                virSocketAddr netmask;\n                g_autofree char *netmaskStr = NULL;\n\n                if (virSocketAddrPrefixToNetmask(ip->prefix, &netmask, AF_INET) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Failed to translate prefix %d to netmask\"),\n                                   ip->prefix);\n                    return -1;\n                }\n                if (!(netmaskStr = virSocketAddrFormat(&netmask)))\n                    return -1;\n                virCommandAddArgFormat(cmd, \"--mask=%s\", netmaskStr);\n            }\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET6))\n                virCommandAddArgFormat(cmd, \"--prefix-length-ipv6=%u\", ip->prefix);\n        }\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_DBUS_P2P)) {\n        if (!(id = qemuSlirpGetDBusVMStateId(net)))\n            return -1;\n\n        if (!(dbus_path = qemuSlirpGetDBusPath(cfg, vm->def, net->info.alias)))\n            return -1;\n\n        if (unlink(dbus_path) < 0 && errno != ENOENT) {\n            virReportSystemError(errno, _(\"Unable to unlink %s\"), dbus_path);\n            return -1;\n        }\n\n        dbus_addr = g_strdup_printf(\"unix:path=%s\", dbus_path);\n\n        virCommandAddArgFormat(cmd, \"--dbus-id=%s\", id);\n\n        virCommandAddArgFormat(cmd, \"--dbus-p2p=%s\", dbus_addr);\n\n        if (incoming &&\n            qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE))\n            virCommandAddArg(cmd, \"--dbus-incoming\");\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_EXIT_WITH_PARENT))\n        virCommandAddArg(cmd, \"--exit-with-parent\");\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"slirp\") < 0)\n        return -1;\n\n    if (qemuSecurityCommandRun(driver, vm, cmd, -1, -1, &exitstatus, &cmdret) < 0)\n        return -1;\n\n    if (cmdret < 0 || exitstatus != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not start 'slirp'. exitstatus: %d\"), exitstatus);\n        goto error;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read slirp pidfile '%s'\"),\n                             pidfile);\n        goto error;\n    }\n\n    if (dbus_path) {\n        virTimeBackOffVar timebackoff;\n\n        if (virTimeBackOffStart(&timebackoff, 1, timeout) < 0)\n            goto error;\n\n        while (virTimeBackOffWait(&timebackoff)) {\n            char errbuf[1024] = { 0 };\n\n            if (virFileExists(dbus_path))\n                break;\n\n            if (virProcessKill(pid, 0) == 0)\n                continue;\n\n            if (saferead(errfd, errbuf, sizeof(errbuf) - 1) < 0) {\n                virReportSystemError(errno,\n                                     _(\"slirp helper %s died unexpectedly\"),\n                                     cfg->prHelperName);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"slirp helper died and reported: %s\"), errbuf);\n            }\n            goto error;\n        }\n\n        if (!virFileExists(dbus_path)) {\n            virReportError(VIR_ERR_OPERATION_TIMEOUT, \"%s\",\n                           _(\"slirp dbus socket did not show up\"));\n            goto error;\n        }\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE) &&\n        qemuDBusVMStateAdd(driver, vm, id, dbus_addr, hotplug) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to register slirp migration\"));\n        goto error;\n    }\n\n    slirp->pid = pid;\n    return 0;\n\n error:\n    if (pid != -1)\n        virProcessKillPainfully(pid, true);\n    if (pidfile)\n        unlink(pidfile);\n    if (dbus_path)\n        unlink(dbus_path);\n    return -1;\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nint\nqemuSlirpStart(qemuSlirpPtr slirp,\n               virDomainObjPtr vm,\n               virQEMUDriverPtr driver,\n               virDomainNetDefPtr net,\n               bool hotplug,\n               bool incoming)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autoptr(virCommand) cmd = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autofree char *dbus_path = NULL;\n    g_autofree char *dbus_addr = NULL;\n    g_autofree char *id = NULL;\n    size_t i;\n    const unsigned long long timeout = 5 * 1000; /* ms */\n    pid_t pid = (pid_t) -1;\n    int rc;\n    int exitstatus = 0;\n    int cmdret = 0;\n    VIR_AUTOCLOSE errfd = -1;\n\n    if (incoming &&\n        !qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE)) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"The slirp-helper doesn't support migration\"));\n    }\n\n    if (!(pidfile = qemuSlirpCreatePidFilename(cfg, vm->def, net->info.alias)))\n        return -1;\n\n    if (!(cmd = virCommandNew(cfg->slirpHelperName)))\n        return -1;\n\n    virCommandClearCaps(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandSetErrorFD(cmd, &errfd);\n    virCommandDaemonize(cmd);\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", slirp->fd[1]);\n    virCommandPassFD(cmd, slirp->fd[1],\n                     VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    slirp->fd[1] = -1;\n\n    for (i = 0; i < net->guestIP.nips; i++) {\n        const virNetDevIPAddr *ip = net->guestIP.ips[i];\n        g_autofree char *addr = NULL;\n        const char *opt = \"\";\n\n        if (!(addr = virSocketAddrFormat(&ip->address)))\n            return -1;\n\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET))\n            opt = \"--net\";\n        if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET6))\n            opt = \"--prefix-ipv6\";\n\n        virCommandAddArgFormat(cmd, \"%s=%s\", opt, addr);\n\n        if (ip->prefix) {\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET)) {\n                virSocketAddr netmask;\n                g_autofree char *netmaskStr = NULL;\n\n                if (virSocketAddrPrefixToNetmask(ip->prefix, &netmask, AF_INET) < 0) {\n                    virReportError(VIR_ERR_INTERNAL_ERROR,\n                                   _(\"Failed to translate prefix %d to netmask\"),\n                                   ip->prefix);\n                    return -1;\n                }\n                if (!(netmaskStr = virSocketAddrFormat(&netmask)))\n                    return -1;\n                virCommandAddArgFormat(cmd, \"--mask=%s\", netmaskStr);\n            }\n            if (VIR_SOCKET_ADDR_IS_FAMILY(&ip->address, AF_INET6))\n                virCommandAddArgFormat(cmd, \"--prefix-length-ipv6=%u\", ip->prefix);\n        }\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_DBUS_P2P)) {\n        if (!(id = qemuSlirpGetDBusVMStateId(net)))\n            return -1;\n\n        if (!(dbus_path = qemuSlirpGetDBusPath(cfg, vm->def, net->info.alias)))\n            return -1;\n\n        if (unlink(dbus_path) < 0 && errno != ENOENT) {\n            virReportSystemError(errno, _(\"Unable to unlink %s\"), dbus_path);\n            return -1;\n        }\n\n        dbus_addr = g_strdup_printf(\"unix:path=%s\", dbus_path);\n\n        virCommandAddArgFormat(cmd, \"--dbus-id=%s\", id);\n\n        virCommandAddArgFormat(cmd, \"--dbus-p2p=%s\", dbus_addr);\n\n        if (incoming &&\n            qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE))\n            virCommandAddArg(cmd, \"--dbus-incoming\");\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_EXIT_WITH_PARENT))\n        virCommandAddArg(cmd, \"--exit-with-parent\");\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"slirp\") < 0)\n        return -1;\n\n    if (qemuSecurityCommandRun(driver, vm, cmd, -1, -1, &exitstatus, &cmdret) < 0)\n        return -1;\n\n    if (cmdret < 0 || exitstatus != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not start 'slirp'. exitstatus: %d\"), exitstatus);\n        goto error;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read slirp pidfile '%s'\"),\n                             pidfile);\n        goto error;\n    }\n\n    if (dbus_path) {\n        virTimeBackOffVar timebackoff;\n\n        if (virTimeBackOffStart(&timebackoff, 1, timeout) < 0)\n            goto error;\n\n        while (virTimeBackOffWait(&timebackoff)) {\n            char errbuf[1024] = { 0 };\n\n            if (virFileExists(dbus_path))\n                break;\n\n            if (virProcessKill(pid, 0) == 0)\n                continue;\n\n            if (saferead(errfd, errbuf, sizeof(errbuf) - 1) < 0) {\n                virReportSystemError(errno,\n                                     _(\"slirp helper %s died unexpectedly\"),\n                                     cfg->prHelperName);\n            } else {\n                virReportError(VIR_ERR_OPERATION_FAILED,\n                               _(\"slirp helper died and reported: %s\"), errbuf);\n            }\n            goto error;\n        }\n\n        if (!virFileExists(dbus_path)) {\n            virReportError(VIR_ERR_OPERATION_TIMEOUT, \"%s\",\n                           _(\"slirp dbus socket did not show up\"));\n            goto error;\n        }\n    }\n\n    if (qemuSlirpHasFeature(slirp, QEMU_SLIRP_FEATURE_MIGRATE) &&\n        qemuDBusVMStateAdd(driver, vm, id, dbus_addr, hotplug) < 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"Failed to register slirp migration\"));\n        goto error;\n    }\n\n    slirp->pid = pid;\n    return 0;\n\n error:\n    if (pid != -1)\n        virProcessKillPainfully(pid, true);\n    if (pidfile)\n        unlink(pidfile);\n    if (dbus_path)\n        unlink(dbus_path);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_NETWORK_PRIVATE",
          "args": [
            "net"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuExtTPMStart",
          "args": [
            "driver",
            "vm",
            "incomingMigration"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtTPMStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_tpm.c",
          "lines": "828-845",
          "snippet": "int\nqemuExtTPMStart(virQEMUDriverPtr driver,\n                virDomainObjPtr vm,\n                bool incomingMigration)\n{\n    virDomainTPMDefPtr tpm = vm->def->tpm;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        return qemuExtTPMStartEmulator(driver, vm, incomingMigration);\n\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"qemu_tpm.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_security.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_extdevice.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nqemuExtTPMStart(virQEMUDriverPtr driver,\n                virDomainObjPtr vm,\n                bool incomingMigration)\n{\n    virDomainTPMDefPtr tpm = vm->def->tpm;\n\n    switch (tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        return qemuExtTPMStartEmulator(driver, vm, incomingMigration);\n\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtVhostUserGPUStart",
          "args": [
            "driver",
            "vm",
            "video"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtVhostUserGPUStart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
          "lines": "104-195",
          "snippet": "int qemuExtVhostUserGPUStart(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainVideoDefPtr video)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortname = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    int pair[2] = { -1, -1 };\n    int cmdret = 0, rc;\n    int exitstatus = 0;\n    pid_t pid;\n    int ret = -1;\n\n    shortname = virDomainDefGetShortName(vm->def);\n    if (!shortname)\n        goto error;\n\n    /* stop any left-over for this VM */\n    qemuExtVhostUserGPUStop(driver, vm, video);\n\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(\n              cfg->stateDir, shortname, video->info.alias)))\n        goto error;\n\n    if (qemuSecuritySetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto error;\n\n    if (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"failed to create socket\"));\n        goto error;\n    }\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0)\n        goto error;\n\n    cmd = virCommandNew(video->driver->vhost_user_binary);\n    if (!cmd)\n        goto error;\n\n    virCommandClearCaps(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandDaemonize(cmd);\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"vhost-user-gpu\") < 0)\n        goto error;\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", pair[0]);\n    virCommandPassFD(cmd, pair[0], VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    pair[0] = -1;\n\n    if (video->accel) {\n        if (video->accel->accel3d)\n            virCommandAddArg(cmd, \"--virgl\");\n\n        if (video->accel->rendernode)\n            virCommandAddArgFormat(cmd, \"--render-node=%s\", video->accel->rendernode);\n    }\n\n    if (qemuSecurityStartVhostUserGPU(driver, vm, cmd,\n                                      &exitstatus, &cmdret) < 0)\n        goto error;\n\n    if (cmdret < 0 || exitstatus != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not start 'vhost-user-gpu'. exitstatus: %d\"), exitstatus);\n        goto cleanup;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read vhost-user-gpu pidfile '%s'\"),\n                             pidfile);\n        goto cleanup;\n    }\n\n    ret = 0;\n    QEMU_DOMAIN_VIDEO_PRIVATE(video)->vhost_user_fd = pair[1];\n    pair[1] = -1;\n\n cleanup:\n    VIR_FORCE_CLOSE(pair[0]);\n    VIR_FORCE_CLOSE(pair[1]);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"vhost-user-gpu failed to start\"));\n    goto cleanup;\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nint qemuExtVhostUserGPUStart(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainVideoDefPtr video)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortname = NULL;\n    g_autofree char *pidfile = NULL;\n    g_autoptr(virCommand) cmd = NULL;\n    int pair[2] = { -1, -1 };\n    int cmdret = 0, rc;\n    int exitstatus = 0;\n    pid_t pid;\n    int ret = -1;\n\n    shortname = virDomainDefGetShortName(vm->def);\n    if (!shortname)\n        goto error;\n\n    /* stop any left-over for this VM */\n    qemuExtVhostUserGPUStop(driver, vm, video);\n\n    if (!(pidfile = qemuVhostUserGPUCreatePidFilename(\n              cfg->stateDir, shortname, video->info.alias)))\n        goto error;\n\n    if (qemuSecuritySetSocketLabel(driver->securityManager, vm->def) < 0)\n        goto error;\n\n    if (socketpair(AF_UNIX, SOCK_STREAM, 0, pair) < 0) {\n        virReportSystemError(errno, \"%s\", _(\"failed to create socket\"));\n        goto error;\n    }\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, vm->def) < 0)\n        goto error;\n\n    cmd = virCommandNew(video->driver->vhost_user_binary);\n    if (!cmd)\n        goto error;\n\n    virCommandClearCaps(cmd);\n    virCommandSetPidFile(cmd, pidfile);\n    virCommandDaemonize(cmd);\n\n    if (qemuExtDeviceLogCommand(driver, vm, cmd, \"vhost-user-gpu\") < 0)\n        goto error;\n\n    virCommandAddArgFormat(cmd, \"--fd=%d\", pair[0]);\n    virCommandPassFD(cmd, pair[0], VIR_COMMAND_PASS_FD_CLOSE_PARENT);\n    pair[0] = -1;\n\n    if (video->accel) {\n        if (video->accel->accel3d)\n            virCommandAddArg(cmd, \"--virgl\");\n\n        if (video->accel->rendernode)\n            virCommandAddArgFormat(cmd, \"--render-node=%s\", video->accel->rendernode);\n    }\n\n    if (qemuSecurityStartVhostUserGPU(driver, vm, cmd,\n                                      &exitstatus, &cmdret) < 0)\n        goto error;\n\n    if (cmdret < 0 || exitstatus != 0) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Could not start 'vhost-user-gpu'. exitstatus: %d\"), exitstatus);\n        goto cleanup;\n    }\n\n    rc = virPidFileReadPath(pidfile, &pid);\n    if (rc < 0) {\n        virReportSystemError(-rc,\n                             _(\"Unable to read vhost-user-gpu pidfile '%s'\"),\n                             pidfile);\n        goto cleanup;\n    }\n\n    ret = 0;\n    QEMU_DOMAIN_VIDEO_PRIVATE(video)->vhost_user_fd = pair[1];\n    pair[1] = -1;\n\n cleanup:\n    VIR_FORCE_CLOSE(pair[0]);\n    VIR_FORCE_CLOSE(pair[1]);\n\n    return ret;\n\n error:\n    virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                   _(\"vhost-user-gpu failed to start\"));\n    goto cleanup;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtDevicesInitPaths",
          "args": [
            "driver",
            "def"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtDevicesInitPaths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
          "lines": "71-81",
          "snippet": "static int\nqemuExtDevicesInitPaths(virQEMUDriverPtr driver,\n                        virDomainDefPtr def)\n{\n    int ret = 0;\n\n    if (def->tpm)\n        ret = qemuExtTPMInitPaths(driver, def);\n\n    return ret;\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtpm.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_command.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nstatic int\nqemuExtDevicesInitPaths(virQEMUDriverPtr driver,\n                        virDomainDefPtr def)\n{\n    int ret = 0;\n\n    if (def->tpm)\n        ret = qemuExtTPMInitPaths(driver, def);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nint\nqemuExtDevicesStart(virQEMUDriverPtr driver,\n                    virDomainObjPtr vm,\n                    virLogManagerPtr logManager,\n                    bool incomingMigration)\n{\n    virDomainDefPtr def = vm->def;\n    size_t i;\n\n    if (qemuExtDevicesInitPaths(driver, def) < 0)\n        return -1;\n\n    for (i = 0; i < def->nvideos; i++) {\n        virDomainVideoDefPtr video = def->videos[i];\n\n        if (video->backend == VIR_DOMAIN_VIDEO_BACKEND_TYPE_VHOSTUSER) {\n            if (qemuExtVhostUserGPUStart(driver, vm, video) < 0)\n                return -1;\n        }\n    }\n\n    if (def->tpm && qemuExtTPMStart(driver, vm, incomingMigration) < 0)\n        return -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n        if (slirp &&\n            qemuSlirpStart(slirp, vm, driver, net, false, incomingMigration) < 0)\n            return -1;\n    }\n\n    for (i = 0; i < def->nfss; i++) {\n        virDomainFSDefPtr fs = def->fss[i];\n\n        if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS) {\n            if (qemuVirtioFSStart(logManager, driver, vm, fs) < 0)\n                return -1;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuExtDevicesCleanupHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
    "lines": "152-161",
    "snippet": "void\nqemuExtDevicesCleanupHost(virQEMUDriverPtr driver,\n                          virDomainDefPtr def)\n{\n    if (qemuExtDevicesInitPaths(driver, def) < 0)\n        return;\n\n    if (def->tpm)\n        qemuExtTPMCleanupHost(def);\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtpm.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_tpm.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_command.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuExtTPMCleanupHost",
          "args": [
            "def"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtTPMCleanupHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_tpm.c",
          "lines": "730-742",
          "snippet": "void\nqemuExtTPMCleanupHost(virDomainDefPtr def)\n{\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        qemuTPMDeleteEmulatorStorage(def->tpm);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        /* nothing to do */\n        break;\n    }\n}",
          "includes": [
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"qemu_tpm.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_security.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_extdevice.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <config.h>\n\nvoid\nqemuExtTPMCleanupHost(virDomainDefPtr def)\n{\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        qemuTPMDeleteEmulatorStorage(def->tpm);\n        break;\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        /* nothing to do */\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtDevicesInitPaths",
          "args": [
            "driver",
            "def"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtDevicesInitPaths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
          "lines": "71-81",
          "snippet": "static int\nqemuExtDevicesInitPaths(virQEMUDriverPtr driver,\n                        virDomainDefPtr def)\n{\n    int ret = 0;\n\n    if (def->tpm)\n        ret = qemuExtTPMInitPaths(driver, def);\n\n    return ret;\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtpm.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_command.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nstatic int\nqemuExtDevicesInitPaths(virQEMUDriverPtr driver,\n                        virDomainDefPtr def)\n{\n    int ret = 0;\n\n    if (def->tpm)\n        ret = qemuExtTPMInitPaths(driver, def);\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nvoid\nqemuExtDevicesCleanupHost(virQEMUDriverPtr driver,\n                          virDomainDefPtr def)\n{\n    if (qemuExtDevicesInitPaths(driver, def) < 0)\n        return;\n\n    if (def->tpm)\n        qemuExtTPMCleanupHost(def);\n}"
  },
  {
    "function_name": "qemuExtDevicesPrepareHost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
    "lines": "129-149",
    "snippet": "int\nqemuExtDevicesPrepareHost(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm)\n{\n    virDomainDefPtr def = vm->def;\n    size_t i;\n\n    if (def->tpm &&\n        qemuExtTPMPrepareHost(driver, def) < 0)\n        return -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n        if (slirp && qemuSlirpOpen(slirp, driver, def) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtpm.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_tpm.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_command.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuSlirpOpen",
          "args": [
            "slirp",
            "driver",
            "def"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSlirpOpen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_slirp.c",
          "lines": "165-194",
          "snippet": "int\nqemuSlirpOpen(qemuSlirpPtr slirp,\n              virQEMUDriverPtr driver,\n              virDomainDefPtr def)\n{\n    int rc, pair[2] = { -1, -1 };\n\n    if (qemuSecuritySetSocketLabel(driver->securityManager, def) < 0)\n        goto error;\n\n    rc = socketpair(AF_UNIX, SOCK_DGRAM, 0, pair);\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, def) < 0)\n        goto error;\n\n    if (rc < 0) {\n        virReportSystemError(errno, \"%s\", _(\"failed to create socketpair\"));\n        goto error;\n    }\n\n    slirp->fd[0] = pair[0];\n    slirp->fd[1] = pair[1];\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(pair[0]);\n    VIR_FORCE_CLOSE(pair[1]);\n    return -1;\n}",
          "includes": [
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virjson.h\"",
            "#include \"virerror.h\"",
            "#include \"virenum.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_dbus.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virpidfile.h\"\n#include \"virlog.h\"\n#include \"virjson.h\"\n#include \"virerror.h\"\n#include \"virenum.h\"\n#include \"viralloc.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_dbus.h\"\n#include <config.h>\n\nint\nqemuSlirpOpen(qemuSlirpPtr slirp,\n              virQEMUDriverPtr driver,\n              virDomainDefPtr def)\n{\n    int rc, pair[2] = { -1, -1 };\n\n    if (qemuSecuritySetSocketLabel(driver->securityManager, def) < 0)\n        goto error;\n\n    rc = socketpair(AF_UNIX, SOCK_DGRAM, 0, pair);\n\n    if (qemuSecurityClearSocketLabel(driver->securityManager, def) < 0)\n        goto error;\n\n    if (rc < 0) {\n        virReportSystemError(errno, \"%s\", _(\"failed to create socketpair\"));\n        goto error;\n    }\n\n    slirp->fd[0] = pair[0];\n    slirp->fd[1] = pair[1];\n\n    return 0;\n\n error:\n    VIR_FORCE_CLOSE(pair[0]);\n    VIR_FORCE_CLOSE(pair[1]);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_NETWORK_PRIVATE",
          "args": [
            "net"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuExtTPMPrepareHost",
          "args": [
            "driver",
            "def"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtTPMPrepareHost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_tpm.c",
          "lines": "703-727",
          "snippet": "int\nqemuExtTPMPrepareHost(virQEMUDriverPtr driver,\n                      virDomainDefPtr def)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortName = NULL;\n\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        shortName = virDomainDefGetShortName(def);\n        if (!shortName)\n            return -1;\n\n        return qemuTPMEmulatorPrepareHost(def->tpm, cfg->swtpmLogDir,\n                                          def->name, cfg->swtpm_user,\n                                          cfg->swtpm_group,\n                                          cfg->swtpmStateDir, cfg->user,\n                                          shortName);\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"qemu_tpm.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_security.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_extdevice.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nqemuExtTPMPrepareHost(virQEMUDriverPtr driver,\n                      virDomainDefPtr def)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    g_autofree char *shortName = NULL;\n\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        shortName = virDomainDefGetShortName(def);\n        if (!shortName)\n            return -1;\n\n        return qemuTPMEmulatorPrepareHost(def->tpm, cfg->swtpmLogDir,\n                                          def->name, cfg->swtpm_user,\n                                          cfg->swtpm_group,\n                                          cfg->swtpmStateDir, cfg->user,\n                                          shortName);\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nint\nqemuExtDevicesPrepareHost(virQEMUDriverPtr driver,\n                          virDomainObjPtr vm)\n{\n    virDomainDefPtr def = vm->def;\n    size_t i;\n\n    if (def->tpm &&\n        qemuExtTPMPrepareHost(driver, def) < 0)\n        return -1;\n\n    for (i = 0; i < def->nnets; i++) {\n        virDomainNetDefPtr net = def->nets[i];\n        qemuSlirpPtr slirp = QEMU_DOMAIN_NETWORK_PRIVATE(net)->slirp;\n\n        if (slirp && qemuSlirpOpen(slirp, driver, def) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuExtDevicesPrepareDomain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
    "lines": "92-118",
    "snippet": "int\nqemuExtDevicesPrepareDomain(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm)\n{\n    int ret = 0;\n    size_t i;\n\n    for (i = 0; i < vm->def->nvideos; i++) {\n        virDomainVideoDefPtr video = vm->def->videos[i];\n\n        if (video->backend == VIR_DOMAIN_VIDEO_BACKEND_TYPE_VHOSTUSER) {\n            if ((ret = qemuExtVhostUserGPUPrepareDomain(driver, video)) < 0)\n                break;\n        }\n    }\n\n    for (i = 0; i < vm->def->nfss; i++) {\n        virDomainFSDefPtr fs = vm->def->fss[i];\n\n        if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS) {\n            if (qemuVirtioFSPrepareDomain(driver, fs) < 0)\n                return -1;\n        }\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtpm.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_tpm.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_command.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuVirtioFSPrepareDomain",
          "args": [
            "driver",
            "fs"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "qemuVirtioFSPrepareDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_virtiofs.c",
          "lines": "330-338",
          "snippet": "int\nqemuVirtioFSPrepareDomain(virQEMUDriverPtr driver,\n                          virDomainFSDefPtr fs)\n{\n    if (fs->binary)\n        return 0;\n\n    return qemuVhostUserFillDomainFS(driver, fs);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virqemu.h\"",
            "#include \"virpidfile.h\"",
            "#include \"qemu_virtiofs.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_command.h\"",
            "#include \"virlog.h\"",
            "#include \"logging/log_manager.h\"",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virqemu.h\"\n#include \"virpidfile.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_security.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_command.h\"\n#include \"virlog.h\"\n#include \"logging/log_manager.h\"\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nint\nqemuVirtioFSPrepareDomain(virQEMUDriverPtr driver,\n                          virDomainFSDefPtr fs)\n{\n    if (fs->binary)\n        return 0;\n\n    return qemuVhostUserFillDomainFS(driver, fs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuExtVhostUserGPUPrepareDomain",
          "args": [
            "driver",
            "video"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtVhostUserGPUPrepareDomain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_vhost_user_gpu.c",
          "lines": "86-90",
          "snippet": "int qemuExtVhostUserGPUPrepareDomain(virQEMUDriverPtr driver,\n                                     virDomainVideoDefPtr video)\n{\n    return qemuVhostUserFillDomainGPU(driver, video);\n}",
          "includes": [
            "#include \"virpidfile.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"configmake.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_vhost_user.h\"",
            "#include \"qemu_vhost_user_gpu.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"configmake.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_vhost_user.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include <config.h>\n\nint qemuExtVhostUserGPUPrepareDomain(virQEMUDriverPtr driver,\n                                     virDomainVideoDefPtr video)\n{\n    return qemuVhostUserFillDomainGPU(driver, video);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nint\nqemuExtDevicesPrepareDomain(virQEMUDriverPtr driver,\n                            virDomainObjPtr vm)\n{\n    int ret = 0;\n    size_t i;\n\n    for (i = 0; i < vm->def->nvideos; i++) {\n        virDomainVideoDefPtr video = vm->def->videos[i];\n\n        if (video->backend == VIR_DOMAIN_VIDEO_BACKEND_TYPE_VHOSTUSER) {\n            if ((ret = qemuExtVhostUserGPUPrepareDomain(driver, video)) < 0)\n                break;\n        }\n    }\n\n    for (i = 0; i < vm->def->nfss; i++) {\n        virDomainFSDefPtr fs = vm->def->fss[i];\n\n        if (fs->fsdriver == VIR_DOMAIN_FS_DRIVER_TYPE_VIRTIOFS) {\n            if (qemuVirtioFSPrepareDomain(driver, fs) < 0)\n                return -1;\n        }\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuExtDevicesInitPaths",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
    "lines": "71-81",
    "snippet": "static int\nqemuExtDevicesInitPaths(virQEMUDriverPtr driver,\n                        virDomainDefPtr def)\n{\n    int ret = 0;\n\n    if (def->tpm)\n        ret = qemuExtTPMInitPaths(driver, def);\n\n    return ret;\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtpm.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_tpm.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_command.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuExtTPMInitPaths",
          "args": [
            "driver",
            "def"
          ],
          "line": 78
        },
        "resolved": true,
        "details": {
          "function_name": "qemuExtTPMInitPaths",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_tpm.c",
          "lines": "684-700",
          "snippet": "int\nqemuExtTPMInitPaths(virQEMUDriverPtr driver,\n                    virDomainDefPtr def)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        return qemuTPMEmulatorInitPaths(def->tpm, cfg->swtpmStorageDir,\n                                        def->uuid);\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"qemu_tpm.h\"",
            "#include \"configmake.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virstring.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"viralloc.h\"",
            "#include \"vircommand.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"qemu_tpm.h\"\n#include \"configmake.h\"\n#include \"virpidfile.h\"\n#include \"virstring.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"viralloc.h\"\n#include \"vircommand.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_security.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_extdevice.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <config.h>\n\nint\nqemuExtTPMInitPaths(virQEMUDriverPtr driver,\n                    virDomainDefPtr def)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n\n    switch (def->tpm->type) {\n    case VIR_DOMAIN_TPM_TYPE_EMULATOR:\n        return qemuTPMEmulatorInitPaths(def->tpm, cfg->swtpmStorageDir,\n                                        def->uuid);\n    case VIR_DOMAIN_TPM_TYPE_PASSTHROUGH:\n    case VIR_DOMAIN_TPM_TYPE_LAST:\n        break;\n    }\n\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nstatic int\nqemuExtDevicesInitPaths(virQEMUDriverPtr driver,\n                        virDomainDefPtr def)\n{\n    int ret = 0;\n\n    if (def->tpm)\n        ret = qemuExtTPMInitPaths(driver, def);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuExtDeviceLogCommand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_extdevice.c",
    "lines": "42-57",
    "snippet": "int\nqemuExtDeviceLogCommand(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virCommandPtr cmd,\n                        const char *info)\n{\n    g_autofree char *timestamp = virTimeStringNow();\n    g_autofree char *cmds = virCommandToString(cmd, false);\n\n    if (!timestamp || !cmds)\n        return -1;\n\n    return qemuDomainLogAppendMessage(driver, vm,\n                                      _(\"%s: Starting external device: %s\\n%s\\n\"),\n                                      timestamp, info, cmds);\n}",
    "includes": [
      "#include \"virpidfile.h\"",
      "#include \"virtpm.h\"",
      "#include \"virtime.h\"",
      "#include \"virstring.h\"",
      "#include \"virlog.h\"",
      "#include \"viralloc.h\"",
      "#include \"qemu_virtiofs.h\"",
      "#include \"qemu_slirp.h\"",
      "#include \"qemu_tpm.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_vhost_user_gpu.h\"",
      "#include \"qemu_extdevice.h\"",
      "#include \"qemu_command.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainLogAppendMessage",
          "args": [
            "driver",
            "vm",
            "_(\"%s: Starting external device: %s\\n%s\\n\")",
            "timestamp",
            "info",
            "cmds"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainLogAppendMessage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10921-10970",
          "snippet": "int\nqemuDomainLogAppendMessage(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           const char *fmt,\n                           ...)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    virLogManagerPtr manager = NULL;\n    va_list ap;\n    g_autofree char *path = NULL;\n    int writefd = -1;\n    g_autofree char *message = NULL;\n    int ret = -1;\n\n    va_start(ap, fmt);\n\n    message = g_strdup_vprintf(fmt, ap);\n\n    VIR_DEBUG(\"Append log message (vm='%s' message='%s) stdioLogD=%d\",\n              vm->def->name, message, cfg->stdioLogD);\n\n    path = g_strdup_printf(\"%s/%s.log\", cfg->logDir, vm->def->name);\n\n    if (cfg->stdioLogD) {\n        if (!(manager = virLogManagerNew(virQEMUDriverIsPrivileged(driver))))\n            goto cleanup;\n\n        if (virLogManagerDomainAppendMessage(manager, \"qemu\", vm->def->uuid,\n                                             vm->def->name, path, message, 0) < 0)\n            goto cleanup;\n    } else {\n        if ((writefd = open(path, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR)) < 0) {\n            virReportSystemError(errno, _(\"failed to create logfile %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (safewrite(writefd, message, strlen(message)) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    va_end(ap);\n    VIR_FORCE_CLOSE(writefd);\n    virLogManagerFree(manager);\n\n    return ret;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nobj, obj->def->name);\n\nint\nqemuDomainLogAppendMessage(virQEMUDriverPtr driver,\n                           virDomainObjPtr vm,\n                           const char *fmt,\n                           ...)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    virLogManagerPtr manager = NULL;\n    va_list ap;\n    g_autofree char *path = NULL;\n    int writefd = -1;\n    g_autofree char *message = NULL;\n    int ret = -1;\n\n    va_start(ap, fmt);\n\n    message = g_strdup_vprintf(fmt, ap);\n\n    VIR_DEBUG(\"Append log message (vm='%s' message='%s) stdioLogD=%d\",\n              vm->def->name, message, cfg->stdioLogD);\n\n    path = g_strdup_printf(\"%s/%s.log\", cfg->logDir, vm->def->name);\n\n    if (cfg->stdioLogD) {\n        if (!(manager = virLogManagerNew(virQEMUDriverIsPrivileged(driver))))\n            goto cleanup;\n\n        if (virLogManagerDomainAppendMessage(manager, \"qemu\", vm->def->uuid,\n                                             vm->def->name, path, message, 0) < 0)\n            goto cleanup;\n    } else {\n        if ((writefd = open(path, O_WRONLY | O_CREAT | O_APPEND, S_IRUSR | S_IWUSR)) < 0) {\n            virReportSystemError(errno, _(\"failed to create logfile %s\"),\n                                 path);\n            goto cleanup;\n        }\n\n        if (safewrite(writefd, message, strlen(message)) < 0)\n            goto cleanup;\n    }\n\n    ret = 0;\n\n cleanup:\n    va_end(ap);\n    VIR_FORCE_CLOSE(writefd);\n    virLogManagerFree(manager);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"%s: Starting external device: %s\\n%s\\n\""
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virCommandToString",
          "args": [
            "cmd",
            "false"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "virCommandToString",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/vircommand.c",
          "lines": "2082-2135",
          "snippet": "char *\nvirCommandToString(virCommandPtr cmd, bool linebreaks)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool prevopt = false;\n\n    /* Cannot assume virCommandRun will be called; so report the error\n     * now.  If virCommandRun is called, it will report the same error. */\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return NULL;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return NULL;\n    }\n\n    for (i = 0; i < cmd->nenv; i++) {\n        /* In shell, a='b c' has a different meaning than 'a=b c', so\n         * we must determine where the '=' lives.  */\n        char *eq = strchr(cmd->env[i], '=');\n\n        if (!eq) {\n            virBufferFreeAndReset(&buf);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid use of command API\"));\n            return NULL;\n        }\n        eq++;\n        virBufferAdd(&buf, cmd->env[i], eq - cmd->env[i]);\n        virBufferEscapeShell(&buf, eq);\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks)\n            virBufferAddLit(&buf, \"\\\\\\n\");\n    }\n    virBufferEscapeShell(&buf, cmd->args[0]);\n    for (i = 1; i < cmd->nargs; i++) {\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks) {\n            /* Line break if this is a --arg or if\n             * the previous arg was a positional option\n             */\n            if (cmd->args[i][0] == '-' ||\n                !prevopt)\n                virBufferAddLit(&buf, \"\\\\\\n\");\n        }\n        virBufferEscapeShell(&buf, cmd->args[i]);\n        prevopt = (cmd->args[i][0] == '-');\n    }\n\n    return virBufferContentAndReset(&buf);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virthread.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virutil.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommandpriv.h\"",
            "#include \"viralloc.h\"",
            "# include <sys/apparmor.h>",
            "# include <selinux/selinux.h>",
            "# include <cap-ng.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "# include <sys/wait.h>",
            "#include <sys/stat.h>",
            "#include <stdarg.h>",
            "#include <signal.h>",
            "# include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virthread.h\"\n#include \"virbuffer.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virutil.h\"\n#include \"virerror.h\"\n#include \"vircommandpriv.h\"\n#include \"viralloc.h\"\n# include <sys/apparmor.h>\n# include <selinux/selinux.h>\n# include <cap-ng.h>\n#include <unistd.h>\n#include <fcntl.h>\n# include <sys/wait.h>\n#include <sys/stat.h>\n#include <stdarg.h>\n#include <signal.h>\n# include <poll.h>\n#include <config.h>\n\nchar *\nvirCommandToString(virCommandPtr cmd, bool linebreaks)\n{\n    size_t i;\n    virBuffer buf = VIR_BUFFER_INITIALIZER;\n    bool prevopt = false;\n\n    /* Cannot assume virCommandRun will be called; so report the error\n     * now.  If virCommandRun is called, it will report the same error. */\n    if (!cmd ||cmd->has_error == ENOMEM) {\n        virReportOOMError();\n        return NULL;\n    }\n    if (cmd->has_error) {\n        virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                       _(\"invalid use of command API\"));\n        return NULL;\n    }\n\n    for (i = 0; i < cmd->nenv; i++) {\n        /* In shell, a='b c' has a different meaning than 'a=b c', so\n         * we must determine where the '=' lives.  */\n        char *eq = strchr(cmd->env[i], '=');\n\n        if (!eq) {\n            virBufferFreeAndReset(&buf);\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"invalid use of command API\"));\n            return NULL;\n        }\n        eq++;\n        virBufferAdd(&buf, cmd->env[i], eq - cmd->env[i]);\n        virBufferEscapeShell(&buf, eq);\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks)\n            virBufferAddLit(&buf, \"\\\\\\n\");\n    }\n    virBufferEscapeShell(&buf, cmd->args[0]);\n    for (i = 1; i < cmd->nargs; i++) {\n        virBufferAddChar(&buf, ' ');\n        if (linebreaks) {\n            /* Line break if this is a --arg or if\n             * the previous arg was a positional option\n             */\n            if (cmd->args[i][0] == '-' ||\n                !prevopt)\n                virBufferAddLit(&buf, \"\\\\\\n\");\n        }\n        virBufferEscapeShell(&buf, cmd->args[i]);\n        prevopt = (cmd->args[i][0] == '-');\n    }\n\n    return virBufferContentAndReset(&buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virTimeStringNow",
          "args": [],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "virTimeStringNow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virtime.c",
          "lines": "256-271",
          "snippet": "char *virTimeStringNow(void)\n{\n    char *ret;\n\n    if (VIR_ALLOC_N(ret, VIR_TIME_STRING_BUFLEN) < 0)\n        return NULL;\n\n    if (virTimeStringNowRaw(ret) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format time\"));\n        VIR_FREE(ret);\n        return NULL;\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virtime.h\"",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virtime.h\"\n#include <sys/time.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virTimeStringNow(void)\n{\n    char *ret;\n\n    if (VIR_ALLOC_N(ret, VIR_TIME_STRING_BUFLEN) < 0)\n        return NULL;\n\n    if (virTimeStringNowRaw(ret) < 0) {\n        virReportSystemError(errno, \"%s\",\n                             _(\"Unable to format time\"));\n        VIR_FREE(ret);\n        return NULL;\n    }\n\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"virpidfile.h\"\n#include \"virtpm.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_virtiofs.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_tpm.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_vhost_user_gpu.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_command.h\"\n#include <config.h>\n\nint\nqemuExtDeviceLogCommand(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm,\n                        virCommandPtr cmd,\n                        const char *info)\n{\n    g_autofree char *timestamp = virTimeStringNow();\n    g_autofree char *cmds = virCommandToString(cmd, false);\n\n    if (!timestamp || !cmds)\n        return -1;\n\n    return qemuDomainLogAppendMessage(driver, vm,\n                                      _(\"%s: Starting external device: %s\\n%s\\n\"),\n                                      timestamp, info, cmds);\n}"
  }
]