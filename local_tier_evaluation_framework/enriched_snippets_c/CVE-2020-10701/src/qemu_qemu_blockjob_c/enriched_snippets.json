[
  {
    "function_name": "qemuBlockjobConvertMonitorStatus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1755-1786",
    "snippet": "qemuBlockjobState\nqemuBlockjobConvertMonitorStatus(int monitorstatus)\n{\n    qemuBlockjobState ret = QEMU_BLOCKJOB_STATE_LAST;\n\n    switch ((qemuMonitorJobStatus) monitorstatus) {\n    case QEMU_MONITOR_JOB_STATUS_READY:\n        ret = QEMU_BLOCKJOB_STATE_READY;\n        break;\n\n    case QEMU_MONITOR_JOB_STATUS_CONCLUDED:\n        ret = QEMU_BLOCKJOB_STATE_CONCLUDED;\n        break;\n\n    case QEMU_MONITOR_JOB_STATUS_UNKNOWN:\n    case QEMU_MONITOR_JOB_STATUS_CREATED:\n    case QEMU_MONITOR_JOB_STATUS_RUNNING:\n    case QEMU_MONITOR_JOB_STATUS_PAUSED:\n    case QEMU_MONITOR_JOB_STATUS_STANDBY:\n    case QEMU_MONITOR_JOB_STATUS_WAITING:\n    case QEMU_MONITOR_JOB_STATUS_PENDING:\n    case QEMU_MONITOR_JOB_STATUS_ABORTING:\n    case QEMU_MONITOR_JOB_STATUS_UNDEFINED:\n    case QEMU_MONITOR_JOB_STATUS_NULL:\n    case QEMU_MONITOR_JOB_STATUS_LAST:\n    default:\n        break;\n    }\n\n    return ret;\n\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockjobState\nqemuBlockjobConvertMonitorStatus(int monitorstatus)\n{\n    qemuBlockjobState ret = QEMU_BLOCKJOB_STATE_LAST;\n\n    switch ((qemuMonitorJobStatus) monitorstatus) {\n    case QEMU_MONITOR_JOB_STATUS_READY:\n        ret = QEMU_BLOCKJOB_STATE_READY;\n        break;\n\n    case QEMU_MONITOR_JOB_STATUS_CONCLUDED:\n        ret = QEMU_BLOCKJOB_STATE_CONCLUDED;\n        break;\n\n    case QEMU_MONITOR_JOB_STATUS_UNKNOWN:\n    case QEMU_MONITOR_JOB_STATUS_CREATED:\n    case QEMU_MONITOR_JOB_STATUS_RUNNING:\n    case QEMU_MONITOR_JOB_STATUS_PAUSED:\n    case QEMU_MONITOR_JOB_STATUS_STANDBY:\n    case QEMU_MONITOR_JOB_STATUS_WAITING:\n    case QEMU_MONITOR_JOB_STATUS_PENDING:\n    case QEMU_MONITOR_JOB_STATUS_ABORTING:\n    case QEMU_MONITOR_JOB_STATUS_UNDEFINED:\n    case QEMU_MONITOR_JOB_STATUS_NULL:\n    case QEMU_MONITOR_JOB_STATUS_LAST:\n    default:\n        break;\n    }\n\n    return ret;\n\n}"
  },
  {
    "function_name": "qemuBlockJobGetByDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1736-1745",
    "snippet": "qemuBlockJobDataPtr\nqemuBlockJobGetByDisk(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "job"
          ],
          "line": 1744
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobGetByDisk(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}"
  },
  {
    "function_name": "qemuBlockJobSyncEnd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1720-1733",
    "snippet": "void\nqemuBlockJobSyncEnd(virDomainObjPtr vm,\n                    qemuBlockJobDataPtr job,\n                    int asyncJob)\n{\n    const char *diskdst = NULL;\n\n    if (job->disk)\n        diskdst = job->disk->dst;\n\n    VIR_DEBUG(\"disk=%s\", NULLSTR(diskdst));\n    job->synchronous = false;\n    qemuBlockJobUpdate(vm, job, asyncJob);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBlockJobUpdate",
          "args": [
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 1732
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1664-1680",
          "snippet": "int\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"disk=%s\"",
            "NULLSTR(diskdst)"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "diskdst"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nqemuBlockJobSyncEnd(virDomainObjPtr vm,\n                    qemuBlockJobDataPtr job,\n                    int asyncJob)\n{\n    const char *diskdst = NULL;\n\n    if (job->disk)\n        diskdst = job->disk->dst;\n\n    VIR_DEBUG(\"disk=%s\", NULLSTR(diskdst));\n    job->synchronous = false;\n    qemuBlockJobUpdate(vm, job, asyncJob);\n}"
  },
  {
    "function_name": "qemuBlockJobSyncBegin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1697-1707",
    "snippet": "void\nqemuBlockJobSyncBegin(qemuBlockJobDataPtr job)\n{\n    const char *diskdst = NULL;\n\n    if (job->disk)\n        diskdst = job->disk->dst;\n\n    VIR_DEBUG(\"disk=%s\", NULLSTR(diskdst));\n    job->synchronous = true;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"disk=%s\"",
            "NULLSTR(diskdst)"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "diskdst"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nqemuBlockJobSyncBegin(qemuBlockJobDataPtr job)\n{\n    const char *diskdst = NULL;\n\n    if (job->disk)\n        diskdst = job->disk->dst;\n\n    VIR_DEBUG(\"disk=%s\", NULLSTR(diskdst));\n    job->synchronous = true;\n}"
  },
  {
    "function_name": "qemuBlockJobUpdate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1664-1680",
    "snippet": "int\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBlockJobEventProcessLegacy",
          "args": [
            "priv->driver",
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 1677
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEventProcessLegacy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "777-833",
          "snippet": "static void\nqemuBlockJobEventProcessLegacy(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               qemuBlockJobDataPtr job,\n                               int asyncJob)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    VIR_DEBUG(\"disk=%s, mirrorState=%s, type=%d, state=%d, newstate=%d\",\n              disk->dst,\n              NULLSTR(virDomainDiskMirrorStateTypeToString(disk->mirrorState)),\n              job->type,\n              job->state,\n              job->newstate);\n\n    if (job->newstate == -1)\n        return;\n\n    qemuBlockJobEmitEvents(driver, vm, disk, job->type, job->newstate);\n\n    job->state = job->newstate;\n    job->newstate = -1;\n\n    /* If we completed a block pull or commit, then update the XML\n     * to match.  */\n    switch ((virConnectDomainEventBlockJobStatus) job->state) {\n    case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n        qemuBlockJobEventProcessLegacyCompleted(driver, vm, job, asyncJob);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_READY:\n        disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_READY;\n        qemuDomainSaveStatus(vm);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_FAILED:\n    case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        if (disk->mirror) {\n            virDomainLockImageDetach(driver->lockManager, vm, disk->mirror);\n\n            /* Ideally, we would restore seclabels on the backing chain here\n             * but we don't know if somebody else is not using parts of it.\n             * Remove security driver metadata so that they are not leaked. */\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            virObjectUnref(disk->mirror);\n            disk->mirror = NULL;\n        }\n        disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_NONE;\n        disk->mirrorJob = VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN;\n        qemuBlockJobUnregister(job, vm);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_LAST:\n        break;\n    }\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessLegacy(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               qemuBlockJobDataPtr job,\n                               int asyncJob)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    VIR_DEBUG(\"disk=%s, mirrorState=%s, type=%d, state=%d, newstate=%d\",\n              disk->dst,\n              NULLSTR(virDomainDiskMirrorStateTypeToString(disk->mirrorState)),\n              job->type,\n              job->state,\n              job->newstate);\n\n    if (job->newstate == -1)\n        return;\n\n    qemuBlockJobEmitEvents(driver, vm, disk, job->type, job->newstate);\n\n    job->state = job->newstate;\n    job->newstate = -1;\n\n    /* If we completed a block pull or commit, then update the XML\n     * to match.  */\n    switch ((virConnectDomainEventBlockJobStatus) job->state) {\n    case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n        qemuBlockJobEventProcessLegacyCompleted(driver, vm, job, asyncJob);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_READY:\n        disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_READY;\n        qemuDomainSaveStatus(vm);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_FAILED:\n    case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        if (disk->mirror) {\n            virDomainLockImageDetach(driver->lockManager, vm, disk->mirror);\n\n            /* Ideally, we would restore seclabels on the backing chain here\n             * but we don't know if somebody else is not using parts of it.\n             * Remove security driver metadata so that they are not leaked. */\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            virObjectUnref(disk->mirror);\n            disk->mirror = NULL;\n        }\n        disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_NONE;\n        disk->mirrorJob = VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN;\n        qemuBlockJobUnregister(job, vm);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_LAST:\n        break;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEventProcess",
          "args": [
            "priv->driver",
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEventProcess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1615-1650",
          "snippet": "static void\nqemuBlockJobEventProcess(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuBlockJobDataPtr job,\n                         qemuDomainAsyncJob asyncJob)\n\n{\n    switch ((qemuBlockjobState) job->newstate) {\n    case QEMU_BLOCKJOB_STATE_COMPLETED:\n    case QEMU_BLOCKJOB_STATE_FAILED:\n    case QEMU_BLOCKJOB_STATE_CANCELLED:\n    case QEMU_BLOCKJOB_STATE_CONCLUDED:\n        qemuBlockJobEventProcessConcluded(job, driver, vm, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_STATE_READY:\n        /* mirror may be NULL for copy job corresponding to migration */\n        if (job->disk) {\n            job->disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_READY;\n            qemuBlockJobEmitEvents(driver, vm, job->disk, job->type, job->newstate);\n        }\n        job->state = job->newstate;\n        job->newstate = -1;\n        qemuDomainSaveStatus(vm);\n        break;\n\n    case QEMU_BLOCKJOB_STATE_NEW:\n    case QEMU_BLOCKJOB_STATE_RUNNING:\n    case QEMU_BLOCKJOB_STATE_LAST:\n    /* these are never processed as 'newstate' */\n    case QEMU_BLOCKJOB_STATE_ABORTING:\n    case QEMU_BLOCKJOB_STATE_PIVOTING:\n    default:\n        job->newstate = -1;\n    }\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcess(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuBlockJobDataPtr job,\n                         qemuDomainAsyncJob asyncJob)\n\n{\n    switch ((qemuBlockjobState) job->newstate) {\n    case QEMU_BLOCKJOB_STATE_COMPLETED:\n    case QEMU_BLOCKJOB_STATE_FAILED:\n    case QEMU_BLOCKJOB_STATE_CANCELLED:\n    case QEMU_BLOCKJOB_STATE_CONCLUDED:\n        qemuBlockJobEventProcessConcluded(job, driver, vm, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_STATE_READY:\n        /* mirror may be NULL for copy job corresponding to migration */\n        if (job->disk) {\n            job->disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_READY;\n            qemuBlockJobEmitEvents(driver, vm, job->disk, job->type, job->newstate);\n        }\n        job->state = job->newstate;\n        job->newstate = -1;\n        qemuDomainSaveStatus(vm);\n        break;\n\n    case QEMU_BLOCKJOB_STATE_NEW:\n    case QEMU_BLOCKJOB_STATE_RUNNING:\n    case QEMU_BLOCKJOB_STATE_LAST:\n    /* these are never processed as 'newstate' */\n    case QEMU_BLOCKJOB_STATE_ABORTING:\n    case QEMU_BLOCKJOB_STATE_PIVOTING:\n    default:\n        job->newstate = -1;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_BLOCKDEV"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}"
  },
  {
    "function_name": "qemuBlockJobEventProcess",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1615-1650",
    "snippet": "static void\nqemuBlockJobEventProcess(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuBlockJobDataPtr job,\n                         qemuDomainAsyncJob asyncJob)\n\n{\n    switch ((qemuBlockjobState) job->newstate) {\n    case QEMU_BLOCKJOB_STATE_COMPLETED:\n    case QEMU_BLOCKJOB_STATE_FAILED:\n    case QEMU_BLOCKJOB_STATE_CANCELLED:\n    case QEMU_BLOCKJOB_STATE_CONCLUDED:\n        qemuBlockJobEventProcessConcluded(job, driver, vm, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_STATE_READY:\n        /* mirror may be NULL for copy job corresponding to migration */\n        if (job->disk) {\n            job->disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_READY;\n            qemuBlockJobEmitEvents(driver, vm, job->disk, job->type, job->newstate);\n        }\n        job->state = job->newstate;\n        job->newstate = -1;\n        qemuDomainSaveStatus(vm);\n        break;\n\n    case QEMU_BLOCKJOB_STATE_NEW:\n    case QEMU_BLOCKJOB_STATE_RUNNING:\n    case QEMU_BLOCKJOB_STATE_LAST:\n    /* these are never processed as 'newstate' */\n    case QEMU_BLOCKJOB_STATE_ABORTING:\n    case QEMU_BLOCKJOB_STATE_PIVOTING:\n    default:\n        job->newstate = -1;\n    }\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainSaveStatus",
          "args": [
            "vm"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9569-9573",
          "snippet": "void\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEmitEvents",
          "args": [
            "driver",
            "vm",
            "job->disk",
            "job->type",
            "job->newstate"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEmitEvents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "600-628",
          "snippet": "static void\nqemuBlockJobEmitEvents(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       virDomainDiskDefPtr disk,\n                       virDomainBlockJobType type,\n                       virConnectDomainEventBlockJobStatus status)\n{\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr event2 = NULL;\n\n    /* don't emit events for jobs without disk */\n    if (!disk)\n        return;\n\n    /* don't emit events for internal jobs and states */\n    if (type >= VIR_DOMAIN_BLOCK_JOB_TYPE_LAST ||\n        status >= VIR_DOMAIN_BLOCK_JOB_LAST)\n        return;\n\n    if (virStorageSourceIsLocalStorage(disk->src) &&\n        !virStorageSourceIsEmpty(disk->src)) {\n        event = virDomainEventBlockJobNewFromObj(vm, virDomainDiskGetSource(disk),\n                                                 type, status);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    event2 = virDomainEventBlockJob2NewFromObj(vm, disk->dst, type, status);\n    virObjectEventStateQueue(driver->domainEventState, event2);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEmitEvents(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       virDomainDiskDefPtr disk,\n                       virDomainBlockJobType type,\n                       virConnectDomainEventBlockJobStatus status)\n{\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr event2 = NULL;\n\n    /* don't emit events for jobs without disk */\n    if (!disk)\n        return;\n\n    /* don't emit events for internal jobs and states */\n    if (type >= VIR_DOMAIN_BLOCK_JOB_TYPE_LAST ||\n        status >= VIR_DOMAIN_BLOCK_JOB_LAST)\n        return;\n\n    if (virStorageSourceIsLocalStorage(disk->src) &&\n        !virStorageSourceIsEmpty(disk->src)) {\n        event = virDomainEventBlockJobNewFromObj(vm, virDomainDiskGetSource(disk),\n                                                 type, status);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    event2 = virDomainEventBlockJob2NewFromObj(vm, disk->dst, type, status);\n    virObjectEventStateQueue(driver->domainEventState, event2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEventProcessConcluded",
          "args": [
            "job",
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 1627
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEventProcessConcluded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1533-1612",
          "snippet": "static void\nqemuBlockJobEventProcessConcluded(qemuBlockJobDataPtr job,\n                                  virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob)\n{\n    qemuMonitorJobInfoPtr *jobinfo = NULL;\n    size_t njobinfo = 0;\n    size_t i;\n    bool refreshed = false;\n    unsigned long long progressCurrent = 0;\n    unsigned long long progressTotal = 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* we need to fetch the error state as the event does not propagate it */\n    if (job->newstate == QEMU_BLOCKJOB_STATE_CONCLUDED &&\n        qemuMonitorGetJobInfo(qemuDomainGetMonitor(vm), &jobinfo, &njobinfo) == 0) {\n\n        for (i = 0; i < njobinfo; i++) {\n            if (STRNEQ_NULLABLE(job->name, jobinfo[i]->id))\n                continue;\n\n            progressCurrent = jobinfo[i]->progressCurrent;\n            progressTotal = jobinfo[i]->progressTotal;\n\n            job->errmsg = g_strdup(jobinfo[i]->error);\n\n            if (job->errmsg)\n                job->newstate = QEMU_BLOCKJOB_STATE_FAILED;\n            else\n                job->newstate = QEMU_BLOCKJOB_STATE_COMPLETED;\n\n            refreshed = true;\n\n            break;\n        }\n\n        if (i == njobinfo)\n            VIR_WARN(\"failed to refresh job '%s'\", job->name);\n    }\n\n    /* dismiss job in qemu */\n    ignore_value(qemuMonitorJobDismiss(qemuDomainGetMonitor(vm), job->name));\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n\n    if ((job->newstate == QEMU_BLOCKJOB_STATE_COMPLETED ||\n         job->newstate == QEMU_BLOCKJOB_STATE_FAILED) &&\n        job->state == QEMU_BLOCKJOB_STATE_ABORTING)\n        job->newstate = QEMU_BLOCKJOB_STATE_CANCELLED;\n\n    if (refreshed)\n        qemuDomainSaveStatus(vm);\n\n    VIR_DEBUG(\"handling job '%s' state '%d' newstate '%d'\", job->name, job->state, job->newstate);\n\n    qemuBlockJobEventProcessConcludedTransition(job, driver, vm, asyncJob,\n                                                progressCurrent, progressTotal);\n\n    /* unplug the backing chains in case the job inherited them */\n    if (!job->disk) {\n        if (job->chain)\n            qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob,\n                                                         job->chain);\n        if (job->mirrorChain)\n            qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob,\n                                                         job->mirrorChain);\n    }\n\n cleanup:\n    qemuBlockJobUnregister(job, vm);\n    qemuDomainSaveConfig(vm);\n\n    for (i = 0; i < njobinfo; i++)\n        qemuMonitorJobInfoFree(jobinfo[i]);\n    VIR_FREE(jobinfo);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessConcluded(qemuBlockJobDataPtr job,\n                                  virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob)\n{\n    qemuMonitorJobInfoPtr *jobinfo = NULL;\n    size_t njobinfo = 0;\n    size_t i;\n    bool refreshed = false;\n    unsigned long long progressCurrent = 0;\n    unsigned long long progressTotal = 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* we need to fetch the error state as the event does not propagate it */\n    if (job->newstate == QEMU_BLOCKJOB_STATE_CONCLUDED &&\n        qemuMonitorGetJobInfo(qemuDomainGetMonitor(vm), &jobinfo, &njobinfo) == 0) {\n\n        for (i = 0; i < njobinfo; i++) {\n            if (STRNEQ_NULLABLE(job->name, jobinfo[i]->id))\n                continue;\n\n            progressCurrent = jobinfo[i]->progressCurrent;\n            progressTotal = jobinfo[i]->progressTotal;\n\n            job->errmsg = g_strdup(jobinfo[i]->error);\n\n            if (job->errmsg)\n                job->newstate = QEMU_BLOCKJOB_STATE_FAILED;\n            else\n                job->newstate = QEMU_BLOCKJOB_STATE_COMPLETED;\n\n            refreshed = true;\n\n            break;\n        }\n\n        if (i == njobinfo)\n            VIR_WARN(\"failed to refresh job '%s'\", job->name);\n    }\n\n    /* dismiss job in qemu */\n    ignore_value(qemuMonitorJobDismiss(qemuDomainGetMonitor(vm), job->name));\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n\n    if ((job->newstate == QEMU_BLOCKJOB_STATE_COMPLETED ||\n         job->newstate == QEMU_BLOCKJOB_STATE_FAILED) &&\n        job->state == QEMU_BLOCKJOB_STATE_ABORTING)\n        job->newstate = QEMU_BLOCKJOB_STATE_CANCELLED;\n\n    if (refreshed)\n        qemuDomainSaveStatus(vm);\n\n    VIR_DEBUG(\"handling job '%s' state '%d' newstate '%d'\", job->name, job->state, job->newstate);\n\n    qemuBlockJobEventProcessConcludedTransition(job, driver, vm, asyncJob,\n                                                progressCurrent, progressTotal);\n\n    /* unplug the backing chains in case the job inherited them */\n    if (!job->disk) {\n        if (job->chain)\n            qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob,\n                                                         job->chain);\n        if (job->mirrorChain)\n            qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob,\n                                                         job->mirrorChain);\n    }\n\n cleanup:\n    qemuBlockJobUnregister(job, vm);\n    qemuDomainSaveConfig(vm);\n\n    for (i = 0; i < njobinfo; i++)\n        qemuMonitorJobInfoFree(jobinfo[i]);\n    VIR_FREE(jobinfo);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcess(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuBlockJobDataPtr job,\n                         qemuDomainAsyncJob asyncJob)\n\n{\n    switch ((qemuBlockjobState) job->newstate) {\n    case QEMU_BLOCKJOB_STATE_COMPLETED:\n    case QEMU_BLOCKJOB_STATE_FAILED:\n    case QEMU_BLOCKJOB_STATE_CANCELLED:\n    case QEMU_BLOCKJOB_STATE_CONCLUDED:\n        qemuBlockJobEventProcessConcluded(job, driver, vm, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_STATE_READY:\n        /* mirror may be NULL for copy job corresponding to migration */\n        if (job->disk) {\n            job->disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_READY;\n            qemuBlockJobEmitEvents(driver, vm, job->disk, job->type, job->newstate);\n        }\n        job->state = job->newstate;\n        job->newstate = -1;\n        qemuDomainSaveStatus(vm);\n        break;\n\n    case QEMU_BLOCKJOB_STATE_NEW:\n    case QEMU_BLOCKJOB_STATE_RUNNING:\n    case QEMU_BLOCKJOB_STATE_LAST:\n    /* these are never processed as 'newstate' */\n    case QEMU_BLOCKJOB_STATE_ABORTING:\n    case QEMU_BLOCKJOB_STATE_PIVOTING:\n    default:\n        job->newstate = -1;\n    }\n}"
  },
  {
    "function_name": "qemuBlockJobEventProcessConcluded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1533-1612",
    "snippet": "static void\nqemuBlockJobEventProcessConcluded(qemuBlockJobDataPtr job,\n                                  virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob)\n{\n    qemuMonitorJobInfoPtr *jobinfo = NULL;\n    size_t njobinfo = 0;\n    size_t i;\n    bool refreshed = false;\n    unsigned long long progressCurrent = 0;\n    unsigned long long progressTotal = 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* we need to fetch the error state as the event does not propagate it */\n    if (job->newstate == QEMU_BLOCKJOB_STATE_CONCLUDED &&\n        qemuMonitorGetJobInfo(qemuDomainGetMonitor(vm), &jobinfo, &njobinfo) == 0) {\n\n        for (i = 0; i < njobinfo; i++) {\n            if (STRNEQ_NULLABLE(job->name, jobinfo[i]->id))\n                continue;\n\n            progressCurrent = jobinfo[i]->progressCurrent;\n            progressTotal = jobinfo[i]->progressTotal;\n\n            job->errmsg = g_strdup(jobinfo[i]->error);\n\n            if (job->errmsg)\n                job->newstate = QEMU_BLOCKJOB_STATE_FAILED;\n            else\n                job->newstate = QEMU_BLOCKJOB_STATE_COMPLETED;\n\n            refreshed = true;\n\n            break;\n        }\n\n        if (i == njobinfo)\n            VIR_WARN(\"failed to refresh job '%s'\", job->name);\n    }\n\n    /* dismiss job in qemu */\n    ignore_value(qemuMonitorJobDismiss(qemuDomainGetMonitor(vm), job->name));\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n\n    if ((job->newstate == QEMU_BLOCKJOB_STATE_COMPLETED ||\n         job->newstate == QEMU_BLOCKJOB_STATE_FAILED) &&\n        job->state == QEMU_BLOCKJOB_STATE_ABORTING)\n        job->newstate = QEMU_BLOCKJOB_STATE_CANCELLED;\n\n    if (refreshed)\n        qemuDomainSaveStatus(vm);\n\n    VIR_DEBUG(\"handling job '%s' state '%d' newstate '%d'\", job->name, job->state, job->newstate);\n\n    qemuBlockJobEventProcessConcludedTransition(job, driver, vm, asyncJob,\n                                                progressCurrent, progressTotal);\n\n    /* unplug the backing chains in case the job inherited them */\n    if (!job->disk) {\n        if (job->chain)\n            qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob,\n                                                         job->chain);\n        if (job->mirrorChain)\n            qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob,\n                                                         job->mirrorChain);\n    }\n\n cleanup:\n    qemuBlockJobUnregister(job, vm);\n    qemuDomainSaveConfig(vm);\n\n    for (i = 0; i < njobinfo; i++)\n        qemuMonitorJobInfoFree(jobinfo[i]);\n    VIR_FREE(jobinfo);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "jobinfo"
          ],
          "line": 1611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJobInfoFree",
          "args": [
            "jobinfo[i]"
          ],
          "line": 1610
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJobInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4475-4484",
          "snippet": "void\nqemuMonitorJobInfoFree(qemuMonitorJobInfoPtr job)\n{\n    if (!job)\n        return;\n\n    VIR_FREE(job->id);\n    VIR_FREE(job->error);\n    VIR_FREE(job);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorJobInfoFree(qemuMonitorJobInfoPtr job)\n{\n    if (!job)\n        return;\n\n    VIR_FREE(job->id);\n    VIR_FREE(job->error);\n    VIR_FREE(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainSaveConfig",
          "args": [
            "vm"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainSaveConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9576-9595",
          "snippet": "void\nqemuDomainSaveConfig(virDomainObjPtr obj)\n{\n    virQEMUDriverPtr driver = QEMU_DOMAIN_PRIVATE(obj)->driver;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    virDomainDefPtr def = NULL;\n\n    if (virDomainObjIsActive(obj))\n        def = obj->newDef;\n    else\n        def = obj->def;\n\n    if (!def)\n        return;\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (virDomainDefSave(def, driver->xmlopt, cfg->configDir) < 0)\n        VIR_WARN(\"Failed to save config of vm %s\", obj->def->name);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nobj, obj->def->name);\n\nvoid\nqemuDomainSaveConfig(virDomainObjPtr obj)\n{\n    virQEMUDriverPtr driver = QEMU_DOMAIN_PRIVATE(obj)->driver;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    virDomainDefPtr def = NULL;\n\n    if (virDomainObjIsActive(obj))\n        def = obj->newDef;\n    else\n        def = obj->def;\n\n    if (!def)\n        return;\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (virDomainDefSave(def, driver->xmlopt, cfg->configDir) < 0)\n        VIR_WARN(\"Failed to save config of vm %s\", obj->def->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobUnregister",
          "args": [
            "job",
            "vm"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobUnregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "201-223",
          "snippet": "static void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEventProcessConcludedRemoveChain",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "job->mirrorChain"
          ],
          "line": 1601
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEventProcessConcludedRemoveChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "836-855",
          "snippet": "static void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEventProcessConcludedTransition",
          "args": [
            "job",
            "driver",
            "vm",
            "asyncJob",
            "progressCurrent",
            "progressTotal"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEventProcessConcludedTransition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1470-1530",
          "snippet": "static void\nqemuBlockJobEventProcessConcludedTransition(qemuBlockJobDataPtr job,\n                                            virQEMUDriverPtr driver,\n                                            virDomainObjPtr vm,\n                                            qemuDomainAsyncJob asyncJob,\n                                            unsigned long long progressCurrent,\n                                            unsigned long long progressTotal)\n{\n    bool success = job->newstate == QEMU_BLOCKJOB_STATE_COMPLETED;\n\n    switch ((qemuBlockJobType) job->type) {\n    case QEMU_BLOCKJOB_TYPE_PULL:\n        if (success)\n            qemuBlockJobProcessEventCompletedPull(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_COMMIT:\n        if (success)\n            qemuBlockJobProcessEventCompletedCommit(driver, vm, job, asyncJob);\n        else\n            qemuBlockJobProcessEventFailedCommitCommon(vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_ACTIVE_COMMIT:\n        if (success) {\n            qemuBlockJobProcessEventCompletedActiveCommit(driver, vm, job, asyncJob);\n        } else {\n            qemuBlockJobProcessEventFailedActiveCommit(driver, vm, job);\n            qemuBlockJobProcessEventFailedCommitCommon(vm, job, asyncJob);\n        }\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_CREATE:\n        qemuBlockJobProcessEventConcludedCreate(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_COPY:\n        if (job->state == QEMU_BLOCKJOB_STATE_PIVOTING && success)\n            qemuBlockJobProcessEventConcludedCopyPivot(driver, vm, job, asyncJob);\n        else\n            qemuBlockJobProcessEventConcludedCopyAbort(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_BACKUP:\n        qemuBlockJobProcessEventConcludedBackup(driver, vm, job, asyncJob,\n                                                job->newstate, progressCurrent,\n                                                progressTotal);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_BROKEN:\n    case QEMU_BLOCKJOB_TYPE_NONE:\n    case QEMU_BLOCKJOB_TYPE_INTERNAL:\n    case QEMU_BLOCKJOB_TYPE_LAST:\n    default:\n        break;\n    }\n\n    qemuBlockJobEmitEvents(driver, vm, job->disk, job->type, job->newstate);\n    job->state = job->newstate;\n    job->newstate = -1;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessConcludedTransition(qemuBlockJobDataPtr job,\n                                            virQEMUDriverPtr driver,\n                                            virDomainObjPtr vm,\n                                            qemuDomainAsyncJob asyncJob,\n                                            unsigned long long progressCurrent,\n                                            unsigned long long progressTotal)\n{\n    bool success = job->newstate == QEMU_BLOCKJOB_STATE_COMPLETED;\n\n    switch ((qemuBlockJobType) job->type) {\n    case QEMU_BLOCKJOB_TYPE_PULL:\n        if (success)\n            qemuBlockJobProcessEventCompletedPull(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_COMMIT:\n        if (success)\n            qemuBlockJobProcessEventCompletedCommit(driver, vm, job, asyncJob);\n        else\n            qemuBlockJobProcessEventFailedCommitCommon(vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_ACTIVE_COMMIT:\n        if (success) {\n            qemuBlockJobProcessEventCompletedActiveCommit(driver, vm, job, asyncJob);\n        } else {\n            qemuBlockJobProcessEventFailedActiveCommit(driver, vm, job);\n            qemuBlockJobProcessEventFailedCommitCommon(vm, job, asyncJob);\n        }\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_CREATE:\n        qemuBlockJobProcessEventConcludedCreate(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_COPY:\n        if (job->state == QEMU_BLOCKJOB_STATE_PIVOTING && success)\n            qemuBlockJobProcessEventConcludedCopyPivot(driver, vm, job, asyncJob);\n        else\n            qemuBlockJobProcessEventConcludedCopyAbort(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_BACKUP:\n        qemuBlockJobProcessEventConcludedBackup(driver, vm, job, asyncJob,\n                                                job->newstate, progressCurrent,\n                                                progressTotal);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_BROKEN:\n    case QEMU_BLOCKJOB_TYPE_NONE:\n    case QEMU_BLOCKJOB_TYPE_INTERNAL:\n    case QEMU_BLOCKJOB_TYPE_LAST:\n    default:\n        break;\n    }\n\n    qemuBlockJobEmitEvents(driver, vm, job->disk, job->type, job->newstate);\n    job->state = job->newstate;\n    job->newstate = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"handling job '%s' state '%d' newstate '%d'\"",
            "job->name",
            "job->state",
            "job->newstate"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainSaveStatus",
          "args": [
            "vm"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9569-9573",
          "snippet": "void\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1579
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuMonitorJobDismiss(qemuDomainGetMonitor(vm), job->name)"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJobDismiss",
          "args": [
            "qemuDomainGetMonitor(vm)",
            "job->name"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJobDismiss",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3294-3303",
          "snippet": "int\nqemuMonitorJobDismiss(qemuMonitorPtr mon,\n                      const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobDismiss(mon, jobname);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJobDismiss(qemuMonitorPtr mon,\n                      const char *jobname)\n{\n    VIR_DEBUG(\"jobname=%s\", jobname);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobDismiss(mon, jobname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainGetMonitor",
          "args": [
            "vm"
          ],
          "line": 1577
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12703-12707",
          "snippet": "qemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nqemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"failed to refresh job '%s'\"",
            "job->name"
          ],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "jobinfo[i]->error"
          ],
          "line": 1560
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "STRNEQ_NULLABLE",
          "args": [
            "job->name",
            "jobinfo[i]->id"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetJobInfo",
          "args": [
            "qemuDomainGetMonitor(vm)",
            "&jobinfo",
            "&njobinfo"
          ],
          "line": 1551
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetJobInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4487-4495",
          "snippet": "int\nqemuMonitorGetJobInfo(qemuMonitorPtr mon,\n                      qemuMonitorJobInfoPtr **jobs,\n                      size_t *njobs)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetJobInfo(mon, jobs, njobs);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetJobInfo(qemuMonitorPtr mon,\n                      qemuMonitorJobInfoPtr **jobs,\n                      size_t *njobs)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetJobInfo(mon, jobs, njobs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 1546
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessConcluded(qemuBlockJobDataPtr job,\n                                  virQEMUDriverPtr driver,\n                                  virDomainObjPtr vm,\n                                  qemuDomainAsyncJob asyncJob)\n{\n    qemuMonitorJobInfoPtr *jobinfo = NULL;\n    size_t njobinfo = 0;\n    size_t i;\n    bool refreshed = false;\n    unsigned long long progressCurrent = 0;\n    unsigned long long progressTotal = 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        goto cleanup;\n\n    /* we need to fetch the error state as the event does not propagate it */\n    if (job->newstate == QEMU_BLOCKJOB_STATE_CONCLUDED &&\n        qemuMonitorGetJobInfo(qemuDomainGetMonitor(vm), &jobinfo, &njobinfo) == 0) {\n\n        for (i = 0; i < njobinfo; i++) {\n            if (STRNEQ_NULLABLE(job->name, jobinfo[i]->id))\n                continue;\n\n            progressCurrent = jobinfo[i]->progressCurrent;\n            progressTotal = jobinfo[i]->progressTotal;\n\n            job->errmsg = g_strdup(jobinfo[i]->error);\n\n            if (job->errmsg)\n                job->newstate = QEMU_BLOCKJOB_STATE_FAILED;\n            else\n                job->newstate = QEMU_BLOCKJOB_STATE_COMPLETED;\n\n            refreshed = true;\n\n            break;\n        }\n\n        if (i == njobinfo)\n            VIR_WARN(\"failed to refresh job '%s'\", job->name);\n    }\n\n    /* dismiss job in qemu */\n    ignore_value(qemuMonitorJobDismiss(qemuDomainGetMonitor(vm), job->name));\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        goto cleanup;\n\n    if ((job->newstate == QEMU_BLOCKJOB_STATE_COMPLETED ||\n         job->newstate == QEMU_BLOCKJOB_STATE_FAILED) &&\n        job->state == QEMU_BLOCKJOB_STATE_ABORTING)\n        job->newstate = QEMU_BLOCKJOB_STATE_CANCELLED;\n\n    if (refreshed)\n        qemuDomainSaveStatus(vm);\n\n    VIR_DEBUG(\"handling job '%s' state '%d' newstate '%d'\", job->name, job->state, job->newstate);\n\n    qemuBlockJobEventProcessConcludedTransition(job, driver, vm, asyncJob,\n                                                progressCurrent, progressTotal);\n\n    /* unplug the backing chains in case the job inherited them */\n    if (!job->disk) {\n        if (job->chain)\n            qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob,\n                                                         job->chain);\n        if (job->mirrorChain)\n            qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob,\n                                                         job->mirrorChain);\n    }\n\n cleanup:\n    qemuBlockJobUnregister(job, vm);\n    qemuDomainSaveConfig(vm);\n\n    for (i = 0; i < njobinfo; i++)\n        qemuMonitorJobInfoFree(jobinfo[i]);\n    VIR_FREE(jobinfo);\n}"
  },
  {
    "function_name": "qemuBlockJobEventProcessConcludedTransition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1470-1530",
    "snippet": "static void\nqemuBlockJobEventProcessConcludedTransition(qemuBlockJobDataPtr job,\n                                            virQEMUDriverPtr driver,\n                                            virDomainObjPtr vm,\n                                            qemuDomainAsyncJob asyncJob,\n                                            unsigned long long progressCurrent,\n                                            unsigned long long progressTotal)\n{\n    bool success = job->newstate == QEMU_BLOCKJOB_STATE_COMPLETED;\n\n    switch ((qemuBlockJobType) job->type) {\n    case QEMU_BLOCKJOB_TYPE_PULL:\n        if (success)\n            qemuBlockJobProcessEventCompletedPull(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_COMMIT:\n        if (success)\n            qemuBlockJobProcessEventCompletedCommit(driver, vm, job, asyncJob);\n        else\n            qemuBlockJobProcessEventFailedCommitCommon(vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_ACTIVE_COMMIT:\n        if (success) {\n            qemuBlockJobProcessEventCompletedActiveCommit(driver, vm, job, asyncJob);\n        } else {\n            qemuBlockJobProcessEventFailedActiveCommit(driver, vm, job);\n            qemuBlockJobProcessEventFailedCommitCommon(vm, job, asyncJob);\n        }\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_CREATE:\n        qemuBlockJobProcessEventConcludedCreate(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_COPY:\n        if (job->state == QEMU_BLOCKJOB_STATE_PIVOTING && success)\n            qemuBlockJobProcessEventConcludedCopyPivot(driver, vm, job, asyncJob);\n        else\n            qemuBlockJobProcessEventConcludedCopyAbort(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_BACKUP:\n        qemuBlockJobProcessEventConcludedBackup(driver, vm, job, asyncJob,\n                                                job->newstate, progressCurrent,\n                                                progressTotal);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_BROKEN:\n    case QEMU_BLOCKJOB_TYPE_NONE:\n    case QEMU_BLOCKJOB_TYPE_INTERNAL:\n    case QEMU_BLOCKJOB_TYPE_LAST:\n    default:\n        break;\n    }\n\n    qemuBlockJobEmitEvents(driver, vm, job->disk, job->type, job->newstate);\n    job->state = job->newstate;\n    job->newstate = -1;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBlockJobEmitEvents",
          "args": [
            "driver",
            "vm",
            "job->disk",
            "job->type",
            "job->newstate"
          ],
          "line": 1527
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEmitEvents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "600-628",
          "snippet": "static void\nqemuBlockJobEmitEvents(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       virDomainDiskDefPtr disk,\n                       virDomainBlockJobType type,\n                       virConnectDomainEventBlockJobStatus status)\n{\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr event2 = NULL;\n\n    /* don't emit events for jobs without disk */\n    if (!disk)\n        return;\n\n    /* don't emit events for internal jobs and states */\n    if (type >= VIR_DOMAIN_BLOCK_JOB_TYPE_LAST ||\n        status >= VIR_DOMAIN_BLOCK_JOB_LAST)\n        return;\n\n    if (virStorageSourceIsLocalStorage(disk->src) &&\n        !virStorageSourceIsEmpty(disk->src)) {\n        event = virDomainEventBlockJobNewFromObj(vm, virDomainDiskGetSource(disk),\n                                                 type, status);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    event2 = virDomainEventBlockJob2NewFromObj(vm, disk->dst, type, status);\n    virObjectEventStateQueue(driver->domainEventState, event2);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEmitEvents(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       virDomainDiskDefPtr disk,\n                       virDomainBlockJobType type,\n                       virConnectDomainEventBlockJobStatus status)\n{\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr event2 = NULL;\n\n    /* don't emit events for jobs without disk */\n    if (!disk)\n        return;\n\n    /* don't emit events for internal jobs and states */\n    if (type >= VIR_DOMAIN_BLOCK_JOB_TYPE_LAST ||\n        status >= VIR_DOMAIN_BLOCK_JOB_LAST)\n        return;\n\n    if (virStorageSourceIsLocalStorage(disk->src) &&\n        !virStorageSourceIsEmpty(disk->src)) {\n        event = virDomainEventBlockJobNewFromObj(vm, virDomainDiskGetSource(disk),\n                                                 type, status);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    event2 = virDomainEventBlockJob2NewFromObj(vm, disk->dst, type, status);\n    virObjectEventStateQueue(driver->domainEventState, event2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobProcessEventConcludedBackup",
          "args": [
            "driver",
            "vm",
            "job",
            "asyncJob",
            "job->newstate",
            "progressCurrent",
            "progressTotal"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobProcessEventConcludedBackup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1425-1467",
          "snippet": "static void\nqemuBlockJobProcessEventConcludedBackup(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob,\n                                        qemuBlockjobState newstate,\n                                        unsigned long long progressCurrent,\n                                        unsigned long long progressTotal)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) backend = NULL;\n    g_autoptr(virJSONValue) actions = NULL;\n\n    qemuBackupNotifyBlockjobEnd(vm, job->disk, newstate,\n                                progressCurrent, progressTotal, asyncJob);\n\n    if (job->data.backup.store &&\n        !(backend = qemuBlockStorageSourceDetachPrepare(job->data.backup.store, NULL)))\n        return;\n\n    if (job->data.backup.bitmap) {\n        actions = virJSONValueNewArray();\n\n        if (qemuMonitorTransactionBitmapRemove(actions,\n                                               job->disk->src->nodeformat,\n                                               job->data.backup.bitmap) < 0)\n            return;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    if (backend)\n        qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), backend);\n\n    if (actions)\n        qemuMonitorTransaction(qemuDomainGetMonitor(vm), &actions);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    if (job->data.backup.store)\n        qemuDomainStorageSourceAccessRevoke(driver, vm, job->data.backup.store);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventConcludedBackup(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob,\n                                        qemuBlockjobState newstate,\n                                        unsigned long long progressCurrent,\n                                        unsigned long long progressTotal)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) backend = NULL;\n    g_autoptr(virJSONValue) actions = NULL;\n\n    qemuBackupNotifyBlockjobEnd(vm, job->disk, newstate,\n                                progressCurrent, progressTotal, asyncJob);\n\n    if (job->data.backup.store &&\n        !(backend = qemuBlockStorageSourceDetachPrepare(job->data.backup.store, NULL)))\n        return;\n\n    if (job->data.backup.bitmap) {\n        actions = virJSONValueNewArray();\n\n        if (qemuMonitorTransactionBitmapRemove(actions,\n                                               job->disk->src->nodeformat,\n                                               job->data.backup.bitmap) < 0)\n            return;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    if (backend)\n        qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), backend);\n\n    if (actions)\n        qemuMonitorTransaction(qemuDomainGetMonitor(vm), &actions);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    if (job->data.backup.store)\n        qemuDomainStorageSourceAccessRevoke(driver, vm, job->data.backup.store);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobProcessEventConcludedCopyAbort",
          "args": [
            "driver",
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobProcessEventConcludedCopyAbort",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1307-1323",
          "snippet": "static void\nqemuBlockJobProcessEventConcludedCopyAbort(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    VIR_DEBUG(\"copy job '%s' on VM '%s' aborted\", job->name, vm->def->name);\n\n    /* mirror may be NULL for copy job corresponding to migration */\n    if (!job->disk ||\n        !job->disk->mirror)\n        return;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->disk->mirror);\n    virObjectUnref(job->disk->mirror);\n    job->disk->mirror = NULL;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventConcludedCopyAbort(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    VIR_DEBUG(\"copy job '%s' on VM '%s' aborted\", job->name, vm->def->name);\n\n    /* mirror may be NULL for copy job corresponding to migration */\n    if (!job->disk ||\n        !job->disk->mirror)\n        return;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->disk->mirror);\n    virObjectUnref(job->disk->mirror);\n    job->disk->mirror = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobProcessEventConcludedCopyPivot",
          "args": [
            "driver",
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobProcessEventConcludedCopyPivot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1278-1304",
          "snippet": "static void\nqemuBlockJobProcessEventConcludedCopyPivot(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    VIR_DEBUG(\"copy job '%s' on VM '%s' pivoted\", job->name, vm->def->name);\n\n    /* mirror may be NULL for copy job corresponding to migration */\n    if (!job->disk ||\n        !job->disk->mirror)\n        return;\n\n    /* for shallow copy without reusing external image the user can either not\n     * specify the backing chain in which case libvirt will open and use the\n     * chain the user provided or not specify a chain in which case we'll\n     * inherit the rest of the chain */\n    if (job->data.copy.shallownew &&\n        !virStorageSourceIsBacking(job->disk->mirror->backingStore))\n        job->disk->mirror->backingStore = g_steal_pointer(&job->disk->src->backingStore);\n\n    qemuBlockJobRewriteConfigDiskSource(vm, job->disk, job->disk->mirror);\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->disk->src);\n    virObjectUnref(job->disk->src);\n    job->disk->src = g_steal_pointer(&job->disk->mirror);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventConcludedCopyPivot(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    VIR_DEBUG(\"copy job '%s' on VM '%s' pivoted\", job->name, vm->def->name);\n\n    /* mirror may be NULL for copy job corresponding to migration */\n    if (!job->disk ||\n        !job->disk->mirror)\n        return;\n\n    /* for shallow copy without reusing external image the user can either not\n     * specify the backing chain in which case libvirt will open and use the\n     * chain the user provided or not specify a chain in which case we'll\n     * inherit the rest of the chain */\n    if (job->data.copy.shallownew &&\n        !virStorageSourceIsBacking(job->disk->mirror->backingStore))\n        job->disk->mirror->backingStore = g_steal_pointer(&job->disk->src->backingStore);\n\n    qemuBlockJobRewriteConfigDiskSource(vm, job->disk, job->disk->mirror);\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->disk->src);\n    virObjectUnref(job->disk->src);\n    job->disk->src = g_steal_pointer(&job->disk->mirror);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobProcessEventConcludedCreate",
          "args": [
            "driver",
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobProcessEventConcludedCreate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1382-1422",
          "snippet": "static void\nqemuBlockJobProcessEventConcludedCreate(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) backend = NULL;\n\n    /* if there is a synchronous client waiting for this job that means that\n     * it will handle further hotplug of the created volume and also that\n     * the 'chain' which was registered is under their control */\n    if (job->synchronous) {\n        virObjectUnref(job->chain);\n        job->chain = NULL;\n        return;\n    }\n\n    if (!job->data.create.src)\n        return;\n\n    if (!(backend = qemuBlockStorageSourceDetachPrepare(job->data.create.src, NULL)))\n        return;\n\n    /* the format node part was not attached yet, so we don't need to detach it */\n    backend->formatAttached = false;\n    if (job->data.create.storage) {\n        backend->storageAttached = false;\n        backend->storageSliceAttached = false;\n        VIR_FREE(backend->encryptsecretAlias);\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), backend);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceAccessRevoke(driver, vm, job->data.create.src);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventConcludedCreate(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) backend = NULL;\n\n    /* if there is a synchronous client waiting for this job that means that\n     * it will handle further hotplug of the created volume and also that\n     * the 'chain' which was registered is under their control */\n    if (job->synchronous) {\n        virObjectUnref(job->chain);\n        job->chain = NULL;\n        return;\n    }\n\n    if (!job->data.create.src)\n        return;\n\n    if (!(backend = qemuBlockStorageSourceDetachPrepare(job->data.create.src, NULL)))\n        return;\n\n    /* the format node part was not attached yet, so we don't need to detach it */\n    backend->formatAttached = false;\n    if (job->data.create.storage) {\n        backend->storageAttached = false;\n        backend->storageSliceAttached = false;\n        VIR_FREE(backend->encryptsecretAlias);\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), backend);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceAccessRevoke(driver, vm, job->data.create.src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobProcessEventFailedCommitCommon",
          "args": [
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 1498
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobProcessEventFailedCommitCommon",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1348-1379",
          "snippet": "static void\nqemuBlockJobProcessEventFailedCommitCommon(virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virJSONValue) actions = virJSONValueNewArray();\n    char **disabledBitmaps = job->data.commit.disabledBitmapsBase;\n\n    if (!disabledBitmaps || !*disabledBitmaps)\n        return;\n\n    for (; *disabledBitmaps; disabledBitmaps++) {\n        qemuMonitorTransactionBitmapEnable(actions,\n                                           job->data.commit.base->nodeformat,\n                                           *disabledBitmaps);\n    }\n\n    if (qemuBlockReopenReadWrite(vm, job->data.commit.base, asyncJob) < 0)\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        return;\n\n    qemuMonitorTransaction(priv->mon, &actions);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n        return;\n\n    if (qemuBlockReopenReadOnly(vm, job->data.commit.base, asyncJob) < 0)\n        return;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventFailedCommitCommon(virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virJSONValue) actions = virJSONValueNewArray();\n    char **disabledBitmaps = job->data.commit.disabledBitmapsBase;\n\n    if (!disabledBitmaps || !*disabledBitmaps)\n        return;\n\n    for (; *disabledBitmaps; disabledBitmaps++) {\n        qemuMonitorTransactionBitmapEnable(actions,\n                                           job->data.commit.base->nodeformat,\n                                           *disabledBitmaps);\n    }\n\n    if (qemuBlockReopenReadWrite(vm, job->data.commit.base, asyncJob) < 0)\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        return;\n\n    qemuMonitorTransaction(priv->mon, &actions);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n        return;\n\n    if (qemuBlockReopenReadOnly(vm, job->data.commit.base, asyncJob) < 0)\n        return;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobProcessEventFailedActiveCommit",
          "args": [
            "driver",
            "vm",
            "job"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobProcessEventFailedActiveCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1326-1345",
          "snippet": "static void\nqemuBlockJobProcessEventFailedActiveCommit(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    VIR_DEBUG(\"active commit job '%s' on VM '%s' failed\", job->name, vm->def->name);\n\n    if (!disk)\n        return;\n\n    /* Ideally, we would make the backing chain read only again (yes, SELinux\n     * can do that using different labels). But that is not implemented yet and\n     * not leaking security driver metadata is more important. */\n    qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n    virObjectUnref(disk->mirror);\n    disk->mirror = NULL;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventFailedActiveCommit(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    VIR_DEBUG(\"active commit job '%s' on VM '%s' failed\", job->name, vm->def->name);\n\n    if (!disk)\n        return;\n\n    /* Ideally, we would make the backing chain read only again (yes, SELinux\n     * can do that using different labels). But that is not implemented yet and\n     * not leaking security driver metadata is more important. */\n    qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n    virObjectUnref(disk->mirror);\n    disk->mirror = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobProcessEventCompletedActiveCommit",
          "args": [
            "driver",
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobProcessEventCompletedActiveCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1206-1275",
          "snippet": "static void\nqemuBlockJobProcessEventCompletedActiveCommit(virQEMUDriverPtr driver,\n                                              virDomainObjPtr vm,\n                                              qemuBlockJobDataPtr job,\n                                              qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgnext = NULL;\n    virStorageSourcePtr cfgtop = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n\n    VIR_DEBUG(\"active commit job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.commit.base)))\n        cfgnext = cfgdisk->src;\n\n    for (n = job->disk->src; n && n != job->data.commit.base; n = n->backingStore) {\n        if (cfgnext) {\n            if (n == job->data.commit.top)\n                cfgtop = cfgnext;\n\n            cfgbaseparent = cfgnext;\n            cfgnext = cfgnext->backingStore;\n        }\n        baseparent = n;\n    }\n\n    if (!n)\n        return;\n\n    if (!cfgdisk) {\n        /* in case when the config disk chain didn't match but the disk top seems\n         * to be identical we need to modify the disk source since the active\n         * commit makes the top level image invalid.\n         */\n        qemuBlockJobRewriteConfigDiskSource(vm, job->disk, job->data.commit.base);\n    } else {\n        cfgbase = cfgbaseparent->backingStore;\n        cfgbaseparent->backingStore = NULL;\n        cfgdisk->src = cfgbase;\n        cfgdisk->src->readonly = cfgtop->readonly;\n        virObjectUnref(cfgtop);\n    }\n\n    /* Move security driver metadata */\n    if (qemuSecurityMoveImageMetadata(driver, vm, job->disk->src, job->data.commit.base) < 0)\n        VIR_WARN(\"Unable to move disk metadata on vm %s\", vm->def->name);\n\n    baseparent->backingStore = NULL;\n    job->disk->src = job->data.commit.base;\n    job->disk->src->readonly = job->data.commit.top->readonly;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->data.commit.top);\n\n    if (job->data.commit.deleteCommittedImages)\n        qemuBlockJobDeleteImages(driver, vm, job->disk, job->data.commit.top);\n\n    virObjectUnref(job->data.commit.top);\n    job->data.commit.top = NULL;\n    /* the mirror element does not serve functional purpose for the commit job */\n    virObjectUnref(job->disk->mirror);\n    job->disk->mirror = NULL;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventCompletedActiveCommit(virQEMUDriverPtr driver,\n                                              virDomainObjPtr vm,\n                                              qemuBlockJobDataPtr job,\n                                              qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgnext = NULL;\n    virStorageSourcePtr cfgtop = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n\n    VIR_DEBUG(\"active commit job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.commit.base)))\n        cfgnext = cfgdisk->src;\n\n    for (n = job->disk->src; n && n != job->data.commit.base; n = n->backingStore) {\n        if (cfgnext) {\n            if (n == job->data.commit.top)\n                cfgtop = cfgnext;\n\n            cfgbaseparent = cfgnext;\n            cfgnext = cfgnext->backingStore;\n        }\n        baseparent = n;\n    }\n\n    if (!n)\n        return;\n\n    if (!cfgdisk) {\n        /* in case when the config disk chain didn't match but the disk top seems\n         * to be identical we need to modify the disk source since the active\n         * commit makes the top level image invalid.\n         */\n        qemuBlockJobRewriteConfigDiskSource(vm, job->disk, job->data.commit.base);\n    } else {\n        cfgbase = cfgbaseparent->backingStore;\n        cfgbaseparent->backingStore = NULL;\n        cfgdisk->src = cfgbase;\n        cfgdisk->src->readonly = cfgtop->readonly;\n        virObjectUnref(cfgtop);\n    }\n\n    /* Move security driver metadata */\n    if (qemuSecurityMoveImageMetadata(driver, vm, job->disk->src, job->data.commit.base) < 0)\n        VIR_WARN(\"Unable to move disk metadata on vm %s\", vm->def->name);\n\n    baseparent->backingStore = NULL;\n    job->disk->src = job->data.commit.base;\n    job->disk->src->readonly = job->data.commit.top->readonly;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->data.commit.top);\n\n    if (job->data.commit.deleteCommittedImages)\n        qemuBlockJobDeleteImages(driver, vm, job->disk, job->data.commit.top);\n\n    virObjectUnref(job->data.commit.top);\n    job->data.commit.top = NULL;\n    /* the mirror element does not serve functional purpose for the commit job */\n    virObjectUnref(job->disk->mirror);\n    job->disk->mirror = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobProcessEventCompletedCommit",
          "args": [
            "driver",
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 1488
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobProcessEventCompletedCommit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1114-1190",
          "snippet": "static void\nqemuBlockJobProcessEventCompletedCommit(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgnext = NULL;\n    virStorageSourcePtr cfgtopparent = NULL;\n    virStorageSourcePtr cfgtop = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n\n    VIR_DEBUG(\"commit job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.commit.base)))\n        cfgnext = cfgdisk->src;\n\n    if (!cfgdisk)\n        qemuBlockJobClearConfigChain(vm, job->disk);\n\n    for (n = job->disk->src; n && n != job->data.commit.base; n = n->backingStore) {\n        if (cfgnext) {\n            if (n == job->data.commit.topparent)\n                cfgtopparent = cfgnext;\n\n            if (n == job->data.commit.top)\n                cfgtop = cfgnext;\n\n            cfgbaseparent = cfgnext;\n            cfgnext = cfgnext->backingStore;\n        }\n        baseparent = n;\n    }\n\n    if (!n)\n        return;\n\n    if (qemuBlockJobProcessEventCompletedCommitBitmaps(vm, job, asyncJob) < 0)\n        return;\n\n    /* revert access to images */\n    qemuDomainStorageSourceAccessAllow(driver, vm, job->data.commit.base,\n                                       true, false, false);\n    if (job->data.commit.topparent != job->disk->src)\n        qemuDomainStorageSourceAccessAllow(driver, vm, job->data.commit.topparent,\n                                           true, false, true);\n\n    baseparent->backingStore = NULL;\n    job->data.commit.topparent->backingStore = job->data.commit.base;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->data.commit.top);\n\n    if (job->data.commit.deleteCommittedImages)\n        qemuBlockJobDeleteImages(driver, vm, job->disk, job->data.commit.top);\n\n    virObjectUnref(job->data.commit.top);\n    job->data.commit.top = NULL;\n\n    if (cfgbaseparent) {\n        cfgbase = cfgbaseparent->backingStore;\n        cfgbaseparent->backingStore = NULL;\n\n        if (cfgtopparent)\n            cfgtopparent->backingStore = cfgbase;\n        else\n            cfgdisk->src = cfgbase;\n\n        virObjectUnref(cfgtop);\n    }\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventCompletedCommit(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgnext = NULL;\n    virStorageSourcePtr cfgtopparent = NULL;\n    virStorageSourcePtr cfgtop = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n\n    VIR_DEBUG(\"commit job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.commit.base)))\n        cfgnext = cfgdisk->src;\n\n    if (!cfgdisk)\n        qemuBlockJobClearConfigChain(vm, job->disk);\n\n    for (n = job->disk->src; n && n != job->data.commit.base; n = n->backingStore) {\n        if (cfgnext) {\n            if (n == job->data.commit.topparent)\n                cfgtopparent = cfgnext;\n\n            if (n == job->data.commit.top)\n                cfgtop = cfgnext;\n\n            cfgbaseparent = cfgnext;\n            cfgnext = cfgnext->backingStore;\n        }\n        baseparent = n;\n    }\n\n    if (!n)\n        return;\n\n    if (qemuBlockJobProcessEventCompletedCommitBitmaps(vm, job, asyncJob) < 0)\n        return;\n\n    /* revert access to images */\n    qemuDomainStorageSourceAccessAllow(driver, vm, job->data.commit.base,\n                                       true, false, false);\n    if (job->data.commit.topparent != job->disk->src)\n        qemuDomainStorageSourceAccessAllow(driver, vm, job->data.commit.topparent,\n                                           true, false, true);\n\n    baseparent->backingStore = NULL;\n    job->data.commit.topparent->backingStore = job->data.commit.base;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->data.commit.top);\n\n    if (job->data.commit.deleteCommittedImages)\n        qemuBlockJobDeleteImages(driver, vm, job->disk, job->data.commit.top);\n\n    virObjectUnref(job->data.commit.top);\n    job->data.commit.top = NULL;\n\n    if (cfgbaseparent) {\n        cfgbase = cfgbaseparent->backingStore;\n        cfgbaseparent->backingStore = NULL;\n\n        if (cfgtopparent)\n            cfgtopparent->backingStore = cfgbase;\n        else\n            cfgdisk->src = cfgbase;\n\n        virObjectUnref(cfgtop);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobProcessEventCompletedPull",
          "args": [
            "driver",
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobProcessEventCompletedPull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "955-1011",
          "snippet": "static void\nqemuBlockJobProcessEventCompletedPull(virQEMUDriverPtr driver,\n                                      virDomainObjPtr vm,\n                                      qemuBlockJobDataPtr job,\n                                      qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n    virStorageSourcePtr tmp;\n\n    VIR_DEBUG(\"pull job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.pull.base)))\n        cfgbase = cfgdisk->src->backingStore;\n\n    if (!cfgdisk)\n        qemuBlockJobClearConfigChain(vm, job->disk);\n\n    /* when pulling if 'base' is right below the top image we don't have to modify it */\n    if (job->disk->src->backingStore == job->data.pull.base)\n        return;\n\n    if (job->data.pull.base) {\n        for (n = job->disk->src->backingStore; n && n != job->data.pull.base; n = n->backingStore) {\n            /* find the image on top of 'base' */\n\n            if (cfgbase) {\n                cfgbaseparent = cfgbase;\n                cfgbase = cfgbase->backingStore;\n            }\n\n            baseparent = n;\n        }\n    }\n\n    tmp = job->disk->src->backingStore;\n    job->disk->src->backingStore = job->data.pull.base;\n    if (baseparent)\n        baseparent->backingStore = NULL;\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, tmp);\n    virObjectUnref(tmp);\n\n    if (cfgdisk) {\n        tmp = cfgdisk->src->backingStore;\n        cfgdisk->src->backingStore = cfgbase;\n        if (cfgbaseparent)\n            cfgbaseparent->backingStore = NULL;\n        virObjectUnref(tmp);\n    }\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventCompletedPull(virQEMUDriverPtr driver,\n                                      virDomainObjPtr vm,\n                                      qemuBlockJobDataPtr job,\n                                      qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n    virStorageSourcePtr tmp;\n\n    VIR_DEBUG(\"pull job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.pull.base)))\n        cfgbase = cfgdisk->src->backingStore;\n\n    if (!cfgdisk)\n        qemuBlockJobClearConfigChain(vm, job->disk);\n\n    /* when pulling if 'base' is right below the top image we don't have to modify it */\n    if (job->disk->src->backingStore == job->data.pull.base)\n        return;\n\n    if (job->data.pull.base) {\n        for (n = job->disk->src->backingStore; n && n != job->data.pull.base; n = n->backingStore) {\n            /* find the image on top of 'base' */\n\n            if (cfgbase) {\n                cfgbaseparent = cfgbase;\n                cfgbase = cfgbase->backingStore;\n            }\n\n            baseparent = n;\n        }\n    }\n\n    tmp = job->disk->src->backingStore;\n    job->disk->src->backingStore = job->data.pull.base;\n    if (baseparent)\n        baseparent->backingStore = NULL;\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, tmp);\n    virObjectUnref(tmp);\n\n    if (cfgdisk) {\n        tmp = cfgdisk->src->backingStore;\n        cfgdisk->src->backingStore = cfgbase;\n        if (cfgbaseparent)\n            cfgbaseparent->backingStore = NULL;\n        virObjectUnref(tmp);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessConcludedTransition(qemuBlockJobDataPtr job,\n                                            virQEMUDriverPtr driver,\n                                            virDomainObjPtr vm,\n                                            qemuDomainAsyncJob asyncJob,\n                                            unsigned long long progressCurrent,\n                                            unsigned long long progressTotal)\n{\n    bool success = job->newstate == QEMU_BLOCKJOB_STATE_COMPLETED;\n\n    switch ((qemuBlockJobType) job->type) {\n    case QEMU_BLOCKJOB_TYPE_PULL:\n        if (success)\n            qemuBlockJobProcessEventCompletedPull(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_COMMIT:\n        if (success)\n            qemuBlockJobProcessEventCompletedCommit(driver, vm, job, asyncJob);\n        else\n            qemuBlockJobProcessEventFailedCommitCommon(vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_ACTIVE_COMMIT:\n        if (success) {\n            qemuBlockJobProcessEventCompletedActiveCommit(driver, vm, job, asyncJob);\n        } else {\n            qemuBlockJobProcessEventFailedActiveCommit(driver, vm, job);\n            qemuBlockJobProcessEventFailedCommitCommon(vm, job, asyncJob);\n        }\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_CREATE:\n        qemuBlockJobProcessEventConcludedCreate(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_COPY:\n        if (job->state == QEMU_BLOCKJOB_STATE_PIVOTING && success)\n            qemuBlockJobProcessEventConcludedCopyPivot(driver, vm, job, asyncJob);\n        else\n            qemuBlockJobProcessEventConcludedCopyAbort(driver, vm, job, asyncJob);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_BACKUP:\n        qemuBlockJobProcessEventConcludedBackup(driver, vm, job, asyncJob,\n                                                job->newstate, progressCurrent,\n                                                progressTotal);\n        break;\n\n    case QEMU_BLOCKJOB_TYPE_BROKEN:\n    case QEMU_BLOCKJOB_TYPE_NONE:\n    case QEMU_BLOCKJOB_TYPE_INTERNAL:\n    case QEMU_BLOCKJOB_TYPE_LAST:\n    default:\n        break;\n    }\n\n    qemuBlockJobEmitEvents(driver, vm, job->disk, job->type, job->newstate);\n    job->state = job->newstate;\n    job->newstate = -1;\n}"
  },
  {
    "function_name": "qemuBlockJobProcessEventConcludedBackup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1425-1467",
    "snippet": "static void\nqemuBlockJobProcessEventConcludedBackup(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob,\n                                        qemuBlockjobState newstate,\n                                        unsigned long long progressCurrent,\n                                        unsigned long long progressTotal)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) backend = NULL;\n    g_autoptr(virJSONValue) actions = NULL;\n\n    qemuBackupNotifyBlockjobEnd(vm, job->disk, newstate,\n                                progressCurrent, progressTotal, asyncJob);\n\n    if (job->data.backup.store &&\n        !(backend = qemuBlockStorageSourceDetachPrepare(job->data.backup.store, NULL)))\n        return;\n\n    if (job->data.backup.bitmap) {\n        actions = virJSONValueNewArray();\n\n        if (qemuMonitorTransactionBitmapRemove(actions,\n                                               job->disk->src->nodeformat,\n                                               job->data.backup.bitmap) < 0)\n            return;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    if (backend)\n        qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), backend);\n\n    if (actions)\n        qemuMonitorTransaction(qemuDomainGetMonitor(vm), &actions);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    if (job->data.backup.store)\n        qemuDomainStorageSourceAccessRevoke(driver, vm, job->data.backup.store);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainStorageSourceAccessRevoke",
          "args": [
            "driver",
            "vm",
            "job->data.backup.store"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainStorageSourceAccessRevoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12082-12090",
          "snippet": "void\nqemuDomainStorageSourceAccessRevoke(virQEMUDriverPtr driver,\n                                    virDomainObjPtr vm,\n                                    virStorageSourcePtr elem)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_REVOKE;\n\n    ignore_value(qemuDomainStorageSourceAccessModify(driver, vm, elem, flags));\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainStorageSourceAccessRevoke(virQEMUDriverPtr driver,\n                                    virDomainObjPtr vm,\n                                    virStorageSourcePtr elem)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_REVOKE;\n\n    ignore_value(qemuDomainStorageSourceAccessModify(driver, vm, elem, flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorTransaction",
          "args": [
            "qemuDomainGetMonitor(vm)",
            "&actions"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3073-3081",
          "snippet": "int\nqemuMonitorTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    VIR_DEBUG(\"actions=%p\", *actions);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONTransaction(mon, actions);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    VIR_DEBUG(\"actions=%p\", *actions);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONTransaction(mon, actions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainGetMonitor",
          "args": [
            "vm"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12703-12707",
          "snippet": "qemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nqemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceAttachRollback",
          "args": [
            "qemuDomainGetMonitor(vm)",
            "backend"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceAttachRollback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1724-1764",
          "snippet": "void\nqemuBlockStorageSourceAttachRollback(qemuMonitorPtr mon,\n                                     qemuBlockStorageSourceAttachDataPtr data)\n{\n    virErrorPtr orig_err;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (data->driveAdded) {\n        if (qemuMonitorDriveDel(mon, data->driveAlias) < 0)\n            VIR_WARN(\"Unable to remove drive %s (%s) after failed \"\n                     \"qemuMonitorAddDevice\", data->driveAlias, data->driveCmd);\n    }\n\n    if (data->formatAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->formatNodeName));\n\n    if (data->storageSliceAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageSliceNodeName));\n\n    if (data->storageAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageNodeName));\n\n    if (data->prmgrAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->prmgrAlias, false));\n\n    if (data->authsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->authsecretAlias, false));\n\n    if (data->encryptsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->encryptsecretAlias, false));\n\n    if (data->httpcookiesecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->httpcookiesecretAlias, false));\n\n    if (data->tlsAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->tlsAlias, false));\n\n\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBlockStorageSourceAttachRollback(qemuMonitorPtr mon,\n                                     qemuBlockStorageSourceAttachDataPtr data)\n{\n    virErrorPtr orig_err;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (data->driveAdded) {\n        if (qemuMonitorDriveDel(mon, data->driveAlias) < 0)\n            VIR_WARN(\"Unable to remove drive %s (%s) after failed \"\n                     \"qemuMonitorAddDevice\", data->driveAlias, data->driveCmd);\n    }\n\n    if (data->formatAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->formatNodeName));\n\n    if (data->storageSliceAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageSliceNodeName));\n\n    if (data->storageAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageNodeName));\n\n    if (data->prmgrAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->prmgrAlias, false));\n\n    if (data->authsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->authsecretAlias, false));\n\n    if (data->encryptsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->encryptsecretAlias, false));\n\n    if (data->httpcookiesecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->httpcookiesecretAlias, false));\n\n    if (data->tlsAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->tlsAlias, false));\n\n\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorTransactionBitmapRemove",
          "args": [
            "actions",
            "job->disk->src->nodeformat",
            "job->data.backup.bitmap"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTransactionBitmapRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4511-4517",
          "snippet": "int\nqemuMonitorTransactionBitmapRemove(virJSONValuePtr actions,\n                                   const char *node,\n                                   const char *name)\n{\n    return qemuMonitorJSONTransactionBitmapRemove(actions, node, name);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBitmapRemove(virJSONValuePtr actions,\n                                   const char *node,\n                                   const char *name)\n{\n    return qemuMonitorJSONTransactionBitmapRemove(actions, node, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewArray",
          "args": [],
          "line": 1445
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "560-568",
          "snippet": "virJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceDetachPrepare",
          "args": [
            "job->data.backup.store",
            "NULL"
          ],
          "line": 1441
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceDetachPrepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1775-1820",
          "snippet": "qemuBlockStorageSourceAttachDataPtr\nqemuBlockStorageSourceDetachPrepare(virStorageSourcePtr src,\n                                    char *driveAlias)\n{\n    qemuDomainStorageSourcePrivatePtr srcpriv = QEMU_DOMAIN_STORAGE_SOURCE_PRIVATE(src);\n    g_autoptr(qemuBlockStorageSourceAttachData) data = NULL;\n\n    data = g_new0(qemuBlockStorageSourceAttachData, 1);\n\n    if (driveAlias) {\n        data->driveAlias = g_steal_pointer(&driveAlias);\n        data->driveAdded = true;\n    } else {\n        data->formatNodeName = src->nodeformat;\n        data->formatAttached = true;\n        data->storageNodeName = src->nodestorage;\n        data->storageAttached = true;\n\n        /* 'raw' format doesn't need the extra 'raw' layer when slicing, thus\n         * the nodename is NULL */\n        if (src->sliceStorage &&\n            src->sliceStorage->nodename) {\n            data->storageSliceNodeName = src->sliceStorage->nodename;\n            data->storageSliceAttached = true;\n        }\n    }\n\n    if (src->pr &&\n        !virStoragePRDefIsManaged(src->pr))\n        data->prmgrAlias = g_strdup(src->pr->mgralias);\n\n    data->tlsAlias = g_strdup(src->tlsAlias);\n\n    if (srcpriv) {\n        if (srcpriv->secinfo && srcpriv->secinfo->type == VIR_DOMAIN_SECRET_INFO_TYPE_AES)\n            data->authsecretAlias = g_strdup(srcpriv->secinfo->s.aes.alias);\n\n        if (srcpriv->encinfo && srcpriv->encinfo->type == VIR_DOMAIN_SECRET_INFO_TYPE_AES)\n            data->encryptsecretAlias = g_strdup(srcpriv->encinfo->s.aes.alias);\n\n        if (srcpriv->httpcookie)\n            data->httpcookiesecretAlias = g_strdup(srcpriv->httpcookie->s.aes.alias);\n    }\n\n    return g_steal_pointer(&data);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nqemuBlockStorageSourceAttachDataPtr\nqemuBlockStorageSourceDetachPrepare(virStorageSourcePtr src,\n                                    char *driveAlias)\n{\n    qemuDomainStorageSourcePrivatePtr srcpriv = QEMU_DOMAIN_STORAGE_SOURCE_PRIVATE(src);\n    g_autoptr(qemuBlockStorageSourceAttachData) data = NULL;\n\n    data = g_new0(qemuBlockStorageSourceAttachData, 1);\n\n    if (driveAlias) {\n        data->driveAlias = g_steal_pointer(&driveAlias);\n        data->driveAdded = true;\n    } else {\n        data->formatNodeName = src->nodeformat;\n        data->formatAttached = true;\n        data->storageNodeName = src->nodestorage;\n        data->storageAttached = true;\n\n        /* 'raw' format doesn't need the extra 'raw' layer when slicing, thus\n         * the nodename is NULL */\n        if (src->sliceStorage &&\n            src->sliceStorage->nodename) {\n            data->storageSliceNodeName = src->sliceStorage->nodename;\n            data->storageSliceAttached = true;\n        }\n    }\n\n    if (src->pr &&\n        !virStoragePRDefIsManaged(src->pr))\n        data->prmgrAlias = g_strdup(src->pr->mgralias);\n\n    data->tlsAlias = g_strdup(src->tlsAlias);\n\n    if (srcpriv) {\n        if (srcpriv->secinfo && srcpriv->secinfo->type == VIR_DOMAIN_SECRET_INFO_TYPE_AES)\n            data->authsecretAlias = g_strdup(srcpriv->secinfo->s.aes.alias);\n\n        if (srcpriv->encinfo && srcpriv->encinfo->type == VIR_DOMAIN_SECRET_INFO_TYPE_AES)\n            data->encryptsecretAlias = g_strdup(srcpriv->encinfo->s.aes.alias);\n\n        if (srcpriv->httpcookie)\n            data->httpcookiesecretAlias = g_strdup(srcpriv->httpcookie->s.aes.alias);\n    }\n\n    return g_steal_pointer(&data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBackupNotifyBlockjobEnd",
          "args": [
            "vm",
            "job->disk",
            "newstate",
            "progressCurrent",
            "progressTotal",
            "asyncJob"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBackupNotifyBlockjobEnd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_backup.c",
          "lines": "933-1044",
          "snippet": "void\nqemuBackupNotifyBlockjobEnd(virDomainObjPtr vm,\n                            virDomainDiskDefPtr disk,\n                            qemuBlockjobState state,\n                            unsigned long long cur,\n                            unsigned long long end,\n                            int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool has_running = false;\n    bool has_cancelling = false;\n    bool has_cancelled = false;\n    bool has_failed = false;\n    qemuDomainJobStatus jobstatus = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n    virDomainBackupDefPtr backup = priv->backup;\n    size_t i;\n\n    VIR_DEBUG(\"vm: '%s', disk:'%s', state:'%d'\",\n              vm->def->name, disk->dst, state);\n\n    if (!backup)\n        return;\n\n    if (backup->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n            return;\n        ignore_value(qemuMonitorNBDServerStop(priv->mon));\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            return;\n\n        /* update the final statistics with the current job's data */\n        backup->pull_tmp_used += cur;\n        backup->pull_tmp_total += end;\n    } else {\n        backup->push_transferred += cur;\n        backup->push_total += end;\n    }\n\n    for (i = 0; i < backup->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = backup->disks + i;\n\n        if (!backupdisk->store)\n            continue;\n\n        if (STREQ(disk->dst, backupdisk->name)) {\n            switch (state) {\n            case QEMU_BLOCKJOB_STATE_COMPLETED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_COMPLETE;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_CONCLUDED:\n            case QEMU_BLOCKJOB_STATE_FAILED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_FAILED;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_CANCELLED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLED;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_READY:\n            case QEMU_BLOCKJOB_STATE_NEW:\n            case QEMU_BLOCKJOB_STATE_RUNNING:\n            case QEMU_BLOCKJOB_STATE_ABORTING:\n            case QEMU_BLOCKJOB_STATE_PIVOTING:\n            case QEMU_BLOCKJOB_STATE_LAST:\n            default:\n                break;\n            }\n        }\n\n        switch (backupdisk->state) {\n        case VIR_DOMAIN_BACKUP_DISK_STATE_COMPLETE:\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING:\n            has_running = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING:\n            has_cancelling = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_FAILED:\n            has_failed = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLED:\n            has_cancelled = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_NONE:\n        case VIR_DOMAIN_BACKUP_DISK_STATE_LAST:\n            break;\n        }\n    }\n\n    if (has_running && (has_failed || has_cancelled)) {\n        /* cancel the rest of the jobs */\n        qemuBackupJobCancelBlockjobs(vm, backup, false, asyncJob);\n    } else if (!has_running && !has_cancelling) {\n        /* all sub-jobs have stopped */\n\n        if (has_failed)\n            jobstatus = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        else if (has_cancelled && backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH)\n            jobstatus = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n\n        qemuBackupJobTerminate(vm, jobstatus);\n    }\n\n    /* otherwise we must wait for the jobs to end */\n}",
          "includes": [
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virdomaincheckpointobjlist.h\"\n#include \"backup_conf.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_command.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBackupNotifyBlockjobEnd(virDomainObjPtr vm,\n                            virDomainDiskDefPtr disk,\n                            qemuBlockjobState state,\n                            unsigned long long cur,\n                            unsigned long long end,\n                            int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    bool has_running = false;\n    bool has_cancelling = false;\n    bool has_cancelled = false;\n    bool has_failed = false;\n    qemuDomainJobStatus jobstatus = QEMU_DOMAIN_JOB_STATUS_COMPLETED;\n    virDomainBackupDefPtr backup = priv->backup;\n    size_t i;\n\n    VIR_DEBUG(\"vm: '%s', disk:'%s', state:'%d'\",\n              vm->def->name, disk->dst, state);\n\n    if (!backup)\n        return;\n\n    if (backup->type == VIR_DOMAIN_BACKUP_TYPE_PULL) {\n        if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n            return;\n        ignore_value(qemuMonitorNBDServerStop(priv->mon));\n        if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n            return;\n\n        /* update the final statistics with the current job's data */\n        backup->pull_tmp_used += cur;\n        backup->pull_tmp_total += end;\n    } else {\n        backup->push_transferred += cur;\n        backup->push_total += end;\n    }\n\n    for (i = 0; i < backup->ndisks; i++) {\n        virDomainBackupDiskDefPtr backupdisk = backup->disks + i;\n\n        if (!backupdisk->store)\n            continue;\n\n        if (STREQ(disk->dst, backupdisk->name)) {\n            switch (state) {\n            case QEMU_BLOCKJOB_STATE_COMPLETED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_COMPLETE;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_CONCLUDED:\n            case QEMU_BLOCKJOB_STATE_FAILED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_FAILED;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_CANCELLED:\n                backupdisk->state = VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLED;\n                break;\n\n            case QEMU_BLOCKJOB_STATE_READY:\n            case QEMU_BLOCKJOB_STATE_NEW:\n            case QEMU_BLOCKJOB_STATE_RUNNING:\n            case QEMU_BLOCKJOB_STATE_ABORTING:\n            case QEMU_BLOCKJOB_STATE_PIVOTING:\n            case QEMU_BLOCKJOB_STATE_LAST:\n            default:\n                break;\n            }\n        }\n\n        switch (backupdisk->state) {\n        case VIR_DOMAIN_BACKUP_DISK_STATE_COMPLETE:\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_RUNNING:\n            has_running = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLING:\n            has_cancelling = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_FAILED:\n            has_failed = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_CANCELLED:\n            has_cancelled = true;\n            break;\n\n        case VIR_DOMAIN_BACKUP_DISK_STATE_NONE:\n        case VIR_DOMAIN_BACKUP_DISK_STATE_LAST:\n            break;\n        }\n    }\n\n    if (has_running && (has_failed || has_cancelled)) {\n        /* cancel the rest of the jobs */\n        qemuBackupJobCancelBlockjobs(vm, backup, false, asyncJob);\n    } else if (!has_running && !has_cancelling) {\n        /* all sub-jobs have stopped */\n\n        if (has_failed)\n            jobstatus = QEMU_DOMAIN_JOB_STATUS_FAILED;\n        else if (has_cancelled && backup->type == VIR_DOMAIN_BACKUP_TYPE_PUSH)\n            jobstatus = QEMU_DOMAIN_JOB_STATUS_CANCELED;\n\n        qemuBackupJobTerminate(vm, jobstatus);\n    }\n\n    /* otherwise we must wait for the jobs to end */\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventConcludedBackup(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob,\n                                        qemuBlockjobState newstate,\n                                        unsigned long long progressCurrent,\n                                        unsigned long long progressTotal)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) backend = NULL;\n    g_autoptr(virJSONValue) actions = NULL;\n\n    qemuBackupNotifyBlockjobEnd(vm, job->disk, newstate,\n                                progressCurrent, progressTotal, asyncJob);\n\n    if (job->data.backup.store &&\n        !(backend = qemuBlockStorageSourceDetachPrepare(job->data.backup.store, NULL)))\n        return;\n\n    if (job->data.backup.bitmap) {\n        actions = virJSONValueNewArray();\n\n        if (qemuMonitorTransactionBitmapRemove(actions,\n                                               job->disk->src->nodeformat,\n                                               job->data.backup.bitmap) < 0)\n            return;\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    if (backend)\n        qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), backend);\n\n    if (actions)\n        qemuMonitorTransaction(qemuDomainGetMonitor(vm), &actions);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    if (job->data.backup.store)\n        qemuDomainStorageSourceAccessRevoke(driver, vm, job->data.backup.store);\n}"
  },
  {
    "function_name": "qemuBlockJobProcessEventConcludedCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1382-1422",
    "snippet": "static void\nqemuBlockJobProcessEventConcludedCreate(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) backend = NULL;\n\n    /* if there is a synchronous client waiting for this job that means that\n     * it will handle further hotplug of the created volume and also that\n     * the 'chain' which was registered is under their control */\n    if (job->synchronous) {\n        virObjectUnref(job->chain);\n        job->chain = NULL;\n        return;\n    }\n\n    if (!job->data.create.src)\n        return;\n\n    if (!(backend = qemuBlockStorageSourceDetachPrepare(job->data.create.src, NULL)))\n        return;\n\n    /* the format node part was not attached yet, so we don't need to detach it */\n    backend->formatAttached = false;\n    if (job->data.create.storage) {\n        backend->storageAttached = false;\n        backend->storageSliceAttached = false;\n        VIR_FREE(backend->encryptsecretAlias);\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), backend);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceAccessRevoke(driver, vm, job->data.create.src);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainStorageSourceAccessRevoke",
          "args": [
            "driver",
            "vm",
            "job->data.create.src"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainStorageSourceAccessRevoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12082-12090",
          "snippet": "void\nqemuDomainStorageSourceAccessRevoke(virQEMUDriverPtr driver,\n                                    virDomainObjPtr vm,\n                                    virStorageSourcePtr elem)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_REVOKE;\n\n    ignore_value(qemuDomainStorageSourceAccessModify(driver, vm, elem, flags));\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainStorageSourceAccessRevoke(virQEMUDriverPtr driver,\n                                    virDomainObjPtr vm,\n                                    virStorageSourcePtr elem)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_REVOKE;\n\n    ignore_value(qemuDomainStorageSourceAccessModify(driver, vm, elem, flags));\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 1418
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceAttachRollback",
          "args": [
            "qemuDomainGetMonitor(vm)",
            "backend"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceAttachRollback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1724-1764",
          "snippet": "void\nqemuBlockStorageSourceAttachRollback(qemuMonitorPtr mon,\n                                     qemuBlockStorageSourceAttachDataPtr data)\n{\n    virErrorPtr orig_err;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (data->driveAdded) {\n        if (qemuMonitorDriveDel(mon, data->driveAlias) < 0)\n            VIR_WARN(\"Unable to remove drive %s (%s) after failed \"\n                     \"qemuMonitorAddDevice\", data->driveAlias, data->driveCmd);\n    }\n\n    if (data->formatAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->formatNodeName));\n\n    if (data->storageSliceAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageSliceNodeName));\n\n    if (data->storageAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageNodeName));\n\n    if (data->prmgrAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->prmgrAlias, false));\n\n    if (data->authsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->authsecretAlias, false));\n\n    if (data->encryptsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->encryptsecretAlias, false));\n\n    if (data->httpcookiesecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->httpcookiesecretAlias, false));\n\n    if (data->tlsAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->tlsAlias, false));\n\n\n    virErrorRestore(&orig_err);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBlockStorageSourceAttachRollback(qemuMonitorPtr mon,\n                                     qemuBlockStorageSourceAttachDataPtr data)\n{\n    virErrorPtr orig_err;\n\n    virErrorPreserveLast(&orig_err);\n\n    if (data->driveAdded) {\n        if (qemuMonitorDriveDel(mon, data->driveAlias) < 0)\n            VIR_WARN(\"Unable to remove drive %s (%s) after failed \"\n                     \"qemuMonitorAddDevice\", data->driveAlias, data->driveCmd);\n    }\n\n    if (data->formatAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->formatNodeName));\n\n    if (data->storageSliceAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageSliceNodeName));\n\n    if (data->storageAttached)\n        ignore_value(qemuMonitorBlockdevDel(mon, data->storageNodeName));\n\n    if (data->prmgrAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->prmgrAlias, false));\n\n    if (data->authsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->authsecretAlias, false));\n\n    if (data->encryptsecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->encryptsecretAlias, false));\n\n    if (data->httpcookiesecretAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->httpcookiesecretAlias, false));\n\n    if (data->tlsAlias)\n        ignore_value(qemuMonitorDelObject(mon, data->tlsAlias, false));\n\n\n    virErrorRestore(&orig_err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainGetMonitor",
          "args": [
            "vm"
          ],
          "line": 1416
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12703-12707",
          "snippet": "qemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nqemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "backend->encryptsecretAlias"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceDetachPrepare",
          "args": [
            "job->data.create.src",
            "NULL"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceDetachPrepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1775-1820",
          "snippet": "qemuBlockStorageSourceAttachDataPtr\nqemuBlockStorageSourceDetachPrepare(virStorageSourcePtr src,\n                                    char *driveAlias)\n{\n    qemuDomainStorageSourcePrivatePtr srcpriv = QEMU_DOMAIN_STORAGE_SOURCE_PRIVATE(src);\n    g_autoptr(qemuBlockStorageSourceAttachData) data = NULL;\n\n    data = g_new0(qemuBlockStorageSourceAttachData, 1);\n\n    if (driveAlias) {\n        data->driveAlias = g_steal_pointer(&driveAlias);\n        data->driveAdded = true;\n    } else {\n        data->formatNodeName = src->nodeformat;\n        data->formatAttached = true;\n        data->storageNodeName = src->nodestorage;\n        data->storageAttached = true;\n\n        /* 'raw' format doesn't need the extra 'raw' layer when slicing, thus\n         * the nodename is NULL */\n        if (src->sliceStorage &&\n            src->sliceStorage->nodename) {\n            data->storageSliceNodeName = src->sliceStorage->nodename;\n            data->storageSliceAttached = true;\n        }\n    }\n\n    if (src->pr &&\n        !virStoragePRDefIsManaged(src->pr))\n        data->prmgrAlias = g_strdup(src->pr->mgralias);\n\n    data->tlsAlias = g_strdup(src->tlsAlias);\n\n    if (srcpriv) {\n        if (srcpriv->secinfo && srcpriv->secinfo->type == VIR_DOMAIN_SECRET_INFO_TYPE_AES)\n            data->authsecretAlias = g_strdup(srcpriv->secinfo->s.aes.alias);\n\n        if (srcpriv->encinfo && srcpriv->encinfo->type == VIR_DOMAIN_SECRET_INFO_TYPE_AES)\n            data->encryptsecretAlias = g_strdup(srcpriv->encinfo->s.aes.alias);\n\n        if (srcpriv->httpcookie)\n            data->httpcookiesecretAlias = g_strdup(srcpriv->httpcookie->s.aes.alias);\n    }\n\n    return g_steal_pointer(&data);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nqemuBlockStorageSourceAttachDataPtr\nqemuBlockStorageSourceDetachPrepare(virStorageSourcePtr src,\n                                    char *driveAlias)\n{\n    qemuDomainStorageSourcePrivatePtr srcpriv = QEMU_DOMAIN_STORAGE_SOURCE_PRIVATE(src);\n    g_autoptr(qemuBlockStorageSourceAttachData) data = NULL;\n\n    data = g_new0(qemuBlockStorageSourceAttachData, 1);\n\n    if (driveAlias) {\n        data->driveAlias = g_steal_pointer(&driveAlias);\n        data->driveAdded = true;\n    } else {\n        data->formatNodeName = src->nodeformat;\n        data->formatAttached = true;\n        data->storageNodeName = src->nodestorage;\n        data->storageAttached = true;\n\n        /* 'raw' format doesn't need the extra 'raw' layer when slicing, thus\n         * the nodename is NULL */\n        if (src->sliceStorage &&\n            src->sliceStorage->nodename) {\n            data->storageSliceNodeName = src->sliceStorage->nodename;\n            data->storageSliceAttached = true;\n        }\n    }\n\n    if (src->pr &&\n        !virStoragePRDefIsManaged(src->pr))\n        data->prmgrAlias = g_strdup(src->pr->mgralias);\n\n    data->tlsAlias = g_strdup(src->tlsAlias);\n\n    if (srcpriv) {\n        if (srcpriv->secinfo && srcpriv->secinfo->type == VIR_DOMAIN_SECRET_INFO_TYPE_AES)\n            data->authsecretAlias = g_strdup(srcpriv->secinfo->s.aes.alias);\n\n        if (srcpriv->encinfo && srcpriv->encinfo->type == VIR_DOMAIN_SECRET_INFO_TYPE_AES)\n            data->encryptsecretAlias = g_strdup(srcpriv->encinfo->s.aes.alias);\n\n        if (srcpriv->httpcookie)\n            data->httpcookiesecretAlias = g_strdup(srcpriv->httpcookie->s.aes.alias);\n    }\n\n    return g_steal_pointer(&data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job->chain"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventConcludedCreate(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) backend = NULL;\n\n    /* if there is a synchronous client waiting for this job that means that\n     * it will handle further hotplug of the created volume and also that\n     * the 'chain' which was registered is under their control */\n    if (job->synchronous) {\n        virObjectUnref(job->chain);\n        job->chain = NULL;\n        return;\n    }\n\n    if (!job->data.create.src)\n        return;\n\n    if (!(backend = qemuBlockStorageSourceDetachPrepare(job->data.create.src, NULL)))\n        return;\n\n    /* the format node part was not attached yet, so we don't need to detach it */\n    backend->formatAttached = false;\n    if (job->data.create.storage) {\n        backend->storageAttached = false;\n        backend->storageSliceAttached = false;\n        VIR_FREE(backend->encryptsecretAlias);\n    }\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceAttachRollback(qemuDomainGetMonitor(vm), backend);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceAccessRevoke(driver, vm, job->data.create.src);\n}"
  },
  {
    "function_name": "qemuBlockJobProcessEventFailedCommitCommon",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1348-1379",
    "snippet": "static void\nqemuBlockJobProcessEventFailedCommitCommon(virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virJSONValue) actions = virJSONValueNewArray();\n    char **disabledBitmaps = job->data.commit.disabledBitmapsBase;\n\n    if (!disabledBitmaps || !*disabledBitmaps)\n        return;\n\n    for (; *disabledBitmaps; disabledBitmaps++) {\n        qemuMonitorTransactionBitmapEnable(actions,\n                                           job->data.commit.base->nodeformat,\n                                           *disabledBitmaps);\n    }\n\n    if (qemuBlockReopenReadWrite(vm, job->data.commit.base, asyncJob) < 0)\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        return;\n\n    qemuMonitorTransaction(priv->mon, &actions);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n        return;\n\n    if (qemuBlockReopenReadOnly(vm, job->data.commit.base, asyncJob) < 0)\n        return;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBlockReopenReadOnly",
          "args": [
            "vm",
            "job->data.commit.base",
            "asyncJob"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "priv->driver",
            "vm"
          ],
          "line": 1374
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorTransaction",
          "args": [
            "priv->mon",
            "&actions"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3073-3081",
          "snippet": "int\nqemuMonitorTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    VIR_DEBUG(\"actions=%p\", *actions);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONTransaction(mon, actions);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    VIR_DEBUG(\"actions=%p\", *actions);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONTransaction(mon, actions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "priv->driver",
            "vm",
            "asyncJob"
          ],
          "line": 1369
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockReopenReadWrite",
          "args": [
            "vm",
            "job->data.commit.base",
            "asyncJob"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3279-3294",
          "snippet": "int\nqemuBlockReopenReadWrite(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (!src->readonly)\n        return 0;\n\n    src->readonly = false;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = true;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadWrite(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (!src->readonly)\n        return 0;\n\n    src->readonly = false;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = true;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorTransactionBitmapEnable",
          "args": [
            "actions",
            "job->data.commit.base->nodeformat",
            "*disabledBitmaps"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTransactionBitmapEnable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4520-4526",
          "snippet": "int\nqemuMonitorTransactionBitmapEnable(virJSONValuePtr actions,\n                                   const char *node,\n                                   const char *name)\n{\n    return qemuMonitorJSONTransactionBitmapEnable(actions, node, name);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransactionBitmapEnable(virJSONValuePtr actions,\n                                   const char *node,\n                                   const char *name)\n{\n    return qemuMonitorJSONTransactionBitmapEnable(actions, node, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virJSONValueNewArray",
          "args": [],
          "line": 1354
        },
        "resolved": true,
        "details": {
          "function_name": "virJSONValueNewArray",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virjson.c",
          "lines": "560-568",
          "snippet": "virJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}",
          "includes": [
            "# include <yajl/yajl_parse.h>",
            "# include <yajl/yajl_gen.h>",
            "#include \"virenum.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virjson.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <yajl/yajl_parse.h>\n# include <yajl/yajl_gen.h>\n#include \"virenum.h\"\n#include \"virbuffer.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virjson.h\"\n#include <config.h>\n\nvirJSONValuePtr\nvirJSONValueNewArray(void)\n{\n    virJSONValuePtr val = g_new0(virJSONValue, 1);\n\n    val->type = VIR_JSON_TYPE_ARRAY;\n\n    return val;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventFailedCommitCommon(virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virJSONValue) actions = virJSONValueNewArray();\n    char **disabledBitmaps = job->data.commit.disabledBitmapsBase;\n\n    if (!disabledBitmaps || !*disabledBitmaps)\n        return;\n\n    for (; *disabledBitmaps; disabledBitmaps++) {\n        qemuMonitorTransactionBitmapEnable(actions,\n                                           job->data.commit.base->nodeformat,\n                                           *disabledBitmaps);\n    }\n\n    if (qemuBlockReopenReadWrite(vm, job->data.commit.base, asyncJob) < 0)\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        return;\n\n    qemuMonitorTransaction(priv->mon, &actions);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n        return;\n\n    if (qemuBlockReopenReadOnly(vm, job->data.commit.base, asyncJob) < 0)\n        return;\n}"
  },
  {
    "function_name": "qemuBlockJobProcessEventFailedActiveCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1326-1345",
    "snippet": "static void\nqemuBlockJobProcessEventFailedActiveCommit(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    VIR_DEBUG(\"active commit job '%s' on VM '%s' failed\", job->name, vm->def->name);\n\n    if (!disk)\n        return;\n\n    /* Ideally, we would make the backing chain read only again (yes, SELinux\n     * can do that using different labels). But that is not implemented yet and\n     * not leaking security driver metadata is more important. */\n    qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n    virObjectUnref(disk->mirror);\n    disk->mirror = NULL;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "disk->mirror"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockRemoveImageMetadata",
          "args": [
            "driver",
            "vm",
            "disk->dst",
            "disk->mirror"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockRemoveImageMetadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "2749-2770",
          "snippet": "int\nqemuBlockRemoveImageMetadata(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *diskTarget,\n                             virStorageSourcePtr src)\n{\n    virStorageSourcePtr n;\n    int ret = 0;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (qemuSecurityMoveImageMetadata(driver, vm, n, NULL) < 0) {\n            VIR_WARN(\"Unable to remove disk metadata on \"\n                     \"vm %s from %s (disk target %s)\",\n                     vm->def->name,\n                     NULLSTR(n->path),\n                     diskTarget);\n            ret = -1;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockRemoveImageMetadata(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *diskTarget,\n                             virStorageSourcePtr src)\n{\n    virStorageSourcePtr n;\n    int ret = 0;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (qemuSecurityMoveImageMetadata(driver, vm, n, NULL) < 0) {\n            VIR_WARN(\"Unable to remove disk metadata on \"\n                     \"vm %s from %s (disk target %s)\",\n                     vm->def->name,\n                     NULLSTR(n->path),\n                     diskTarget);\n            ret = -1;\n        }\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"active commit job '%s' on VM '%s' failed\"",
            "job->name",
            "vm->def->name"
          ],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventFailedActiveCommit(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    VIR_DEBUG(\"active commit job '%s' on VM '%s' failed\", job->name, vm->def->name);\n\n    if (!disk)\n        return;\n\n    /* Ideally, we would make the backing chain read only again (yes, SELinux\n     * can do that using different labels). But that is not implemented yet and\n     * not leaking security driver metadata is more important. */\n    qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n    virObjectUnref(disk->mirror);\n    disk->mirror = NULL;\n}"
  },
  {
    "function_name": "qemuBlockJobProcessEventConcludedCopyAbort",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1307-1323",
    "snippet": "static void\nqemuBlockJobProcessEventConcludedCopyAbort(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    VIR_DEBUG(\"copy job '%s' on VM '%s' aborted\", job->name, vm->def->name);\n\n    /* mirror may be NULL for copy job corresponding to migration */\n    if (!job->disk ||\n        !job->disk->mirror)\n        return;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->disk->mirror);\n    virObjectUnref(job->disk->mirror);\n    job->disk->mirror = NULL;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job->disk->mirror"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEventProcessConcludedRemoveChain",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "job->disk->mirror"
          ],
          "line": 1320
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEventProcessConcludedRemoveChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "836-855",
          "snippet": "static void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"copy job '%s' on VM '%s' aborted\"",
            "job->name",
            "vm->def->name"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventConcludedCopyAbort(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    VIR_DEBUG(\"copy job '%s' on VM '%s' aborted\", job->name, vm->def->name);\n\n    /* mirror may be NULL for copy job corresponding to migration */\n    if (!job->disk ||\n        !job->disk->mirror)\n        return;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->disk->mirror);\n    virObjectUnref(job->disk->mirror);\n    job->disk->mirror = NULL;\n}"
  },
  {
    "function_name": "qemuBlockJobProcessEventConcludedCopyPivot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1278-1304",
    "snippet": "static void\nqemuBlockJobProcessEventConcludedCopyPivot(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    VIR_DEBUG(\"copy job '%s' on VM '%s' pivoted\", job->name, vm->def->name);\n\n    /* mirror may be NULL for copy job corresponding to migration */\n    if (!job->disk ||\n        !job->disk->mirror)\n        return;\n\n    /* for shallow copy without reusing external image the user can either not\n     * specify the backing chain in which case libvirt will open and use the\n     * chain the user provided or not specify a chain in which case we'll\n     * inherit the rest of the chain */\n    if (job->data.copy.shallownew &&\n        !virStorageSourceIsBacking(job->disk->mirror->backingStore))\n        job->disk->mirror->backingStore = g_steal_pointer(&job->disk->src->backingStore);\n\n    qemuBlockJobRewriteConfigDiskSource(vm, job->disk, job->disk->mirror);\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->disk->src);\n    virObjectUnref(job->disk->src);\n    job->disk->src = g_steal_pointer(&job->disk->mirror);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&job->disk->mirror"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job->disk->src"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEventProcessConcludedRemoveChain",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "job->disk->src"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEventProcessConcludedRemoveChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "836-855",
          "snippet": "static void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobRewriteConfigDiskSource",
          "args": [
            "vm",
            "job->disk",
            "job->disk->mirror"
          ],
          "line": 1299
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobRewriteConfigDiskSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "662-701",
          "snippet": "static void\nqemuBlockJobRewriteConfigDiskSource(virDomainObjPtr vm,\n                                    virDomainDiskDefPtr disk,\n                                    virStorageSourcePtr newsrc)\n{\n    virDomainDiskDefPtr persistDisk = NULL;\n    g_autoptr(virStorageSource) copy = NULL;\n    virStorageSourcePtr n;\n\n    if (!vm->newDef)\n        return;\n\n    if (!(persistDisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, persistDisk->src))\n        return;\n\n    if (!(copy = virStorageSourceCopy(newsrc, true)) ||\n        virStorageSourceInitChainElement(copy, persistDisk->src, true) < 0) {\n        VIR_WARN(\"Unable to update persistent definition on vm %s after block job\",\n                 vm->def->name);\n        return;\n    }\n\n    for (n = copy; virStorageSourceIsBacking(n); n = n->backingStore) {\n        qemuBlockJobCleanStorageSourceRuntime(n);\n\n        /* discard any detected backing store */\n        if (virStorageSourceIsBacking(n->backingStore) &&\n            n->backingStore->detected) {\n            virObjectUnref(n->backingStore);\n            n->backingStore = NULL;\n            break;\n        }\n    }\n\n    virObjectUnref(persistDisk->src);\n    persistDisk->src = g_steal_pointer(&copy);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobRewriteConfigDiskSource(virDomainObjPtr vm,\n                                    virDomainDiskDefPtr disk,\n                                    virStorageSourcePtr newsrc)\n{\n    virDomainDiskDefPtr persistDisk = NULL;\n    g_autoptr(virStorageSource) copy = NULL;\n    virStorageSourcePtr n;\n\n    if (!vm->newDef)\n        return;\n\n    if (!(persistDisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, persistDisk->src))\n        return;\n\n    if (!(copy = virStorageSourceCopy(newsrc, true)) ||\n        virStorageSourceInitChainElement(copy, persistDisk->src, true) < 0) {\n        VIR_WARN(\"Unable to update persistent definition on vm %s after block job\",\n                 vm->def->name);\n        return;\n    }\n\n    for (n = copy; virStorageSourceIsBacking(n); n = n->backingStore) {\n        qemuBlockJobCleanStorageSourceRuntime(n);\n\n        /* discard any detected backing store */\n        if (virStorageSourceIsBacking(n->backingStore) &&\n            n->backingStore->detected) {\n            virObjectUnref(n->backingStore);\n            n->backingStore = NULL;\n            break;\n        }\n    }\n\n    virObjectUnref(persistDisk->src);\n    persistDisk->src = g_steal_pointer(&copy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&job->disk->src->backingStore"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "job->disk->mirror->backingStore"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"copy job '%s' on VM '%s' pivoted\"",
            "job->name",
            "vm->def->name"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventConcludedCopyPivot(virQEMUDriverPtr driver,\n                                           virDomainObjPtr vm,\n                                           qemuBlockJobDataPtr job,\n                                           qemuDomainAsyncJob asyncJob)\n{\n    VIR_DEBUG(\"copy job '%s' on VM '%s' pivoted\", job->name, vm->def->name);\n\n    /* mirror may be NULL for copy job corresponding to migration */\n    if (!job->disk ||\n        !job->disk->mirror)\n        return;\n\n    /* for shallow copy without reusing external image the user can either not\n     * specify the backing chain in which case libvirt will open and use the\n     * chain the user provided or not specify a chain in which case we'll\n     * inherit the rest of the chain */\n    if (job->data.copy.shallownew &&\n        !virStorageSourceIsBacking(job->disk->mirror->backingStore))\n        job->disk->mirror->backingStore = g_steal_pointer(&job->disk->src->backingStore);\n\n    qemuBlockJobRewriteConfigDiskSource(vm, job->disk, job->disk->mirror);\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->disk->src);\n    virObjectUnref(job->disk->src);\n    job->disk->src = g_steal_pointer(&job->disk->mirror);\n}"
  },
  {
    "function_name": "qemuBlockJobProcessEventCompletedActiveCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1206-1275",
    "snippet": "static void\nqemuBlockJobProcessEventCompletedActiveCommit(virQEMUDriverPtr driver,\n                                              virDomainObjPtr vm,\n                                              qemuBlockJobDataPtr job,\n                                              qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgnext = NULL;\n    virStorageSourcePtr cfgtop = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n\n    VIR_DEBUG(\"active commit job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.commit.base)))\n        cfgnext = cfgdisk->src;\n\n    for (n = job->disk->src; n && n != job->data.commit.base; n = n->backingStore) {\n        if (cfgnext) {\n            if (n == job->data.commit.top)\n                cfgtop = cfgnext;\n\n            cfgbaseparent = cfgnext;\n            cfgnext = cfgnext->backingStore;\n        }\n        baseparent = n;\n    }\n\n    if (!n)\n        return;\n\n    if (!cfgdisk) {\n        /* in case when the config disk chain didn't match but the disk top seems\n         * to be identical we need to modify the disk source since the active\n         * commit makes the top level image invalid.\n         */\n        qemuBlockJobRewriteConfigDiskSource(vm, job->disk, job->data.commit.base);\n    } else {\n        cfgbase = cfgbaseparent->backingStore;\n        cfgbaseparent->backingStore = NULL;\n        cfgdisk->src = cfgbase;\n        cfgdisk->src->readonly = cfgtop->readonly;\n        virObjectUnref(cfgtop);\n    }\n\n    /* Move security driver metadata */\n    if (qemuSecurityMoveImageMetadata(driver, vm, job->disk->src, job->data.commit.base) < 0)\n        VIR_WARN(\"Unable to move disk metadata on vm %s\", vm->def->name);\n\n    baseparent->backingStore = NULL;\n    job->disk->src = job->data.commit.base;\n    job->disk->src->readonly = job->data.commit.top->readonly;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->data.commit.top);\n\n    if (job->data.commit.deleteCommittedImages)\n        qemuBlockJobDeleteImages(driver, vm, job->disk, job->data.commit.top);\n\n    virObjectUnref(job->data.commit.top);\n    job->data.commit.top = NULL;\n    /* the mirror element does not serve functional purpose for the commit job */\n    virObjectUnref(job->disk->mirror);\n    job->disk->mirror = NULL;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job->disk->mirror"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDeleteImages",
          "args": [
            "driver",
            "vm",
            "job->disk",
            "job->data.commit.top"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDeleteImages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1028-1050",
          "snippet": "static void\nqemuBlockJobDeleteImages(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainDiskDefPtr disk,\n                         virStorageSourcePtr top)\n{\n    virStorageSourcePtr p = top;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    uid_t uid;\n    gid_t gid;\n\n    for (; p != NULL; p = p->backingStore) {\n        if (virStorageSourceGetActualType(p) == VIR_STORAGE_TYPE_FILE) {\n\n            qemuDomainGetImageIds(cfg, vm, p, disk->src, &uid, &gid);\n\n            if (virFileRemove(p->path, uid, gid) < 0) {\n                VIR_WARN(\"Unable to remove snapshot image file '%s' (%s)\",\n                         p->path, g_strerror(errno));\n            }\n        }\n    }\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobDeleteImages(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainDiskDefPtr disk,\n                         virStorageSourcePtr top)\n{\n    virStorageSourcePtr p = top;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    uid_t uid;\n    gid_t gid;\n\n    for (; p != NULL; p = p->backingStore) {\n        if (virStorageSourceGetActualType(p) == VIR_STORAGE_TYPE_FILE) {\n\n            qemuDomainGetImageIds(cfg, vm, p, disk->src, &uid, &gid);\n\n            if (virFileRemove(p->path, uid, gid) < 0) {\n                VIR_WARN(\"Unable to remove snapshot image file '%s' (%s)\",\n                         p->path, g_strerror(errno));\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEventProcessConcludedRemoveChain",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "job->data.commit.top"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEventProcessConcludedRemoveChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "836-855",
          "snippet": "static void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to move disk metadata on vm %s\"",
            "vm->def->name"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSecurityMoveImageMetadata",
          "args": [
            "driver",
            "vm",
            "job->disk->src",
            "job->data.commit.base"
          ],
          "line": 1258
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSecurityMoveImageMetadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_security.c",
          "lines": "171-187",
          "snippet": "int\nqemuSecurityMoveImageMetadata(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virStorageSourcePtr src,\n                              virStorageSourcePtr dst)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    pid_t pid = -1;\n\n    if (!priv->rememberOwner)\n        return 0;\n\n    if (qemuDomainNamespaceEnabled(vm, QEMU_DOMAIN_NS_MOUNT))\n        pid = vm->pid;\n\n    return virSecurityManagerMoveImageMetadata(driver->securityManager, pid, src, dst);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"qemu_security.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuSecurityMoveImageMetadata(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virStorageSourcePtr src,\n                              virStorageSourcePtr dst)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    pid_t pid = -1;\n\n    if (!priv->rememberOwner)\n        return 0;\n\n    if (qemuDomainNamespaceEnabled(vm, QEMU_DOMAIN_NS_MOUNT))\n        pid = vm->pid;\n\n    return virSecurityManagerMoveImageMetadata(driver->securityManager, pid, src, dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobRewriteConfigDiskSource",
          "args": [
            "vm",
            "job->disk",
            "job->data.commit.base"
          ],
          "line": 1248
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobRewriteConfigDiskSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "662-701",
          "snippet": "static void\nqemuBlockJobRewriteConfigDiskSource(virDomainObjPtr vm,\n                                    virDomainDiskDefPtr disk,\n                                    virStorageSourcePtr newsrc)\n{\n    virDomainDiskDefPtr persistDisk = NULL;\n    g_autoptr(virStorageSource) copy = NULL;\n    virStorageSourcePtr n;\n\n    if (!vm->newDef)\n        return;\n\n    if (!(persistDisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, persistDisk->src))\n        return;\n\n    if (!(copy = virStorageSourceCopy(newsrc, true)) ||\n        virStorageSourceInitChainElement(copy, persistDisk->src, true) < 0) {\n        VIR_WARN(\"Unable to update persistent definition on vm %s after block job\",\n                 vm->def->name);\n        return;\n    }\n\n    for (n = copy; virStorageSourceIsBacking(n); n = n->backingStore) {\n        qemuBlockJobCleanStorageSourceRuntime(n);\n\n        /* discard any detected backing store */\n        if (virStorageSourceIsBacking(n->backingStore) &&\n            n->backingStore->detected) {\n            virObjectUnref(n->backingStore);\n            n->backingStore = NULL;\n            break;\n        }\n    }\n\n    virObjectUnref(persistDisk->src);\n    persistDisk->src = g_steal_pointer(&copy);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobRewriteConfigDiskSource(virDomainObjPtr vm,\n                                    virDomainDiskDefPtr disk,\n                                    virStorageSourcePtr newsrc)\n{\n    virDomainDiskDefPtr persistDisk = NULL;\n    g_autoptr(virStorageSource) copy = NULL;\n    virStorageSourcePtr n;\n\n    if (!vm->newDef)\n        return;\n\n    if (!(persistDisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, persistDisk->src))\n        return;\n\n    if (!(copy = virStorageSourceCopy(newsrc, true)) ||\n        virStorageSourceInitChainElement(copy, persistDisk->src, true) < 0) {\n        VIR_WARN(\"Unable to update persistent definition on vm %s after block job\",\n                 vm->def->name);\n        return;\n    }\n\n    for (n = copy; virStorageSourceIsBacking(n); n = n->backingStore) {\n        qemuBlockJobCleanStorageSourceRuntime(n);\n\n        /* discard any detected backing store */\n        if (virStorageSourceIsBacking(n->backingStore) &&\n            n->backingStore->detected) {\n            virObjectUnref(n->backingStore);\n            n->backingStore = NULL;\n            break;\n        }\n    }\n\n    virObjectUnref(persistDisk->src);\n    persistDisk->src = g_steal_pointer(&copy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobGetConfigDisk",
          "args": [
            "vm",
            "job->disk",
            "job->data.commit.base"
          ],
          "line": 1226
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobGetConfigDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "870-904",
          "snippet": "static virDomainDiskDefPtr\nqemuBlockJobGetConfigDisk(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr diskChainBottom)\n{\n    virStorageSourcePtr disksrc = NULL;\n    virStorageSourcePtr cfgsrc = NULL;\n    virDomainDiskDefPtr ret = NULL;\n\n    if (!vm->newDef || !disk)\n        return NULL;\n\n    disksrc = disk->src;\n\n    if (!(ret = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return NULL;\n\n    cfgsrc = ret->src;\n\n    while (disksrc && cfgsrc) {\n        if (!virStorageSourceIsSameLocation(disksrc, cfgsrc))\n            return NULL;\n\n        if (diskChainBottom && diskChainBottom == disksrc)\n            return ret;\n\n        disksrc = disksrc->backingStore;\n        cfgsrc = cfgsrc->backingStore;\n    }\n\n    if (disksrc || cfgsrc)\n        return NULL;\n\n    return ret;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainDiskDefPtr\nqemuBlockJobGetConfigDisk(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr diskChainBottom)\n{\n    virStorageSourcePtr disksrc = NULL;\n    virStorageSourcePtr cfgsrc = NULL;\n    virDomainDiskDefPtr ret = NULL;\n\n    if (!vm->newDef || !disk)\n        return NULL;\n\n    disksrc = disk->src;\n\n    if (!(ret = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return NULL;\n\n    cfgsrc = ret->src;\n\n    while (disksrc && cfgsrc) {\n        if (!virStorageSourceIsSameLocation(disksrc, cfgsrc))\n            return NULL;\n\n        if (diskChainBottom && diskChainBottom == disksrc)\n            return ret;\n\n        disksrc = disksrc->backingStore;\n        cfgsrc = cfgsrc->backingStore;\n    }\n\n    if (disksrc || cfgsrc)\n        return NULL;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"active commit job '%s' on VM '%s' completed\"",
            "job->name",
            "vm->def->name"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventCompletedActiveCommit(virQEMUDriverPtr driver,\n                                              virDomainObjPtr vm,\n                                              qemuBlockJobDataPtr job,\n                                              qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgnext = NULL;\n    virStorageSourcePtr cfgtop = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n\n    VIR_DEBUG(\"active commit job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.commit.base)))\n        cfgnext = cfgdisk->src;\n\n    for (n = job->disk->src; n && n != job->data.commit.base; n = n->backingStore) {\n        if (cfgnext) {\n            if (n == job->data.commit.top)\n                cfgtop = cfgnext;\n\n            cfgbaseparent = cfgnext;\n            cfgnext = cfgnext->backingStore;\n        }\n        baseparent = n;\n    }\n\n    if (!n)\n        return;\n\n    if (!cfgdisk) {\n        /* in case when the config disk chain didn't match but the disk top seems\n         * to be identical we need to modify the disk source since the active\n         * commit makes the top level image invalid.\n         */\n        qemuBlockJobRewriteConfigDiskSource(vm, job->disk, job->data.commit.base);\n    } else {\n        cfgbase = cfgbaseparent->backingStore;\n        cfgbaseparent->backingStore = NULL;\n        cfgdisk->src = cfgbase;\n        cfgdisk->src->readonly = cfgtop->readonly;\n        virObjectUnref(cfgtop);\n    }\n\n    /* Move security driver metadata */\n    if (qemuSecurityMoveImageMetadata(driver, vm, job->disk->src, job->data.commit.base) < 0)\n        VIR_WARN(\"Unable to move disk metadata on vm %s\", vm->def->name);\n\n    baseparent->backingStore = NULL;\n    job->disk->src = job->data.commit.base;\n    job->disk->src->readonly = job->data.commit.top->readonly;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->data.commit.top);\n\n    if (job->data.commit.deleteCommittedImages)\n        qemuBlockJobDeleteImages(driver, vm, job->disk, job->data.commit.top);\n\n    virObjectUnref(job->data.commit.top);\n    job->data.commit.top = NULL;\n    /* the mirror element does not serve functional purpose for the commit job */\n    virObjectUnref(job->disk->mirror);\n    job->disk->mirror = NULL;\n}"
  },
  {
    "function_name": "qemuBlockJobProcessEventCompletedCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1114-1190",
    "snippet": "static void\nqemuBlockJobProcessEventCompletedCommit(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgnext = NULL;\n    virStorageSourcePtr cfgtopparent = NULL;\n    virStorageSourcePtr cfgtop = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n\n    VIR_DEBUG(\"commit job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.commit.base)))\n        cfgnext = cfgdisk->src;\n\n    if (!cfgdisk)\n        qemuBlockJobClearConfigChain(vm, job->disk);\n\n    for (n = job->disk->src; n && n != job->data.commit.base; n = n->backingStore) {\n        if (cfgnext) {\n            if (n == job->data.commit.topparent)\n                cfgtopparent = cfgnext;\n\n            if (n == job->data.commit.top)\n                cfgtop = cfgnext;\n\n            cfgbaseparent = cfgnext;\n            cfgnext = cfgnext->backingStore;\n        }\n        baseparent = n;\n    }\n\n    if (!n)\n        return;\n\n    if (qemuBlockJobProcessEventCompletedCommitBitmaps(vm, job, asyncJob) < 0)\n        return;\n\n    /* revert access to images */\n    qemuDomainStorageSourceAccessAllow(driver, vm, job->data.commit.base,\n                                       true, false, false);\n    if (job->data.commit.topparent != job->disk->src)\n        qemuDomainStorageSourceAccessAllow(driver, vm, job->data.commit.topparent,\n                                           true, false, true);\n\n    baseparent->backingStore = NULL;\n    job->data.commit.topparent->backingStore = job->data.commit.base;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->data.commit.top);\n\n    if (job->data.commit.deleteCommittedImages)\n        qemuBlockJobDeleteImages(driver, vm, job->disk, job->data.commit.top);\n\n    virObjectUnref(job->data.commit.top);\n    job->data.commit.top = NULL;\n\n    if (cfgbaseparent) {\n        cfgbase = cfgbaseparent->backingStore;\n        cfgbaseparent->backingStore = NULL;\n\n        if (cfgtopparent)\n            cfgtopparent->backingStore = cfgbase;\n        else\n            cfgdisk->src = cfgbase;\n\n        virObjectUnref(cfgtop);\n    }\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfgtop"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDeleteImages",
          "args": [
            "driver",
            "vm",
            "job->disk",
            "job->data.commit.top"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDeleteImages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1028-1050",
          "snippet": "static void\nqemuBlockJobDeleteImages(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainDiskDefPtr disk,\n                         virStorageSourcePtr top)\n{\n    virStorageSourcePtr p = top;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    uid_t uid;\n    gid_t gid;\n\n    for (; p != NULL; p = p->backingStore) {\n        if (virStorageSourceGetActualType(p) == VIR_STORAGE_TYPE_FILE) {\n\n            qemuDomainGetImageIds(cfg, vm, p, disk->src, &uid, &gid);\n\n            if (virFileRemove(p->path, uid, gid) < 0) {\n                VIR_WARN(\"Unable to remove snapshot image file '%s' (%s)\",\n                         p->path, g_strerror(errno));\n            }\n        }\n    }\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobDeleteImages(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainDiskDefPtr disk,\n                         virStorageSourcePtr top)\n{\n    virStorageSourcePtr p = top;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    uid_t uid;\n    gid_t gid;\n\n    for (; p != NULL; p = p->backingStore) {\n        if (virStorageSourceGetActualType(p) == VIR_STORAGE_TYPE_FILE) {\n\n            qemuDomainGetImageIds(cfg, vm, p, disk->src, &uid, &gid);\n\n            if (virFileRemove(p->path, uid, gid) < 0) {\n                VIR_WARN(\"Unable to remove snapshot image file '%s' (%s)\",\n                         p->path, g_strerror(errno));\n            }\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEventProcessConcludedRemoveChain",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "job->data.commit.top"
          ],
          "line": 1171
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEventProcessConcludedRemoveChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "836-855",
          "snippet": "static void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainStorageSourceAccessAllow",
          "args": [
            "driver",
            "vm",
            "job->data.commit.topparent",
            "true",
            "false",
            "true"
          ],
          "line": 1165
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainStorageSourceAccessAllow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12115-12137",
          "snippet": "int\nqemuDomainStorageSourceAccessAllow(virQEMUDriverPtr driver,\n                                   virDomainObjPtr vm,\n                                   virStorageSourcePtr elem,\n                                   bool readonly,\n                                   bool newSource,\n                                   bool chainTop)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_SKIP_REVOKE;\n\n    if (readonly)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_FORCE_READ_ONLY;\n    else\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_FORCE_READ_WRITE;\n\n    if (!newSource)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_MODIFY_ACCESS;\n\n    if (chainTop)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_CHAIN_TOP;\n\n    return qemuDomainStorageSourceAccessModify(driver, vm, elem, flags);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainStorageSourceAccessAllow(virQEMUDriverPtr driver,\n                                   virDomainObjPtr vm,\n                                   virStorageSourcePtr elem,\n                                   bool readonly,\n                                   bool newSource,\n                                   bool chainTop)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_SKIP_REVOKE;\n\n    if (readonly)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_FORCE_READ_ONLY;\n    else\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_FORCE_READ_WRITE;\n\n    if (!newSource)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_MODIFY_ACCESS;\n\n    if (chainTop)\n        flags |= QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_CHAIN_TOP;\n\n    return qemuDomainStorageSourceAccessModify(driver, vm, elem, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobProcessEventCompletedCommitBitmaps",
          "args": [
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 1158
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobProcessEventCompletedCommitBitmaps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1058-1098",
          "snippet": "static int\nqemuBlockJobProcessEventCompletedCommitBitmaps(virDomainObjPtr vm,\n                                               qemuBlockJobDataPtr job,\n                                               qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virHashTable) blockNamedNodeData = NULL;\n    g_autoptr(virJSONValue) actions = NULL;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV_REOPEN))\n        return 0;\n\n    if (!(blockNamedNodeData = qemuBlockGetNamedNodeData(vm, asyncJob)))\n        return -1;\n\n    if (qemuBlockBitmapsHandleCommitFinish(job->data.commit.top,\n                                           job->data.commit.base,\n                                           blockNamedNodeData,\n                                           &actions,\n                                           job->data.commit.disabledBitmapsBase) < 0)\n        return 0;\n\n    if (!actions)\n        return 0;\n\n    if (qemuBlockReopenReadWrite(vm, job->data.commit.base, asyncJob) < 0)\n        return -1;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        return -1;\n\n    qemuMonitorTransaction(priv->mon, &actions);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n        return -1;\n\n    if (qemuBlockReopenReadOnly(vm, job->data.commit.base, asyncJob) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nqemuBlockJobProcessEventCompletedCommitBitmaps(virDomainObjPtr vm,\n                                               qemuBlockJobDataPtr job,\n                                               qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virHashTable) blockNamedNodeData = NULL;\n    g_autoptr(virJSONValue) actions = NULL;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV_REOPEN))\n        return 0;\n\n    if (!(blockNamedNodeData = qemuBlockGetNamedNodeData(vm, asyncJob)))\n        return -1;\n\n    if (qemuBlockBitmapsHandleCommitFinish(job->data.commit.top,\n                                           job->data.commit.base,\n                                           blockNamedNodeData,\n                                           &actions,\n                                           job->data.commit.disabledBitmapsBase) < 0)\n        return 0;\n\n    if (!actions)\n        return 0;\n\n    if (qemuBlockReopenReadWrite(vm, job->data.commit.base, asyncJob) < 0)\n        return -1;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        return -1;\n\n    qemuMonitorTransaction(priv->mon, &actions);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n        return -1;\n\n    if (qemuBlockReopenReadOnly(vm, job->data.commit.base, asyncJob) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobClearConfigChain",
          "args": [
            "vm",
            "job->disk"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobClearConfigChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "920-937",
          "snippet": "static void\nqemuBlockJobClearConfigChain(virDomainObjPtr vm,\n                             virDomainDiskDefPtr disk)\n{\n    virDomainDiskDefPtr cfgdisk = NULL;\n\n    if (!vm->newDef || !disk)\n        return;\n\n    if (!(cfgdisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, cfgdisk->src))\n        return;\n\n    virObjectUnref(cfgdisk->src->backingStore);\n    cfgdisk->src->backingStore = NULL;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobClearConfigChain(virDomainObjPtr vm,\n                             virDomainDiskDefPtr disk)\n{\n    virDomainDiskDefPtr cfgdisk = NULL;\n\n    if (!vm->newDef || !disk)\n        return;\n\n    if (!(cfgdisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, cfgdisk->src))\n        return;\n\n    virObjectUnref(cfgdisk->src->backingStore);\n    cfgdisk->src->backingStore = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobGetConfigDisk",
          "args": [
            "vm",
            "job->disk",
            "job->data.commit.base"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobGetConfigDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "870-904",
          "snippet": "static virDomainDiskDefPtr\nqemuBlockJobGetConfigDisk(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr diskChainBottom)\n{\n    virStorageSourcePtr disksrc = NULL;\n    virStorageSourcePtr cfgsrc = NULL;\n    virDomainDiskDefPtr ret = NULL;\n\n    if (!vm->newDef || !disk)\n        return NULL;\n\n    disksrc = disk->src;\n\n    if (!(ret = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return NULL;\n\n    cfgsrc = ret->src;\n\n    while (disksrc && cfgsrc) {\n        if (!virStorageSourceIsSameLocation(disksrc, cfgsrc))\n            return NULL;\n\n        if (diskChainBottom && diskChainBottom == disksrc)\n            return ret;\n\n        disksrc = disksrc->backingStore;\n        cfgsrc = cfgsrc->backingStore;\n    }\n\n    if (disksrc || cfgsrc)\n        return NULL;\n\n    return ret;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainDiskDefPtr\nqemuBlockJobGetConfigDisk(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr diskChainBottom)\n{\n    virStorageSourcePtr disksrc = NULL;\n    virStorageSourcePtr cfgsrc = NULL;\n    virDomainDiskDefPtr ret = NULL;\n\n    if (!vm->newDef || !disk)\n        return NULL;\n\n    disksrc = disk->src;\n\n    if (!(ret = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return NULL;\n\n    cfgsrc = ret->src;\n\n    while (disksrc && cfgsrc) {\n        if (!virStorageSourceIsSameLocation(disksrc, cfgsrc))\n            return NULL;\n\n        if (diskChainBottom && diskChainBottom == disksrc)\n            return ret;\n\n        disksrc = disksrc->backingStore;\n        cfgsrc = cfgsrc->backingStore;\n    }\n\n    if (disksrc || cfgsrc)\n        return NULL;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"commit job '%s' on VM '%s' completed\"",
            "job->name",
            "vm->def->name"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventCompletedCommit(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgnext = NULL;\n    virStorageSourcePtr cfgtopparent = NULL;\n    virStorageSourcePtr cfgtop = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n\n    VIR_DEBUG(\"commit job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.commit.base)))\n        cfgnext = cfgdisk->src;\n\n    if (!cfgdisk)\n        qemuBlockJobClearConfigChain(vm, job->disk);\n\n    for (n = job->disk->src; n && n != job->data.commit.base; n = n->backingStore) {\n        if (cfgnext) {\n            if (n == job->data.commit.topparent)\n                cfgtopparent = cfgnext;\n\n            if (n == job->data.commit.top)\n                cfgtop = cfgnext;\n\n            cfgbaseparent = cfgnext;\n            cfgnext = cfgnext->backingStore;\n        }\n        baseparent = n;\n    }\n\n    if (!n)\n        return;\n\n    if (qemuBlockJobProcessEventCompletedCommitBitmaps(vm, job, asyncJob) < 0)\n        return;\n\n    /* revert access to images */\n    qemuDomainStorageSourceAccessAllow(driver, vm, job->data.commit.base,\n                                       true, false, false);\n    if (job->data.commit.topparent != job->disk->src)\n        qemuDomainStorageSourceAccessAllow(driver, vm, job->data.commit.topparent,\n                                           true, false, true);\n\n    baseparent->backingStore = NULL;\n    job->data.commit.topparent->backingStore = job->data.commit.base;\n\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, job->data.commit.top);\n\n    if (job->data.commit.deleteCommittedImages)\n        qemuBlockJobDeleteImages(driver, vm, job->disk, job->data.commit.top);\n\n    virObjectUnref(job->data.commit.top);\n    job->data.commit.top = NULL;\n\n    if (cfgbaseparent) {\n        cfgbase = cfgbaseparent->backingStore;\n        cfgbaseparent->backingStore = NULL;\n\n        if (cfgtopparent)\n            cfgtopparent->backingStore = cfgbase;\n        else\n            cfgdisk->src = cfgbase;\n\n        virObjectUnref(cfgtop);\n    }\n}"
  },
  {
    "function_name": "qemuBlockJobProcessEventCompletedCommitBitmaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1058-1098",
    "snippet": "static int\nqemuBlockJobProcessEventCompletedCommitBitmaps(virDomainObjPtr vm,\n                                               qemuBlockJobDataPtr job,\n                                               qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virHashTable) blockNamedNodeData = NULL;\n    g_autoptr(virJSONValue) actions = NULL;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV_REOPEN))\n        return 0;\n\n    if (!(blockNamedNodeData = qemuBlockGetNamedNodeData(vm, asyncJob)))\n        return -1;\n\n    if (qemuBlockBitmapsHandleCommitFinish(job->data.commit.top,\n                                           job->data.commit.base,\n                                           blockNamedNodeData,\n                                           &actions,\n                                           job->data.commit.disabledBitmapsBase) < 0)\n        return 0;\n\n    if (!actions)\n        return 0;\n\n    if (qemuBlockReopenReadWrite(vm, job->data.commit.base, asyncJob) < 0)\n        return -1;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        return -1;\n\n    qemuMonitorTransaction(priv->mon, &actions);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n        return -1;\n\n    if (qemuBlockReopenReadOnly(vm, job->data.commit.base, asyncJob) < 0)\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBlockReopenReadOnly",
          "args": [
            "vm",
            "job->data.commit.base",
            "asyncJob"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadOnly",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3308-3323",
          "snippet": "int\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadOnly(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (src->readonly)\n        return 0;\n\n    src->readonly = true;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = false;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "priv->driver",
            "vm"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorTransaction",
          "args": [
            "priv->mon",
            "&actions"
          ],
          "line": 1089
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorTransaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3073-3081",
          "snippet": "int\nqemuMonitorTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    VIR_DEBUG(\"actions=%p\", *actions);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONTransaction(mon, actions);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorTransaction(qemuMonitorPtr mon, virJSONValuePtr *actions)\n{\n    VIR_DEBUG(\"actions=%p\", *actions);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONTransaction(mon, actions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "priv->driver",
            "vm",
            "asyncJob"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockReopenReadWrite",
          "args": [
            "vm",
            "job->data.commit.base",
            "asyncJob"
          ],
          "line": 1083
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockReopenReadWrite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3279-3294",
          "snippet": "int\nqemuBlockReopenReadWrite(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (!src->readonly)\n        return 0;\n\n    src->readonly = false;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = true;\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockReopenReadWrite(virDomainObjPtr vm,\n                         virStorageSourcePtr src,\n                         qemuDomainAsyncJob asyncJob)\n{\n    if (!src->readonly)\n        return 0;\n\n    src->readonly = false;\n    if (qemuBlockReopenFormat(vm, src, asyncJob) < 0) {\n        src->readonly = true;\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockBitmapsHandleCommitFinish",
          "args": [
            "job->data.commit.top",
            "job->data.commit.base",
            "blockNamedNodeData",
            "&actions",
            "job->data.commit.disabledBitmapsBase"
          ],
          "line": 1073
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockBitmapsHandleCommitFinish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "3129-3222",
          "snippet": "int\nqemuBlockBitmapsHandleCommitFinish(virStorageSourcePtr topsrc,\n                                   virStorageSourcePtr basesrc,\n                                   virHashTablePtr blockNamedNodeData,\n                                   virJSONValuePtr *actions,\n                                   char **disabledBitmapsBase)\n{\n    g_autoptr(virJSONValue) act = virJSONValueNewArray();\n    virStorageSourcePtr n;\n    qemuBlockNamedNodeDataPtr entry;\n    g_autoptr(virHashTable) commitdata = NULL;\n    struct qemuBlockBitmapsHandleCommitData *bitmapdata;\n    size_t i;\n\n    commitdata = virHashNew(qemuBlockBitmapsHandleCommitDataFree);\n\n    for (n = topsrc; n != basesrc; n = n->backingStore) {\n        if (!(entry = virHashLookup(blockNamedNodeData, n->nodeformat)))\n            continue;\n\n        for (i = 0; i < entry->nbitmaps; i++) {\n            qemuBlockNamedNodeDataBitmapPtr bitmap = entry->bitmaps[i];\n\n            if (!(bitmapdata = virHashLookup(commitdata, bitmap->name))) {\n                bitmapdata = g_new0(struct qemuBlockBitmapsHandleCommitData, 1);\n\n                /* we must mirror the state of the topmost bitmap and merge\n                 * everything else */\n                bitmapdata->create = true;\n                bitmapdata->enable = bitmap->recording;\n                bitmapdata->basenode = basesrc->nodeformat;\n                bitmapdata->merge = virJSONValueNewArray();\n                bitmapdata->granularity = bitmap->granularity;\n                bitmapdata->persistent = bitmap->persistent;\n\n                if (virHashAddEntry(commitdata, bitmap->name, bitmapdata) < 0) {\n                    qemuBlockBitmapsHandleCommitDataFree(bitmapdata);\n                    return -1;\n                }\n            }\n\n            if (bitmap->inconsistent ||\n                !qemuBlockBitmapChainIsValid(topsrc, bitmap->name, blockNamedNodeData))\n                bitmapdata->skip = true;\n\n            if (qemuMonitorTransactionBitmapMergeSourceAddBitmap(bitmapdata->merge,\n                                                                 n->nodeformat,\n                                                                 bitmap->name) < 0)\n                return -1;\n        }\n    }\n\n    if ((entry = virHashLookup(blockNamedNodeData, basesrc->nodeformat))) {\n        /* note that all bitmaps in 'base' were disabled when commit was started */\n        for (i = 0; i < entry->nbitmaps; i++) {\n            qemuBlockNamedNodeDataBitmapPtr bitmap = entry->bitmaps[i];\n\n            if ((bitmapdata = virHashLookup(commitdata, bitmap->name))) {\n                bitmapdata->create = false;\n            } else {\n                if (disabledBitmapsBase) {\n                    char **disabledbitmaps;\n\n                    for (disabledbitmaps = disabledBitmapsBase; *disabledbitmaps; disabledbitmaps++) {\n                        if (STREQ(*disabledbitmaps, bitmap->name)) {\n                            bitmapdata = g_new0(struct qemuBlockBitmapsHandleCommitData, 1);\n\n                            bitmapdata->create = false;\n                            bitmapdata->enable = true;\n                            bitmapdata->basenode = basesrc->nodeformat;\n                            bitmapdata->granularity = bitmap->granularity;\n                            bitmapdata->persistent = bitmap->persistent;\n\n                            if (virHashAddEntry(commitdata, bitmap->name, bitmapdata) < 0) {\n                                qemuBlockBitmapsHandleCommitDataFree(bitmapdata);\n                                return -1;\n                            }\n\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (virHashForEach(commitdata, qemuBlockBitmapsHandleCommitFinishIterate, act) < 0)\n        return -1;\n\n    if (virJSONValueArraySize(act) > 0)\n        *actions = g_steal_pointer(&act);\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockBitmapsHandleCommitFinish(virStorageSourcePtr topsrc,\n                                   virStorageSourcePtr basesrc,\n                                   virHashTablePtr blockNamedNodeData,\n                                   virJSONValuePtr *actions,\n                                   char **disabledBitmapsBase)\n{\n    g_autoptr(virJSONValue) act = virJSONValueNewArray();\n    virStorageSourcePtr n;\n    qemuBlockNamedNodeDataPtr entry;\n    g_autoptr(virHashTable) commitdata = NULL;\n    struct qemuBlockBitmapsHandleCommitData *bitmapdata;\n    size_t i;\n\n    commitdata = virHashNew(qemuBlockBitmapsHandleCommitDataFree);\n\n    for (n = topsrc; n != basesrc; n = n->backingStore) {\n        if (!(entry = virHashLookup(blockNamedNodeData, n->nodeformat)))\n            continue;\n\n        for (i = 0; i < entry->nbitmaps; i++) {\n            qemuBlockNamedNodeDataBitmapPtr bitmap = entry->bitmaps[i];\n\n            if (!(bitmapdata = virHashLookup(commitdata, bitmap->name))) {\n                bitmapdata = g_new0(struct qemuBlockBitmapsHandleCommitData, 1);\n\n                /* we must mirror the state of the topmost bitmap and merge\n                 * everything else */\n                bitmapdata->create = true;\n                bitmapdata->enable = bitmap->recording;\n                bitmapdata->basenode = basesrc->nodeformat;\n                bitmapdata->merge = virJSONValueNewArray();\n                bitmapdata->granularity = bitmap->granularity;\n                bitmapdata->persistent = bitmap->persistent;\n\n                if (virHashAddEntry(commitdata, bitmap->name, bitmapdata) < 0) {\n                    qemuBlockBitmapsHandleCommitDataFree(bitmapdata);\n                    return -1;\n                }\n            }\n\n            if (bitmap->inconsistent ||\n                !qemuBlockBitmapChainIsValid(topsrc, bitmap->name, blockNamedNodeData))\n                bitmapdata->skip = true;\n\n            if (qemuMonitorTransactionBitmapMergeSourceAddBitmap(bitmapdata->merge,\n                                                                 n->nodeformat,\n                                                                 bitmap->name) < 0)\n                return -1;\n        }\n    }\n\n    if ((entry = virHashLookup(blockNamedNodeData, basesrc->nodeformat))) {\n        /* note that all bitmaps in 'base' were disabled when commit was started */\n        for (i = 0; i < entry->nbitmaps; i++) {\n            qemuBlockNamedNodeDataBitmapPtr bitmap = entry->bitmaps[i];\n\n            if ((bitmapdata = virHashLookup(commitdata, bitmap->name))) {\n                bitmapdata->create = false;\n            } else {\n                if (disabledBitmapsBase) {\n                    char **disabledbitmaps;\n\n                    for (disabledbitmaps = disabledBitmapsBase; *disabledbitmaps; disabledbitmaps++) {\n                        if (STREQ(*disabledbitmaps, bitmap->name)) {\n                            bitmapdata = g_new0(struct qemuBlockBitmapsHandleCommitData, 1);\n\n                            bitmapdata->create = false;\n                            bitmapdata->enable = true;\n                            bitmapdata->basenode = basesrc->nodeformat;\n                            bitmapdata->granularity = bitmap->granularity;\n                            bitmapdata->persistent = bitmap->persistent;\n\n                            if (virHashAddEntry(commitdata, bitmap->name, bitmapdata) < 0) {\n                                qemuBlockBitmapsHandleCommitDataFree(bitmapdata);\n                                return -1;\n                            }\n\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (virHashForEach(commitdata, qemuBlockBitmapsHandleCommitFinishIterate, act) < 0)\n        return -1;\n\n    if (virJSONValueArraySize(act) > 0)\n        *actions = g_steal_pointer(&act);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockGetNamedNodeData",
          "args": [
            "vm",
            "asyncJob"
          ],
          "line": 1070
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockGetNamedNodeData",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "2805-2824",
          "snippet": "virHashTablePtr\nqemuBlockGetNamedNodeData(virDomainObjPtr vm,\n                          qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverPtr driver = priv->driver;\n    g_autoptr(virHashTable) blockNamedNodeData = NULL;\n    bool supports_flat = virQEMUCapsGet(priv->qemuCaps,\n                                        QEMU_CAPS_QMP_QUERY_NAMED_BLOCK_NODES_FLAT);\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return NULL;\n\n    blockNamedNodeData = qemuMonitorBlockGetNamedNodeData(priv->mon, supports_flat);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !blockNamedNodeData)\n        return NULL;\n\n    return g_steal_pointer(&blockNamedNodeData);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvirHashTablePtr\nqemuBlockGetNamedNodeData(virDomainObjPtr vm,\n                          qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    virQEMUDriverPtr driver = priv->driver;\n    g_autoptr(virHashTable) blockNamedNodeData = NULL;\n    bool supports_flat = virQEMUCapsGet(priv->qemuCaps,\n                                        QEMU_CAPS_QMP_QUERY_NAMED_BLOCK_NODES_FLAT);\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return NULL;\n\n    blockNamedNodeData = qemuMonitorBlockGetNamedNodeData(priv->mon, supports_flat);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !blockNamedNodeData)\n        return NULL;\n\n    return g_steal_pointer(&blockNamedNodeData);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_BLOCKDEV_REOPEN"
          ],
          "line": 1067
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nqemuBlockJobProcessEventCompletedCommitBitmaps(virDomainObjPtr vm,\n                                               qemuBlockJobDataPtr job,\n                                               qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virHashTable) blockNamedNodeData = NULL;\n    g_autoptr(virJSONValue) actions = NULL;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV_REOPEN))\n        return 0;\n\n    if (!(blockNamedNodeData = qemuBlockGetNamedNodeData(vm, asyncJob)))\n        return -1;\n\n    if (qemuBlockBitmapsHandleCommitFinish(job->data.commit.top,\n                                           job->data.commit.base,\n                                           blockNamedNodeData,\n                                           &actions,\n                                           job->data.commit.disabledBitmapsBase) < 0)\n        return 0;\n\n    if (!actions)\n        return 0;\n\n    if (qemuBlockReopenReadWrite(vm, job->data.commit.base, asyncJob) < 0)\n        return -1;\n\n    if (qemuDomainObjEnterMonitorAsync(priv->driver, vm, asyncJob) < 0)\n        return -1;\n\n    qemuMonitorTransaction(priv->mon, &actions);\n\n    if (qemuDomainObjExitMonitor(priv->driver, vm) < 0)\n        return -1;\n\n    if (qemuBlockReopenReadOnly(vm, job->data.commit.base, asyncJob) < 0)\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuBlockJobDeleteImages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "1028-1050",
    "snippet": "static void\nqemuBlockJobDeleteImages(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainDiskDefPtr disk,\n                         virStorageSourcePtr top)\n{\n    virStorageSourcePtr p = top;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    uid_t uid;\n    gid_t gid;\n\n    for (; p != NULL; p = p->backingStore) {\n        if (virStorageSourceGetActualType(p) == VIR_STORAGE_TYPE_FILE) {\n\n            qemuDomainGetImageIds(cfg, vm, p, disk->src, &uid, &gid);\n\n            if (virFileRemove(p->path, uid, gid) < 0) {\n                VIR_WARN(\"Unable to remove snapshot image file '%s' (%s)\",\n                         p->path, g_strerror(errno));\n            }\n        }\n    }\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to remove snapshot image file '%s' (%s)\"",
            "p->path",
            "g_strerror(errno)"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strerror",
          "args": [
            "errno"
          ],
          "line": 1046
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virFileRemove",
          "args": [
            "p->path",
            "uid",
            "gid"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "virFileRemove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "2844-2856",
          "snippet": "int\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nint\nvirFileRemove(const char *path,\n              uid_t uid G_GNUC_UNUSED,\n              gid_t gid G_GNUC_UNUSED)\n{\n    if (unlink(path) < 0) {\n        virReportSystemError(errno, _(\"Unable to unlink path '%s'\"),\n                             path);\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainGetImageIds",
          "args": [
            "cfg",
            "vm",
            "p",
            "disk->src",
            "&uid",
            "&gid"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetImageIds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11527-11562",
          "snippet": "void\nqemuDomainGetImageIds(virQEMUDriverConfigPtr cfg,\n                      virDomainObjPtr vm,\n                      virStorageSourcePtr src,\n                      virStorageSourcePtr parentSrc,\n                      uid_t *uid, gid_t *gid)\n{\n    virSecurityLabelDefPtr vmlabel;\n    virSecurityDeviceLabelDefPtr disklabel;\n\n    if (uid)\n        *uid = -1;\n    if (gid)\n        *gid = -1;\n\n    if (cfg) {\n        if (uid)\n            *uid = cfg->user;\n\n        if (gid)\n            *gid = cfg->group;\n    }\n\n    if (vm && (vmlabel = virDomainDefGetSecurityLabelDef(vm->def, \"dac\")) &&\n        vmlabel->label)\n        virParseOwnershipIds(vmlabel->label, uid, gid);\n\n    if (parentSrc &&\n        (disklabel = virStorageSourceGetSecurityLabelDef(parentSrc, \"dac\")) &&\n        disklabel->label)\n        virParseOwnershipIds(disklabel->label, uid, gid);\n\n    if ((disklabel = virStorageSourceGetSecurityLabelDef(src, \"dac\")) &&\n        disklabel->label)\n        virParseOwnershipIds(disklabel->label, uid, gid);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nvoid\nqemuDomainGetImageIds(virQEMUDriverConfigPtr cfg,\n                      virDomainObjPtr vm,\n                      virStorageSourcePtr src,\n                      virStorageSourcePtr parentSrc,\n                      uid_t *uid, gid_t *gid)\n{\n    virSecurityLabelDefPtr vmlabel;\n    virSecurityDeviceLabelDefPtr disklabel;\n\n    if (uid)\n        *uid = -1;\n    if (gid)\n        *gid = -1;\n\n    if (cfg) {\n        if (uid)\n            *uid = cfg->user;\n\n        if (gid)\n            *gid = cfg->group;\n    }\n\n    if (vm && (vmlabel = virDomainDefGetSecurityLabelDef(vm->def, \"dac\")) &&\n        vmlabel->label)\n        virParseOwnershipIds(vmlabel->label, uid, gid);\n\n    if (parentSrc &&\n        (disklabel = virStorageSourceGetSecurityLabelDef(parentSrc, \"dac\")) &&\n        disklabel->label)\n        virParseOwnershipIds(disklabel->label, uid, gid);\n\n    if ((disklabel = virStorageSourceGetSecurityLabelDef(src, \"dac\")) &&\n        disklabel->label)\n        virParseOwnershipIds(disklabel->label, uid, gid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceGetActualType",
          "args": [
            "p"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceGetActualType",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2574-2583",
          "snippet": "int\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceGetActualType(const virStorageSource *def)\n{\n    if (def->type == VIR_STORAGE_TYPE_VOLUME &&\n        def->srcpool &&\n        def->srcpool->actualtype != VIR_STORAGE_TYPE_NONE)\n        return def->srcpool->actualtype;\n\n    return def->type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUDriverGetConfig",
          "args": [
            "driver"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUDriverGetConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_conf.c",
          "lines": "1211-1218",
          "snippet": "virQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"virutil.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virstring.h\"",
            "#include \"virsocket.h\"",
            "#include \"virfile.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virlog.h\"",
            "#include \"virxml.h\"",
            "#include \"datatypes.h\"",
            "#include \"viralloc.h\"",
            "#include \"virconf.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"virerror.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"virutil.h\"\n#include \"storage_conf.h\"\n#include \"virstring.h\"\n#include \"virsocket.h\"\n#include \"virfile.h\"\n#include \"domain_nwfilter.h\"\n#include \"cpu/cpu.h\"\n#include \"virlog.h\"\n#include \"virxml.h\"\n#include \"datatypes.h\"\n#include \"viralloc.h\"\n#include \"virconf.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"qemu_security.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"virerror.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <config.h>\n\nvirQEMUDriverConfigPtr virQEMUDriverGetConfig(virQEMUDriverPtr driver)\n{\n    virQEMUDriverConfigPtr conf;\n    qemuDriverLock(driver);\n    conf = virObjectRef(driver->config);\n    qemuDriverUnlock(driver);\n    return conf;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobDeleteImages(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         virDomainDiskDefPtr disk,\n                         virStorageSourcePtr top)\n{\n    virStorageSourcePtr p = top;\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    uid_t uid;\n    gid_t gid;\n\n    for (; p != NULL; p = p->backingStore) {\n        if (virStorageSourceGetActualType(p) == VIR_STORAGE_TYPE_FILE) {\n\n            qemuDomainGetImageIds(cfg, vm, p, disk->src, &uid, &gid);\n\n            if (virFileRemove(p->path, uid, gid) < 0) {\n                VIR_WARN(\"Unable to remove snapshot image file '%s' (%s)\",\n                         p->path, g_strerror(errno));\n            }\n        }\n    }\n}"
  },
  {
    "function_name": "qemuBlockJobProcessEventCompletedPull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "955-1011",
    "snippet": "static void\nqemuBlockJobProcessEventCompletedPull(virQEMUDriverPtr driver,\n                                      virDomainObjPtr vm,\n                                      qemuBlockJobDataPtr job,\n                                      qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n    virStorageSourcePtr tmp;\n\n    VIR_DEBUG(\"pull job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.pull.base)))\n        cfgbase = cfgdisk->src->backingStore;\n\n    if (!cfgdisk)\n        qemuBlockJobClearConfigChain(vm, job->disk);\n\n    /* when pulling if 'base' is right below the top image we don't have to modify it */\n    if (job->disk->src->backingStore == job->data.pull.base)\n        return;\n\n    if (job->data.pull.base) {\n        for (n = job->disk->src->backingStore; n && n != job->data.pull.base; n = n->backingStore) {\n            /* find the image on top of 'base' */\n\n            if (cfgbase) {\n                cfgbaseparent = cfgbase;\n                cfgbase = cfgbase->backingStore;\n            }\n\n            baseparent = n;\n        }\n    }\n\n    tmp = job->disk->src->backingStore;\n    job->disk->src->backingStore = job->data.pull.base;\n    if (baseparent)\n        baseparent->backingStore = NULL;\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, tmp);\n    virObjectUnref(tmp);\n\n    if (cfgdisk) {\n        tmp = cfgdisk->src->backingStore;\n        cfgdisk->src->backingStore = cfgbase;\n        if (cfgbaseparent)\n            cfgbaseparent->backingStore = NULL;\n        virObjectUnref(tmp);\n    }\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "tmp"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEventProcessConcludedRemoveChain",
          "args": [
            "driver",
            "vm",
            "asyncJob",
            "tmp"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEventProcessConcludedRemoveChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "836-855",
          "snippet": "static void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobClearConfigChain",
          "args": [
            "vm",
            "job->disk"
          ],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobClearConfigChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "920-937",
          "snippet": "static void\nqemuBlockJobClearConfigChain(virDomainObjPtr vm,\n                             virDomainDiskDefPtr disk)\n{\n    virDomainDiskDefPtr cfgdisk = NULL;\n\n    if (!vm->newDef || !disk)\n        return;\n\n    if (!(cfgdisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, cfgdisk->src))\n        return;\n\n    virObjectUnref(cfgdisk->src->backingStore);\n    cfgdisk->src->backingStore = NULL;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobClearConfigChain(virDomainObjPtr vm,\n                             virDomainDiskDefPtr disk)\n{\n    virDomainDiskDefPtr cfgdisk = NULL;\n\n    if (!vm->newDef || !disk)\n        return;\n\n    if (!(cfgdisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, cfgdisk->src))\n        return;\n\n    virObjectUnref(cfgdisk->src->backingStore);\n    cfgdisk->src->backingStore = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobGetConfigDisk",
          "args": [
            "vm",
            "job->disk",
            "job->data.pull.base"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobGetConfigDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "870-904",
          "snippet": "static virDomainDiskDefPtr\nqemuBlockJobGetConfigDisk(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr diskChainBottom)\n{\n    virStorageSourcePtr disksrc = NULL;\n    virStorageSourcePtr cfgsrc = NULL;\n    virDomainDiskDefPtr ret = NULL;\n\n    if (!vm->newDef || !disk)\n        return NULL;\n\n    disksrc = disk->src;\n\n    if (!(ret = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return NULL;\n\n    cfgsrc = ret->src;\n\n    while (disksrc && cfgsrc) {\n        if (!virStorageSourceIsSameLocation(disksrc, cfgsrc))\n            return NULL;\n\n        if (diskChainBottom && diskChainBottom == disksrc)\n            return ret;\n\n        disksrc = disksrc->backingStore;\n        cfgsrc = cfgsrc->backingStore;\n    }\n\n    if (disksrc || cfgsrc)\n        return NULL;\n\n    return ret;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainDiskDefPtr\nqemuBlockJobGetConfigDisk(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr diskChainBottom)\n{\n    virStorageSourcePtr disksrc = NULL;\n    virStorageSourcePtr cfgsrc = NULL;\n    virDomainDiskDefPtr ret = NULL;\n\n    if (!vm->newDef || !disk)\n        return NULL;\n\n    disksrc = disk->src;\n\n    if (!(ret = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return NULL;\n\n    cfgsrc = ret->src;\n\n    while (disksrc && cfgsrc) {\n        if (!virStorageSourceIsSameLocation(disksrc, cfgsrc))\n            return NULL;\n\n        if (diskChainBottom && diskChainBottom == disksrc)\n            return ret;\n\n        disksrc = disksrc->backingStore;\n        cfgsrc = cfgsrc->backingStore;\n    }\n\n    if (disksrc || cfgsrc)\n        return NULL;\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"pull job '%s' on VM '%s' completed\"",
            "job->name",
            "vm->def->name"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobProcessEventCompletedPull(virQEMUDriverPtr driver,\n                                      virDomainObjPtr vm,\n                                      qemuBlockJobDataPtr job,\n                                      qemuDomainAsyncJob asyncJob)\n{\n    virStorageSourcePtr baseparent = NULL;\n    virDomainDiskDefPtr cfgdisk = NULL;\n    virStorageSourcePtr cfgbase = NULL;\n    virStorageSourcePtr cfgbaseparent = NULL;\n    virStorageSourcePtr n;\n    virStorageSourcePtr tmp;\n\n    VIR_DEBUG(\"pull job '%s' on VM '%s' completed\", job->name, vm->def->name);\n\n    /* if the job isn't associated with a disk there's nothing to do */\n    if (!job->disk)\n        return;\n\n    if ((cfgdisk = qemuBlockJobGetConfigDisk(vm, job->disk, job->data.pull.base)))\n        cfgbase = cfgdisk->src->backingStore;\n\n    if (!cfgdisk)\n        qemuBlockJobClearConfigChain(vm, job->disk);\n\n    /* when pulling if 'base' is right below the top image we don't have to modify it */\n    if (job->disk->src->backingStore == job->data.pull.base)\n        return;\n\n    if (job->data.pull.base) {\n        for (n = job->disk->src->backingStore; n && n != job->data.pull.base; n = n->backingStore) {\n            /* find the image on top of 'base' */\n\n            if (cfgbase) {\n                cfgbaseparent = cfgbase;\n                cfgbase = cfgbase->backingStore;\n            }\n\n            baseparent = n;\n        }\n    }\n\n    tmp = job->disk->src->backingStore;\n    job->disk->src->backingStore = job->data.pull.base;\n    if (baseparent)\n        baseparent->backingStore = NULL;\n    qemuBlockJobEventProcessConcludedRemoveChain(driver, vm, asyncJob, tmp);\n    virObjectUnref(tmp);\n\n    if (cfgdisk) {\n        tmp = cfgdisk->src->backingStore;\n        cfgdisk->src->backingStore = cfgbase;\n        if (cfgbaseparent)\n            cfgbaseparent->backingStore = NULL;\n        virObjectUnref(tmp);\n    }\n}"
  },
  {
    "function_name": "qemuBlockJobClearConfigChain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "920-937",
    "snippet": "static void\nqemuBlockJobClearConfigChain(virDomainObjPtr vm,\n                             virDomainDiskDefPtr disk)\n{\n    virDomainDiskDefPtr cfgdisk = NULL;\n\n    if (!vm->newDef || !disk)\n        return;\n\n    if (!(cfgdisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, cfgdisk->src))\n        return;\n\n    virObjectUnref(cfgdisk->src->backingStore);\n    cfgdisk->src->backingStore = NULL;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "cfgdisk->src->backingStore"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsSameLocation",
          "args": [
            "disk->src",
            "cfgdisk->src"
          ],
          "line": 932
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsSameLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2480-2518",
          "snippet": "bool\nvirStorageSourceIsSameLocation(virStorageSourcePtr a,\n                               virStorageSourcePtr b)\n{\n    size_t i;\n\n    /* there are multiple possibilities to define an empty source */\n    if (virStorageSourceIsEmpty(a) &&\n        virStorageSourceIsEmpty(b))\n        return true;\n\n    if (virStorageSourceGetActualType(a) != virStorageSourceGetActualType(b))\n        return false;\n\n    if (STRNEQ_NULLABLE(a->path, b->path) ||\n        STRNEQ_NULLABLE(a->volume, b->volume) ||\n        STRNEQ_NULLABLE(a->snapshot, b->snapshot))\n        return false;\n\n    if (a->type == VIR_STORAGE_TYPE_NETWORK) {\n        if (a->protocol != b->protocol ||\n            a->nhosts != b->nhosts)\n            return false;\n\n        for (i = 0; i < a->nhosts; i++) {\n            if (a->hosts[i].transport != b->hosts[i].transport ||\n                a->hosts[i].port != b->hosts[i].port ||\n                STRNEQ_NULLABLE(a->hosts[i].name, b->hosts[i].name) ||\n                STRNEQ_NULLABLE(a->hosts[i].socket, b->hosts[i].socket))\n                return false;\n        }\n    }\n\n    if (a->type == VIR_STORAGE_TYPE_NVME &&\n        !virStorageSourceNVMeDefIsEqual(a->nvme, b->nvme))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nbool\nvirStorageSourceIsSameLocation(virStorageSourcePtr a,\n                               virStorageSourcePtr b)\n{\n    size_t i;\n\n    /* there are multiple possibilities to define an empty source */\n    if (virStorageSourceIsEmpty(a) &&\n        virStorageSourceIsEmpty(b))\n        return true;\n\n    if (virStorageSourceGetActualType(a) != virStorageSourceGetActualType(b))\n        return false;\n\n    if (STRNEQ_NULLABLE(a->path, b->path) ||\n        STRNEQ_NULLABLE(a->volume, b->volume) ||\n        STRNEQ_NULLABLE(a->snapshot, b->snapshot))\n        return false;\n\n    if (a->type == VIR_STORAGE_TYPE_NETWORK) {\n        if (a->protocol != b->protocol ||\n            a->nhosts != b->nhosts)\n            return false;\n\n        for (i = 0; i < a->nhosts; i++) {\n            if (a->hosts[i].transport != b->hosts[i].transport ||\n                a->hosts[i].port != b->hosts[i].port ||\n                STRNEQ_NULLABLE(a->hosts[i].name, b->hosts[i].name) ||\n                STRNEQ_NULLABLE(a->hosts[i].socket, b->hosts[i].socket))\n                return false;\n        }\n    }\n\n    if (a->type == VIR_STORAGE_TYPE_NVME &&\n        !virStorageSourceNVMeDefIsEqual(a->nvme, b->nvme))\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskByTarget",
          "args": [
            "vm->newDef",
            "disk->dst"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskByTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17337-17349",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobClearConfigChain(virDomainObjPtr vm,\n                             virDomainDiskDefPtr disk)\n{\n    virDomainDiskDefPtr cfgdisk = NULL;\n\n    if (!vm->newDef || !disk)\n        return;\n\n    if (!(cfgdisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, cfgdisk->src))\n        return;\n\n    virObjectUnref(cfgdisk->src->backingStore);\n    cfgdisk->src->backingStore = NULL;\n}"
  },
  {
    "function_name": "qemuBlockJobGetConfigDisk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "870-904",
    "snippet": "static virDomainDiskDefPtr\nqemuBlockJobGetConfigDisk(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr diskChainBottom)\n{\n    virStorageSourcePtr disksrc = NULL;\n    virStorageSourcePtr cfgsrc = NULL;\n    virDomainDiskDefPtr ret = NULL;\n\n    if (!vm->newDef || !disk)\n        return NULL;\n\n    disksrc = disk->src;\n\n    if (!(ret = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return NULL;\n\n    cfgsrc = ret->src;\n\n    while (disksrc && cfgsrc) {\n        if (!virStorageSourceIsSameLocation(disksrc, cfgsrc))\n            return NULL;\n\n        if (diskChainBottom && diskChainBottom == disksrc)\n            return ret;\n\n        disksrc = disksrc->backingStore;\n        cfgsrc = cfgsrc->backingStore;\n    }\n\n    if (disksrc || cfgsrc)\n        return NULL;\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virStorageSourceIsSameLocation",
          "args": [
            "disksrc",
            "cfgsrc"
          ],
          "line": 890
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsSameLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2480-2518",
          "snippet": "bool\nvirStorageSourceIsSameLocation(virStorageSourcePtr a,\n                               virStorageSourcePtr b)\n{\n    size_t i;\n\n    /* there are multiple possibilities to define an empty source */\n    if (virStorageSourceIsEmpty(a) &&\n        virStorageSourceIsEmpty(b))\n        return true;\n\n    if (virStorageSourceGetActualType(a) != virStorageSourceGetActualType(b))\n        return false;\n\n    if (STRNEQ_NULLABLE(a->path, b->path) ||\n        STRNEQ_NULLABLE(a->volume, b->volume) ||\n        STRNEQ_NULLABLE(a->snapshot, b->snapshot))\n        return false;\n\n    if (a->type == VIR_STORAGE_TYPE_NETWORK) {\n        if (a->protocol != b->protocol ||\n            a->nhosts != b->nhosts)\n            return false;\n\n        for (i = 0; i < a->nhosts; i++) {\n            if (a->hosts[i].transport != b->hosts[i].transport ||\n                a->hosts[i].port != b->hosts[i].port ||\n                STRNEQ_NULLABLE(a->hosts[i].name, b->hosts[i].name) ||\n                STRNEQ_NULLABLE(a->hosts[i].socket, b->hosts[i].socket))\n                return false;\n        }\n    }\n\n    if (a->type == VIR_STORAGE_TYPE_NVME &&\n        !virStorageSourceNVMeDefIsEqual(a->nvme, b->nvme))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nbool\nvirStorageSourceIsSameLocation(virStorageSourcePtr a,\n                               virStorageSourcePtr b)\n{\n    size_t i;\n\n    /* there are multiple possibilities to define an empty source */\n    if (virStorageSourceIsEmpty(a) &&\n        virStorageSourceIsEmpty(b))\n        return true;\n\n    if (virStorageSourceGetActualType(a) != virStorageSourceGetActualType(b))\n        return false;\n\n    if (STRNEQ_NULLABLE(a->path, b->path) ||\n        STRNEQ_NULLABLE(a->volume, b->volume) ||\n        STRNEQ_NULLABLE(a->snapshot, b->snapshot))\n        return false;\n\n    if (a->type == VIR_STORAGE_TYPE_NETWORK) {\n        if (a->protocol != b->protocol ||\n            a->nhosts != b->nhosts)\n            return false;\n\n        for (i = 0; i < a->nhosts; i++) {\n            if (a->hosts[i].transport != b->hosts[i].transport ||\n                a->hosts[i].port != b->hosts[i].port ||\n                STRNEQ_NULLABLE(a->hosts[i].name, b->hosts[i].name) ||\n                STRNEQ_NULLABLE(a->hosts[i].socket, b->hosts[i].socket))\n                return false;\n        }\n    }\n\n    if (a->type == VIR_STORAGE_TYPE_NVME &&\n        !virStorageSourceNVMeDefIsEqual(a->nvme, b->nvme))\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskByTarget",
          "args": [
            "vm->newDef",
            "disk->dst"
          ],
          "line": 884
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskByTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17337-17349",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virDomainDiskDefPtr\nqemuBlockJobGetConfigDisk(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr diskChainBottom)\n{\n    virStorageSourcePtr disksrc = NULL;\n    virStorageSourcePtr cfgsrc = NULL;\n    virDomainDiskDefPtr ret = NULL;\n\n    if (!vm->newDef || !disk)\n        return NULL;\n\n    disksrc = disk->src;\n\n    if (!(ret = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return NULL;\n\n    cfgsrc = ret->src;\n\n    while (disksrc && cfgsrc) {\n        if (!virStorageSourceIsSameLocation(disksrc, cfgsrc))\n            return NULL;\n\n        if (diskChainBottom && diskChainBottom == disksrc)\n            return ret;\n\n        disksrc = disksrc->backingStore;\n        cfgsrc = cfgsrc->backingStore;\n    }\n\n    if (disksrc || cfgsrc)\n        return NULL;\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuBlockJobEventProcessConcludedRemoveChain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "836-855",
    "snippet": "static void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainStorageSourceChainAccessRevoke",
          "args": [
            "driver",
            "vm",
            "chain"
          ],
          "line": 854
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainStorageSourceChainAccessRevoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12063-12073",
          "snippet": "int\nqemuDomainStorageSourceChainAccessRevoke(virQEMUDriverPtr driver,\n                                         virDomainObjPtr vm,\n                                         virStorageSourcePtr src)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_REVOKE |\n                                               QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_CHAIN |\n                                               QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_CHAIN_TOP;\n\n    return qemuDomainStorageSourceAccessModify(driver, vm, src, flags);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainStorageSourceChainAccessRevoke(virQEMUDriverPtr driver,\n                                         virDomainObjPtr vm,\n                                         virStorageSourcePtr src)\n{\n    qemuDomainStorageSourceAccessFlags flags = QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_REVOKE |\n                                               QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_CHAIN |\n                                               QEMU_DOMAIN_STORAGE_SOURCE_ACCESS_CHAIN_TOP;\n\n    return qemuDomainStorageSourceAccessModify(driver, vm, src, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceChainDetach",
          "args": [
            "qemuDomainGetMonitor(vm)",
            "data"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceChainDetach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1929-1937",
          "snippet": "void\nqemuBlockStorageSourceChainDetach(qemuMonitorPtr mon,\n                                  qemuBlockStorageSourceChainDataPtr data)\n{\n    size_t i;\n\n    for (i = 0; i < data->nsrcdata; i++)\n        qemuBlockStorageSourceAttachRollback(mon, data->srcdata[i]);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nvoid\nqemuBlockStorageSourceChainDetach(qemuMonitorPtr mon,\n                                  qemuBlockStorageSourceChainDataPtr data)\n{\n    size_t i;\n\n    for (i = 0; i < data->nsrcdata; i++)\n        qemuBlockStorageSourceAttachRollback(mon, data->srcdata[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainGetMonitor",
          "args": [
            "vm"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainGetMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "12703-12707",
          "snippet": "qemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nqemuMonitorPtr\nqemuDomainGetMonitor(virDomainObjPtr vm)\n{\n    return ((qemuDomainObjPrivatePtr) vm->privateData)->mon;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitorAsync",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitorAsync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10216-10222",
          "snippet": "int\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "qemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nqemuDomainJobTypeToString(job),\n              qemuDomainAgentJobTypeToString(agentJob),\n              qemuDomainAsyncJobTypeToString(asyncJob),\n              obj, obj->def->name,\n              qemuDomainJobTypeToString(priv->job.active),\n              qemuDomainAgentJobTypeToString(priv->job.agentActive),\n              qemuDomainAsyncJobTypeToString(priv->job.asyncJob));\n\nint\nqemuDomainObjEnterMonitorAsync(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj,\n                               qemuDomainAsyncJob asyncJob)\n{\n    return qemuDomainObjEnterMonitorInternal(driver, obj, asyncJob);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockStorageSourceChainDetachPrepareBlockdev",
          "args": [
            "chain"
          ],
          "line": 844
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockStorageSourceChainDetachPrepareBlockdev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "1846-1865",
          "snippet": "qemuBlockStorageSourceChainDataPtr\nqemuBlockStorageSourceChainDetachPrepareBlockdev(virStorageSourcePtr src)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) backend = NULL;\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n    virStorageSourcePtr n;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (!(backend = qemuBlockStorageSourceDetachPrepare(n, NULL)))\n            return NULL;\n\n        if (VIR_APPEND_ELEMENT(data->srcdata, data->nsrcdata, backend) < 0)\n            return NULL;\n    }\n\n    return g_steal_pointer(&data);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nqemuBlockStorageSourceChainDataPtr\nqemuBlockStorageSourceChainDetachPrepareBlockdev(virStorageSourcePtr src)\n{\n    g_autoptr(qemuBlockStorageSourceAttachData) backend = NULL;\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n    virStorageSourcePtr n;\n\n    if (VIR_ALLOC(data) < 0)\n        return NULL;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (!(backend = qemuBlockStorageSourceDetachPrepare(n, NULL)))\n            return NULL;\n\n        if (VIR_APPEND_ELEMENT(data->srcdata, data->nsrcdata, backend) < 0)\n            return NULL;\n    }\n\n    return g_steal_pointer(&data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessConcludedRemoveChain(virQEMUDriverPtr driver,\n                                             virDomainObjPtr vm,\n                                             qemuDomainAsyncJob asyncJob,\n                                             virStorageSourcePtr chain)\n{\n    g_autoptr(qemuBlockStorageSourceChainData) data = NULL;\n\n    if (!(data = qemuBlockStorageSourceChainDetachPrepareBlockdev(chain)))\n        return;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return;\n\n    qemuBlockStorageSourceChainDetach(qemuDomainGetMonitor(vm), data);\n    if (qemuDomainObjExitMonitor(driver, vm) < 0)\n        return;\n\n    qemuDomainStorageSourceChainAccessRevoke(driver, vm, chain);\n}"
  },
  {
    "function_name": "qemuBlockJobEventProcessLegacy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "777-833",
    "snippet": "static void\nqemuBlockJobEventProcessLegacy(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               qemuBlockJobDataPtr job,\n                               int asyncJob)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    VIR_DEBUG(\"disk=%s, mirrorState=%s, type=%d, state=%d, newstate=%d\",\n              disk->dst,\n              NULLSTR(virDomainDiskMirrorStateTypeToString(disk->mirrorState)),\n              job->type,\n              job->state,\n              job->newstate);\n\n    if (job->newstate == -1)\n        return;\n\n    qemuBlockJobEmitEvents(driver, vm, disk, job->type, job->newstate);\n\n    job->state = job->newstate;\n    job->newstate = -1;\n\n    /* If we completed a block pull or commit, then update the XML\n     * to match.  */\n    switch ((virConnectDomainEventBlockJobStatus) job->state) {\n    case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n        qemuBlockJobEventProcessLegacyCompleted(driver, vm, job, asyncJob);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_READY:\n        disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_READY;\n        qemuDomainSaveStatus(vm);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_FAILED:\n    case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        if (disk->mirror) {\n            virDomainLockImageDetach(driver->lockManager, vm, disk->mirror);\n\n            /* Ideally, we would restore seclabels on the backing chain here\n             * but we don't know if somebody else is not using parts of it.\n             * Remove security driver metadata so that they are not leaked. */\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            virObjectUnref(disk->mirror);\n            disk->mirror = NULL;\n        }\n        disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_NONE;\n        disk->mirrorJob = VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN;\n        qemuBlockJobUnregister(job, vm);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_LAST:\n        break;\n    }\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBlockJobUnregister",
          "args": [
            "job",
            "vm"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobUnregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "201-223",
          "snippet": "static void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "disk->mirror"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockRemoveImageMetadata",
          "args": [
            "driver",
            "vm",
            "disk->dst",
            "disk->mirror"
          ],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockRemoveImageMetadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "2749-2770",
          "snippet": "int\nqemuBlockRemoveImageMetadata(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *diskTarget,\n                             virStorageSourcePtr src)\n{\n    virStorageSourcePtr n;\n    int ret = 0;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (qemuSecurityMoveImageMetadata(driver, vm, n, NULL) < 0) {\n            VIR_WARN(\"Unable to remove disk metadata on \"\n                     \"vm %s from %s (disk target %s)\",\n                     vm->def->name,\n                     NULLSTR(n->path),\n                     diskTarget);\n            ret = -1;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockRemoveImageMetadata(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *diskTarget,\n                             virStorageSourcePtr src)\n{\n    virStorageSourcePtr n;\n    int ret = 0;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (qemuSecurityMoveImageMetadata(driver, vm, n, NULL) < 0) {\n            VIR_WARN(\"Unable to remove disk metadata on \"\n                     \"vm %s from %s (disk target %s)\",\n                     vm->def->name,\n                     NULLSTR(n->path),\n                     diskTarget);\n            ret = -1;\n        }\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainLockImageDetach",
          "args": [
            "driver->lockManager",
            "vm",
            "disk->mirror"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainLockImageDetach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/domain_lock.c",
          "lines": "284-308",
          "snippet": "int virDomainLockImageDetach(virLockManagerPluginPtr plugin,\n                             virDomainObjPtr dom,\n                             virStorageSourcePtr src)\n{\n    virLockManagerPtr lock;\n    int ret = -1;\n\n    VIR_DEBUG(\"plugin=%p dom=%p src=%p\", plugin, dom, src);\n\n    if (!(lock = virDomainLockManagerNew(plugin, NULL, dom, false, 0)))\n        return -1;\n\n    if (virDomainLockManagerAddImage(lock, src) < 0)\n        goto cleanup;\n\n    if (virLockManagerRelease(lock, NULL, 0) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virLockManagerFree(lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_lock.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"domain_lock.h\"\n#include <config.h>\n\nint virDomainLockImageDetach(virLockManagerPluginPtr plugin,\n                             virDomainObjPtr dom,\n                             virStorageSourcePtr src)\n{\n    virLockManagerPtr lock;\n    int ret = -1;\n\n    VIR_DEBUG(\"plugin=%p dom=%p src=%p\", plugin, dom, src);\n\n    if (!(lock = virDomainLockManagerNew(plugin, NULL, dom, false, 0)))\n        return -1;\n\n    if (virDomainLockManagerAddImage(lock, src) < 0)\n        goto cleanup;\n\n    if (virLockManagerRelease(lock, NULL, 0) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virLockManagerFree(lock);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainSaveStatus",
          "args": [
            "vm"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9569-9573",
          "snippet": "void\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEventProcessLegacyCompleted",
          "args": [
            "driver",
            "vm",
            "job",
            "asyncJob"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEventProcessLegacyCompleted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "704-764",
          "snippet": "static void\nqemuBlockJobEventProcessLegacyCompleted(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        int asyncJob)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    if (!disk)\n        return;\n\n    if (disk->mirrorState == VIR_DOMAIN_DISK_MIRROR_STATE_PIVOT) {\n        qemuBlockJobRewriteConfigDiskSource(vm, disk, disk->mirror);\n        /* XXX We want to revoke security labels as well as audit that\n         * revocation, before dropping the original source.  But it gets\n         * tricky if both source and mirror share common backing files (we\n         * want to only revoke the non-shared portion of the chain); so for\n         * now, we leak the access to the original.  */\n        virDomainLockImageDetach(driver->lockManager, vm, disk->src);\n\n        /* Move secret driver metadata */\n        if (qemuSecurityMoveImageMetadata(driver, vm, disk->src, disk->mirror) < 0) {\n            VIR_WARN(\"Unable to move disk metadata on \"\n                     \"vm %s from %s to %s (disk target %s)\",\n                     vm->def->name,\n                     NULLSTR(disk->src->path),\n                     NULLSTR(disk->mirror->path),\n                     disk->dst);\n        }\n\n        virObjectUnref(disk->src);\n        disk->src = disk->mirror;\n    } else {\n        if (disk->mirror) {\n            virDomainLockImageDetach(driver->lockManager, vm, disk->mirror);\n\n            /* Ideally, we would restore seclabels on the backing chain here\n             * but we don't know if somebody else is not using parts of it.\n             * Remove security driver metadata so that they are not leaked. */\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            virObjectUnref(disk->mirror);\n        }\n\n        qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n    }\n\n    /* Recompute the cached backing chain to match our\n     * updates.  Better would be storing the chain ourselves\n     * rather than reprobing, but we haven't quite completed\n     * that conversion to use our XML tracking. */\n    disk->mirror = NULL;\n    disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_NONE;\n    disk->mirrorJob = VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN;\n    disk->src->id = 0;\n    virStorageSourceBackingStoreClear(disk->src);\n    ignore_value(qemuDomainDetermineDiskChain(driver, vm, disk, NULL, true));\n    ignore_value(qemuBlockNodeNamesDetect(driver, vm, asyncJob));\n    qemuBlockJobUnregister(job, vm);\n    qemuDomainSaveConfig(vm);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessLegacyCompleted(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        int asyncJob)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    if (!disk)\n        return;\n\n    if (disk->mirrorState == VIR_DOMAIN_DISK_MIRROR_STATE_PIVOT) {\n        qemuBlockJobRewriteConfigDiskSource(vm, disk, disk->mirror);\n        /* XXX We want to revoke security labels as well as audit that\n         * revocation, before dropping the original source.  But it gets\n         * tricky if both source and mirror share common backing files (we\n         * want to only revoke the non-shared portion of the chain); so for\n         * now, we leak the access to the original.  */\n        virDomainLockImageDetach(driver->lockManager, vm, disk->src);\n\n        /* Move secret driver metadata */\n        if (qemuSecurityMoveImageMetadata(driver, vm, disk->src, disk->mirror) < 0) {\n            VIR_WARN(\"Unable to move disk metadata on \"\n                     \"vm %s from %s to %s (disk target %s)\",\n                     vm->def->name,\n                     NULLSTR(disk->src->path),\n                     NULLSTR(disk->mirror->path),\n                     disk->dst);\n        }\n\n        virObjectUnref(disk->src);\n        disk->src = disk->mirror;\n    } else {\n        if (disk->mirror) {\n            virDomainLockImageDetach(driver->lockManager, vm, disk->mirror);\n\n            /* Ideally, we would restore seclabels on the backing chain here\n             * but we don't know if somebody else is not using parts of it.\n             * Remove security driver metadata so that they are not leaked. */\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            virObjectUnref(disk->mirror);\n        }\n\n        qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n    }\n\n    /* Recompute the cached backing chain to match our\n     * updates.  Better would be storing the chain ourselves\n     * rather than reprobing, but we haven't quite completed\n     * that conversion to use our XML tracking. */\n    disk->mirror = NULL;\n    disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_NONE;\n    disk->mirrorJob = VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN;\n    disk->src->id = 0;\n    virStorageSourceBackingStoreClear(disk->src);\n    ignore_value(qemuDomainDetermineDiskChain(driver, vm, disk, NULL, true));\n    ignore_value(qemuBlockNodeNamesDetect(driver, vm, asyncJob));\n    qemuBlockJobUnregister(job, vm);\n    qemuDomainSaveConfig(vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobEmitEvents",
          "args": [
            "driver",
            "vm",
            "disk",
            "job->type",
            "job->newstate"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobEmitEvents",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "600-628",
          "snippet": "static void\nqemuBlockJobEmitEvents(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       virDomainDiskDefPtr disk,\n                       virDomainBlockJobType type,\n                       virConnectDomainEventBlockJobStatus status)\n{\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr event2 = NULL;\n\n    /* don't emit events for jobs without disk */\n    if (!disk)\n        return;\n\n    /* don't emit events for internal jobs and states */\n    if (type >= VIR_DOMAIN_BLOCK_JOB_TYPE_LAST ||\n        status >= VIR_DOMAIN_BLOCK_JOB_LAST)\n        return;\n\n    if (virStorageSourceIsLocalStorage(disk->src) &&\n        !virStorageSourceIsEmpty(disk->src)) {\n        event = virDomainEventBlockJobNewFromObj(vm, virDomainDiskGetSource(disk),\n                                                 type, status);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    event2 = virDomainEventBlockJob2NewFromObj(vm, disk->dst, type, status);\n    virObjectEventStateQueue(driver->domainEventState, event2);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEmitEvents(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       virDomainDiskDefPtr disk,\n                       virDomainBlockJobType type,\n                       virConnectDomainEventBlockJobStatus status)\n{\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr event2 = NULL;\n\n    /* don't emit events for jobs without disk */\n    if (!disk)\n        return;\n\n    /* don't emit events for internal jobs and states */\n    if (type >= VIR_DOMAIN_BLOCK_JOB_TYPE_LAST ||\n        status >= VIR_DOMAIN_BLOCK_JOB_LAST)\n        return;\n\n    if (virStorageSourceIsLocalStorage(disk->src) &&\n        !virStorageSourceIsEmpty(disk->src)) {\n        event = virDomainEventBlockJobNewFromObj(vm, virDomainDiskGetSource(disk),\n                                                 type, status);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    event2 = virDomainEventBlockJob2NewFromObj(vm, disk->dst, type, status);\n    virObjectEventStateQueue(driver->domainEventState, event2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"disk=%s, mirrorState=%s, type=%d, state=%d, newstate=%d\"",
            "disk->dst",
            "NULLSTR(virDomainDiskMirrorStateTypeToString(disk->mirrorState))",
            "job->type",
            "job->state",
            "job->newstate"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "virDomainDiskMirrorStateTypeToString(disk->mirrorState)"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virDomainDiskMirrorStateTypeToString",
          "args": [
            "disk->mirrorState"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessLegacy(virQEMUDriverPtr driver,\n                               virDomainObjPtr vm,\n                               qemuBlockJobDataPtr job,\n                               int asyncJob)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    VIR_DEBUG(\"disk=%s, mirrorState=%s, type=%d, state=%d, newstate=%d\",\n              disk->dst,\n              NULLSTR(virDomainDiskMirrorStateTypeToString(disk->mirrorState)),\n              job->type,\n              job->state,\n              job->newstate);\n\n    if (job->newstate == -1)\n        return;\n\n    qemuBlockJobEmitEvents(driver, vm, disk, job->type, job->newstate);\n\n    job->state = job->newstate;\n    job->newstate = -1;\n\n    /* If we completed a block pull or commit, then update the XML\n     * to match.  */\n    switch ((virConnectDomainEventBlockJobStatus) job->state) {\n    case VIR_DOMAIN_BLOCK_JOB_COMPLETED:\n        qemuBlockJobEventProcessLegacyCompleted(driver, vm, job, asyncJob);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_READY:\n        disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_READY;\n        qemuDomainSaveStatus(vm);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_FAILED:\n    case VIR_DOMAIN_BLOCK_JOB_CANCELED:\n        if (disk->mirror) {\n            virDomainLockImageDetach(driver->lockManager, vm, disk->mirror);\n\n            /* Ideally, we would restore seclabels on the backing chain here\n             * but we don't know if somebody else is not using parts of it.\n             * Remove security driver metadata so that they are not leaked. */\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            virObjectUnref(disk->mirror);\n            disk->mirror = NULL;\n        }\n        disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_NONE;\n        disk->mirrorJob = VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN;\n        qemuBlockJobUnregister(job, vm);\n        break;\n\n    case VIR_DOMAIN_BLOCK_JOB_LAST:\n        break;\n    }\n}"
  },
  {
    "function_name": "qemuBlockJobEventProcessLegacyCompleted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "704-764",
    "snippet": "static void\nqemuBlockJobEventProcessLegacyCompleted(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        int asyncJob)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    if (!disk)\n        return;\n\n    if (disk->mirrorState == VIR_DOMAIN_DISK_MIRROR_STATE_PIVOT) {\n        qemuBlockJobRewriteConfigDiskSource(vm, disk, disk->mirror);\n        /* XXX We want to revoke security labels as well as audit that\n         * revocation, before dropping the original source.  But it gets\n         * tricky if both source and mirror share common backing files (we\n         * want to only revoke the non-shared portion of the chain); so for\n         * now, we leak the access to the original.  */\n        virDomainLockImageDetach(driver->lockManager, vm, disk->src);\n\n        /* Move secret driver metadata */\n        if (qemuSecurityMoveImageMetadata(driver, vm, disk->src, disk->mirror) < 0) {\n            VIR_WARN(\"Unable to move disk metadata on \"\n                     \"vm %s from %s to %s (disk target %s)\",\n                     vm->def->name,\n                     NULLSTR(disk->src->path),\n                     NULLSTR(disk->mirror->path),\n                     disk->dst);\n        }\n\n        virObjectUnref(disk->src);\n        disk->src = disk->mirror;\n    } else {\n        if (disk->mirror) {\n            virDomainLockImageDetach(driver->lockManager, vm, disk->mirror);\n\n            /* Ideally, we would restore seclabels on the backing chain here\n             * but we don't know if somebody else is not using parts of it.\n             * Remove security driver metadata so that they are not leaked. */\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            virObjectUnref(disk->mirror);\n        }\n\n        qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n    }\n\n    /* Recompute the cached backing chain to match our\n     * updates.  Better would be storing the chain ourselves\n     * rather than reprobing, but we haven't quite completed\n     * that conversion to use our XML tracking. */\n    disk->mirror = NULL;\n    disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_NONE;\n    disk->mirrorJob = VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN;\n    disk->src->id = 0;\n    virStorageSourceBackingStoreClear(disk->src);\n    ignore_value(qemuDomainDetermineDiskChain(driver, vm, disk, NULL, true));\n    ignore_value(qemuBlockNodeNamesDetect(driver, vm, asyncJob));\n    qemuBlockJobUnregister(job, vm);\n    qemuDomainSaveConfig(vm);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainSaveConfig",
          "args": [
            "vm"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainSaveConfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9576-9595",
          "snippet": "void\nqemuDomainSaveConfig(virDomainObjPtr obj)\n{\n    virQEMUDriverPtr driver = QEMU_DOMAIN_PRIVATE(obj)->driver;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    virDomainDefPtr def = NULL;\n\n    if (virDomainObjIsActive(obj))\n        def = obj->newDef;\n    else\n        def = obj->def;\n\n    if (!def)\n        return;\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (virDomainDefSave(def, driver->xmlopt, cfg->configDir) < 0)\n        VIR_WARN(\"Failed to save config of vm %s\", obj->def->name);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);",
            "obj, obj->def->name);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\nobj, obj->def->name);\n\nvoid\nqemuDomainSaveConfig(virDomainObjPtr obj)\n{\n    virQEMUDriverPtr driver = QEMU_DOMAIN_PRIVATE(obj)->driver;\n    g_autoptr(virQEMUDriverConfig) cfg = NULL;\n    virDomainDefPtr def = NULL;\n\n    if (virDomainObjIsActive(obj))\n        def = obj->newDef;\n    else\n        def = obj->def;\n\n    if (!def)\n        return;\n\n    cfg = virQEMUDriverGetConfig(driver);\n\n    if (virDomainDefSave(def, driver->xmlopt, cfg->configDir) < 0)\n        VIR_WARN(\"Failed to save config of vm %s\", obj->def->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobUnregister",
          "args": [
            "job",
            "vm"
          ],
          "line": 762
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobUnregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "201-223",
          "snippet": "static void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuBlockNodeNamesDetect(driver, vm, asyncJob)"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockNodeNamesDetect",
          "args": [
            "driver",
            "vm",
            "asyncJob"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockNodeNamesDetect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "322-357",
          "snippet": "int\nqemuBlockNodeNamesDetect(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virHashTable) disktable = NULL;\n    g_autoptr(virJSONValue) data = NULL;\n    g_autoptr(virJSONValue) blockstats = NULL;\n    virDomainDiskDefPtr disk;\n    size_t i;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QUERY_NAMED_BLOCK_NODES))\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    data = qemuMonitorQueryNamedBlockNodes(qemuDomainGetMonitor(vm));\n    blockstats = qemuMonitorQueryBlockstats(qemuDomainGetMonitor(vm));\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !data || !blockstats)\n        return -1;\n\n    if (!(disktable = qemuBlockNodeNameGetBackingChain(data, blockstats)))\n        return -1;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        disk = vm->def->disks[i];\n\n        if (qemuBlockDiskDetectNodes(disk, disktable) < 0)\n            return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockNodeNamesDetect(virQEMUDriverPtr driver,\n                         virDomainObjPtr vm,\n                         qemuDomainAsyncJob asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(virHashTable) disktable = NULL;\n    g_autoptr(virJSONValue) data = NULL;\n    g_autoptr(virJSONValue) blockstats = NULL;\n    virDomainDiskDefPtr disk;\n    size_t i;\n\n    if (!virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_QUERY_NAMED_BLOCK_NODES))\n        return 0;\n\n    if (qemuDomainObjEnterMonitorAsync(driver, vm, asyncJob) < 0)\n        return -1;\n\n    data = qemuMonitorQueryNamedBlockNodes(qemuDomainGetMonitor(vm));\n    blockstats = qemuMonitorQueryBlockstats(qemuDomainGetMonitor(vm));\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || !data || !blockstats)\n        return -1;\n\n    if (!(disktable = qemuBlockNodeNameGetBackingChain(data, blockstats)))\n        return -1;\n\n    for (i = 0; i < vm->def->ndisks; i++) {\n        disk = vm->def->disks[i];\n\n        if (qemuBlockDiskDetectNodes(disk, disktable) < 0)\n            return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_value",
          "args": [
            "qemuDomainDetermineDiskChain(driver, vm, disk, NULL, true)"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuDomainDetermineDiskChain",
          "args": [
            "driver",
            "vm",
            "disk",
            "NULL",
            "true"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainDetermineDiskChain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "11685-11793",
          "snippet": "int\nqemuDomainDetermineDiskChain(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainDiskDefPtr disk,\n                             virStorageSourcePtr disksrc,\n                             bool report_broken)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    virStorageSourcePtr src; /* iterator for the backing chain declared in XML */\n    virStorageSourcePtr n; /* iterator for the backing chain detected from disk */\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    uid_t uid;\n    gid_t gid;\n\n    if (!disksrc)\n        disksrc = disk->src;\n\n    if (virStorageSourceIsEmpty(disksrc))\n        return 0;\n\n    /* There is no need to check the backing chain for disks without backing\n     * support */\n    if (virStorageSourceIsLocalStorage(disksrc) &&\n        disksrc->format > VIR_STORAGE_FILE_NONE &&\n        disksrc->format < VIR_STORAGE_FILE_BACKING) {\n\n        if (!virFileExists(disksrc->path)) {\n            if (report_broken)\n                virStorageFileReportBrokenChain(errno, disksrc, disksrc);\n\n            return -1;\n        }\n\n        /* terminate the chain for such images as the code below would do */\n        if (!disksrc->backingStore &&\n            !(disksrc->backingStore = virStorageSourceNew()))\n            return -1;\n\n        /* host cdrom requires special treatment in qemu, so we need to check\n         * whether a block device is a cdrom */\n        if (disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM &&\n            disksrc->format == VIR_STORAGE_FILE_RAW &&\n            virStorageSourceIsBlockLocal(disksrc) &&\n            virFileIsCDROM(disksrc->path) == 1)\n            disksrc->hostcdrom = true;\n\n        return 0;\n    }\n\n    src = disksrc;\n    /* skip to the end of the chain if there is any */\n    while (virStorageSourceHasBacking(src)) {\n        if (report_broken) {\n            int rv = virStorageFileSupportsAccess(src);\n\n            if (rv < 0)\n                return -1;\n\n            if (rv > 0) {\n                if (qemuDomainStorageFileInit(driver, vm, src, disksrc) < 0)\n                    return -1;\n\n                if (virStorageFileAccess(src, F_OK) < 0) {\n                    virStorageFileReportBrokenChain(errno, src, disksrc);\n                    virStorageFileDeinit(src);\n                    return -1;\n                }\n\n                virStorageFileDeinit(src);\n            }\n        }\n        src = src->backingStore;\n    }\n\n    /* We skipped to the end of the chain. Skip detection if there's the\n     * terminator. (An allocated but empty backingStore) */\n    if (src->backingStore) {\n        if (qemuDomainStorageSourceValidateDepth(disksrc, 0, disk->dst) < 0)\n            return -1;\n\n        return 0;\n    }\n\n    qemuDomainGetImageIds(cfg, vm, src, disksrc, &uid, &gid);\n\n    if (virStorageFileGetMetadata(src, uid, gid, report_broken) < 0)\n        return -1;\n\n    for (n = src->backingStore; virStorageSourceIsBacking(n); n = n->backingStore) {\n        /* convert detected ISO format to 'raw' as qemu would not understand it */\n        if (n->format == VIR_STORAGE_FILE_ISO)\n            n->format = VIR_STORAGE_FILE_RAW;\n\n        if (qemuDomainValidateStorageSource(n, priv->qemuCaps) < 0)\n            return -1;\n\n        qemuDomainPrepareStorageSourceConfig(n, cfg, priv->qemuCaps);\n        qemuDomainPrepareDiskSourceData(disk, n);\n\n        if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV) &&\n            qemuDomainPrepareStorageSourceBlockdev(disk, n, priv, cfg) < 0)\n            return -1;\n    }\n\n    if (qemuDomainStorageSourceValidateDepth(disksrc, 0, disk->dst) < 0)\n        return -1;\n\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuDomainDetermineDiskChain(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             virDomainDiskDefPtr disk,\n                             virStorageSourcePtr disksrc,\n                             bool report_broken)\n{\n    g_autoptr(virQEMUDriverConfig) cfg = virQEMUDriverGetConfig(driver);\n    virStorageSourcePtr src; /* iterator for the backing chain declared in XML */\n    virStorageSourcePtr n; /* iterator for the backing chain detected from disk */\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    uid_t uid;\n    gid_t gid;\n\n    if (!disksrc)\n        disksrc = disk->src;\n\n    if (virStorageSourceIsEmpty(disksrc))\n        return 0;\n\n    /* There is no need to check the backing chain for disks without backing\n     * support */\n    if (virStorageSourceIsLocalStorage(disksrc) &&\n        disksrc->format > VIR_STORAGE_FILE_NONE &&\n        disksrc->format < VIR_STORAGE_FILE_BACKING) {\n\n        if (!virFileExists(disksrc->path)) {\n            if (report_broken)\n                virStorageFileReportBrokenChain(errno, disksrc, disksrc);\n\n            return -1;\n        }\n\n        /* terminate the chain for such images as the code below would do */\n        if (!disksrc->backingStore &&\n            !(disksrc->backingStore = virStorageSourceNew()))\n            return -1;\n\n        /* host cdrom requires special treatment in qemu, so we need to check\n         * whether a block device is a cdrom */\n        if (disk->device == VIR_DOMAIN_DISK_DEVICE_CDROM &&\n            disksrc->format == VIR_STORAGE_FILE_RAW &&\n            virStorageSourceIsBlockLocal(disksrc) &&\n            virFileIsCDROM(disksrc->path) == 1)\n            disksrc->hostcdrom = true;\n\n        return 0;\n    }\n\n    src = disksrc;\n    /* skip to the end of the chain if there is any */\n    while (virStorageSourceHasBacking(src)) {\n        if (report_broken) {\n            int rv = virStorageFileSupportsAccess(src);\n\n            if (rv < 0)\n                return -1;\n\n            if (rv > 0) {\n                if (qemuDomainStorageFileInit(driver, vm, src, disksrc) < 0)\n                    return -1;\n\n                if (virStorageFileAccess(src, F_OK) < 0) {\n                    virStorageFileReportBrokenChain(errno, src, disksrc);\n                    virStorageFileDeinit(src);\n                    return -1;\n                }\n\n                virStorageFileDeinit(src);\n            }\n        }\n        src = src->backingStore;\n    }\n\n    /* We skipped to the end of the chain. Skip detection if there's the\n     * terminator. (An allocated but empty backingStore) */\n    if (src->backingStore) {\n        if (qemuDomainStorageSourceValidateDepth(disksrc, 0, disk->dst) < 0)\n            return -1;\n\n        return 0;\n    }\n\n    qemuDomainGetImageIds(cfg, vm, src, disksrc, &uid, &gid);\n\n    if (virStorageFileGetMetadata(src, uid, gid, report_broken) < 0)\n        return -1;\n\n    for (n = src->backingStore; virStorageSourceIsBacking(n); n = n->backingStore) {\n        /* convert detected ISO format to 'raw' as qemu would not understand it */\n        if (n->format == VIR_STORAGE_FILE_ISO)\n            n->format = VIR_STORAGE_FILE_RAW;\n\n        if (qemuDomainValidateStorageSource(n, priv->qemuCaps) < 0)\n            return -1;\n\n        qemuDomainPrepareStorageSourceConfig(n, cfg, priv->qemuCaps);\n        qemuDomainPrepareDiskSourceData(disk, n);\n\n        if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV) &&\n            qemuDomainPrepareStorageSourceBlockdev(disk, n, priv, cfg) < 0)\n            return -1;\n    }\n\n    if (qemuDomainStorageSourceValidateDepth(disksrc, 0, disk->dst) < 0)\n        return -1;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceBackingStoreClear",
          "args": [
            "disk->src"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceBackingStoreClear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2657-2669",
          "snippet": "void\nvirStorageSourceBackingStoreClear(virStorageSourcePtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->relPath);\n    VIR_FREE(def->backingStoreRaw);\n\n    /* recursively free backing chain */\n    virObjectUnref(def->backingStore);\n    def->backingStore = NULL;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvoid\nvirStorageSourceBackingStoreClear(virStorageSourcePtr def)\n{\n    if (!def)\n        return;\n\n    VIR_FREE(def->relPath);\n    VIR_FREE(def->backingStoreRaw);\n\n    /* recursively free backing chain */\n    virObjectUnref(def->backingStore);\n    def->backingStore = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockRemoveImageMetadata",
          "args": [
            "driver",
            "vm",
            "disk->dst",
            "disk->src"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockRemoveImageMetadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_block.c",
          "lines": "2749-2770",
          "snippet": "int\nqemuBlockRemoveImageMetadata(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *diskTarget,\n                             virStorageSourcePtr src)\n{\n    virStorageSourcePtr n;\n    int ret = 0;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (qemuSecurityMoveImageMetadata(driver, vm, n, NULL) < 0) {\n            VIR_WARN(\"Unable to remove disk metadata on \"\n                     \"vm %s from %s (disk target %s)\",\n                     vm->def->name,\n                     NULLSTR(n->path),\n                     diskTarget);\n            ret = -1;\n        }\n    }\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_block.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"qemu_security.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_command.h\"\n#include \"qemu_block.h\"\n#include <config.h>\n\nint\nqemuBlockRemoveImageMetadata(virQEMUDriverPtr driver,\n                             virDomainObjPtr vm,\n                             const char *diskTarget,\n                             virStorageSourcePtr src)\n{\n    virStorageSourcePtr n;\n    int ret = 0;\n\n    for (n = src; virStorageSourceIsBacking(n); n = n->backingStore) {\n        if (qemuSecurityMoveImageMetadata(driver, vm, n, NULL) < 0) {\n            VIR_WARN(\"Unable to remove disk metadata on \"\n                     \"vm %s from %s (disk target %s)\",\n                     vm->def->name,\n                     NULLSTR(n->path),\n                     diskTarget);\n            ret = -1;\n        }\n    }\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "disk->mirror"
          ],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainLockImageDetach",
          "args": [
            "driver->lockManager",
            "vm",
            "disk->mirror"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainLockImageDetach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/locking/domain_lock.c",
          "lines": "284-308",
          "snippet": "int virDomainLockImageDetach(virLockManagerPluginPtr plugin,\n                             virDomainObjPtr dom,\n                             virStorageSourcePtr src)\n{\n    virLockManagerPtr lock;\n    int ret = -1;\n\n    VIR_DEBUG(\"plugin=%p dom=%p src=%p\", plugin, dom, src);\n\n    if (!(lock = virDomainLockManagerNew(plugin, NULL, dom, false, 0)))\n        return -1;\n\n    if (virDomainLockManagerAddImage(lock, src) < 0)\n        goto cleanup;\n\n    if (virLockManagerRelease(lock, NULL, 0) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virLockManagerFree(lock);\n\n    return ret;\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"viralloc.h\"",
            "#include \"domain_lock.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"viralloc.h\"\n#include \"domain_lock.h\"\n#include <config.h>\n\nint virDomainLockImageDetach(virLockManagerPluginPtr plugin,\n                             virDomainObjPtr dom,\n                             virStorageSourcePtr src)\n{\n    virLockManagerPtr lock;\n    int ret = -1;\n\n    VIR_DEBUG(\"plugin=%p dom=%p src=%p\", plugin, dom, src);\n\n    if (!(lock = virDomainLockManagerNew(plugin, NULL, dom, false, 0)))\n        return -1;\n\n    if (virDomainLockManagerAddImage(lock, src) < 0)\n        goto cleanup;\n\n    if (virLockManagerRelease(lock, NULL, 0) < 0)\n        goto cleanup;\n\n    ret = 0;\n\n cleanup:\n    virLockManagerFree(lock);\n\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to move disk metadata on \"\n                     \"vm %s from %s to %s (disk target %s)\"",
            "vm->def->name",
            "NULLSTR(disk->src->path)",
            "NULLSTR(disk->mirror->path)",
            "disk->dst"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "disk->mirror->path"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "NULLSTR",
          "args": [
            "disk->src->path"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuSecurityMoveImageMetadata",
          "args": [
            "driver",
            "vm",
            "disk->src",
            "disk->mirror"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "qemuSecurityMoveImageMetadata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_security.c",
          "lines": "171-187",
          "snippet": "int\nqemuSecurityMoveImageMetadata(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virStorageSourcePtr src,\n                              virStorageSourcePtr dst)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    pid_t pid = -1;\n\n    if (!priv->rememberOwner)\n        return 0;\n\n    if (qemuDomainNamespaceEnabled(vm, QEMU_DOMAIN_NS_MOUNT))\n        pid = vm->pid;\n\n    return virSecurityManagerMoveImageMetadata(driver->securityManager, pid, src, dst);\n}",
          "includes": [
            "#include \"virlog.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virlog.h\"\n#include \"qemu_security.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nint\nqemuSecurityMoveImageMetadata(virQEMUDriverPtr driver,\n                              virDomainObjPtr vm,\n                              virStorageSourcePtr src,\n                              virStorageSourcePtr dst)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    pid_t pid = -1;\n\n    if (!priv->rememberOwner)\n        return 0;\n\n    if (qemuDomainNamespaceEnabled(vm, QEMU_DOMAIN_NS_MOUNT))\n        pid = vm->pid;\n\n    return virSecurityManagerMoveImageMetadata(driver->securityManager, pid, src, dst);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobRewriteConfigDiskSource",
          "args": [
            "vm",
            "disk",
            "disk->mirror"
          ],
          "line": 716
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobRewriteConfigDiskSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "662-701",
          "snippet": "static void\nqemuBlockJobRewriteConfigDiskSource(virDomainObjPtr vm,\n                                    virDomainDiskDefPtr disk,\n                                    virStorageSourcePtr newsrc)\n{\n    virDomainDiskDefPtr persistDisk = NULL;\n    g_autoptr(virStorageSource) copy = NULL;\n    virStorageSourcePtr n;\n\n    if (!vm->newDef)\n        return;\n\n    if (!(persistDisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, persistDisk->src))\n        return;\n\n    if (!(copy = virStorageSourceCopy(newsrc, true)) ||\n        virStorageSourceInitChainElement(copy, persistDisk->src, true) < 0) {\n        VIR_WARN(\"Unable to update persistent definition on vm %s after block job\",\n                 vm->def->name);\n        return;\n    }\n\n    for (n = copy; virStorageSourceIsBacking(n); n = n->backingStore) {\n        qemuBlockJobCleanStorageSourceRuntime(n);\n\n        /* discard any detected backing store */\n        if (virStorageSourceIsBacking(n->backingStore) &&\n            n->backingStore->detected) {\n            virObjectUnref(n->backingStore);\n            n->backingStore = NULL;\n            break;\n        }\n    }\n\n    virObjectUnref(persistDisk->src);\n    persistDisk->src = g_steal_pointer(&copy);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobRewriteConfigDiskSource(virDomainObjPtr vm,\n                                    virDomainDiskDefPtr disk,\n                                    virStorageSourcePtr newsrc)\n{\n    virDomainDiskDefPtr persistDisk = NULL;\n    g_autoptr(virStorageSource) copy = NULL;\n    virStorageSourcePtr n;\n\n    if (!vm->newDef)\n        return;\n\n    if (!(persistDisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, persistDisk->src))\n        return;\n\n    if (!(copy = virStorageSourceCopy(newsrc, true)) ||\n        virStorageSourceInitChainElement(copy, persistDisk->src, true) < 0) {\n        VIR_WARN(\"Unable to update persistent definition on vm %s after block job\",\n                 vm->def->name);\n        return;\n    }\n\n    for (n = copy; virStorageSourceIsBacking(n); n = n->backingStore) {\n        qemuBlockJobCleanStorageSourceRuntime(n);\n\n        /* discard any detected backing store */\n        if (virStorageSourceIsBacking(n->backingStore) &&\n            n->backingStore->detected) {\n            virObjectUnref(n->backingStore);\n            n->backingStore = NULL;\n            break;\n        }\n    }\n\n    virObjectUnref(persistDisk->src);\n    persistDisk->src = g_steal_pointer(&copy);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEventProcessLegacyCompleted(virQEMUDriverPtr driver,\n                                        virDomainObjPtr vm,\n                                        qemuBlockJobDataPtr job,\n                                        int asyncJob)\n{\n    virDomainDiskDefPtr disk = job->disk;\n\n    if (!disk)\n        return;\n\n    if (disk->mirrorState == VIR_DOMAIN_DISK_MIRROR_STATE_PIVOT) {\n        qemuBlockJobRewriteConfigDiskSource(vm, disk, disk->mirror);\n        /* XXX We want to revoke security labels as well as audit that\n         * revocation, before dropping the original source.  But it gets\n         * tricky if both source and mirror share common backing files (we\n         * want to only revoke the non-shared portion of the chain); so for\n         * now, we leak the access to the original.  */\n        virDomainLockImageDetach(driver->lockManager, vm, disk->src);\n\n        /* Move secret driver metadata */\n        if (qemuSecurityMoveImageMetadata(driver, vm, disk->src, disk->mirror) < 0) {\n            VIR_WARN(\"Unable to move disk metadata on \"\n                     \"vm %s from %s to %s (disk target %s)\",\n                     vm->def->name,\n                     NULLSTR(disk->src->path),\n                     NULLSTR(disk->mirror->path),\n                     disk->dst);\n        }\n\n        virObjectUnref(disk->src);\n        disk->src = disk->mirror;\n    } else {\n        if (disk->mirror) {\n            virDomainLockImageDetach(driver->lockManager, vm, disk->mirror);\n\n            /* Ideally, we would restore seclabels on the backing chain here\n             * but we don't know if somebody else is not using parts of it.\n             * Remove security driver metadata so that they are not leaked. */\n            qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->mirror);\n\n            virObjectUnref(disk->mirror);\n        }\n\n        qemuBlockRemoveImageMetadata(driver, vm, disk->dst, disk->src);\n    }\n\n    /* Recompute the cached backing chain to match our\n     * updates.  Better would be storing the chain ourselves\n     * rather than reprobing, but we haven't quite completed\n     * that conversion to use our XML tracking. */\n    disk->mirror = NULL;\n    disk->mirrorState = VIR_DOMAIN_DISK_MIRROR_STATE_NONE;\n    disk->mirrorJob = VIR_DOMAIN_BLOCK_JOB_TYPE_UNKNOWN;\n    disk->src->id = 0;\n    virStorageSourceBackingStoreClear(disk->src);\n    ignore_value(qemuDomainDetermineDiskChain(driver, vm, disk, NULL, true));\n    ignore_value(qemuBlockNodeNamesDetect(driver, vm, asyncJob));\n    qemuBlockJobUnregister(job, vm);\n    qemuDomainSaveConfig(vm);\n}"
  },
  {
    "function_name": "qemuBlockJobRewriteConfigDiskSource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "662-701",
    "snippet": "static void\nqemuBlockJobRewriteConfigDiskSource(virDomainObjPtr vm,\n                                    virDomainDiskDefPtr disk,\n                                    virStorageSourcePtr newsrc)\n{\n    virDomainDiskDefPtr persistDisk = NULL;\n    g_autoptr(virStorageSource) copy = NULL;\n    virStorageSourcePtr n;\n\n    if (!vm->newDef)\n        return;\n\n    if (!(persistDisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, persistDisk->src))\n        return;\n\n    if (!(copy = virStorageSourceCopy(newsrc, true)) ||\n        virStorageSourceInitChainElement(copy, persistDisk->src, true) < 0) {\n        VIR_WARN(\"Unable to update persistent definition on vm %s after block job\",\n                 vm->def->name);\n        return;\n    }\n\n    for (n = copy; virStorageSourceIsBacking(n); n = n->backingStore) {\n        qemuBlockJobCleanStorageSourceRuntime(n);\n\n        /* discard any detected backing store */\n        if (virStorageSourceIsBacking(n->backingStore) &&\n            n->backingStore->detected) {\n            virObjectUnref(n->backingStore);\n            n->backingStore = NULL;\n            break;\n        }\n    }\n\n    virObjectUnref(persistDisk->src);\n    persistDisk->src = g_steal_pointer(&copy);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&copy"
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "persistDisk->src"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "n->backingStore"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobCleanStorageSourceRuntime",
          "args": [
            "n"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobCleanStorageSourceRuntime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "636-647",
          "snippet": "static void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"Unable to update persistent definition on vm %s after block job\"",
            "vm->def->name"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virStorageSourceInitChainElement",
          "args": [
            "copy",
            "persistDisk->src",
            "true"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceInitChainElement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2536-2550",
          "snippet": "int\nvirStorageSourceInitChainElement(virStorageSourcePtr newelem,\n                                 virStorageSourcePtr old,\n                                 bool transferLabels)\n{\n    if (transferLabels &&\n        !newelem->seclabels &&\n        virStorageSourceSeclabelsCopy(newelem, old) < 0)\n        return -1;\n\n    newelem->shared = old->shared;\n    newelem->readonly = old->readonly;\n\n    return 0;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nint\nvirStorageSourceInitChainElement(virStorageSourcePtr newelem,\n                                 virStorageSourcePtr old,\n                                 bool transferLabels)\n{\n    if (transferLabels &&\n        !newelem->seclabels &&\n        virStorageSourceSeclabelsCopy(newelem, old) < 0)\n        return -1;\n\n    newelem->shared = old->shared;\n    newelem->readonly = old->readonly;\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceCopy",
          "args": [
            "newsrc",
            "true"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceCopy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2356-2471",
          "snippet": "virStorageSourcePtr\nvirStorageSourceCopy(const virStorageSource *src,\n                     bool backingChain)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->id = src->id;\n    def->type = src->type;\n    def->protocol = src->protocol;\n    def->format = src->format;\n    def->capacity = src->capacity;\n    def->allocation = src->allocation;\n    def->has_allocation = src->has_allocation;\n    def->physical = src->physical;\n    def->readonly = src->readonly;\n    def->shared = src->shared;\n    def->haveTLS = src->haveTLS;\n    def->tlsFromConfig = src->tlsFromConfig;\n    def->detected = src->detected;\n    def->debugLevel = src->debugLevel;\n    def->debug = src->debug;\n    def->iomode = src->iomode;\n    def->cachemode = src->cachemode;\n    def->discard = src->discard;\n    def->detect_zeroes = src->detect_zeroes;\n    def->sslverify = src->sslverify;\n    def->readahead = src->readahead;\n    def->timeout = src->timeout;\n\n    /* storage driver metadata are not copied */\n    def->drv = NULL;\n\n    def->path = g_strdup(src->path);\n    def->volume = g_strdup(src->volume);\n    def->relPath = g_strdup(src->relPath);\n    def->backingStoreRaw = g_strdup(src->backingStoreRaw);\n    def->backingStoreRawFormat = src->backingStoreRawFormat;\n    def->externalDataStoreRaw = g_strdup(src->externalDataStoreRaw);\n    def->snapshot = g_strdup(src->snapshot);\n    def->configFile = g_strdup(src->configFile);\n    def->nodeformat = g_strdup(src->nodeformat);\n    def->nodestorage = g_strdup(src->nodestorage);\n    def->compat = g_strdup(src->compat);\n    def->tlsAlias = g_strdup(src->tlsAlias);\n    def->tlsCertdir = g_strdup(src->tlsCertdir);\n\n    if (src->sliceStorage)\n        def->sliceStorage = virStorageSourceSliceCopy(src->sliceStorage);\n\n    if (src->nhosts) {\n        if (!(def->hosts = virStorageNetHostDefCopy(src->nhosts, src->hosts)))\n            return NULL;\n\n        def->nhosts = src->nhosts;\n    }\n\n    virStorageSourceNetCookiesCopy(def, src);\n\n    if (src->srcpool &&\n        !(def->srcpool = virStorageSourcePoolDefCopy(src->srcpool)))\n        return NULL;\n\n    if (src->features &&\n        !(def->features = virBitmapNewCopy(src->features)))\n        return NULL;\n\n    if (src->encryption &&\n        !(def->encryption = virStorageEncryptionCopy(src->encryption)))\n        return NULL;\n\n    if (src->perms &&\n        !(def->perms = virStoragePermsCopy(src->perms)))\n        return NULL;\n\n    if (src->timestamps &&\n        !(def->timestamps = virStorageTimestampsCopy(src->timestamps)))\n        return NULL;\n\n    if (virStorageSourceSeclabelsCopy(def, src) < 0)\n        return NULL;\n\n    if (src->auth &&\n        !(def->auth = virStorageAuthDefCopy(src->auth)))\n        return NULL;\n\n    if (src->pr &&\n        !(def->pr = virStoragePRDefCopy(src->pr)))\n        return NULL;\n\n    if (src->nvme)\n        def->nvme = virStorageSourceNVMeDefCopy(src->nvme);\n\n    if (virStorageSourceInitiatorCopy(&def->initiator, &src->initiator) < 0)\n        return NULL;\n\n    if (backingChain && src->backingStore) {\n        if (!(def->backingStore = virStorageSourceCopy(src->backingStore,\n                                                       true)))\n            return NULL;\n    }\n\n    if (src->externalDataStore) {\n        if (!(def->externalDataStore = virStorageSourceCopy(src->externalDataStore,\n                                                            true)))\n            return NULL;\n    }\n\n    /* ssh config passthrough for libguestfs */\n    def->ssh_host_key_check_disabled = src->ssh_host_key_check_disabled;\n    def->ssh_user = g_strdup(src->ssh_user);\n\n    return g_steal_pointer(&def);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nvirStorageSourcePtr\nvirStorageSourceCopy(const virStorageSource *src,\n                     bool backingChain)\n{\n    g_autoptr(virStorageSource) def = NULL;\n\n    if (!(def = virStorageSourceNew()))\n        return NULL;\n\n    def->id = src->id;\n    def->type = src->type;\n    def->protocol = src->protocol;\n    def->format = src->format;\n    def->capacity = src->capacity;\n    def->allocation = src->allocation;\n    def->has_allocation = src->has_allocation;\n    def->physical = src->physical;\n    def->readonly = src->readonly;\n    def->shared = src->shared;\n    def->haveTLS = src->haveTLS;\n    def->tlsFromConfig = src->tlsFromConfig;\n    def->detected = src->detected;\n    def->debugLevel = src->debugLevel;\n    def->debug = src->debug;\n    def->iomode = src->iomode;\n    def->cachemode = src->cachemode;\n    def->discard = src->discard;\n    def->detect_zeroes = src->detect_zeroes;\n    def->sslverify = src->sslverify;\n    def->readahead = src->readahead;\n    def->timeout = src->timeout;\n\n    /* storage driver metadata are not copied */\n    def->drv = NULL;\n\n    def->path = g_strdup(src->path);\n    def->volume = g_strdup(src->volume);\n    def->relPath = g_strdup(src->relPath);\n    def->backingStoreRaw = g_strdup(src->backingStoreRaw);\n    def->backingStoreRawFormat = src->backingStoreRawFormat;\n    def->externalDataStoreRaw = g_strdup(src->externalDataStoreRaw);\n    def->snapshot = g_strdup(src->snapshot);\n    def->configFile = g_strdup(src->configFile);\n    def->nodeformat = g_strdup(src->nodeformat);\n    def->nodestorage = g_strdup(src->nodestorage);\n    def->compat = g_strdup(src->compat);\n    def->tlsAlias = g_strdup(src->tlsAlias);\n    def->tlsCertdir = g_strdup(src->tlsCertdir);\n\n    if (src->sliceStorage)\n        def->sliceStorage = virStorageSourceSliceCopy(src->sliceStorage);\n\n    if (src->nhosts) {\n        if (!(def->hosts = virStorageNetHostDefCopy(src->nhosts, src->hosts)))\n            return NULL;\n\n        def->nhosts = src->nhosts;\n    }\n\n    virStorageSourceNetCookiesCopy(def, src);\n\n    if (src->srcpool &&\n        !(def->srcpool = virStorageSourcePoolDefCopy(src->srcpool)))\n        return NULL;\n\n    if (src->features &&\n        !(def->features = virBitmapNewCopy(src->features)))\n        return NULL;\n\n    if (src->encryption &&\n        !(def->encryption = virStorageEncryptionCopy(src->encryption)))\n        return NULL;\n\n    if (src->perms &&\n        !(def->perms = virStoragePermsCopy(src->perms)))\n        return NULL;\n\n    if (src->timestamps &&\n        !(def->timestamps = virStorageTimestampsCopy(src->timestamps)))\n        return NULL;\n\n    if (virStorageSourceSeclabelsCopy(def, src) < 0)\n        return NULL;\n\n    if (src->auth &&\n        !(def->auth = virStorageAuthDefCopy(src->auth)))\n        return NULL;\n\n    if (src->pr &&\n        !(def->pr = virStoragePRDefCopy(src->pr)))\n        return NULL;\n\n    if (src->nvme)\n        def->nvme = virStorageSourceNVMeDefCopy(src->nvme);\n\n    if (virStorageSourceInitiatorCopy(&def->initiator, &src->initiator) < 0)\n        return NULL;\n\n    if (backingChain && src->backingStore) {\n        if (!(def->backingStore = virStorageSourceCopy(src->backingStore,\n                                                       true)))\n            return NULL;\n    }\n\n    if (src->externalDataStore) {\n        if (!(def->externalDataStore = virStorageSourceCopy(src->externalDataStore,\n                                                            true)))\n            return NULL;\n    }\n\n    /* ssh config passthrough for libguestfs */\n    def->ssh_host_key_check_disabled = src->ssh_host_key_check_disabled;\n    def->ssh_user = g_strdup(src->ssh_user);\n\n    return g_steal_pointer(&def);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsSameLocation",
          "args": [
            "disk->src",
            "persistDisk->src"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsSameLocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2480-2518",
          "snippet": "bool\nvirStorageSourceIsSameLocation(virStorageSourcePtr a,\n                               virStorageSourcePtr b)\n{\n    size_t i;\n\n    /* there are multiple possibilities to define an empty source */\n    if (virStorageSourceIsEmpty(a) &&\n        virStorageSourceIsEmpty(b))\n        return true;\n\n    if (virStorageSourceGetActualType(a) != virStorageSourceGetActualType(b))\n        return false;\n\n    if (STRNEQ_NULLABLE(a->path, b->path) ||\n        STRNEQ_NULLABLE(a->volume, b->volume) ||\n        STRNEQ_NULLABLE(a->snapshot, b->snapshot))\n        return false;\n\n    if (a->type == VIR_STORAGE_TYPE_NETWORK) {\n        if (a->protocol != b->protocol ||\n            a->nhosts != b->nhosts)\n            return false;\n\n        for (i = 0; i < a->nhosts; i++) {\n            if (a->hosts[i].transport != b->hosts[i].transport ||\n                a->hosts[i].port != b->hosts[i].port ||\n                STRNEQ_NULLABLE(a->hosts[i].name, b->hosts[i].name) ||\n                STRNEQ_NULLABLE(a->hosts[i].socket, b->hosts[i].socket))\n                return false;\n        }\n    }\n\n    if (a->type == VIR_STORAGE_TYPE_NVME &&\n        !virStorageSourceNVMeDefIsEqual(a->nvme, b->nvme))\n        return false;\n\n    return true;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int cowGetBackingStore(char **, int *,\n                              const char *, size_t);",
            "static int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);",
            "static int\nqedGetBackingStore(char **, int *, const char *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nstatic int cowGetBackingStore(char **, int *,\n                              const char *, size_t);\nstatic int qcowXGetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int vmdk4GetBackingStore(char **, int *,\n                                const char *, size_t);\nstatic int\nqedGetBackingStore(char **, int *, const char *, size_t);\n\nbool\nvirStorageSourceIsSameLocation(virStorageSourcePtr a,\n                               virStorageSourcePtr b)\n{\n    size_t i;\n\n    /* there are multiple possibilities to define an empty source */\n    if (virStorageSourceIsEmpty(a) &&\n        virStorageSourceIsEmpty(b))\n        return true;\n\n    if (virStorageSourceGetActualType(a) != virStorageSourceGetActualType(b))\n        return false;\n\n    if (STRNEQ_NULLABLE(a->path, b->path) ||\n        STRNEQ_NULLABLE(a->volume, b->volume) ||\n        STRNEQ_NULLABLE(a->snapshot, b->snapshot))\n        return false;\n\n    if (a->type == VIR_STORAGE_TYPE_NETWORK) {\n        if (a->protocol != b->protocol ||\n            a->nhosts != b->nhosts)\n            return false;\n\n        for (i = 0; i < a->nhosts; i++) {\n            if (a->hosts[i].transport != b->hosts[i].transport ||\n                a->hosts[i].port != b->hosts[i].port ||\n                STRNEQ_NULLABLE(a->hosts[i].name, b->hosts[i].name) ||\n                STRNEQ_NULLABLE(a->hosts[i].socket, b->hosts[i].socket))\n                return false;\n        }\n    }\n\n    if (a->type == VIR_STORAGE_TYPE_NVME &&\n        !virStorageSourceNVMeDefIsEqual(a->nvme, b->nvme))\n        return false;\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskByTarget",
          "args": [
            "vm->newDef",
            "disk->dst"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskByTarget",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "17337-17349",
          "snippet": "virDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nvirDomainDiskDefPtr\nvirDomainDiskByTarget(virDomainDefPtr def,\n                      const char *dst)\n{\n    size_t i;\n\n    for (i = 0; i < def->ndisks; i++) {\n        if (STREQ(def->disks[i]->dst, dst))\n            return def->disks[i];\n    }\n\n    return NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobRewriteConfigDiskSource(virDomainObjPtr vm,\n                                    virDomainDiskDefPtr disk,\n                                    virStorageSourcePtr newsrc)\n{\n    virDomainDiskDefPtr persistDisk = NULL;\n    g_autoptr(virStorageSource) copy = NULL;\n    virStorageSourcePtr n;\n\n    if (!vm->newDef)\n        return;\n\n    if (!(persistDisk = virDomainDiskByTarget(vm->newDef, disk->dst)))\n        return;\n\n    if (!virStorageSourceIsSameLocation(disk->src, persistDisk->src))\n        return;\n\n    if (!(copy = virStorageSourceCopy(newsrc, true)) ||\n        virStorageSourceInitChainElement(copy, persistDisk->src, true) < 0) {\n        VIR_WARN(\"Unable to update persistent definition on vm %s after block job\",\n                 vm->def->name);\n        return;\n    }\n\n    for (n = copy; virStorageSourceIsBacking(n); n = n->backingStore) {\n        qemuBlockJobCleanStorageSourceRuntime(n);\n\n        /* discard any detected backing store */\n        if (virStorageSourceIsBacking(n->backingStore) &&\n            n->backingStore->detected) {\n            virObjectUnref(n->backingStore);\n            n->backingStore = NULL;\n            break;\n        }\n    }\n\n    virObjectUnref(persistDisk->src);\n    persistDisk->src = g_steal_pointer(&copy);\n}"
  },
  {
    "function_name": "qemuBlockJobCleanStorageSourceRuntime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "636-647",
    "snippet": "static void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "src->tlsCertdir"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "src->tlsAlias"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "src->nodeformat"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "src->nodestorage"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "src->backingStoreRaw"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "src->relPath"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobCleanStorageSourceRuntime(virStorageSourcePtr src)\n{\n    src->id = 0;\n    src->detected = false;\n    VIR_FREE(src->relPath);\n    VIR_FREE(src->backingStoreRaw);\n    VIR_FREE(src->nodestorage);\n    VIR_FREE(src->nodeformat);\n    VIR_FREE(src->tlsAlias);\n    VIR_FREE(src->tlsCertdir);\n}"
  },
  {
    "function_name": "qemuBlockJobEmitEvents",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "600-628",
    "snippet": "static void\nqemuBlockJobEmitEvents(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       virDomainDiskDefPtr disk,\n                       virDomainBlockJobType type,\n                       virConnectDomainEventBlockJobStatus status)\n{\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr event2 = NULL;\n\n    /* don't emit events for jobs without disk */\n    if (!disk)\n        return;\n\n    /* don't emit events for internal jobs and states */\n    if (type >= VIR_DOMAIN_BLOCK_JOB_TYPE_LAST ||\n        status >= VIR_DOMAIN_BLOCK_JOB_LAST)\n        return;\n\n    if (virStorageSourceIsLocalStorage(disk->src) &&\n        !virStorageSourceIsEmpty(disk->src)) {\n        event = virDomainEventBlockJobNewFromObj(vm, virDomainDiskGetSource(disk),\n                                                 type, status);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    event2 = virDomainEventBlockJob2NewFromObj(vm, disk->dst, type, status);\n    virObjectEventStateQueue(driver->domainEventState, event2);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectEventStateQueue",
          "args": [
            "driver->domainEventState",
            "event2"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectEventStateQueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/object_event.c",
          "lines": "772-777",
          "snippet": "void\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virobject.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"network_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectEventStateFlush(virObjectEventStatePtr state);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virobject.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"network_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virObjectEventStateFlush(virObjectEventStatePtr state);\n\nvoid\nvirObjectEventStateQueue(virObjectEventStatePtr state,\n                         virObjectEventPtr event)\n{\n    virObjectEventStateQueueRemote(state, event, -1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventBlockJob2NewFromObj",
          "args": [
            "vm",
            "disk->dst",
            "type",
            "status"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventBlockJob2NewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "939-948",
          "snippet": "virObjectEventPtr\nvirDomainEventBlockJob2NewFromObj(virDomainObjPtr obj,\n                                  const char *dst,\n                                  int type,\n                                  int status)\n{\n    return virDomainEventBlockJobNew(VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2,\n                                     obj->def->id, obj->def->name,\n                                     obj->def->uuid, dst, type, status);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventBlockJob2NewFromObj(virDomainObjPtr obj,\n                                  const char *dst,\n                                  int type,\n                                  int status)\n{\n    return virDomainEventBlockJobNew(VIR_DOMAIN_EVENT_ID_BLOCK_JOB_2,\n                                     obj->def->id, obj->def->name,\n                                     obj->def->uuid, dst, type, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainEventBlockJobNewFromObj",
          "args": [
            "vm",
            "virDomainDiskGetSource(disk)",
            "type",
            "status"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainEventBlockJobNewFromObj",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_event.c",
          "lines": "917-926",
          "snippet": "virObjectEventPtr\nvirDomainEventBlockJobNewFromObj(virDomainObjPtr obj,\n                                 const char *path,\n                                 int type,\n                                 int status)\n{\n    return virDomainEventBlockJobNew(VIR_DOMAIN_EVENT_ID_BLOCK_JOB,\n                                     obj->def->id, obj->def->name,\n                                     obj->def->uuid, path, type, status);\n}",
          "includes": [
            "#include \"virtypedparam.h\"",
            "#include \"virstring.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"object_event_private.h\"",
            "#include \"object_event.h\"",
            "#include \"domain_event.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virDomainEventDispose(void *obj);",
            "static void virDomainEventLifecycleDispose(void *obj);",
            "static void virDomainEventRTCChangeDispose(void *obj);",
            "static void virDomainEventWatchdogDispose(void *obj);",
            "static void virDomainEventIOErrorDispose(void *obj);",
            "static void virDomainEventGraphicsDispose(void *obj);",
            "static void virDomainEventBlockJobDispose(void *obj);",
            "static void virDomainEventDiskChangeDispose(void *obj);",
            "static void virDomainEventTrayChangeDispose(void *obj);",
            "static void virDomainEventBalloonChangeDispose(void *obj);",
            "static void virDomainEventDeviceRemovedDispose(void *obj);",
            "static void virDomainEventPMDispose(void *obj);",
            "static void virDomainQemuMonitorEventDispose(void *obj);",
            "static void virDomainEventTunableDispose(void *obj);",
            "static void virDomainEventAgentLifecycleDispose(void *obj);",
            "static void virDomainEventDeviceAddedDispose(void *obj);",
            "static void virDomainEventMigrationIterationDispose(void *obj);",
            "static void virDomainEventJobCompletedDispose(void *obj);",
            "static void virDomainEventDeviceRemovalFailedDispose(void *obj);",
            "static void virDomainEventMetadataChangeDispose(void *obj);",
            "static void virDomainEventBlockThresholdDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virtypedparam.h\"\n#include \"virstring.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"object_event_private.h\"\n#include \"object_event.h\"\n#include \"domain_event.h\"\n#include <config.h>\n\nstatic void virDomainEventDispose(void *obj);\nstatic void virDomainEventLifecycleDispose(void *obj);\nstatic void virDomainEventRTCChangeDispose(void *obj);\nstatic void virDomainEventWatchdogDispose(void *obj);\nstatic void virDomainEventIOErrorDispose(void *obj);\nstatic void virDomainEventGraphicsDispose(void *obj);\nstatic void virDomainEventBlockJobDispose(void *obj);\nstatic void virDomainEventDiskChangeDispose(void *obj);\nstatic void virDomainEventTrayChangeDispose(void *obj);\nstatic void virDomainEventBalloonChangeDispose(void *obj);\nstatic void virDomainEventDeviceRemovedDispose(void *obj);\nstatic void virDomainEventPMDispose(void *obj);\nstatic void virDomainQemuMonitorEventDispose(void *obj);\nstatic void virDomainEventTunableDispose(void *obj);\nstatic void virDomainEventAgentLifecycleDispose(void *obj);\nstatic void virDomainEventDeviceAddedDispose(void *obj);\nstatic void virDomainEventMigrationIterationDispose(void *obj);\nstatic void virDomainEventJobCompletedDispose(void *obj);\nstatic void virDomainEventDeviceRemovalFailedDispose(void *obj);\nstatic void virDomainEventMetadataChangeDispose(void *obj);\nstatic void virDomainEventBlockThresholdDispose(void *obj);\n\nvirObjectEventPtr\nvirDomainEventBlockJobNewFromObj(virDomainObjPtr obj,\n                                 const char *path,\n                                 int type,\n                                 int status)\n{\n    return virDomainEventBlockJobNew(VIR_DOMAIN_EVENT_ID_BLOCK_JOB,\n                                     obj->def->id, obj->def->name,\n                                     obj->def->uuid, path, type, status);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virDomainDiskGetSource",
          "args": [
            "disk"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "virDomainDiskGetSource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/conf/domain_conf.c",
          "lines": "2155-2159",
          "snippet": "const char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}",
          "includes": [
            "#include \"vircrypto.h\"",
            "#include \"virutil.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virmdev.h\"",
            "#include \"virarptable.h\"",
            "#include \"virnetdevmacvlan.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virnetdev.h\"",
            "#include \"virstring.h\"",
            "#include \"virsecret.h\"",
            "#include \"virtpm.h\"",
            "#include \"network_conf.h\"",
            "#include \"device_conf.h\"",
            "#include \"netdev_vlan_conf.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"netdev_vport_profile_conf.h\"",
            "#include \"secret_conf.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"storage_conf.h\"",
            "#include \"virnetworkportdef.h\"",
            "#include \"nwfilter_conf.h\"",
            "#include \"virlog.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include \"snapshot_conf.h\"",
            "#include \"domain_conf.h\"",
            "#include \"domain_addr.h\"",
            "#include \"datatypes.h\"",
            "#include \"checkpoint_conf.h\"",
            "#include \"virerror.h\"",
            "#include \"internal.h\"",
            "#include \"configmake.h\"",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vircrypto.h\"\n#include \"virutil.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virmdev.h\"\n#include \"virarptable.h\"\n#include \"virnetdevmacvlan.h\"\n#include \"virnetdevtap.h\"\n#include \"virnetdev.h\"\n#include \"virstring.h\"\n#include \"virsecret.h\"\n#include \"virtpm.h\"\n#include \"network_conf.h\"\n#include \"device_conf.h\"\n#include \"netdev_vlan_conf.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"netdev_vport_profile_conf.h\"\n#include \"secret_conf.h\"\n#include \"virbitmap.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"storage_conf.h\"\n#include \"virnetworkportdef.h\"\n#include \"nwfilter_conf.h\"\n#include \"virlog.h\"\n#include \"virbuffer.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include \"snapshot_conf.h\"\n#include \"domain_conf.h\"\n#include \"domain_addr.h\"\n#include \"datatypes.h\"\n#include \"checkpoint_conf.h\"\n#include \"virerror.h\"\n#include \"internal.h\"\n#include \"configmake.h\"\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <config.h>\n\nconst char *\nvirDomainDiskGetSource(virDomainDiskDef const *def)\n{\n    return def->src->path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsEmpty",
          "args": [
            "disk->src"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsEmpty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2619-2633",
          "snippet": "bool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsEmpty(virStorageSourcePtr src)\n{\n    if (virStorageSourceIsLocalStorage(src) && !src->path)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NONE)\n        return true;\n\n    if (src->type == VIR_STORAGE_TYPE_NETWORK &&\n        src->protocol == VIR_STORAGE_NET_PROTOCOL_NONE)\n        return true;\n\n    return false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsLocalStorage",
          "args": [
            "disk->src"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsLocalStorage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "2586-2608",
          "snippet": "bool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsLocalStorage(const virStorageSource *src)\n{\n    virStorageType type = virStorageSourceGetActualType(src);\n\n    switch (type) {\n    case VIR_STORAGE_TYPE_FILE:\n    case VIR_STORAGE_TYPE_BLOCK:\n    case VIR_STORAGE_TYPE_DIR:\n        return true;\n\n    case VIR_STORAGE_TYPE_NETWORK:\n    case VIR_STORAGE_TYPE_VOLUME:\n        /* While NVMe disks are local, they are not accessible via src->path.\n         * Therefore, we have to return false here. */\n    case VIR_STORAGE_TYPE_NVME:\n    case VIR_STORAGE_TYPE_LAST:\n    case VIR_STORAGE_TYPE_NONE:\n        return false;\n    }\n\n    return false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobEmitEvents(virQEMUDriverPtr driver,\n                       virDomainObjPtr vm,\n                       virDomainDiskDefPtr disk,\n                       virDomainBlockJobType type,\n                       virConnectDomainEventBlockJobStatus status)\n{\n    virObjectEventPtr event = NULL;\n    virObjectEventPtr event2 = NULL;\n\n    /* don't emit events for jobs without disk */\n    if (!disk)\n        return;\n\n    /* don't emit events for internal jobs and states */\n    if (type >= VIR_DOMAIN_BLOCK_JOB_TYPE_LAST ||\n        status >= VIR_DOMAIN_BLOCK_JOB_LAST)\n        return;\n\n    if (virStorageSourceIsLocalStorage(disk->src) &&\n        !virStorageSourceIsEmpty(disk->src)) {\n        event = virDomainEventBlockJobNewFromObj(vm, virDomainDiskGetSource(disk),\n                                                 type, status);\n        virObjectEventStateQueue(driver->domainEventState, event);\n    }\n\n    event2 = virDomainEventBlockJob2NewFromObj(vm, disk->dst, type, status);\n    virObjectEventStateQueue(driver->domainEventState, event2);\n}"
  },
  {
    "function_name": "qemuBlockJobRefreshJobs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "495-591",
    "snippet": "int\nqemuBlockJobRefreshJobs(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorJobInfoPtr *jobinfo = NULL;\n    size_t njobinfo = 0;\n    qemuBlockJobDataPtr job = NULL;\n    int newstate;\n    size_t i;\n    int ret = -1;\n    int rc;\n\n    qemuDomainObjEnterMonitor(driver, vm);\n\n    rc = qemuMonitorGetJobInfo(priv->mon, &jobinfo, &njobinfo);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        goto cleanup;\n\n    for (i = 0; i < njobinfo; i++) {\n        if (!(job = virHashLookup(priv->blockjobs, jobinfo[i]->id))) {\n            VIR_DEBUG(\"ignoring untracked job '%s'\", jobinfo[i]->id);\n            continue;\n        }\n\n        /* try cancelling invalid jobs - this works only if the job is not\n         * concluded. In such case it will fail. We'll leave such job linger\n         * in qemu and just forget about it in libvirt because there's not much\n         * we coud do besides killing the VM */\n        if (job->invalidData) {\n\n            qemuBlockJobMarkBroken(job);\n\n            qemuDomainObjEnterMonitor(driver, vm);\n\n            rc = qemuMonitorJobCancel(priv->mon, job->name, true);\n            if (rc == -1 && jobinfo[i]->status == QEMU_MONITOR_JOB_STATUS_CONCLUDED)\n                VIR_WARN(\"can't cancel job '%s' with invalid data\", job->name);\n\n            if (qemuDomainObjExitMonitor(driver, vm) < 0)\n                goto cleanup;\n\n            if (rc < 0)\n                qemuBlockJobUnregister(job, vm);\n            else\n                job->reconnected = true;\n            continue;\n        }\n\n        if ((newstate = qemuBlockjobConvertMonitorStatus(jobinfo[i]->status)) < 0)\n            continue;\n\n        if (newstate != job->state) {\n            if ((job->state == QEMU_BLOCKJOB_STATE_FAILED ||\n                 job->state == QEMU_BLOCKJOB_STATE_COMPLETED)) {\n                /* preserve the old state but allow the job to be bumped to\n                 * execute the finishing steps */\n                job->newstate = job->state;\n            } else if (newstate == QEMU_BLOCKJOB_STATE_CONCLUDED) {\n                job->errmsg = g_strdup(jobinfo[i]->error);\n\n                if (job->errmsg)\n                    job->newstate = QEMU_BLOCKJOB_STATE_FAILED;\n                else\n                    job->newstate = QEMU_BLOCKJOB_STATE_COMPLETED;\n            } else if (newstate == QEMU_BLOCKJOB_STATE_READY) {\n                /* Apply _READY state only if it was not applied before */\n                if (job->state == QEMU_BLOCKJOB_STATE_NEW ||\n                    job->state == QEMU_BLOCKJOB_STATE_RUNNING)\n                    job->newstate = newstate;\n            }\n            /* don't update the job otherwise */\n        }\n\n        job->reconnected = true;\n\n        if (job->newstate != -1)\n            qemuBlockJobUpdate(vm, job, QEMU_ASYNC_JOB_NONE);\n    }\n\n    /* remove data for job which qemu didn't report (the algorithm is\n     * inefficient, but the possibility of such jobs is very low */\n    while ((job = virHashSearch(priv->blockjobs, qemuBlockJobRefreshJobsFindInactive, NULL, NULL))) {\n        VIR_WARN(\"dropping blockjob '%s' untracked by qemu\", job->name);\n        qemuBlockJobUnregister(job, vm);\n    }\n\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < njobinfo; i++)\n        qemuMonitorJobInfoFree(jobinfo[i]);\n    VIR_FREE(jobinfo);\n\n    return ret;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "jobinfo"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJobInfoFree",
          "args": [
            "jobinfo[i]"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJobInfoFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4475-4484",
          "snippet": "void\nqemuMonitorJobInfoFree(qemuMonitorJobInfoPtr job)\n{\n    if (!job)\n        return;\n\n    VIR_FREE(job->id);\n    VIR_FREE(job->error);\n    VIR_FREE(job);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nvoid\nqemuMonitorJobInfoFree(qemuMonitorJobInfoPtr job)\n{\n    if (!job)\n        return;\n\n    VIR_FREE(job->id);\n    VIR_FREE(job->error);\n    VIR_FREE(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobUnregister",
          "args": [
            "job",
            "vm"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobUnregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "201-223",
          "snippet": "static void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"dropping blockjob '%s' untracked by qemu\"",
            "job->name"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashSearch",
          "args": [
            "priv->blockjobs",
            "qemuBlockJobRefreshJobsFindInactive",
            "NULL",
            "NULL"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "virHashSearch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "736-761",
          "snippet": "void *virHashSearch(const virHashTable *ctable,\n                    virHashSearcher iter,\n                    const void *data,\n                    void **name)\n{\n    size_t i;\n\n    /* Cast away const for internal detection of misuse.  */\n    virHashTablePtr table = (virHashTablePtr)ctable;\n\n    if (table == NULL || iter == NULL)\n        return NULL;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry;\n        for (entry = table->table[i]; entry; entry = entry->next) {\n            if (iter(entry->payload, entry->name, data)) {\n                if (name)\n                    *name = table->keyCopy(entry->name);\n                return entry->payload;\n            }\n        }\n    }\n\n    return NULL;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *virHashSearch(const virHashTable *ctable,\n                    virHashSearcher iter,\n                    const void *data,\n                    void **name)\n{\n    size_t i;\n\n    /* Cast away const for internal detection of misuse.  */\n    virHashTablePtr table = (virHashTablePtr)ctable;\n\n    if (table == NULL || iter == NULL)\n        return NULL;\n\n    for (i = 0; i < table->size; i++) {\n        virHashEntryPtr entry;\n        for (entry = table->table[i]; entry; entry = entry->next) {\n            if (iter(entry->payload, entry->name, data)) {\n                if (name)\n                    *name = table->keyCopy(entry->name);\n                return entry->payload;\n            }\n        }\n    }\n\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobUpdate",
          "args": [
            "vm",
            "job",
            "QEMU_ASYNC_JOB_NONE"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobUpdate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1664-1680",
          "snippet": "int\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobUpdate(virDomainObjPtr vm,\n                   qemuBlockJobDataPtr job,\n                   int asyncJob)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (job->newstate == -1)\n        return -1;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV))\n        qemuBlockJobEventProcess(priv->driver, vm, job, asyncJob);\n    else\n        qemuBlockJobEventProcessLegacy(priv->driver, vm, job, asyncJob);\n\n    return job->state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "jobinfo[i]->error"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockjobConvertMonitorStatus",
          "args": [
            "jobinfo[i]->status"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockjobConvertMonitorStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "1755-1786",
          "snippet": "qemuBlockjobState\nqemuBlockjobConvertMonitorStatus(int monitorstatus)\n{\n    qemuBlockjobState ret = QEMU_BLOCKJOB_STATE_LAST;\n\n    switch ((qemuMonitorJobStatus) monitorstatus) {\n    case QEMU_MONITOR_JOB_STATUS_READY:\n        ret = QEMU_BLOCKJOB_STATE_READY;\n        break;\n\n    case QEMU_MONITOR_JOB_STATUS_CONCLUDED:\n        ret = QEMU_BLOCKJOB_STATE_CONCLUDED;\n        break;\n\n    case QEMU_MONITOR_JOB_STATUS_UNKNOWN:\n    case QEMU_MONITOR_JOB_STATUS_CREATED:\n    case QEMU_MONITOR_JOB_STATUS_RUNNING:\n    case QEMU_MONITOR_JOB_STATUS_PAUSED:\n    case QEMU_MONITOR_JOB_STATUS_STANDBY:\n    case QEMU_MONITOR_JOB_STATUS_WAITING:\n    case QEMU_MONITOR_JOB_STATUS_PENDING:\n    case QEMU_MONITOR_JOB_STATUS_ABORTING:\n    case QEMU_MONITOR_JOB_STATUS_UNDEFINED:\n    case QEMU_MONITOR_JOB_STATUS_NULL:\n    case QEMU_MONITOR_JOB_STATUS_LAST:\n    default:\n        break;\n    }\n\n    return ret;\n\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockjobState\nqemuBlockjobConvertMonitorStatus(int monitorstatus)\n{\n    qemuBlockjobState ret = QEMU_BLOCKJOB_STATE_LAST;\n\n    switch ((qemuMonitorJobStatus) monitorstatus) {\n    case QEMU_MONITOR_JOB_STATUS_READY:\n        ret = QEMU_BLOCKJOB_STATE_READY;\n        break;\n\n    case QEMU_MONITOR_JOB_STATUS_CONCLUDED:\n        ret = QEMU_BLOCKJOB_STATE_CONCLUDED;\n        break;\n\n    case QEMU_MONITOR_JOB_STATUS_UNKNOWN:\n    case QEMU_MONITOR_JOB_STATUS_CREATED:\n    case QEMU_MONITOR_JOB_STATUS_RUNNING:\n    case QEMU_MONITOR_JOB_STATUS_PAUSED:\n    case QEMU_MONITOR_JOB_STATUS_STANDBY:\n    case QEMU_MONITOR_JOB_STATUS_WAITING:\n    case QEMU_MONITOR_JOB_STATUS_PENDING:\n    case QEMU_MONITOR_JOB_STATUS_ABORTING:\n    case QEMU_MONITOR_JOB_STATUS_UNDEFINED:\n    case QEMU_MONITOR_JOB_STATUS_NULL:\n    case QEMU_MONITOR_JOB_STATUS_LAST:\n    default:\n        break;\n    }\n\n    return ret;\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjExitMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjExitMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10189-10200",
          "snippet": "int qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nint qemuDomainObjExitMonitor(virQEMUDriverPtr driver,\n                             virDomainObjPtr obj)\n{\n    qemuDomainObjExitMonitorInternal(driver, obj);\n    if (!virDomainObjIsActive(obj)) {\n        if (virGetLastErrorCode() == VIR_ERR_OK)\n            virReportError(VIR_ERR_OPERATION_FAILED, \"%s\",\n                           _(\"domain is no longer running\"));\n        return -1;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_WARN",
          "args": [
            "\"can't cancel job '%s' with invalid data\"",
            "job->name"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuMonitorJobCancel",
          "args": [
            "priv->mon",
            "job->name",
            "true"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorJobCancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "3306-3316",
          "snippet": "int\nqemuMonitorJobCancel(qemuMonitorPtr mon,\n                     const char *jobname,\n                     bool quiet)\n{\n    VIR_DEBUG(\"jobname='%s' quiet=%d\", jobname, quiet);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobCancel(mon, jobname, quiet);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorJobCancel(qemuMonitorPtr mon,\n                     const char *jobname,\n                     bool quiet)\n{\n    VIR_DEBUG(\"jobname='%s' quiet=%d\", jobname, quiet);\n\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONJobCancel(mon, jobname, quiet);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuDomainObjEnterMonitor",
          "args": [
            "driver",
            "vm"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainObjEnterMonitor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "10172-10177",
          "snippet": "void qemuDomainObjEnterMonitor(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj)\n{\n    ignore_value(qemuDomainObjEnterMonitorInternal(driver, obj,\n                                                   QEMU_ASYNC_JOB_NONE));\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid qemuDomainObjEnterMonitor(virQEMUDriverPtr driver,\n                               virDomainObjPtr obj)\n{\n    ignore_value(qemuDomainObjEnterMonitorInternal(driver, obj,\n                                                   QEMU_ASYNC_JOB_NONE));\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobMarkBroken",
          "args": [
            "job"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobMarkBroken",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "147-153",
          "snippet": "static void\nqemuBlockJobMarkBroken(qemuBlockJobDataPtr job)\n{\n    qemuBlockJobDataDisposeJobdata(job);\n    job->brokentype = job->type;\n    job->type = QEMU_BLOCKJOB_TYPE_BROKEN;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobMarkBroken(qemuBlockJobDataPtr job)\n{\n    qemuBlockJobDataDisposeJobdata(job);\n    job->brokentype = job->type;\n    job->type = QEMU_BLOCKJOB_TYPE_BROKEN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_DEBUG",
          "args": [
            "\"ignoring untracked job '%s'\"",
            "jobinfo[i]->id"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virHashLookup",
          "args": [
            "priv->blockjobs",
            "jobinfo[i]->id"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "virHashLookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "473-482",
          "snippet": "void *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nvoid *\nvirHashLookup(const virHashTable *table, const void *name)\n{\n    virHashEntryPtr entry = virHashGetEntry(table, name);\n\n    if (!entry)\n        return NULL;\n\n    return entry->payload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuMonitorGetJobInfo",
          "args": [
            "priv->mon",
            "&jobinfo",
            "&njobinfo"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "qemuMonitorGetJobInfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_monitor.c",
          "lines": "4487-4495",
          "snippet": "int\nqemuMonitorGetJobInfo(qemuMonitorPtr mon,\n                      qemuMonitorJobInfoPtr **jobs,\n                      size_t *njobs)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetJobInfo(mon, jobs, njobs);\n}",
          "includes": [
            "#include \"qemu_monitor_priv.h\"",
            "# include \"libvirt_qemu_probes.h\"",
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virtime.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virobject.h\"",
            "#include \"virprocess.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_monitor_json.h\"",
            "#include \"qemu_monitor_text.h\"",
            "#include \"qemu_monitor.h\"",
            "#include <gio/gio.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <poll.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_monitor_priv.h\"\n# include \"libvirt_qemu_probes.h\"\n#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virtime.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virobject.h\"\n#include \"virprocess.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virerror.h\"\n#include \"qemu_process.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_monitor_json.h\"\n#include \"qemu_monitor_text.h\"\n#include \"qemu_monitor.h\"\n#include <gio/gio.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <poll.h>\n#include <config.h>\n\nint\nqemuMonitorGetJobInfo(qemuMonitorPtr mon,\n                      qemuMonitorJobInfoPtr **jobs,\n                      size_t *njobs)\n{\n    QEMU_CHECK_MONITOR(mon);\n\n    return qemuMonitorJSONGetJobInfo(mon, jobs, njobs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobRefreshJobs(virQEMUDriverPtr driver,\n                        virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuMonitorJobInfoPtr *jobinfo = NULL;\n    size_t njobinfo = 0;\n    qemuBlockJobDataPtr job = NULL;\n    int newstate;\n    size_t i;\n    int ret = -1;\n    int rc;\n\n    qemuDomainObjEnterMonitor(driver, vm);\n\n    rc = qemuMonitorGetJobInfo(priv->mon, &jobinfo, &njobinfo);\n\n    if (qemuDomainObjExitMonitor(driver, vm) < 0 || rc < 0)\n        goto cleanup;\n\n    for (i = 0; i < njobinfo; i++) {\n        if (!(job = virHashLookup(priv->blockjobs, jobinfo[i]->id))) {\n            VIR_DEBUG(\"ignoring untracked job '%s'\", jobinfo[i]->id);\n            continue;\n        }\n\n        /* try cancelling invalid jobs - this works only if the job is not\n         * concluded. In such case it will fail. We'll leave such job linger\n         * in qemu and just forget about it in libvirt because there's not much\n         * we coud do besides killing the VM */\n        if (job->invalidData) {\n\n            qemuBlockJobMarkBroken(job);\n\n            qemuDomainObjEnterMonitor(driver, vm);\n\n            rc = qemuMonitorJobCancel(priv->mon, job->name, true);\n            if (rc == -1 && jobinfo[i]->status == QEMU_MONITOR_JOB_STATUS_CONCLUDED)\n                VIR_WARN(\"can't cancel job '%s' with invalid data\", job->name);\n\n            if (qemuDomainObjExitMonitor(driver, vm) < 0)\n                goto cleanup;\n\n            if (rc < 0)\n                qemuBlockJobUnregister(job, vm);\n            else\n                job->reconnected = true;\n            continue;\n        }\n\n        if ((newstate = qemuBlockjobConvertMonitorStatus(jobinfo[i]->status)) < 0)\n            continue;\n\n        if (newstate != job->state) {\n            if ((job->state == QEMU_BLOCKJOB_STATE_FAILED ||\n                 job->state == QEMU_BLOCKJOB_STATE_COMPLETED)) {\n                /* preserve the old state but allow the job to be bumped to\n                 * execute the finishing steps */\n                job->newstate = job->state;\n            } else if (newstate == QEMU_BLOCKJOB_STATE_CONCLUDED) {\n                job->errmsg = g_strdup(jobinfo[i]->error);\n\n                if (job->errmsg)\n                    job->newstate = QEMU_BLOCKJOB_STATE_FAILED;\n                else\n                    job->newstate = QEMU_BLOCKJOB_STATE_COMPLETED;\n            } else if (newstate == QEMU_BLOCKJOB_STATE_READY) {\n                /* Apply _READY state only if it was not applied before */\n                if (job->state == QEMU_BLOCKJOB_STATE_NEW ||\n                    job->state == QEMU_BLOCKJOB_STATE_RUNNING)\n                    job->newstate = newstate;\n            }\n            /* don't update the job otherwise */\n        }\n\n        job->reconnected = true;\n\n        if (job->newstate != -1)\n            qemuBlockJobUpdate(vm, job, QEMU_ASYNC_JOB_NONE);\n    }\n\n    /* remove data for job which qemu didn't report (the algorithm is\n     * inefficient, but the possibility of such jobs is very low */\n    while ((job = virHashSearch(priv->blockjobs, qemuBlockJobRefreshJobsFindInactive, NULL, NULL))) {\n        VIR_WARN(\"dropping blockjob '%s' untracked by qemu\", job->name);\n        qemuBlockJobUnregister(job, vm);\n    }\n\n    ret = 0;\n\n cleanup:\n    for (i = 0; i < njobinfo; i++)\n        qemuMonitorJobInfoFree(jobinfo[i]);\n    VIR_FREE(jobinfo);\n\n    return ret;\n}"
  },
  {
    "function_name": "qemuBlockJobRefreshJobsFindInactive",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "484-492",
    "snippet": "static int\nqemuBlockJobRefreshJobsFindInactive(const void *payload,\n                                    const void *name G_GNUC_UNUSED,\n                                    const void *data G_GNUC_UNUSED)\n{\n    const qemuBlockJobData *job = payload;\n\n    return !job->reconnected;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nqemuBlockJobRefreshJobsFindInactive(const void *payload,\n                                    const void *name G_GNUC_UNUSED,\n                                    const void *data G_GNUC_UNUSED)\n{\n    const qemuBlockJobData *job = payload;\n\n    return !job->reconnected;\n}"
  },
  {
    "function_name": "qemuBlockJobIsRunning",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "473-480",
    "snippet": "bool\nqemuBlockJobIsRunning(qemuBlockJobDataPtr job)\n{\n    return job->state == QEMU_BLOCKJOB_STATE_RUNNING ||\n           job->state == QEMU_BLOCKJOB_STATE_READY ||\n           job->state == QEMU_BLOCKJOB_STATE_ABORTING ||\n           job->state == QEMU_BLOCKJOB_STATE_PIVOTING;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nbool\nqemuBlockJobIsRunning(qemuBlockJobDataPtr job)\n{\n    return job->state == QEMU_BLOCKJOB_STATE_RUNNING ||\n           job->state == QEMU_BLOCKJOB_STATE_READY ||\n           job->state == QEMU_BLOCKJOB_STATE_ABORTING ||\n           job->state == QEMU_BLOCKJOB_STATE_PIVOTING;\n}"
  },
  {
    "function_name": "qemuBlockJobStartupFinalize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "459-470",
    "snippet": "void\nqemuBlockJobStartupFinalize(virDomainObjPtr vm,\n                            qemuBlockJobDataPtr job)\n{\n    if (!job)\n        return;\n\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        qemuBlockJobUnregister(job, vm);\n\n    virObjectUnref(job);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobUnregister",
          "args": [
            "job",
            "vm"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobUnregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "201-223",
          "snippet": "static void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nqemuBlockJobStartupFinalize(virDomainObjPtr vm,\n                            qemuBlockJobDataPtr job)\n{\n    if (!job)\n        return;\n\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        qemuBlockJobUnregister(job, vm);\n\n    virObjectUnref(job);\n}"
  },
  {
    "function_name": "qemuBlockJobStarted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "440-448",
    "snippet": "void\nqemuBlockJobStarted(qemuBlockJobDataPtr job,\n                    virDomainObjPtr vm)\n{\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        job->state = QEMU_BLOCKJOB_STATE_RUNNING;\n\n    qemuDomainSaveStatus(vm);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainSaveStatus",
          "args": [
            "vm"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9569-9573",
          "snippet": "void\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nvoid\nqemuBlockJobStarted(qemuBlockJobDataPtr job,\n                    virDomainObjPtr vm)\n{\n    if (job->state == QEMU_BLOCKJOB_STATE_NEW)\n        job->state = QEMU_BLOCKJOB_STATE_RUNNING;\n\n    qemuDomainSaveStatus(vm);\n}"
  },
  {
    "function_name": "qemuBlockJobDiskGetJob",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "422-431",
    "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "job"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskGetJob(virDomainDiskDefPtr disk)\n{\n    qemuBlockJobDataPtr job = QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob;\n\n    if (!job)\n        return NULL;\n\n    return virObjectRef(job);\n}"
  },
  {
    "function_name": "qemuBlockJobDiskNewBackup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "390-413",
    "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskNewBackup(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr store,\n                          const char *bitmap)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n\n    jobname = g_strdup_printf(\"backup-%s-%s\", disk->dst, disk->src->nodeformat);\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_BACKUP, jobname)))\n        return NULL;\n\n    job->data.backup.bitmap = g_strdup(bitmap);\n    job->data.backup.store = virObjectRef(store);\n\n    /* backup jobs are usually started in bulk by transaction so the caller\n     * shall save the status XML */\n    if (qemuBlockJobRegister(job, vm, disk, false) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&job"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockJobRegister",
          "args": [
            "job",
            "vm",
            "disk",
            "false"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "169-198",
          "snippet": "int\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "store"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "bitmap"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDataNew",
          "args": [
            "QEMU_BLOCKJOB_TYPE_BACKUP",
            "jobname"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "117-136",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr qemuBlockJobDataClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virClassPtr qemuBlockJobDataClass;\n\nqemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskNewBackup(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr store,\n                          const char *bitmap)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n\n    jobname = g_strdup_printf(\"backup-%s-%s\", disk->dst, disk->src->nodeformat);\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_BACKUP, jobname)))\n        return NULL;\n\n    job->data.backup.bitmap = g_strdup(bitmap);\n    job->data.backup.store = virObjectRef(store);\n\n    /* backup jobs are usually started in bulk by transaction so the caller\n     * shall save the status XML */\n    if (qemuBlockJobRegister(job, vm, disk, false) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}"
  },
  {
    "function_name": "qemuBlockJobDiskNewCopy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "354-387",
    "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskNewCopy(virDomainObjPtr vm,\n                        virDomainDiskDefPtr disk,\n                        virStorageSourcePtr mirror,\n                        bool shallow,\n                        bool reuse,\n                        unsigned int jobflags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        jobname = g_strdup_printf(\"copy-%s-%s\", disk->dst, disk->src->nodeformat);\n    } else {\n        if (!(jobname = qemuAliasDiskDriveFromDisk(disk)))\n            return NULL;\n    }\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_COPY, jobname)))\n        return NULL;\n\n    job->mirrorChain = virObjectRef(mirror);\n\n    if (shallow && !reuse)\n        job->data.copy.shallownew = true;\n\n    job->jobflags = jobflags;\n\n    if (qemuBlockJobRegister(job, vm, disk, true) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&job"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockJobRegister",
          "args": [
            "job",
            "vm",
            "disk",
            "true"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "169-198",
          "snippet": "int\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "mirror"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDataNew",
          "args": [
            "QEMU_BLOCKJOB_TYPE_COPY",
            "jobname"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "117-136",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr qemuBlockJobDataClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virClassPtr qemuBlockJobDataClass;\n\nqemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuAliasDiskDriveFromDisk",
          "args": [
            "disk"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "qemuAliasDiskDriveFromDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_alias.c",
          "lines": "696-709",
          "snippet": "char *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_alias.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QEMU_DRIVE_HOST_PREFIX \"drive-\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_alias.h\"\n#include <config.h>\n\n#define QEMU_DRIVE_HOST_PREFIX \"drive-\"\n\nchar *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"copy-%s-%s\"",
            "disk->dst",
            "disk->src->nodeformat"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_BLOCKDEV"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskNewCopy(virDomainObjPtr vm,\n                        virDomainDiskDefPtr disk,\n                        virStorageSourcePtr mirror,\n                        bool shallow,\n                        bool reuse,\n                        unsigned int jobflags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        jobname = g_strdup_printf(\"copy-%s-%s\", disk->dst, disk->src->nodeformat);\n    } else {\n        if (!(jobname = qemuAliasDiskDriveFromDisk(disk)))\n            return NULL;\n    }\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_COPY, jobname)))\n        return NULL;\n\n    job->mirrorChain = virObjectRef(mirror);\n\n    if (shallow && !reuse)\n        job->data.copy.shallownew = true;\n\n    job->jobflags = jobflags;\n\n    if (qemuBlockJobRegister(job, vm, disk, true) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}"
  },
  {
    "function_name": "qemuBlockJobNewCreate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "324-351",
    "snippet": "qemuBlockJobDataPtr\nqemuBlockJobNewCreate(virDomainObjPtr vm,\n                      virStorageSourcePtr src,\n                      virStorageSourcePtr chain,\n                      bool storage)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n    const char *nodename = src->nodeformat;\n\n    if (storage)\n        nodename = src->nodestorage;\n\n    jobname = g_strdup_printf(\"create-%s\", nodename);\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_CREATE, jobname)))\n        return NULL;\n\n    if (virStorageSourceIsBacking(chain))\n        job->chain = virObjectRef(chain);\n\n     job->data.create.src = virObjectRef(src);\n\n    if (qemuBlockJobRegister(job, vm, NULL, true) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&job"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockJobRegister",
          "args": [
            "job",
            "vm",
            "NULL",
            "true"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "169-198",
          "snippet": "int\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "src"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virStorageSourceIsBacking",
          "args": [
            "chain"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "virStorageSourceIsBacking",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virstoragefile.c",
          "lines": "1581-1585",
          "snippet": "bool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsecret.h\"",
            "#include \"virstorageencryption.h\"",
            "#include \"virjson.h\"",
            "#include \"virbuffer.h\"",
            "#include \"viruri.h\"",
            "#include \"virstring.h\"",
            "#include \"virendian.h\"",
            "#include \"virhash.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viruuid.h\"",
            "#include \"virxml.h\"",
            "#include \"viralloc.h\"",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include \"virstoragefilebackend.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsecret.h\"\n#include \"virstorageencryption.h\"\n#include \"virjson.h\"\n#include \"virbuffer.h\"\n#include \"viruri.h\"\n#include \"virstring.h\"\n#include \"virendian.h\"\n#include \"virhash.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viruuid.h\"\n#include \"virxml.h\"\n#include \"viralloc.h\"\n#include <fcntl.h>\n#include <unistd.h>\n#include \"virstoragefilebackend.h\"\n#include <config.h>\n\nbool\nvirStorageSourceIsBacking(const virStorageSource *src)\n{\n    return src && src->type != VIR_STORAGE_TYPE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDataNew",
          "args": [
            "QEMU_BLOCKJOB_TYPE_CREATE",
            "jobname"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "117-136",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr qemuBlockJobDataClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virClassPtr qemuBlockJobDataClass;\n\nqemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"create-%s\"",
            "nodename"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobNewCreate(virDomainObjPtr vm,\n                      virStorageSourcePtr src,\n                      virStorageSourcePtr chain,\n                      bool storage)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n    const char *nodename = src->nodeformat;\n\n    if (storage)\n        nodename = src->nodestorage;\n\n    jobname = g_strdup_printf(\"create-%s\", nodename);\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_CREATE, jobname)))\n        return NULL;\n\n    if (virStorageSourceIsBacking(chain))\n        job->chain = virObjectRef(chain);\n\n     job->data.create.src = virObjectRef(src);\n\n    if (qemuBlockJobRegister(job, vm, NULL, true) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}"
  },
  {
    "function_name": "qemuBlockJobDiskNewCommit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "282-321",
    "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskNewCommit(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr topparent,\n                          virStorageSourcePtr top,\n                          virStorageSourcePtr base,\n                          char ***disabledBitmapsBase,\n                          bool delete_imgs,\n                          unsigned int jobflags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n    qemuBlockJobType jobtype = QEMU_BLOCKJOB_TYPE_COMMIT;\n\n    if (topparent == NULL)\n        jobtype = QEMU_BLOCKJOB_TYPE_ACTIVE_COMMIT;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        jobname = g_strdup_printf(\"commit-%s-%s\", disk->dst, top->nodeformat);\n    } else {\n        if (!(jobname = qemuAliasDiskDriveFromDisk(disk)))\n            return NULL;\n    }\n\n    if (!(job = qemuBlockJobDataNew(jobtype, jobname)))\n        return NULL;\n\n    job->data.commit.topparent = topparent;\n    job->data.commit.top = top;\n    job->data.commit.base = base;\n    job->data.commit.deleteCommittedImages = delete_imgs;\n    job->data.commit.disabledBitmapsBase = g_steal_pointer(disabledBitmapsBase);\n    job->jobflags = jobflags;\n\n    if (qemuBlockJobRegister(job, vm, disk, true) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&job"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockJobRegister",
          "args": [
            "job",
            "vm",
            "disk",
            "true"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "169-198",
          "snippet": "int\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "disabledBitmapsBase"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDataNew",
          "args": [
            "jobtype",
            "jobname"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "117-136",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr qemuBlockJobDataClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virClassPtr qemuBlockJobDataClass;\n\nqemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuAliasDiskDriveFromDisk",
          "args": [
            "disk"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "qemuAliasDiskDriveFromDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_alias.c",
          "lines": "696-709",
          "snippet": "char *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_alias.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QEMU_DRIVE_HOST_PREFIX \"drive-\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_alias.h\"\n#include <config.h>\n\n#define QEMU_DRIVE_HOST_PREFIX \"drive-\"\n\nchar *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"commit-%s-%s\"",
            "disk->dst",
            "top->nodeformat"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_BLOCKDEV"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskNewCommit(virDomainObjPtr vm,\n                          virDomainDiskDefPtr disk,\n                          virStorageSourcePtr topparent,\n                          virStorageSourcePtr top,\n                          virStorageSourcePtr base,\n                          char ***disabledBitmapsBase,\n                          bool delete_imgs,\n                          unsigned int jobflags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n    qemuBlockJobType jobtype = QEMU_BLOCKJOB_TYPE_COMMIT;\n\n    if (topparent == NULL)\n        jobtype = QEMU_BLOCKJOB_TYPE_ACTIVE_COMMIT;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        jobname = g_strdup_printf(\"commit-%s-%s\", disk->dst, top->nodeformat);\n    } else {\n        if (!(jobname = qemuAliasDiskDriveFromDisk(disk)))\n            return NULL;\n    }\n\n    if (!(job = qemuBlockJobDataNew(jobtype, jobname)))\n        return NULL;\n\n    job->data.commit.topparent = topparent;\n    job->data.commit.top = top;\n    job->data.commit.base = base;\n    job->data.commit.deleteCommittedImages = delete_imgs;\n    job->data.commit.disabledBitmapsBase = g_steal_pointer(disabledBitmapsBase);\n    job->jobflags = jobflags;\n\n    if (qemuBlockJobRegister(job, vm, disk, true) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}"
  },
  {
    "function_name": "qemuBlockJobDiskNewPull",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "252-279",
    "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskNewPull(virDomainObjPtr vm,\n                        virDomainDiskDefPtr disk,\n                        virStorageSourcePtr base,\n                        unsigned int jobflags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        jobname = g_strdup_printf(\"pull-%s-%s\", disk->dst, disk->src->nodeformat);\n    } else {\n        if (!(jobname = qemuAliasDiskDriveFromDisk(disk)))\n            return NULL;\n    }\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_PULL, jobname)))\n        return NULL;\n\n    job->data.pull.base = base;\n    job->jobflags = jobflags;\n\n    if (qemuBlockJobRegister(job, vm, disk, true) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&job"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockJobRegister",
          "args": [
            "job",
            "vm",
            "disk",
            "true"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "169-198",
          "snippet": "int\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDataNew",
          "args": [
            "QEMU_BLOCKJOB_TYPE_PULL",
            "jobname"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "117-136",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr qemuBlockJobDataClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virClassPtr qemuBlockJobDataClass;\n\nqemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuAliasDiskDriveFromDisk",
          "args": [
            "disk"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "qemuAliasDiskDriveFromDisk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_alias.c",
          "lines": "696-709",
          "snippet": "char *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_alias.h\"",
            "#include <config.h>"
          ],
          "macros_used": [
            "#define QEMU_DRIVE_HOST_PREFIX \"drive-\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_alias.h\"\n#include <config.h>\n\n#define QEMU_DRIVE_HOST_PREFIX \"drive-\"\n\nchar *\nqemuAliasDiskDriveFromDisk(const virDomainDiskDef *disk)\n{\n    char *ret;\n\n    if (!disk->info.alias) {\n        virReportError(VIR_ERR_INVALID_ARG, \"%s\",\n                       _(\"disk does not have an alias\"));\n        return NULL;\n    }\n\n    ret = g_strdup_printf(\"%s%s\", QEMU_DRIVE_HOST_PREFIX, disk->info.alias);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"pull-%s-%s\"",
            "disk->dst",
            "disk->src->nodeformat"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virQEMUCapsGet",
          "args": [
            "priv->qemuCaps",
            "QEMU_CAPS_BLOCKDEV"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "virQEMUCapsGetPreferredMachine",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_capabilities.c",
          "lines": "5555-5564",
          "snippet": "const char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}",
          "includes": [
            "#include <sys/utsname.h>",
            "#include <stdarg.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"virutil.h\"",
            "#include \"qemu_firmware.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_qapi.h\"",
            "#include \"qemu_capspriv.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"virstring.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virnuma.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virbitmap.h\"",
            "#include \"vircommand.h\"",
            "#include \"domain_conf.h\"",
            "#include \"cpu/cpu_x86.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virfilecache.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"vircrypto.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <sys/utsname.h>\n#include <stdarg.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"virutil.h\"\n#include \"qemu_firmware.h\"\n#include \"qemu_process.h\"\n#include \"qemu_qapi.h\"\n#include \"qemu_capspriv.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_hostdev.h\"\n#include \"virstring.h\"\n#include \"qemu_monitor.h\"\n#include \"virhostcpu.h\"\n#include \"virnuma.h\"\n#include \"virnodesuspend.h\"\n#include \"virbitmap.h\"\n#include \"vircommand.h\"\n#include \"domain_conf.h\"\n#include \"cpu/cpu_x86.h\"\n#include \"cpu/cpu.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virfilecache.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"vircrypto.h\"\n#include \"viralloc.h\"\n#include \"qemu_capabilities.h\"\n#include <config.h>\n\nconst char *\nvirQEMUCapsGetPreferredMachine(virQEMUCapsPtr qemuCaps,\n                               virDomainVirtType virtType)\n{\n    virQEMUCapsAccelPtr accel = virQEMUCapsGetAccel(qemuCaps, virtType);\n\n    if (!accel->nmachineTypes)\n        return NULL;\n    return accel->machineTypes[0].name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskNewPull(virDomainObjPtr vm,\n                        virDomainDiskDefPtr disk,\n                        virStorageSourcePtr base,\n                        unsigned int jobflags)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    g_autoptr(qemuBlockJobData) job = NULL;\n    g_autofree char *jobname = NULL;\n\n    if (virQEMUCapsGet(priv->qemuCaps, QEMU_CAPS_BLOCKDEV)) {\n        jobname = g_strdup_printf(\"pull-%s-%s\", disk->dst, disk->src->nodeformat);\n    } else {\n        if (!(jobname = qemuAliasDiskDriveFromDisk(disk)))\n            return NULL;\n    }\n\n    if (!(job = qemuBlockJobDataNew(QEMU_BLOCKJOB_TYPE_PULL, jobname)))\n        return NULL;\n\n    job->data.pull.base = base;\n    job->jobflags = jobflags;\n\n    if (qemuBlockJobRegister(job, vm, disk, true) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}"
  },
  {
    "function_name": "qemuBlockJobDiskNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "234-249",
    "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDiskNew(virDomainObjPtr vm,\n                    virDomainDiskDefPtr disk,\n                    qemuBlockJobType type,\n                    const char *jobname)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (!(job = qemuBlockJobDataNew(type, jobname)))\n        return NULL;\n\n    if (qemuBlockJobRegister(job, vm, disk, true) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&job"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockJobRegister",
          "args": [
            "job",
            "vm",
            "disk",
            "true"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobRegister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "169-198",
          "snippet": "int\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDataNew",
          "args": [
            "type",
            "jobname"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDataNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "117-136",
          "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr qemuBlockJobDataClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virClassPtr qemuBlockJobDataClass;\n\nqemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nqemuBlockJobDataPtr\nqemuBlockJobDiskNew(virDomainObjPtr vm,\n                    virDomainDiskDefPtr disk,\n                    qemuBlockJobType type,\n                    const char *jobname)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (!(job = qemuBlockJobDataNew(type, jobname)))\n        return NULL;\n\n    if (qemuBlockJobRegister(job, vm, disk, true) < 0)\n        return NULL;\n\n    return g_steal_pointer(&job);\n}"
  },
  {
    "function_name": "qemuBlockJobUnregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "201-223",
    "snippet": "static void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainSaveStatus",
          "args": [
            "vm"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9569-9573",
          "snippet": "void\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashRemoveEntry",
          "args": [
            "priv->blockjobs",
            "job->name"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "virHashRemoveEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "584-609",
          "snippet": "int\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashRemoveEntry(virHashTablePtr table, const void *name)\n{\n    virHashEntryPtr entry;\n    virHashEntryPtr *nextptr;\n\n    if (table == NULL || name == NULL)\n        return -1;\n\n    nextptr = table->table + virHashComputeKey(table, name);\n    for (entry = *nextptr; entry; entry = entry->next) {\n        if (table->keyEqual(entry->name, name)) {\n            if (table->dataFree)\n                table->dataFree(entry->payload);\n            if (table->keyFree)\n                table->keyFree(entry->name);\n            *nextptr = entry->next;\n            VIR_FREE(entry);\n            table->nbElems--;\n            return 0;\n        }\n        nextptr = &entry->next;\n    }\n\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "diskPriv->blockjob"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "job->disk"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobUnregister(qemuBlockJobDataPtr job,\n                       virDomainObjPtr vm)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n    qemuDomainDiskPrivatePtr diskPriv;\n\n    if (job->disk) {\n        diskPriv = QEMU_DOMAIN_DISK_PRIVATE(job->disk);\n\n        if (job == diskPriv->blockjob) {\n            virObjectUnref(diskPriv->blockjob);\n            diskPriv->blockjob = NULL;\n        }\n\n        job->disk = NULL;\n    }\n\n    /* this may remove the last reference of 'job' */\n    virHashRemoveEntry(priv->blockjobs, job->name);\n\n    qemuDomainSaveStatus(vm);\n}"
  },
  {
    "function_name": "qemuBlockJobRegister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "169-198",
    "snippet": "int\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuDomainSaveStatus",
          "args": [
            "vm"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "qemuDomainSaveStatus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_domain.c",
          "lines": "9569-9573",
          "snippet": "void\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}",
          "includes": [
            "# include <selinux/selinux.h>",
            "# include <sys/mount.h>",
            "#include <fcntl.h>",
            "#include <sys/time.h>",
            "# include <sys/sysmacros.h>",
            "#include \"virdevmapper.h\"",
            "#include \"virutil.h\"",
            "#include \"backup_conf.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"logging/log_manager.h\"",
            "#include \"virsecret.h\"",
            "#include \"virsystemd.h\"",
            "#include \"virrandom.h\"",
            "#include \"vircrypto.h\"",
            "#include \"virprocess.h\"",
            "#include \"virthreadjob.h\"",
            "#include \"virstring.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virtime.h\"",
            "#include \"domain_event.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"domain_addr.h\"",
            "#include \"virfile.h\"",
            "#include \"viruuid.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virerror.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_extdevice.h\"",
            "#include \"qemu_slirp.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_dbus.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void qemuDomainLogContextFinalize(GObject *obj);",
            "static void qemuDomainSaveCookieDispose(void *obj);",
            "static void qemuDomainDiskPrivateDispose(void *obj);",
            "static void qemuDomainStorageSourcePrivateDispose(void *obj);",
            "static void qemuDomainVcpuPrivateDispose(void *obj);",
            "static void qemuDomainChrSourcePrivateDispose(void *obj);",
            "static void qemuDomainVsockPrivateDispose(void *obj);",
            "static void qemuDomainGraphicsPrivateDispose(void *obj);",
            "static void qemuDomainNetworkPrivateDispose(void *obj);",
            "static void qemuDomainFSPrivateDispose(void *obj);",
            "static void qemuDomainVideoPrivateDispose(void *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "# include <selinux/selinux.h>\n# include <sys/mount.h>\n#include <fcntl.h>\n#include <sys/time.h>\n# include <sys/sysmacros.h>\n#include \"virdevmapper.h\"\n#include \"virutil.h\"\n#include \"backup_conf.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"locking/domain_lock.h\"\n#include \"logging/log_manager.h\"\n#include \"virsecret.h\"\n#include \"virsystemd.h\"\n#include \"virrandom.h\"\n#include \"vircrypto.h\"\n#include \"virprocess.h\"\n#include \"virthreadjob.h\"\n#include \"virstring.h\"\n#include \"virstoragefile.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virtime.h\"\n#include \"domain_event.h\"\n#include \"domain_capabilities.h\"\n#include \"domain_addr.h\"\n#include \"virfile.h\"\n#include \"viruuid.h\"\n#include \"cpu/cpu.h\"\n#include \"virerror.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_extdevice.h\"\n#include \"qemu_slirp.h\"\n#include \"qemu_security.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_process.h\"\n#include \"qemu_dbus.h\"\n#include \"qemu_command.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include <config.h>\n\nstatic void qemuDomainLogContextFinalize(GObject *obj);\nstatic void qemuDomainSaveCookieDispose(void *obj);\nstatic void qemuDomainDiskPrivateDispose(void *obj);\nstatic void qemuDomainStorageSourcePrivateDispose(void *obj);\nstatic void qemuDomainVcpuPrivateDispose(void *obj);\nstatic void qemuDomainChrSourcePrivateDispose(void *obj);\nstatic void qemuDomainVsockPrivateDispose(void *obj);\nstatic void qemuDomainGraphicsPrivateDispose(void *obj);\nstatic void qemuDomainNetworkPrivateDispose(void *obj);\nstatic void qemuDomainFSPrivateDispose(void *obj);\nstatic void qemuDomainVideoPrivateDispose(void *obj);\n\nvoid\nqemuDomainSaveStatus(virDomainObjPtr obj)\n{\n    qemuDomainObjSaveStatus(QEMU_DOMAIN_PRIVATE(obj)->driver, obj);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectRef",
          "args": [
            "job"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectRef",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "377-387",
          "snippet": "void *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nvoid *\nvirObjectRef(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return NULL;\n    g_atomic_int_add(&obj->u.s.refs, 1);\n    PROBE(OBJECT_REF, \"obj=%p\", obj);\n    return anyobj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virHashAddEntry",
          "args": [
            "priv->blockjobs",
            "job->name",
            "virObjectRef(job)"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "virHashAddEntry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virhash.c",
          "lines": "404-408",
          "snippet": "int\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}",
          "includes": [
            "#include \"virobject.h\"",
            "#include \"virstring.h\"",
            "#include \"virrandom.h\"",
            "#include \"virhashcode.h\"",
            "#include \"virlog.h\"",
            "#include \"viralloc.h\"",
            "#include \"virhash.h\"",
            "#include \"virerror.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virobject.h\"\n#include \"virstring.h\"\n#include \"virrandom.h\"\n#include \"virhashcode.h\"\n#include \"virlog.h\"\n#include \"viralloc.h\"\n#include \"virhash.h\"\n#include \"virerror.h\"\n#include <config.h>\n\nint\nvirHashAddEntry(virHashTablePtr table, const void *name, void *userdata)\n{\n    return virHashAddOrUpdateEntry(table, name, userdata, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "_(\"disk '%s' has a blockjob assigned\")",
            "disk->dst"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"disk '%s' has a blockjob assigned\""
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "bswap_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_driver.c",
          "lines": "2852-2860",
          "snippet": "static inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}",
          "includes": [
            "#include \"virutil.h\"",
            "#include \"virsocket.h\"",
            "#include \"virdomaincheckpointobjlist.h\"",
            "#include \"virenum.h\"",
            "#include \"virdomainsnapshotobjlist.h\"",
            "#include \"virqemu.h\"",
            "#include \"netdev_bandwidth_conf.h\"",
            "#include \"virnuma.h\"",
            "#include \"virperf.h\"",
            "#include \"vircgroup.h\"",
            "#include \"domain_capabilities.h\"",
            "#include \"virhostdev.h\"",
            "#include \"viraccessapicheckqemu.h\"",
            "#include \"viraccessapicheck.h\"",
            "#include \"virstring.h\"",
            "#include \"virbitmap.h\"",
            "#include \"virtypedparam.h\"",
            "#include \"virtime.h\"",
            "#include \"virnodesuspend.h\"",
            "#include \"virkeycode.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"locking/lock_manager.h\"",
            "#include \"virthreadpool.h\"",
            "#include \"configmake.h\"",
            "#include \"virfdstream.h\"",
            "#include \"virfile.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virhook.h\"",
            "#include \"domain_nwfilter.h\"",
            "#include \"virsysinfo.h\"",
            "#include \"cpu/cpu.h\"",
            "#include \"virxml.h\"",
            "#include \"libvirt_internal.h\"",
            "#include \"virprocess.h\"",
            "#include \"virpidfile.h\"",
            "#include \"virusb.h\"",
            "#include \"virpci.h\"",
            "#include \"node_device_conf.h\"",
            "#include \"domain_driver.h\"",
            "#include \"domain_cgroup.h\"",
            "#include \"domain_audit.h\"",
            "#include \"domain_conf.h\"",
            "#include \"viruuid.h\"",
            "#include \"virarptable.h\"",
            "#include \"viralloc.h\"",
            "#include \"capabilities.h\"",
            "#include \"virnetdevopenvswitch.h\"",
            "#include \"virnetdevtap.h\"",
            "#include \"virhostmem.h\"",
            "#include \"virhostcpu.h\"",
            "#include \"virbuffer.h\"",
            "#include \"datatypes.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_checkpoint.h\"",
            "#include \"qemu_security.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"qemu_migration_params.h\"",
            "#include \"qemu_migration.h\"",
            "#include \"qemu_process.h\"",
            "#include \"qemu_monitor.h\"",
            "#include \"qemu_hotplug.h\"",
            "#include \"qemu_hostdev.h\"",
            "#include \"qemu_cgroup.h\"",
            "#include \"qemu_command.h\"",
            "#include \"qemu_capabilities.h\"",
            "#include \"qemu_conf.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_agent.h\"",
            "#include \"qemu_driver.h\"",
            "#include <sys/ioctl.h>",
            "#include <signal.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <stdarg.h>",
            "#include <dirent.h>",
            "#include <sys/time.h>",
            "#include <sys/poll.h>",
            "#include <sys/types.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virutil.h\"\n#include \"virsocket.h\"\n#include \"virdomaincheckpointobjlist.h\"\n#include \"virenum.h\"\n#include \"virdomainsnapshotobjlist.h\"\n#include \"virqemu.h\"\n#include \"netdev_bandwidth_conf.h\"\n#include \"virnuma.h\"\n#include \"virperf.h\"\n#include \"vircgroup.h\"\n#include \"domain_capabilities.h\"\n#include \"virhostdev.h\"\n#include \"viraccessapicheckqemu.h\"\n#include \"viraccessapicheck.h\"\n#include \"virstring.h\"\n#include \"virbitmap.h\"\n#include \"virtypedparam.h\"\n#include \"virtime.h\"\n#include \"virnodesuspend.h\"\n#include \"virkeycode.h\"\n#include \"locking/domain_lock.h\"\n#include \"locking/lock_manager.h\"\n#include \"virthreadpool.h\"\n#include \"configmake.h\"\n#include \"virfdstream.h\"\n#include \"virfile.h\"\n#include \"virstoragefile.h\"\n#include \"virhook.h\"\n#include \"domain_nwfilter.h\"\n#include \"virsysinfo.h\"\n#include \"cpu/cpu.h\"\n#include \"virxml.h\"\n#include \"libvirt_internal.h\"\n#include \"virprocess.h\"\n#include \"virpidfile.h\"\n#include \"virusb.h\"\n#include \"virpci.h\"\n#include \"node_device_conf.h\"\n#include \"domain_driver.h\"\n#include \"domain_cgroup.h\"\n#include \"domain_audit.h\"\n#include \"domain_conf.h\"\n#include \"viruuid.h\"\n#include \"virarptable.h\"\n#include \"viralloc.h\"\n#include \"capabilities.h\"\n#include \"virnetdevopenvswitch.h\"\n#include \"virnetdevtap.h\"\n#include \"virhostmem.h\"\n#include \"virhostcpu.h\"\n#include \"virbuffer.h\"\n#include \"datatypes.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_checkpoint.h\"\n#include \"qemu_security.h\"\n#include \"qemu_blockjob.h\"\n#include \"qemu_migration_params.h\"\n#include \"qemu_migration.h\"\n#include \"qemu_process.h\"\n#include \"qemu_monitor.h\"\n#include \"qemu_hotplug.h\"\n#include \"qemu_hostdev.h\"\n#include \"qemu_cgroup.h\"\n#include \"qemu_command.h\"\n#include \"qemu_capabilities.h\"\n#include \"qemu_conf.h\"\n#include \"qemu_block.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_agent.h\"\n#include \"qemu_driver.h\"\n#include <sys/ioctl.h>\n#include <signal.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <stdarg.h>\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/poll.h>\n#include <sys/types.h>\n#include <config.h>\n\nstatic inline void\nbswap_header(virQEMUSaveHeaderPtr hdr)\n{\n    hdr->version = GUINT32_SWAP_LE_BE(hdr->version);\n    hdr->data_len = GUINT32_SWAP_LE_BE(hdr->data_len);\n    hdr->was_running = GUINT32_SWAP_LE_BE(hdr->was_running);\n    hdr->compressed = GUINT32_SWAP_LE_BE(hdr->compressed);\n    hdr->cookieOffset = GUINT32_SWAP_LE_BE(hdr->cookieOffset);\n}"
        }
      },
      {
        "call_info": {
          "callee": "QEMU_DOMAIN_DISK_PRIVATE",
          "args": [
            "disk"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nint\nqemuBlockJobRegister(qemuBlockJobDataPtr job,\n                     virDomainObjPtr vm,\n                     virDomainDiskDefPtr disk,\n                     bool savestatus)\n{\n    qemuDomainObjPrivatePtr priv = vm->privateData;\n\n    if (disk && QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"disk '%s' has a blockjob assigned\"), disk->dst);\n        return -1;\n    }\n\n    if (virHashAddEntry(priv->blockjobs, job->name, virObjectRef(job)) < 0) {\n        virObjectUnref(job);\n        return -1;\n    }\n\n    if (disk) {\n        job->disk = disk;\n        job->chain = virObjectRef(disk->src);\n        QEMU_DOMAIN_DISK_PRIVATE(disk)->blockjob = virObjectRef(job);\n    }\n\n    if (savestatus)\n        qemuDomainSaveStatus(vm);\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuBlockJobMarkBroken",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "147-153",
    "snippet": "static void\nqemuBlockJobMarkBroken(qemuBlockJobDataPtr job)\n{\n    qemuBlockJobDataDisposeJobdata(job);\n    job->brokentype = job->type;\n    job->type = QEMU_BLOCKJOB_TYPE_BROKEN;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "qemuBlockJobDataDisposeJobdata",
          "args": [
            "job"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDataDisposeJobdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "77-87",
          "snippet": "static void\nqemuBlockJobDataDisposeJobdata(qemuBlockJobDataPtr job)\n{\n    if (job->type == QEMU_BLOCKJOB_TYPE_CREATE)\n        virObjectUnref(job->data.create.src);\n\n    if (job->type == QEMU_BLOCKJOB_TYPE_BACKUP) {\n        virObjectUnref(job->data.backup.store);\n        g_free(job->data.backup.bitmap);\n    }\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobDataDisposeJobdata(qemuBlockJobDataPtr job)\n{\n    if (job->type == QEMU_BLOCKJOB_TYPE_CREATE)\n        virObjectUnref(job->data.create.src);\n\n    if (job->type == QEMU_BLOCKJOB_TYPE_BACKUP) {\n        virObjectUnref(job->data.backup.store);\n        g_free(job->data.backup.bitmap);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobMarkBroken(qemuBlockJobDataPtr job)\n{\n    qemuBlockJobDataDisposeJobdata(job);\n    job->brokentype = job->type;\n    job->type = QEMU_BLOCKJOB_TYPE_BROKEN;\n}"
  },
  {
    "function_name": "qemuBlockJobDataNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "117-136",
    "snippet": "qemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static virClassPtr qemuBlockJobDataClass;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_steal_pointer",
          "args": [
            "&job"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "name"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectNew",
          "args": [
            "qemuBlockJobDataClass"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "236-253",
          "snippet": "void *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nvoid *\nvirObjectNew(virClassPtr klass)\n{\n    virObjectPtr obj = NULL;\n\n    if (VIR_ALLOC_VAR(obj,\n                      char,\n                      klass->objectSize - sizeof(virObject)) < 0)\n        return NULL;\n\n    obj->u.s.magic = klass->magic;\n    obj->klass = klass;\n    g_atomic_int_set(&obj->u.s.refs, 1);\n\n    PROBE(OBJECT_NEW, \"obj=%p classname=%s\", obj, obj->klass->name);\n\n    return obj;\n}"
        }
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDataInitialize",
          "args": [],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic virClassPtr qemuBlockJobDataClass;\n\nqemuBlockJobDataPtr\nqemuBlockJobDataNew(qemuBlockJobType type,\n                    const char *name)\n{\n    g_autoptr(qemuBlockJobData) job = NULL;\n\n    if (qemuBlockJobDataInitialize() < 0)\n        return NULL;\n\n    if (!(job = virObjectNew(qemuBlockJobDataClass)))\n        return NULL;\n\n    job->name = g_strdup(name);\n\n    job->state = QEMU_BLOCKJOB_STATE_NEW;\n    job->newstate = -1;\n    job->type = type;\n\n    return g_steal_pointer(&job);\n}"
  },
  {
    "function_name": "qemuBlockJobDataOnceInit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "105-112",
    "snippet": "static int\nqemuBlockJobDataOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(qemuBlockJobData, virClassForObject()))\n        return -1;\n\n    return 0;\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_CLASS_NEW",
          "args": [
            "qemuBlockJobData",
            "virClassForObject()"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virClassForObject",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "virClassForObjectRWLockable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "131-138",
          "snippet": "virClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virObjectRWLockableClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic virClassPtr virObjectRWLockableClass;\n\nvirClassPtr\nvirClassForObjectRWLockable(void)\n{\n    if (virObjectInitialize() < 0)\n        return NULL;\n\n    return virObjectRWLockableClass;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic int\nqemuBlockJobDataOnceInit(void)\n{\n    if (!VIR_CLASS_NEW(qemuBlockJobData, virClassForObject()))\n        return -1;\n\n    return 0;\n}"
  },
  {
    "function_name": "qemuBlockJobDataDispose",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "90-102",
    "snippet": "static void\nqemuBlockJobDataDispose(void *obj)\n{\n    qemuBlockJobDataPtr job = obj;\n\n    virObjectUnref(job->chain);\n    virObjectUnref(job->mirrorChain);\n\n    qemuBlockJobDataDisposeJobdata(job);\n\n    g_free(job->name);\n    g_free(job->errmsg);\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "job->errmsg"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "job->name"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemuBlockJobDataDisposeJobdata",
          "args": [
            "job"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "qemuBlockJobDataDisposeJobdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
          "lines": "77-87",
          "snippet": "static void\nqemuBlockJobDataDisposeJobdata(qemuBlockJobDataPtr job)\n{\n    if (job->type == QEMU_BLOCKJOB_TYPE_CREATE)\n        virObjectUnref(job->data.create.src);\n\n    if (job->type == QEMU_BLOCKJOB_TYPE_BACKUP) {\n        virObjectUnref(job->data.backup.store);\n        g_free(job->data.backup.bitmap);\n    }\n}",
          "includes": [
            "#include \"qemu_security.h\"",
            "#include \"virstring.h\"",
            "#include \"viralloc.h\"",
            "#include \"locking/domain_lock.h\"",
            "#include \"virtime.h\"",
            "#include \"virthread.h\"",
            "#include \"virstoragefile.h\"",
            "#include \"virlog.h\"",
            "#include \"conf/domain_event.h\"",
            "#include \"conf/domain_conf.h\"",
            "#include \"qemu_backup.h\"",
            "#include \"qemu_alias.h\"",
            "#include \"qemu_domain.h\"",
            "#include \"qemu_block.h\"",
            "#include \"qemu_blockjob.h\"",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobDataDisposeJobdata(qemuBlockJobDataPtr job)\n{\n    if (job->type == QEMU_BLOCKJOB_TYPE_CREATE)\n        virObjectUnref(job->data.create.src);\n\n    if (job->type == QEMU_BLOCKJOB_TYPE_BACKUP) {\n        virObjectUnref(job->data.backup.store);\n        g_free(job->data.backup.bitmap);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job->mirrorChain"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobDataDispose(void *obj)\n{\n    qemuBlockJobDataPtr job = obj;\n\n    virObjectUnref(job->chain);\n    virObjectUnref(job->mirrorChain);\n\n    qemuBlockJobDataDisposeJobdata(job);\n\n    g_free(job->name);\n    g_free(job->errmsg);\n}"
  },
  {
    "function_name": "qemuBlockJobDataDisposeJobdata",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/qemu/qemu_blockjob.c",
    "lines": "77-87",
    "snippet": "static void\nqemuBlockJobDataDisposeJobdata(qemuBlockJobDataPtr job)\n{\n    if (job->type == QEMU_BLOCKJOB_TYPE_CREATE)\n        virObjectUnref(job->data.create.src);\n\n    if (job->type == QEMU_BLOCKJOB_TYPE_BACKUP) {\n        virObjectUnref(job->data.backup.store);\n        g_free(job->data.backup.bitmap);\n    }\n}",
    "includes": [
      "#include \"qemu_security.h\"",
      "#include \"virstring.h\"",
      "#include \"viralloc.h\"",
      "#include \"locking/domain_lock.h\"",
      "#include \"virtime.h\"",
      "#include \"virthread.h\"",
      "#include \"virstoragefile.h\"",
      "#include \"virlog.h\"",
      "#include \"conf/domain_event.h\"",
      "#include \"conf/domain_conf.h\"",
      "#include \"qemu_backup.h\"",
      "#include \"qemu_alias.h\"",
      "#include \"qemu_domain.h\"",
      "#include \"qemu_block.h\"",
      "#include \"qemu_blockjob.h\"",
      "#include \"internal.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "job->data.backup.bitmap"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "job->data.backup.store"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"qemu_security.h\"\n#include \"virstring.h\"\n#include \"viralloc.h\"\n#include \"locking/domain_lock.h\"\n#include \"virtime.h\"\n#include \"virthread.h\"\n#include \"virstoragefile.h\"\n#include \"virlog.h\"\n#include \"conf/domain_event.h\"\n#include \"conf/domain_conf.h\"\n#include \"qemu_backup.h\"\n#include \"qemu_alias.h\"\n#include \"qemu_domain.h\"\n#include \"qemu_block.h\"\n#include \"qemu_blockjob.h\"\n#include \"internal.h\"\n#include <config.h>\n\nstatic void\nqemuBlockJobDataDisposeJobdata(qemuBlockJobDataPtr job)\n{\n    if (job->type == QEMU_BLOCKJOB_TYPE_CREATE)\n        virObjectUnref(job->data.create.src);\n\n    if (job->type == QEMU_BLOCKJOB_TYPE_BACKUP) {\n        virObjectUnref(job->data.backup.store);\n        g_free(job->data.backup.bitmap);\n    }\n}"
  }
]