[
  {
    "function_name": "virLogManagerDomainAppendMessage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
    "lines": "272-303",
    "snippet": "int\nvirLogManagerDomainAppendMessage(virLogManagerPtr mgr,\n                                 const char *driver,\n                                 const unsigned char *domuuid,\n                                 const char *domname,\n                                 const char *path,\n                                 const char *message,\n                                 unsigned int flags)\n{\n    struct virLogManagerProtocolDomainAppendLogFileArgs args;\n    struct virLogManagerProtocolDomainAppendLogFileRet ret;\n\n    memset(&args, 0, sizeof(args));\n\n    args.driver = (char *)driver;\n    memcpy(args.dom.uuid, domuuid, VIR_UUID_BUFLEN);\n    args.dom.name = (char *)domname;\n    args.path = (char *)path;\n    args.message = (char *)message;\n    args.flags = flags;\n\n    if (virNetClientProgramCall(mgr->program,\n                                mgr->client,\n                                mgr->serial++,\n                                VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_APPEND_LOG_FILE,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainAppendLogFileArgs, &args,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainAppendLogFileRet, &ret) < 0)\n        return -1;\n\n    return ret.ret;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_manager.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientProgramCall",
          "args": [
            "mgr->program",
            "mgr->client",
            "mgr->serial++",
            "VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_APPEND_LOG_FILE",
            "0",
            "NULL",
            "NULL",
            "NULL",
            "(xdrproc_t)xdr_virLogManagerProtocolDomainAppendLogFileArgs",
            "&args",
            "(xdrproc_t)xdr_virLogManagerProtocolDomainAppendLogFileRet",
            "&ret"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "266-400",
          "snippet": "int virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "args.dom.uuid",
            "domuuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nint\nvirLogManagerDomainAppendMessage(virLogManagerPtr mgr,\n                                 const char *driver,\n                                 const unsigned char *domuuid,\n                                 const char *domname,\n                                 const char *path,\n                                 const char *message,\n                                 unsigned int flags)\n{\n    struct virLogManagerProtocolDomainAppendLogFileArgs args;\n    struct virLogManagerProtocolDomainAppendLogFileRet ret;\n\n    memset(&args, 0, sizeof(args));\n\n    args.driver = (char *)driver;\n    memcpy(args.dom.uuid, domuuid, VIR_UUID_BUFLEN);\n    args.dom.name = (char *)domname;\n    args.path = (char *)path;\n    args.message = (char *)message;\n    args.flags = flags;\n\n    if (virNetClientProgramCall(mgr->program,\n                                mgr->client,\n                                mgr->serial++,\n                                VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_APPEND_LOG_FILE,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainAppendLogFileArgs, &args,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainAppendLogFileRet, &ret) < 0)\n        return -1;\n\n    return ret.ret;\n}"
  },
  {
    "function_name": "virLogManagerDomainReadLogFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
    "lines": "239-269",
    "snippet": "char *\nvirLogManagerDomainReadLogFile(virLogManagerPtr mgr,\n                               const char *path,\n                               ino_t inode,\n                               off_t offset,\n                               size_t maxlen,\n                               unsigned int flags)\n{\n    struct virLogManagerProtocolDomainReadLogFileArgs args;\n    struct virLogManagerProtocolDomainReadLogFileRet ret;\n\n    memset(&args, 0, sizeof(args));\n    memset(&ret, 0, sizeof(ret));\n\n    args.path = (char *)path;\n    args.flags = flags;\n    args.pos.inode = inode;\n    args.pos.offset = offset;\n    args.maxlen = maxlen;\n\n    if (virNetClientProgramCall(mgr->program,\n                                mgr->client,\n                                mgr->serial++,\n                                VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_READ_LOG_FILE,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainReadLogFileArgs, &args,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainReadLogFileRet, &ret) < 0)\n        return NULL;\n\n    return ret.data;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_manager.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientProgramCall",
          "args": [
            "mgr->program",
            "mgr->client",
            "mgr->serial++",
            "VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_READ_LOG_FILE",
            "0",
            "NULL",
            "NULL",
            "NULL",
            "(xdrproc_t)xdr_virLogManagerProtocolDomainReadLogFileArgs",
            "&args",
            "(xdrproc_t)xdr_virLogManagerProtocolDomainReadLogFileRet",
            "&ret"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "266-400",
          "snippet": "int virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ret",
            "0",
            "sizeof(ret)"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nchar *\nvirLogManagerDomainReadLogFile(virLogManagerPtr mgr,\n                               const char *path,\n                               ino_t inode,\n                               off_t offset,\n                               size_t maxlen,\n                               unsigned int flags)\n{\n    struct virLogManagerProtocolDomainReadLogFileArgs args;\n    struct virLogManagerProtocolDomainReadLogFileRet ret;\n\n    memset(&args, 0, sizeof(args));\n    memset(&ret, 0, sizeof(ret));\n\n    args.path = (char *)path;\n    args.flags = flags;\n    args.pos.inode = inode;\n    args.pos.offset = offset;\n    args.maxlen = maxlen;\n\n    if (virNetClientProgramCall(mgr->program,\n                                mgr->client,\n                                mgr->serial++,\n                                VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_READ_LOG_FILE,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainReadLogFileArgs, &args,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainReadLogFileRet, &ret) < 0)\n        return NULL;\n\n    return ret.data;\n}"
  },
  {
    "function_name": "virLogManagerDomainGetLogFilePosition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
    "lines": "207-236",
    "snippet": "int\nvirLogManagerDomainGetLogFilePosition(virLogManagerPtr mgr,\n                                      const char *path,\n                                      unsigned int flags,\n                                      ino_t *inode,\n                                      off_t *offset)\n{\n    struct virLogManagerProtocolDomainGetLogFilePositionArgs args;\n    struct virLogManagerProtocolDomainGetLogFilePositionRet ret;\n\n    memset(&args, 0, sizeof(args));\n    memset(&ret, 0, sizeof(ret));\n\n    args.path = (char *)path;\n    args.flags = flags;\n\n    if (virNetClientProgramCall(mgr->program,\n                                mgr->client,\n                                mgr->serial++,\n                                VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_GET_LOG_FILE_POSITION,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainGetLogFilePositionArgs, &args,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainGetLogFilePositionRet, &ret) < 0)\n        return -1;\n\n    *inode = ret.pos.inode;\n    *offset = ret.pos.offset;\n\n    return 0;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_manager.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virNetClientProgramCall",
          "args": [
            "mgr->program",
            "mgr->client",
            "mgr->serial++",
            "VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_GET_LOG_FILE_POSITION",
            "0",
            "NULL",
            "NULL",
            "NULL",
            "(xdrproc_t)xdr_virLogManagerProtocolDomainGetLogFilePositionArgs",
            "&args",
            "(xdrproc_t)xdr_virLogManagerProtocolDomainGetLogFilePositionRet",
            "&ret"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "266-400",
          "snippet": "int virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ret",
            "0",
            "sizeof(ret)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nint\nvirLogManagerDomainGetLogFilePosition(virLogManagerPtr mgr,\n                                      const char *path,\n                                      unsigned int flags,\n                                      ino_t *inode,\n                                      off_t *offset)\n{\n    struct virLogManagerProtocolDomainGetLogFilePositionArgs args;\n    struct virLogManagerProtocolDomainGetLogFilePositionRet ret;\n\n    memset(&args, 0, sizeof(args));\n    memset(&ret, 0, sizeof(ret));\n\n    args.path = (char *)path;\n    args.flags = flags;\n\n    if (virNetClientProgramCall(mgr->program,\n                                mgr->client,\n                                mgr->serial++,\n                                VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_GET_LOG_FILE_POSITION,\n                                0, NULL, NULL, NULL,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainGetLogFilePositionArgs, &args,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainGetLogFilePositionRet, &ret) < 0)\n        return -1;\n\n    *inode = ret.pos.inode;\n    *offset = ret.pos.offset;\n\n    return 0;\n}"
  },
  {
    "function_name": "virLogManagerDomainOpenLogFile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
    "lines": "145-204",
    "snippet": "int\nvirLogManagerDomainOpenLogFile(virLogManagerPtr mgr,\n                               const char *driver,\n                               const unsigned char *domuuid,\n                               const char *domname,\n                               const char *path,\n                               unsigned int flags,\n                               ino_t *inode,\n                               off_t *offset)\n{\n    struct virLogManagerProtocolDomainOpenLogFileArgs args;\n    struct virLogManagerProtocolDomainOpenLogFileRet ret;\n    int *fdout = NULL;\n    size_t fdoutlen = 0;\n    int rv = -1;\n\n    memset(&args, 0, sizeof(args));\n    memset(&ret, 0, sizeof(ret));\n\n    args.driver = (char *)driver;\n    memcpy(args.dom.uuid, domuuid, VIR_UUID_BUFLEN);\n    args.dom.name = (char *)domname;\n    args.path = (char *)path;\n    args.flags = flags;\n\n    if (virNetClientProgramCall(mgr->program,\n                                mgr->client,\n                                mgr->serial++,\n                                VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_OPEN_LOG_FILE,\n                                0, NULL, &fdoutlen, &fdout,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainOpenLogFileArgs, &args,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainOpenLogFileRet, &ret) < 0)\n        goto cleanup;\n\n    if (fdoutlen != 1) {\n        if (fdoutlen) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"too many file descriptors received\"));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"no file descriptor received\"));\n        }\n        goto cleanup;\n    }\n\n    if (inode)\n        *inode = ret.pos.inode;\n    if (offset)\n        *offset = ret.pos.offset;\n\n    rv = fdout[0];\n cleanup:\n    if (rv < 0) {\n        while (fdoutlen)\n            VIR_FORCE_CLOSE(fdout[--fdoutlen]);\n    }\n    VIR_FREE(fdout);\n\n    return rv;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_manager.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "fdout"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FORCE_CLOSE",
          "args": [
            "fdout[--fdoutlen]"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"no file descriptor received\")"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"no file descriptor received\""
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virReportError",
          "args": [
            "VIR_ERR_INTERNAL_ERROR",
            "\"%s\"",
            "_(\"too many file descriptors received\")"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientProgramCall",
          "args": [
            "mgr->program",
            "mgr->client",
            "mgr->serial++",
            "VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_OPEN_LOG_FILE",
            "0",
            "NULL",
            "&fdoutlen",
            "&fdout",
            "(xdrproc_t)xdr_virLogManagerProtocolDomainOpenLogFileArgs",
            "&args",
            "(xdrproc_t)xdr_virLogManagerProtocolDomainOpenLogFileRet",
            "&ret"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramCall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "266-400",
          "snippet": "int virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientProgramCall(virNetClientProgramPtr prog,\n                            virNetClientPtr client,\n                            unsigned serial,\n                            int proc,\n                            size_t noutfds,\n                            int *outfds,\n                            size_t *ninfds,\n                            int **infds,\n                            xdrproc_t args_filter, void *args,\n                            xdrproc_t ret_filter, void *ret)\n{\n    virNetMessagePtr msg;\n    size_t i;\n\n    if (infds)\n        *infds = NULL;\n    if (ninfds)\n        *ninfds = 0;\n\n    if (!(msg = virNetMessageNew(false)))\n        return -1;\n\n    msg->header.prog = prog->program;\n    msg->header.vers = prog->version;\n    msg->header.status = VIR_NET_OK;\n    msg->header.type = noutfds ? VIR_NET_CALL_WITH_FDS : VIR_NET_CALL;\n    msg->header.serial = serial;\n    msg->header.proc = proc;\n    if (VIR_ALLOC_N(msg->fds, noutfds) < 0)\n        goto error;\n    msg->nfds = noutfds;\n    for (i = 0; i < msg->nfds; i++)\n        msg->fds[i] = -1;\n    for (i = 0; i < msg->nfds; i++) {\n        if ((msg->fds[i] = dup(outfds[i])) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot duplicate FD %d\"),\n                                 outfds[i]);\n            goto error;\n        }\n        if (virSetInherit(msg->fds[i], false) < 0) {\n            virReportSystemError(errno,\n                                 _(\"Cannot set close-on-exec %d\"),\n                                 msg->fds[i]);\n            goto error;\n        }\n    }\n\n    if (virNetMessageEncodeHeader(msg) < 0)\n        goto error;\n\n    if (msg->nfds &&\n        virNetMessageEncodeNumFDs(msg) < 0)\n        goto error;\n\n    if (virNetMessageEncodePayload(msg, args_filter, args) < 0)\n        goto error;\n\n    if (virNetClientSendWithReply(client, msg) < 0)\n        goto error;\n\n    /* None of these 3 should ever happen here, because\n     * virNetClientSend should have validated the reply,\n     * but it doesn't hurt to check again.\n     */\n    if (msg->header.type != VIR_NET_REPLY &&\n        msg->header.type != VIR_NET_REPLY_WITH_FDS) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message type %d\"), msg->header.type);\n        goto error;\n    }\n    if (msg->header.proc != proc) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message proc %d != %d\"),\n                       msg->header.proc, proc);\n        goto error;\n    }\n    if (msg->header.serial != serial) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Unexpected message serial %d != %d\"),\n                       msg->header.serial, serial);\n        goto error;\n    }\n\n    switch (msg->header.status) {\n    case VIR_NET_OK:\n        if (infds && ninfds) {\n            *ninfds = msg->nfds;\n            if (VIR_ALLOC_N(*infds, *ninfds) < 0)\n                goto error;\n            for (i = 0; i < *ninfds; i++)\n                (*infds)[i] = -1;\n            for (i = 0; i < *ninfds; i++) {\n                if (((*infds)[i] = dup(msg->fds[i])) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot duplicate FD %d\"),\n                                         msg->fds[i]);\n                    goto error;\n                }\n                if (virSetInherit((*infds)[i], false) < 0) {\n                    virReportSystemError(errno,\n                                         _(\"Cannot set close-on-exec %d\"),\n                                         (*infds)[i]);\n                    goto error;\n                }\n            }\n\n        }\n        if (virNetMessageDecodePayload(msg, ret_filter, ret) < 0)\n            goto error;\n        break;\n\n    case VIR_NET_ERROR:\n        virNetClientProgramDispatchError(prog, msg);\n        goto error;\n\n    case VIR_NET_CONTINUE:\n    default:\n        virReportError(VIR_ERR_RPC,\n                       _(\"Unexpected message status %d\"), msg->header.status);\n        goto error;\n    }\n\n    virNetMessageFree(msg);\n\n    return 0;\n\n error:\n    virNetMessageFree(msg);\n    if (infds && ninfds) {\n        for (i = 0; i < *ninfds; i++)\n            VIR_FORCE_CLOSE((*infds)[i]);\n    }\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "args.dom.uuid",
            "domuuid",
            "VIR_UUID_BUFLEN"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&ret",
            "0",
            "sizeof(ret)"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&args",
            "0",
            "sizeof(args)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nint\nvirLogManagerDomainOpenLogFile(virLogManagerPtr mgr,\n                               const char *driver,\n                               const unsigned char *domuuid,\n                               const char *domname,\n                               const char *path,\n                               unsigned int flags,\n                               ino_t *inode,\n                               off_t *offset)\n{\n    struct virLogManagerProtocolDomainOpenLogFileArgs args;\n    struct virLogManagerProtocolDomainOpenLogFileRet ret;\n    int *fdout = NULL;\n    size_t fdoutlen = 0;\n    int rv = -1;\n\n    memset(&args, 0, sizeof(args));\n    memset(&ret, 0, sizeof(ret));\n\n    args.driver = (char *)driver;\n    memcpy(args.dom.uuid, domuuid, VIR_UUID_BUFLEN);\n    args.dom.name = (char *)domname;\n    args.path = (char *)path;\n    args.flags = flags;\n\n    if (virNetClientProgramCall(mgr->program,\n                                mgr->client,\n                                mgr->serial++,\n                                VIR_LOG_MANAGER_PROTOCOL_PROC_DOMAIN_OPEN_LOG_FILE,\n                                0, NULL, &fdoutlen, &fdout,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainOpenLogFileArgs, &args,\n                                (xdrproc_t)xdr_virLogManagerProtocolDomainOpenLogFileRet, &ret) < 0)\n        goto cleanup;\n\n    if (fdoutlen != 1) {\n        if (fdoutlen) {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"too many file descriptors received\"));\n        } else {\n            virReportError(VIR_ERR_INTERNAL_ERROR, \"%s\",\n                           _(\"no file descriptor received\"));\n        }\n        goto cleanup;\n    }\n\n    if (inode)\n        *inode = ret.pos.inode;\n    if (offset)\n        *offset = ret.pos.offset;\n\n    rv = fdout[0];\n cleanup:\n    if (rv < 0) {\n        while (fdoutlen)\n            VIR_FORCE_CLOSE(fdout[--fdoutlen]);\n    }\n    VIR_FREE(fdout);\n\n    return rv;\n}"
  },
  {
    "function_name": "virLogManagerFree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
    "lines": "130-142",
    "snippet": "void\nvirLogManagerFree(virLogManagerPtr mgr)\n{\n    if (!mgr)\n        return;\n\n    if (mgr->client)\n        virNetClientClose(mgr->client);\n    virObjectUnref(mgr->program);\n    virObjectUnref(mgr->client);\n\n    VIR_FREE(mgr);\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_manager.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "mgr"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "mgr->client"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientClose",
          "args": [
            "mgr->client"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "803-806",
          "snippet": "void virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nvoid\nvirLogManagerFree(virLogManagerPtr mgr)\n{\n    if (!mgr)\n        return;\n\n    if (mgr->client)\n        virNetClientClose(mgr->client);\n    virObjectUnref(mgr->program);\n    virObjectUnref(mgr->client);\n\n    VIR_FREE(mgr);\n}"
  },
  {
    "function_name": "virLogManagerNew",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
    "lines": "111-127",
    "snippet": "virLogManagerPtr\nvirLogManagerNew(bool privileged)\n{\n    virLogManagerPtr mgr;\n\n    if (VIR_ALLOC(mgr) < 0)\n        goto error;\n\n    if (!(mgr->client = virLogManagerConnect(privileged, &mgr->program)))\n        goto error;\n\n    return mgr;\n\n error:\n    virLogManagerFree(mgr);\n    return NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_manager.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virLogManagerFree",
          "args": [
            "mgr"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "virLogManagerFree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
          "lines": "130-142",
          "snippet": "void\nvirLogManagerFree(virLogManagerPtr mgr)\n{\n    if (!mgr)\n        return;\n\n    if (mgr->client)\n        virNetClientClose(mgr->client);\n    virObjectUnref(mgr->program);\n    virObjectUnref(mgr->client);\n\n    VIR_FREE(mgr);\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"log_protocol.h\"",
            "#include \"log_manager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nvoid\nvirLogManagerFree(virLogManagerPtr mgr)\n{\n    if (!mgr)\n        return;\n\n    if (mgr->client)\n        virNetClientClose(mgr->client);\n    virObjectUnref(mgr->program);\n    virObjectUnref(mgr->client);\n\n    VIR_FREE(mgr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogManagerConnect",
          "args": [
            "privileged",
            "&mgr->program"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "virLogManagerConnect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
          "lines": "60-108",
          "snippet": "static virNetClientPtr\nvirLogManagerConnect(bool privileged,\n                     virNetClientProgramPtr *prog)\n{\n    virNetClientPtr client = NULL;\n    char *logdpath;\n    char *daemonPath = NULL;\n\n    *prog = NULL;\n\n    if (!(logdpath = virLogManagerDaemonPath(privileged)))\n        goto error;\n\n    if (!privileged &&\n        !(daemonPath = virFileFindResourceFull(\"virtlogd\",\n                                               NULL, NULL,\n                                               abs_top_builddir \"/src\",\n                                               SBINDIR,\n                                               \"VIRTLOGD_PATH\")))\n        goto error;\n\n    if (!(client = virNetClientNewUNIX(logdpath,\n                                       daemonPath != NULL,\n                                       daemonPath)))\n        goto error;\n\n    if (!(*prog = virNetClientProgramNew(VIR_LOG_MANAGER_PROTOCOL_PROGRAM,\n                                         VIR_LOG_MANAGER_PROTOCOL_PROGRAM_VERSION,\n                                         NULL,\n                                         0,\n                                         NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(client, *prog) < 0)\n        goto error;\n\n    VIR_FREE(daemonPath);\n    VIR_FREE(logdpath);\n\n    return client;\n\n error:\n    VIR_FREE(daemonPath);\n    VIR_FREE(logdpath);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(*prog);\n    return NULL;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"log_protocol.h\"",
            "#include \"log_manager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nstatic virNetClientPtr\nvirLogManagerConnect(bool privileged,\n                     virNetClientProgramPtr *prog)\n{\n    virNetClientPtr client = NULL;\n    char *logdpath;\n    char *daemonPath = NULL;\n\n    *prog = NULL;\n\n    if (!(logdpath = virLogManagerDaemonPath(privileged)))\n        goto error;\n\n    if (!privileged &&\n        !(daemonPath = virFileFindResourceFull(\"virtlogd\",\n                                               NULL, NULL,\n                                               abs_top_builddir \"/src\",\n                                               SBINDIR,\n                                               \"VIRTLOGD_PATH\")))\n        goto error;\n\n    if (!(client = virNetClientNewUNIX(logdpath,\n                                       daemonPath != NULL,\n                                       daemonPath)))\n        goto error;\n\n    if (!(*prog = virNetClientProgramNew(VIR_LOG_MANAGER_PROTOCOL_PROGRAM,\n                                         VIR_LOG_MANAGER_PROTOCOL_PROGRAM_VERSION,\n                                         NULL,\n                                         0,\n                                         NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(client, *prog) < 0)\n        goto error;\n\n    VIR_FREE(daemonPath);\n    VIR_FREE(logdpath);\n\n    return client;\n\n error:\n    VIR_FREE(daemonPath);\n    VIR_FREE(logdpath);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(*prog);\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_ALLOC",
          "args": [
            "mgr"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nvirLogManagerPtr\nvirLogManagerNew(bool privileged)\n{\n    virLogManagerPtr mgr;\n\n    if (VIR_ALLOC(mgr) < 0)\n        goto error;\n\n    if (!(mgr->client = virLogManagerConnect(privileged, &mgr->program)))\n        goto error;\n\n    return mgr;\n\n error:\n    virLogManagerFree(mgr);\n    return NULL;\n}"
  },
  {
    "function_name": "virLogManagerConnect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
    "lines": "60-108",
    "snippet": "static virNetClientPtr\nvirLogManagerConnect(bool privileged,\n                     virNetClientProgramPtr *prog)\n{\n    virNetClientPtr client = NULL;\n    char *logdpath;\n    char *daemonPath = NULL;\n\n    *prog = NULL;\n\n    if (!(logdpath = virLogManagerDaemonPath(privileged)))\n        goto error;\n\n    if (!privileged &&\n        !(daemonPath = virFileFindResourceFull(\"virtlogd\",\n                                               NULL, NULL,\n                                               abs_top_builddir \"/src\",\n                                               SBINDIR,\n                                               \"VIRTLOGD_PATH\")))\n        goto error;\n\n    if (!(client = virNetClientNewUNIX(logdpath,\n                                       daemonPath != NULL,\n                                       daemonPath)))\n        goto error;\n\n    if (!(*prog = virNetClientProgramNew(VIR_LOG_MANAGER_PROTOCOL_PROGRAM,\n                                         VIR_LOG_MANAGER_PROTOCOL_PROGRAM_VERSION,\n                                         NULL,\n                                         0,\n                                         NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(client, *prog) < 0)\n        goto error;\n\n    VIR_FREE(daemonPath);\n    VIR_FREE(logdpath);\n\n    return client;\n\n error:\n    VIR_FREE(daemonPath);\n    VIR_FREE(logdpath);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(*prog);\n    return NULL;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_manager.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "virObjectUnref",
          "args": [
            "*prog"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "virObjectUnref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virobject.c",
          "lines": "338-365",
          "snippet": "bool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}",
          "includes": [
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virthread.h\"",
            "#include \"virobject.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void virObjectLockableDispose(void *anyobj);",
            "static void virObjectRWLockableDispose(void *anyobj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virthread.h\"\n#include \"virobject.h\"\n#include <config.h>\n\nstatic void virObjectLockableDispose(void *anyobj);\nstatic void virObjectRWLockableDispose(void *anyobj);\n\nbool\nvirObjectUnref(void *anyobj)\n{\n    virObjectPtr obj = anyobj;\n\n    if (VIR_OBJECT_NOTVALID(obj))\n        return false;\n\n    bool lastRef = !!g_atomic_int_dec_and_test(&obj->u.s.refs);\n    PROBE(OBJECT_UNREF, \"obj=%p\", obj);\n    if (lastRef) {\n        PROBE(OBJECT_DISPOSE, \"obj=%p\", obj);\n        virClassPtr klass = obj->klass;\n        while (klass) {\n            if (klass->dispose)\n                klass->dispose(obj);\n            klass = klass->parent;\n        }\n\n        /* Clear & poison object */\n        memset(obj, 0, obj->klass->objectSize);\n        obj->u.s.magic = 0xDEADBEEF;\n        obj->klass = (void*)0xDEADBEEF;\n        VIR_FREE(obj);\n    }\n\n    return !lastRef;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientClose",
          "args": [
            "client"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientClose",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "803-806",
          "snippet": "void virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvoid virNetClientClose(virNetClientPtr client)\n{\n    virNetClientCloseInternal(client, VIR_CONNECT_CLOSE_REASON_CLIENT);\n}"
        }
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "logdpath"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "daemonPath"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "logdpath"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "VIR_FREE",
          "args": [
            "daemonPath"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "virNetClientAddProgram",
          "args": [
            "client",
            "*prog"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientAddProgram",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "1005-1021",
          "snippet": "int virNetClientAddProgram(virNetClientPtr client,\n                           virNetClientProgramPtr prog)\n{\n    virObjectLock(client);\n\n    if (VIR_EXPAND_N(client->programs, client->nprograms, 1) < 0)\n        goto error;\n\n    client->programs[client->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnlock(client);\n    return -1;\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nint virNetClientAddProgram(virNetClientPtr client,\n                           virNetClientProgramPtr prog)\n{\n    virObjectLock(client);\n\n    if (VIR_EXPAND_N(client->programs, client->nprograms, 1) < 0)\n        goto error;\n\n    client->programs[client->nprograms-1] = virObjectRef(prog);\n\n    virObjectUnlock(client);\n    return 0;\n\n error:\n    virObjectUnlock(client);\n    return -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientProgramNew",
          "args": [
            "VIR_LOG_MANAGER_PROTOCOL_PROGRAM",
            "VIR_LOG_MANAGER_PROTOCOL_PROGRAM_VERSION",
            "NULL",
            "0",
            "NULL"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientProgramNew",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclientprogram.c",
          "lines": "64-85",
          "snippet": "virNetClientProgramPtr virNetClientProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetClientProgramEventPtr events,\n                                              size_t nevents,\n                                              void *eventOpaque)\n{\n    virNetClientProgramPtr prog;\n\n    if (virNetClientProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetClientProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->events = events;\n    prog->nevents = nevents;\n    prog->eventOpaque = eventOpaque;\n\n    return prog;\n}",
          "includes": [
            "#include \"virthread.h\"",
            "#include \"virfile.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "#include \"viralloc.h\"",
            "#include \"virnetprotocol.h\"",
            "#include \"virnetclient.h\"",
            "#include \"virnetclientprogram.h\"",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static virClassPtr virNetClientProgramClass;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virthread.h\"\n#include \"virfile.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n#include \"viralloc.h\"\n#include \"virnetprotocol.h\"\n#include \"virnetclient.h\"\n#include \"virnetclientprogram.h\"\n#include <unistd.h>\n#include <config.h>\n\nstatic virClassPtr virNetClientProgramClass;\n\nvirNetClientProgramPtr virNetClientProgramNew(unsigned program,\n                                              unsigned version,\n                                              virNetClientProgramEventPtr events,\n                                              size_t nevents,\n                                              void *eventOpaque)\n{\n    virNetClientProgramPtr prog;\n\n    if (virNetClientProgramInitialize() < 0)\n        return NULL;\n\n    if (!(prog = virObjectNew(virNetClientProgramClass)))\n        return NULL;\n\n    prog->program = program;\n    prog->version = version;\n    prog->events = events;\n    prog->nevents = nevents;\n    prog->eventOpaque = eventOpaque;\n\n    return prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virNetClientNewUNIX",
          "args": [
            "logdpath",
            "daemonPath != NULL",
            "daemonPath"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "virNetClientNewUNIX",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/rpc/virnetclient.c",
          "lines": "367-377",
          "snippet": "virNetClientPtr virNetClientNewUNIX(const char *path,\n                                    bool spawnDaemon,\n                                    const char *binary)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectUNIX(path, spawnDaemon, binary, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}",
          "includes": [
            "#include \"vireventglibwatch.h\"",
            "#include \"virstring.h\"",
            "#include \"virprobe.h\"",
            "#include \"virerror.h\"",
            "#include \"virutil.h\"",
            "#include \"virlog.h\"",
            "#include \"virfile.h\"",
            "#include \"virthread.h\"",
            "#include \"viralloc.h\"",
            "#include \"virkeepalive.h\"",
            "#include \"virnetsocket.h\"",
            "#include \"virnetclient.h\"",
            "#include <fcntl.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"vireventglibwatch.h\"\n#include \"virstring.h\"\n#include \"virprobe.h\"\n#include \"virerror.h\"\n#include \"virutil.h\"\n#include \"virlog.h\"\n#include \"virfile.h\"\n#include \"virthread.h\"\n#include \"viralloc.h\"\n#include \"virkeepalive.h\"\n#include \"virnetsocket.h\"\n#include \"virnetclient.h\"\n#include <fcntl.h>\n#include <signal.h>\n#include <unistd.h>\n#include <config.h>\n\nvirNetClientPtr virNetClientNewUNIX(const char *path,\n                                    bool spawnDaemon,\n                                    const char *binary)\n{\n    virNetSocketPtr sock;\n\n    if (virNetSocketNewConnectUNIX(path, spawnDaemon, binary, &sock) < 0)\n        return NULL;\n\n    return virNetClientNew(sock, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "virFileFindResourceFull",
          "args": [
            "\"virtlogd\"",
            "NULL",
            "NULL",
            "abs_top_builddir \"/src\"",
            "SBINDIR",
            "\"VIRTLOGD_PATH\""
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "virFileFindResourceFull",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virfile.c",
          "lines": "1741-1769",
          "snippet": "char *\nvirFileFindResourceFull(const char *filename,\n                        const char *prefix,\n                        const char *suffix,\n                        const char *builddir,\n                        const char *installdir,\n                        const char *envname)\n{\n    char *ret = NULL;\n    const char *envval = envname ? getenv(envname) : NULL;\n    const char *path;\n\n    if (!prefix)\n        prefix = \"\";\n    if (!suffix)\n        suffix = \"\";\n\n    if (envval)\n        path = envval;\n    else if (useDirOverride)\n        path = builddir;\n    else\n        path = installdir;\n\n    ret = g_strdup_printf(\"%s/%s%s%s\", path, prefix, filename, suffix);\n\n    VIR_DEBUG(\"Resolved '%s' to '%s'\", filename, ret);\n    return ret;\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"virlog.h\"",
            "#include \"virkmod.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"vircommand.h\"",
            "#include \"viralloc.h\"",
            "#include \"configmake.h\"",
            "# include <sys/xattr.h>",
            "# include <linux/cdrom.h>",
            "# include <sys/ioctl.h>",
            "#  include <linux/loop.h>",
            "# include <sys/statfs.h>",
            "#  include <linux/magic.h>",
            "#include <sys/file.h>",
            "# include <sys/acl.h>",
            "# include <sys/syscall.h>",
            "# include <sys/mman.h>",
            "# include <mntent.h>",
            "#include <dirent.h>",
            "#include <unistd.h>",
            "# include <sys/mount.h>",
            "#include <sys/stat.h>",
            "# include <libutil.h>",
            "# include <util.h>",
            "# include <pty.h>",
            "# include <termios.h>",
            "#include <fcntl.h>",
            "#include \"internal.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool useDirOverride;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"virlog.h\"\n#include \"virkmod.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"vircommand.h\"\n#include \"viralloc.h\"\n#include \"configmake.h\"\n# include <sys/xattr.h>\n# include <linux/cdrom.h>\n# include <sys/ioctl.h>\n#  include <linux/loop.h>\n# include <sys/statfs.h>\n#  include <linux/magic.h>\n#include <sys/file.h>\n# include <sys/acl.h>\n# include <sys/syscall.h>\n# include <sys/mman.h>\n# include <mntent.h>\n#include <dirent.h>\n#include <unistd.h>\n# include <sys/mount.h>\n#include <sys/stat.h>\n# include <libutil.h>\n# include <util.h>\n# include <pty.h>\n# include <termios.h>\n#include <fcntl.h>\n#include \"internal.h\"\n#include <config.h>\n\nstatic bool useDirOverride;\n\nchar *\nvirFileFindResourceFull(const char *filename,\n                        const char *prefix,\n                        const char *suffix,\n                        const char *builddir,\n                        const char *installdir,\n                        const char *envname)\n{\n    char *ret = NULL;\n    const char *envval = envname ? getenv(envname) : NULL;\n    const char *path;\n\n    if (!prefix)\n        prefix = \"\";\n    if (!suffix)\n        suffix = \"\";\n\n    if (envval)\n        path = envval;\n    else if (useDirOverride)\n        path = builddir;\n    else\n        path = installdir;\n\n    ret = g_strdup_printf(\"%s/%s%s%s\", path, prefix, filename, suffix);\n\n    VIR_DEBUG(\"Resolved '%s' to '%s'\", filename, ret);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virLogManagerDaemonPath",
          "args": [
            "privileged"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "virLogManagerDaemonPath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
          "lines": "43-57",
          "snippet": "static char *\nvirLogManagerDaemonPath(bool privileged)\n{\n    char *path;\n    if (privileged) {\n        path = g_strdup(RUNSTATEDIR \"/libvirt/virtlogd-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        path = g_strdup_printf(\"%s/virtlogd-sock\", rundir);\n    }\n    return path;\n}",
          "includes": [
            "#include \"configmake.h\"",
            "#include \"rpc/virnetclient.h\"",
            "#include \"virfile.h\"",
            "#include \"virerror.h\"",
            "#include \"virstring.h\"",
            "#include \"virutil.h\"",
            "#include \"viralloc.h\"",
            "#include \"log_protocol.h\"",
            "#include \"log_manager.h\"",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nstatic char *\nvirLogManagerDaemonPath(bool privileged)\n{\n    char *path;\n    if (privileged) {\n        path = g_strdup(RUNSTATEDIR \"/libvirt/virtlogd-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        path = g_strdup_printf(\"%s/virtlogd-sock\", rundir);\n    }\n    return path;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nstatic virNetClientPtr\nvirLogManagerConnect(bool privileged,\n                     virNetClientProgramPtr *prog)\n{\n    virNetClientPtr client = NULL;\n    char *logdpath;\n    char *daemonPath = NULL;\n\n    *prog = NULL;\n\n    if (!(logdpath = virLogManagerDaemonPath(privileged)))\n        goto error;\n\n    if (!privileged &&\n        !(daemonPath = virFileFindResourceFull(\"virtlogd\",\n                                               NULL, NULL,\n                                               abs_top_builddir \"/src\",\n                                               SBINDIR,\n                                               \"VIRTLOGD_PATH\")))\n        goto error;\n\n    if (!(client = virNetClientNewUNIX(logdpath,\n                                       daemonPath != NULL,\n                                       daemonPath)))\n        goto error;\n\n    if (!(*prog = virNetClientProgramNew(VIR_LOG_MANAGER_PROTOCOL_PROGRAM,\n                                         VIR_LOG_MANAGER_PROTOCOL_PROGRAM_VERSION,\n                                         NULL,\n                                         0,\n                                         NULL)))\n        goto error;\n\n    if (virNetClientAddProgram(client, *prog) < 0)\n        goto error;\n\n    VIR_FREE(daemonPath);\n    VIR_FREE(logdpath);\n\n    return client;\n\n error:\n    VIR_FREE(daemonPath);\n    VIR_FREE(logdpath);\n    virNetClientClose(client);\n    virObjectUnref(client);\n    virObjectUnref(*prog);\n    return NULL;\n}"
  },
  {
    "function_name": "virLogManagerDaemonPath",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/logging/log_manager.c",
    "lines": "43-57",
    "snippet": "static char *\nvirLogManagerDaemonPath(bool privileged)\n{\n    char *path;\n    if (privileged) {\n        path = g_strdup(RUNSTATEDIR \"/libvirt/virtlogd-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        path = g_strdup_printf(\"%s/virtlogd-sock\", rundir);\n    }\n    return path;\n}",
    "includes": [
      "#include \"configmake.h\"",
      "#include \"rpc/virnetclient.h\"",
      "#include \"virfile.h\"",
      "#include \"virerror.h\"",
      "#include \"virstring.h\"",
      "#include \"virutil.h\"",
      "#include \"viralloc.h\"",
      "#include \"log_protocol.h\"",
      "#include \"log_manager.h\"",
      "#include <config.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/virtlogd-sock\"",
            "rundir"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "vir_g_strdup_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/glibcompat.c",
          "lines": "191-202",
          "snippet": "char *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}",
          "includes": [
            "#include \"glibcompat.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"glibcompat.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <config.h>\n\nchar *\nvir_g_strdup_printf(const char *msg, ...)\n{\n    va_list args;\n    char *ret;\n    va_start(args, msg);\n    ret = g_strdup_vprintf(msg, args);\n    if (!ret)\n        abort();\n    va_end(args);\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "virGetUserRuntimeDirectory",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "virGetUserRuntimeDirectory",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-10701/repo/src/util/virutil.c",
          "lines": "594-601",
          "snippet": "char *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}",
          "includes": [
            "#include \"virsocket.h\"",
            "#include \"virutil.h\"",
            "#include \"virstring.h\"",
            "#include \"virprocess.h\"",
            "#include \"vircommand.h\"",
            "#include \"virfile.h\"",
            "#include \"viralloc.h\"",
            "#include \"virbuffer.h\"",
            "#include \"virlog.h\"",
            "#include \"virerror.h\"",
            "# include <sys/prctl.h>",
            "# include <cap-ng.h>",
            "# include <grp.h>",
            "# include <pwd.h>",
            "# include <libdevmapper.h>",
            "#include <sys/types.h>",
            "# include <sys/sysmacros.h>",
            "# include <conio.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <config.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"virsocket.h\"\n#include \"virutil.h\"\n#include \"virstring.h\"\n#include \"virprocess.h\"\n#include \"vircommand.h\"\n#include \"virfile.h\"\n#include \"viralloc.h\"\n#include \"virbuffer.h\"\n#include \"virlog.h\"\n#include \"virerror.h\"\n# include <sys/prctl.h>\n# include <cap-ng.h>\n# include <grp.h>\n# include <pwd.h>\n# include <libdevmapper.h>\n#include <sys/types.h>\n# include <sys/sysmacros.h>\n# include <conio.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <config.h>\n\nchar *virGetUserRuntimeDirectory(void)\n{\n#ifdef WIN32\n    return g_strdup(g_get_user_runtime_dir());\n#else\n    return g_build_filename(g_get_user_runtime_dir(), \"libvirt\", NULL);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"configmake.h\"\n#include \"rpc/virnetclient.h\"\n#include \"virfile.h\"\n#include \"virerror.h\"\n#include \"virstring.h\"\n#include \"virutil.h\"\n#include \"viralloc.h\"\n#include \"log_protocol.h\"\n#include \"log_manager.h\"\n#include <config.h>\n\nstatic char *\nvirLogManagerDaemonPath(bool privileged)\n{\n    char *path;\n    if (privileged) {\n        path = g_strdup(RUNSTATEDIR \"/libvirt/virtlogd-sock\");\n    } else {\n        g_autofree char *rundir = NULL;\n\n        rundir = virGetUserRuntimeDirectory();\n\n        path = g_strdup_printf(\"%s/virtlogd-sock\", rundir);\n    }\n    return path;\n}"
  }
]